
.vsteensy/build/microSoundRecorder.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00013f64 l    d  .fini	00000000 .fini
00013f68 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
200133d0 l    d  .usbbuffers	00000000 .usbbuffers
20013730 l    d  .data	00000000 .data
20014348 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
000097cc l     F .text	0000000c startup_default_early_hook
000097d8 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
20014348 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
2001434c l       .bss	00000000 object.8610
00013f14 l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 myAPP.cpp
0000047c l     F .text	0000001c llwuISR()
000005c4 l     F .text	00000034 getTime(char*) [clone .constprop.34]
000005f8 l     F .text	00000034 getDate(char*) [clone .constprop.35]
00001f30 l     F .text	00000210 _GLOBAL__sub_I_acqParameters
20014878 l     O .bss	00000004 loop::t3
2001487c l     O .bss	00000004 loop::t4
200192a8 l     O .bss	00000028 makeFilename(char*)::filename
200192d0 l     O .bss	00000004 checkDutyCycle(ACQ_Parameters_s*, short)::t_start
200192f8 l     O .bss	00000030 wavHeader(unsigned long)::wheader
200195ac l     O .bss	00000002 checkDutyCycle(ACQ_Parameters_s*, short)::recording
1fff0200 l     O .dmabuffers	00022d94 setup::data
200195cc l     O .bss	00000004 loop::loopCount
200195d0 l     O .bss	00000002 loop::state
200195d4 l     O .bss	00000004 loop::t0
00000000 l    df *ABS*	00000000 SPI.cpp
00002140 l     F .text	000001f8 SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]
00000000 l    df *ABS*	00000000 Time.cpp
000024f0 l     F .text	00000018 refreshCache(long) [clone .part.0]
200195d8 l     O .bss	00000004 cacheTime
200195dc l     O .bss	00000007 tm
200195e4 l     O .bss	00000004 sysTime
200195e8 l     O .bss	00000001 Status
200195f0 l     O .bss	00000004 prevMillis
2001378c l     O .data	00000004 syncInterval
000135ac l     O .text	0000000c monthDays
200195f4 l     O .bss	00000004 nextSyncTime
00000000 l    df *ABS*	00000000 output_pwm.cpp
000027d4 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE
00000000 l    df *ABS*	00000000 input_i2s.cpp
000029ec l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE
20012fa0 l     O .dmabuffers	00000200 i2s_rx_buffer
00000000 l    df *ABS*	00000000 output_pt8211.cpp
00002a04 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE
00000000 l    df *ABS*	00000000 output_adat.cpp
00002a1c l     F .text	00000018 _GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_adc.cpp
00002a34 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE
00000000 l    df *ABS*	00000000 control_sgtl5000.cpp
00000000 l    df *ABS*	00000000 output_dac.cpp
00002e20 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE
00000000 l    df *ABS*	00000000 input_adcs.cpp
00002e38 l     F .text	00000030 _GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE
00000000 l    df *ABS*	00000000 input_i2s_quad.cpp
00002e68 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E
00000000 l    df *ABS*	00000000 output_dacs.cpp
00002e80 l     F .text	00000018 _GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE
00000000 l    df *ABS*	00000000 play_sd_wav.cpp
00000000 l    df *ABS*	00000000 output_i2s_quad.cpp
00003488 l     F .text	00000018 _GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_i2s_oct.cpp
000034a0 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E
00000000 l    df *ABS*	00000000 output_tdm.cpp
000034b8 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE
00000000 l    df *ABS*	00000000 input_tdm.cpp
000034d0 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE
00000000 l    df *ABS*	00000000 input_i2s_hex.cpp
000034e8 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E
00000000 l    df *ABS*	00000000 input_pdm.cpp
00003500 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE
00000000 l    df *ABS*	00000000 output_i2s.cpp
0000362c l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE
00000000 l    df *ABS*	00000000 output_spdif.cpp
00003644 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE
00000000 l    df *ABS*	00000000 WireKinetis.cpp
00003942 l       .text	00000000 L_1373_delayMicroseconds
00003950 l       .text	00000000 L_1387_delayMicroseconds
00003996 l       .text	00000000 L_1438_delayMicroseconds
00003cca l       .text	00000000 L_2966_delayMicroseconds
20019698 l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SD.cpp
00004040 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsCache.cpp
000040a4 l     F .text	00000046 FsCache::sync() [clone .part.0]
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00004b10 l     F .text	00000034 ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]
00004b44 l     F .text	0000002a ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]
00000000 l    df *ABS*	00000000 upcase.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00005a4c l     F .text	00000032 FatFile::openRoot(FatVolume*) [clone .part.38]
00005b6c l     F .text	00000094 FatFile::sync() [clone .part.42]
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
00006c4c l     F .text	00000028 lfnGetChar(DirLfn_t*, unsigned char)
00000000 l    df *ABS*	00000000 FatFileSFN.cpp
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
0000788c l     F .text	00000018 SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]
000078a4 l     F .text	00000022 SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007f80 l     F .text	00000030 sdIrs()
00007fb0 l     F .text	00000018 isBusyCommandComplete()
00007fc8 l     F .text	00000010 isBusyCommandInhibit()
00007fd8 l     F .text	00000014 isBusyDat()
00007fec l     F .text	0000000c isBusyDMA()
00007ff8 l     F .text	00000014 isBusyFifoRead()
0000800c l     F .text	00000014 isBusyFifoWrite()
00008020 l     F .text	00000018 isBusyTransferComplete()
00008038 l     F .text	000000cc setSdclk(unsigned long)
00008168 l     F .text	00000028 waitTimeout(bool (*)())
00008190 l     F .text	0000004c yieldTimeout(bool (*)())
0000820c l     F .text	0000005c cardCommand(unsigned long, unsigned long)
00008268 l     F .text	0000002c isBusyCMD13()
000082b4 l     F .text	00000064 readReg16(unsigned long, void*)
00008318 l     F .text	00000020 waitDmaStatus() [clone .part.4]
00008338 l     F .text	000000b4 rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
00008544 l     F .text	00000058 waitTransferComplete() [clone .part.8]
00008918 l     F .text	000000ac cardCMD6(unsigned long, unsigned char*)
20019b64 l     O .bss	00000001 m_version2
20019b68 l     O .bss	00000010 m_cid
20019b78 l     O .bss	00000004 m_busyFcn
20019b7c l     O .bss	00000001 m_highCapacity
20019b80 l     O .bss	00000004 m_ocr
20019b84 l     O .bss	00000004 m_rca
20019b88 l     O .bss	00000001 m_transferActive
20019b8c l     O .bss	00000004 m_irqstat
200138d4 l     O .data	00000001 m_errorCode
20019b90 l     O .bss	00000001 m_initDone
20019b94 l     O .bss	00000010 m_csd
20019ba4 l     O .bss	00000001 m_dmaBusy
20019ba8 l     O .bss	00000004 m_sdClkKhz
20019bac l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 SdSpiTeensy3.cpp
00000000 l    df *ABS*	00000000 SdSpiChipSelect.cpp
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
20019bb1 l     O .bss	00000001 tx_noautoflush
20019bb4 l     O .bss	00000004 tx_packet
20019bb8 l     O .bss	00000001 transmit_previous_timeout
20019bbc l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 analog.c
20019bc1 l     O .bss	00000001 calibrating
200138d5 l     O .data	00000001 analog_config_bits
20019bc2 l     O .bss	00000001 analog_reference_internal
200138d6 l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 pins_teensy.c
0000980c l     F .text	0000004c digitalWrite.part.1
00009858 l     F .text	00000078 pinMode.part.2
00000000 l    df *ABS*	00000000 usb_mem.c
200138dc l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
20019bc8 l     O .bss	00000004 ep0_tx_ptr
20019bcc l     O .bss	00000010 rx_last
20019bdc l     O .bss	00000002 ep0_tx_len
20019be0 l     O .bss	00000040 ep0_rx0_buf
20019c20 l     O .bss	00000010 rx_first
20019c30 l     O .bss	00000001 ep0_tx_data_toggle
20019c34 l     O .bss	00000040 ep0_rx1_buf
20019c74 l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
20019c84 l     O .bss	00000010 tx_last
20019c94 l     O .bss	00000008 setup
20019c9c l     O .bss	00000001 ep0_tx_bdt_bank
20019ca0 l     O .bss	00000008 reply_buffer
20019cac l     O .bss	00000004 tx_state
00000000 l    df *ABS*	00000000 yield.cpp
20019cb0 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 AudioStream.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 usb_desc.c
200138f8 l     O .data	00000012 device_descriptor
20013924 l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000bcc0 l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000ccfc l     F .text	00000038 sulp
00013afc l     O .text	00000014 fpi.6173
00013b20 l     O .text	00000014 fpinan.6209
00013b38 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000dc30 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00013b60 l     O .text	00000010 zeroes.7258
00013bb4 l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
00013bc4 l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0001044c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0001046c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00011660 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
00013ef8 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 strtoll.c
000127bc l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
0001298c l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00012b18 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
200139a0 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
20014348 l       .bss	00000000 __bss_start__
20019db8 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
000097c4  w    F .text	00000006 adc0_isr
0000b7e4 g     F .text	0000002c .hidden __aeabi_dcmpun
00009440 g     F .text	0000001c usb_serial_available
000126e8 g     F .text	0000005e __any_on
0000b7a8 g     F .text	00000012 .hidden __aeabi_dcmple
0000cabc g     F .text	000000ba strcpy
0000b6e4 g     F .text	0000007a .hidden __cmpdf2
20019cd0 g     O .bss	00000004 AudioStream::memory_pool
00008890 g     F .text	00000088 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
0000a6c4  w    F .text	000000ec yield
00006628 g     F .text	00000218 FatFile::write(void const*, unsigned int)
0000b6e4 g     F .text	0000007a .hidden __eqdf2
00007878  w    F .text	00000002 SdSpiCard::~SdSpiCard()
00003518 g     F .text	00000114 AudioOutputI2S::config_i2s(bool)
000045e4 g     F .text	000003dc ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)
2001390c g     O .data	00000018 usb_string_manufacturer_name_default
000065b0 g     F .text	00000076 FatFile::truncate()
20013868 g     O .data	0000006c Wire1
0000b254 g     F .text	0000005a .hidden __floatdidf
0000977c  w    F .text	00000048 hard_fault_isr
000097c4  w    F .text	00000006 dma_ch6_isr
20019cd4 g     O .bss	00000001 AudioStream::update_scheduled
20019b54 g     O .bss	00000004 FsDateTime::callback
20013764 g     O .data	00000028 acqParameters
0000a960 g     F .text	00000020 Print::println()
0000379c g     F .text	00000130 TwoWire::isr()
20019d4c g     O .bss	00000002 AudioStream::memory_used
000097c4  w    F .text	00000006 uart0_lon_isr
000044e4 g     F .text	000000fe ExFatFile::seekSet(unsigned long long)
00009c84 g     F .text	00000084 usb_rx_memory
0000785c  w    F .text	00000004 SdSpiCard::errorCode() const
00002ecc  w    F .text	0000000c File::flush()
00002a54 g     F .text	00000084 AudioControlSGTL5000::read(unsigned int)
000097c4  w    F .text	00000006 dma_ch8_isr
000010fc g     F .text	000006c4 doMenu()
0000c53c g     F .text	00000002 __malloc_unlock
00003048  w    F .text	000000c0 SDFile::openNextFile(unsigned char)
20019b60 g     O .bss	00000004 FsVolume::m_cwv
00005e34 g     F .text	000000be FatFile::open(FatFile*, char const*, int)
0000969c g     F .text	000000e0 analog_init
00009d08 g     F .text	00000084 usb_tx
0000dc10 g     F .text	00000020 _strtod_r
000097c4  w    F .text	00000006 portcd_isr
000102fc g     F .text	0000004a _vdprintf_r
00013664  w    O .text	00000060 vtable for SDFile
00012ee8 g     F .text	00000082 _sfread_r
0000c3d4 g     F .text	000000c6 memmove
2001964c g     O .bss	00000008 AudioOutputAnalogStereo::dma
0000bcfc g     F .text	00000014 __locale_ctype_ptr
00008f88 g     F .text	00000068 SdioCard::stopTransmission(bool)
00011e60 g     F .text	0000004c _Balloc
000097c4  w    F .text	00000006 can1_rx_warn_isr
00013f70 g       .ARM.exidx	00000000 __exidx_end
000097c4  w    F .text	00000006 dma_error_isr
00006a44 g     F .text	0000003c FatPartition::freeChain(unsigned long)
20019cc4 g     O .bss	00000001 EventResponder::runningFromYield
00009174 g     F .text	0000001a SdSpiArduinoDriver::receive()
00007a50 g     F .text	00000096 SdSpiCard::cardCommand(unsigned char, unsigned long)
00003ce8 g     F .text	0000000c i2c0_isr
20019602 g     O .bss	00000001 AudioInputI2S::update_responsibility
0000a934 g     F .text	0000002c Print::write(unsigned char const*, unsigned int)
0000b6d4 g     F .text	0000008a .hidden __gtdf2
00006c74 g     F .text	00000024 FatFile::lfnChecksum(unsigned char*)
0000bc64 g     F .text	0000000c __errno
00003258  w    F .text	00000026 SDFile::isDirectory()
000097c4  w    F .text	00000006 portd_isr
000097c4  w    F .text	00000006 enet_error_isr
00013740 g     O .text	00000020 TwoWire::i2c2_hardware
00003370  w    F .text	00000028 File::~File()
00000770 g     F .text	000000a0 makeFilename(char*)
20019cb4 g     O .bss	00000004 EventResponder::firstInterrupt
00011de4 g     F .text	00000004 __localeconv_l
0000787c  w    F .text	0000000e SdSpiCard::~SdSpiCard()
000075e8 g     F .text	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
000097c4  w    F .text	00000006 tpm1_isr
00004fa0 g     F .text	00000018 ExFatPartition::rootLength()
0000074c  w    F .text	00000024 Print::println(__FlashStringHelper const*)
00007860  w    F .text	00000004 SdSpiCard::errorData() const
0000a924  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00013864 g     O .text	00000200 digital_pin_to_info_PGM
0000699c g     F .text	000000a8 FatPartition::allocContiguous(unsigned long, unsigned long*)
20019db4 g     O .bss	00000004 errno
00007ae8 g     F .text	0000004c SdSpiCard::readOCR(unsigned long*)
00009190 g     F .text	00000020 SdSpiArduinoDriver::receive(unsigned char*, unsigned int)
000071e0 g     F .text	00000390 FatFile::open(FatFile*, fname_t*, int)
00004d94 g     F .text	00000012 ExFatPartition::fatGet(unsigned long, unsigned long*)
0000c9e8 g     F .text	00000004 __seofread
00013f70 g       .ARM.exidx	00000000 _etext
20014348 g       .bss	00000000 _sbss
0000b770 g     F .text	00000010 .hidden __aeabi_cdcmple
00008110 g     F .text	0000000c SdioCard::errorData() const
000087c0 g     F .text	000000d0 SdioCard::writeSector(unsigned long, unsigned char const*)
0000991c g     F .text	0000001c digitalRead
000097c4  w    F .text	00000006 porte_isr
00001b60 g     F .text	000003d0 loop
0000abd8 g     F .text	00000018 AudioStream::receiveReadOnly(unsigned int)
000097c4  w    F .text	00000006 portb_isr
000097c4  w    F .text	00000006 spi1_isr
000097c4  w    F .text	00000006 uart3_status_isr
00004248 g     F .text	000000c4 ExFatFile::parsePathName(char const*, ExName_t*, char const**)
000097c4  w    F .text	00000006 mcm_isr
20019328 g     O .bss	00000014 patchCord3
00008d58 g     F .text	000000cc SdioCard::readData(unsigned char*)
0000adc8 g     F .text	00000028 Stream::peekNextDigit()
00002a4c  w    F .text	00000004 AudioControlSGTL5000::disable()
00000548  w    F .text	0000001c c_uSD::~c_uSD()
00007994 g     F .text	00000080 SdSpiCard::readData(unsigned char*, unsigned int)
000039b8 g     F .text	00000114 TwoWire::endTransmission(unsigned char)
20019cb8 g     O .bss	00000004 EventResponder::lastInterrupt
000097c4  w    F .text	00000006 uart1_status_isr
00007660 g     F .text	00000028 FsBaseFile::close()
00009220 g     F .text	000001a6 memcpy
000097c4  w    F .text	00000006 randnum_isr
00011c48 g     F .text	00000180 __hexnan
0000b760 g     F .text	00000020 .hidden __aeabi_cdrcmple
00002eb0  w    F .text	0000000c File::available()
00004dcc g     F .text	00000080 ExFatPartition::freeChain(unsigned long)
00006100 g     F .text	0000002a FatFile::peek()
0000dd90 g     F .text	000016e4 _svfprintf_r
0000b1e4 g     F .text	00000022 .hidden __floatsidf
00003034  w    F .text	00000014 SDFile::whoami()
20019654  w    O .bss	00000001 SDFile::name()::zeroterm
20019bc4 g     O .bss	00000004 systick_millis_count
0000b6dc g     F .text	00000082 .hidden __ltdf2
00005658 g     F .text	000000aa ExFatFile::rename(ExFatFile*, char const*)
0000977c  w    F .text	00000048 bus_fault_isr
000031c4  w    F .text	00000044 SDFile::truncate(unsigned long long)
000038cc g     F .text	000000ec TwoWire::wait_idle()
000097c4  w    F .text	00000006 watchdog_isr
0000b940 g     F .text	00000000 .hidden __aeabi_uldivmod
00003cf4 g     F .text	0000000c i2c1_isr
20019ca8 g     O .bss	00000001 usb_configuration
000097c4  w    F .text	00000006 dma_ch11_isr
00000474  w    F .text	00000006 SdCardInterface::status()
00009070 g     F .text	0000002c SdioCard::syncDevice()
00008628 g     F .text	0000009c SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
0000062c  w    F .text	00000058 StreamFile<FsBaseFile, unsigned long long>::available()
0000612c g     F .text	00000040 FatFile::readDirCache(bool)
00012640 g     F .text	00000060 __ratio
00003d00 g     F .text	0000000c i2c2_isr
20019cd8 g     O .bss	00000070 AudioStream::memory_pool_available_mask
2001962c g     O .bss	00000008 AudioOutputAnalog::dma
2001390c  w    O .data	00000018 usb_string_manufacturer_name
20019dac g     O .bss	00000008 usb_rx_byte_count_data
000097c4  w    F .text	00000006 pit1_isr
0000bd10 g     F .text	00000010 malloc
200192f4 g     O .bss	00000004 maxNoise
000097c4  w    F .text	00000006 dma_ch4_isr
00013720 g     O .text	00000020 TwoWire::i2c1_hardware
20014880 g     O .bss	00000828 queue
0000ad04 g     F .text	00000084 software_isr
000130e0  w    O .text	00000024 vtable for FsFile
00011dc8 g     F .text	0000001c iswspace
000097c4  w    F .text	00000006 dma_ch7_isr
00003668  w    F .text	0000001e TwoWire::read()
00013e08 g     O .text	000000c8 __mprec_tens
0000a600 g     F .text	000000c4 usb_init
20019d4a g     O .bss	00000002 AudioStream::memory_pool_first_mask
00007874  w    F .text	00000004 SdSpiCard::type() const
0000b860 g     F .text	00000040 .hidden __fixunsdfsi
000097c4  w    F .text	00000006 lptmr_isr
000032ec  w    F .text	00000084 SDFile::seek(unsigned long long, int)
20019d74 g     O .bss	00000004 __malloc_top_pad
000098ec g     F .text	00000024 rtc_set
00012eac g     F .text	0000003a __ssrefill_r
000078c8 g     F .text	0000007a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00005704 g     F .text	000000e2 ExFatFile::truncate()
20013730 g     O .data	00000000 .hidden __dso_handle
0000b1c4 g     F .text	0000001e .hidden __aeabi_ui2d
00011de8 g     F .text	0000001c _localeconv_r
00012d04 g     F .text	00000024 _strtoull_r
000098d0 g     F .text	00000010 attachInterruptVector
0000912c g     F .text	00000048 SdSpiArduinoDriver::deactivate()
00012074 g     F .text	00000012 __i2b
20013730 g       .data	00000000 _sdata
200195c8 g     O .bss	00000004 maxValue
00013700 g     O .text	00000020 TwoWire::i2c0_hardware
00002f28  w    F .text	0000000c File::operator bool()
0000b970 g     F .text	000002e2 .hidden __udivmoddi4
0000af40 g     F .text	00000000 .hidden __aeabi_drsub
00005a80 g     F .text	00000034 FatFile::addCluster()
0000c920 g     F .text	00000024 _sbrk_r
00007b34 g     F .text	0000003e SdSpiCard::readRegister(unsigned char, void*)
000081ec g     F .text	00000020 SdioCard::type() const
00002ea4  w    F .text	0000000c File::write(void const*, unsigned int)
000001d0 g     F .text	000001f0 ResetHandler
000093c8 g     F .text	00000048 usb_serial_getchar
000097c4  w    F .text	00000006 can1_bus_off_isr
000097c4  w    F .text	00000006 ftm2_isr
00003134  w    F .text	0000004c SDFile::name()
20019da0 g     O .bss	00000008 usb_cdc_line_coding
00009910 g     F .text	0000000a digitalWrite
20019cbc g     O .bss	00000004 EventResponder::lastYield
000097c4  w    F .text	00000006 uart5_status_isr
000097c4  w    F .text	00000006 lpuart0_status_isr
00004220 g     F .text	00000028 ExFatFile::openRoot(ExFatVolume*)
000135b8 g     O .text	0000000c vtable for AudioInputI2S
00013a90 g     O .text	00000004 usb_endpoint_config_table
000097c4  w    F .text	00000006 dma_ch9_isr
00000730  w    F .text	0000001c Print::write(char const*)
000006b0  w    F .text	00000038 StreamFile<FsBaseFile, unsigned long long>::read()
000097c4  w    F .text	00000006 pit2_isr
0000b794 g     F .text	00000012 .hidden __aeabi_dcmplt
20019550 g     O .bss	00000050 logFile
20019d70 g     O .bss	00000004 __malloc_max_sbrked_mem
00003224  w    F .text	0000001a SDFile::position()
00009938 g     F .text	0000000a pinMode
00007e34 g     F .text	00000042 SdSpiCard::writeStop()
20019350 g     O .bss	00000200 tempBuffer
00009bd0 g     F .text	0000004c usb_free
000097c4  w    F .text	00000006 i2c3_isr
0000b208 g     F .text	0000003a .hidden __extendsfdf2
0000f474 g     F .text	00000e88 __ssvfscanf_r
0000b504 g     F .text	000001d0 .hidden __aeabi_ddiv
0000af4c g     F .text	00000276 .hidden __adddf3
20013790 g     O .data	0000006c Wire2
00007ecc g     F .text	00000032 SdSpiCard::writeData(unsigned char const*)
00002ebc  w    F .text	00000010 File::peek()
00006a80 g     F .text	000000b0 FatPartition::freeClusterCount()
00003f70  w    F .text	000000d0 SDClass::open(char const*, unsigned char)
000124b4 g     F .text	000000d0 __b2d
00001a2c  w    F .text	00000028 SdBase<FsVolume>::errorHalt(char const*)
00013f68 g       .ARM.exidx	00000000 __exidx_start
0000b2b0 g     F .text	00000254 .hidden __aeabi_dmul
000027c8  w    F .text	0000000c DMAChannel::~DMAChannel()
00007d2c g     F .text	00000050 SdSpiCard::writeStart(unsigned long)
000097c4  w    F .text	00000006 pit0_isr
20019cc0 g     O .bss	00000004 EventResponder::firstYield
00013ae8 g     O .text	00000004 _global_impure_ptr
000097c4  w    F .text	00000006 can1_error_isr
000006fc  w    F .text	00000034 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
0000c540 g     F .text	000003de _realloc_r
00003240  w    F .text	00000018 SDFile::read(void*, unsigned int)
0000bc70 g     F .text	00000050 __libc_init_array
20019db8 g       .bss	00000000 __bss_end
00003180  w    F .text	00000044 SDFile::rewindDirectory()
0000365c  w    F .text	0000000c TwoWire::available()
000097c4  w    F .text	00000006 can0_wakeup_isr
00004ac0 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
0000811c g     F .text	0000001c SdioCard::readCID(CID*)
00013d04 g     O .text	00000100 __hexdig
000053b0 g     F .text	000000e6 ExFatFile::addDirCluster()
00000574  w    F .text	0000004e mRecordQueue<250>::update()
000097c4  w    F .text	00000006 flash_cmd_isr
00007e78 g     F .text	00000052 SdSpiCard::writeData(unsigned char, unsigned char const*)
00013ed0 g     O .text	00000028 __mprec_bigtens
00011f40 g     F .text	00000098 __s2b
00003acc g     F .text	0000021c TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
0000a90c  w    F .text	00000004 usb_serial_class::clear()
0000b1c4 g     F .text	0000001e .hidden __floatunsidf
000097c4  w    F .text	00000006 uart2_status_isr
000097dc g     F .text	0000002c _sbrk
00012308 g     F .text	00000042 __mcmp
00013784  w    O .text	00000028 vtable for SDClass
20019668 g     O .bss	00000008 AudioOutputTDM::dma
00002fdc  w    F .text	00000012 SDFile::operator bool()
200138d8 g     O .data	00000004 __brkval
20019bc0 g     O .bss	00000001 usb_cdc_line_rtsdtr
000027ec g     F .text	0000008c AudioInputI2S::isr()
00009654 g     F .text	00000048 usb_serial_flush_callback
00013f04 g     F .text	00000000 _init
00005b4c g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
000097c4  w    F .text	00000006 svcall_isr
0000aa3c g     F .text	0000006c AudioStream::initialize_memory(audio_block_struct*, unsigned int)
00003d10  w    F .text	00000062 SDClass::remove(char const*)
00002ff0  w    F .text	0000001c SDFile::close()
000097c4  w    F .text	00000006 dma_ch15_isr
0000342c  w    F .text	0000005c SDFile::~SDFile()
0000b8a0 g     F .text	0000009e .hidden __aeabi_d2f
00002704 g     F .text	00000020 day()
00013760 g     O .text	00000024 vtable for TwoWire
000097c4  w    F .text	00000006 uart1_error_isr
000113cc g     F .text	00000028 __libc_fini_array
0000cd38 g     F .text	00000ed8 _strtod_l
00011c18 g     F .text	00000030 __match
000097c4  w    F .text	00000006 usbhs_phy_isr
20019634 g     O .bss	00000008 AudioInputAnalogStereo::dma0
200195b0 g     O .bss	00000018 acq
20019db8 g       .bss	00000000 _ebss
00008738 g     F .text	00000088 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00005f10 g     F .text	00000050 FatFile::preAllocate(unsigned long)
2001961c g     O .bss	00000008 AudioOutputADAT::dma
0000069c  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::flush()
00011fd8 g     F .text	00000040 __hi0bits
0000b810 g     F .text	0000004e .hidden __fixdfsi
00005498 g     F .text	0000005a ExFatFile::mkdir(ExFatFile*, ExName_t*)
000097c4 g     F .text	00000006 unused_isr
000097c4  w    F .text	00000006 spi0_isr
000097c4  w    F .text	00000006 dma_ch3_isr
00003d0c  w    F .text	00000002 SDClass::~SDClass()
000027c8  w    F .text	0000000c DMAChannel::~DMAChannel()
200152a8 g     O .bss	00004000 diskBuffer
200192d4 g     O .bss	00000020 text
00000c48 g     F .text	00000114 c_uSD::loadConfig(unsigned long*, int, long*, int)
00003370  w    F .text	00000028 File::~File()
00002744 g     F .text	00000024 year()
0000ae5c g     F .text	00000004 operator delete(void*, unsigned int)
000097c4  w    F .text	00000006 flash_error_isr
0000af4c g     F .text	00000276 .hidden __aeabi_dadd
0000b6dc g     F .text	00000082 .hidden __ledf2
000097c4  w    F .text	00000006 uart5_error_isr
000097c4  w    F .text	00000006 rtc_seconds_isr
000097c4  w    F .text	00000006 pdb_isr
000121b8 g     F .text	000000a0 __pow5mult
00006340 g     F .text	0000005c FatFile::rmdir()
0000b244 g     F .text	0000006a .hidden __aeabi_ul2d
0000977c  w    F .text	00000048 usage_fault_isr
000097c4  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
00006918 g     F .text	00000082 FatPartition::allocateCluster(unsigned long, unsigned long*)
000097c4  w    F .text	00000006 dma_ch14_isr
00003dc4  w    F .text	0000004c SDClass::exists(char const*)
00000564 g     F .text	00000004 getTeensy3Time()
00000000  w      *UND*	00000000 __deregister_frame_info
20019da8 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
00002878 g     F .text	000000a4 AudioInputI2S::update()
0000a8fc g     F .text	00000010 systick_isr
000097c4  w    F .text	00000006 rtc_alarm_isr
00002f48  w    F .text	0000000c File::isDirectory()
00007570 g     F .text	00000076 FatFile::getSFN(char*)
00007c6c g     F .text	0000006c SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
20019cc8 g     O .bss	00000004 AudioStream::first_update
000097c4  w    F .text	00000006 dma_ch2_isr
00000810 g     F .text	0000006c wavHeader(unsigned long)
200138e4 g     O .data	00000010 Serial
20019ccc g     O .bss	00000002 AudioStream::memory_used_max
000097c4  w    F .text	00000006 ftm1_isr
00002ee4  w    F .text	00000016 File::seek(unsigned long long, int)
00000568  w    F .text	0000000c AudioConnection::~AudioConnection()
000135c4 g     O .text	0000001c vtable for AudioControlSGTL5000
0000a92c  w    F .text	00000006 usb_serial_class::write(unsigned char)
00007708 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
000097cc  w    F .text	0000000c startup_early_hook
00007f00 g     F .text	00000064 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
000097c4  w    F .text	00000006 dma_ch13_isr
0000504c g     F .text	0000008c ExFatFile::addCluster()
00013604  w    O .text	00000060 vtable for File
00002a50  w    F .text	00000004 AudioControlSGTL5000::inputLevel(float)
000097c4  w    F .text	00000006 uart2_error_isr
00003e10  w    F .text	00000052 SDClass::usedSize()
00009410 g     F .text	00000030 usb_serial_peekchar
0000b7d0 g     F .text	00000012 .hidden __aeabi_dcmpgt
0000c2d0 g     F .text	00000000 memchr
000068b0 g     F .text	00000066 FatPartition::fatPut(unsigned long, unsigned long)
20013984 g     O .data	00000016 usb_string_serial_number_default
0000977c g     F .text	00000048 fault_isr
00011490 g     F .text	000001d0 _free_r
0000859c g     F .text	0000008c SdioCard::readStop()
000040ec g     F .text	00000060 FsCache::get(unsigned long, unsigned char)
0000bcd8 g     F .text	0000001c __locale_mb_cur_max
0000b7bc g     F .text	00000012 .hidden __aeabi_dcmpge
000097c4  w    F .text	00000006 usb_charge_isr
00002768 g     F .text	00000044 setTime(long)
0000a91c  w    F .text	00000004 usb_serial_class::flush()
00012e28 g     F .text	00000082 _sungetc_r
000097c4  w    F .text	00000006 cmt_isr
0000af48 g     F .text	0000027a .hidden __aeabi_dsub
00006b30 g     F .text	0000011a FatPartition::init(BlockDeviceInterface*, unsigned char)
000097c4  w    F .text	00000006 usbhs_isr
00005c20 g     F .text	0000014e FatFile::mkdir(FatFile*, fname_t*)
20014344 g     O .data	00000004 __malloc_sbrk_base
0000a914  w    F .text	00000004 usb_serial_class::read()
000097c4  w    F .text	00000006 ftm3_isr
00002f8c  w    F .text	0000000c File::rewindDirectory()
00012968 g     F .text	00000024 _strtoll_r
000097c4  w    F .text	00000006 tsi0_isr
00007000 g     F .text	00000128 FatFile::remove()
20014364 g     O .bss	00000514 uSD
0000b244 g     F .text	0000006a .hidden __floatundidf
00009808  w    F .text	00000002 __cxa_pure_virtual
00012258 g     F .text	000000ae __lshift
00005d70 g     F .text	000000c2 FatFile::mkdir(FatFile*, char const*, bool)
000097c4  w    F .text	00000006 spi2_isr
00004fb8 g     F .text	00000058 exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)
0000291c g     F .text	000000d0 AudioInputI2S::begin()
2001963c g     O .bss	00000008 AudioInputAnalogStereo::dma1
00012d28 g     F .text	00000100 __ssprint_r
00012fe4 g     F .text	0000005e _vasnprintf_r
0000ae54  w    F .text	00000002 serialEvent()
00002d3c  w    F .text	0000005c AudioControlSGTL5000::inputSelect(int)
20019c31 g     O .bss	00000001 usb_reboot_timer
000130b0  w    O .text	0000000c vtable for mRecordQueue<250>
200195f8 g     O .bss	00000008 AudioOutputPWM::dma
000103a8 g     F .text	000000a4 __register_exitproc
000049c0 g     F .text	000000fe ExFatFile::open(ExFatFile*, char const*, int)
000027ac g     F .text	0000001c setSyncProvider(long (*)())
0000cc5c g     F .text	000000a0 strncmp
00000ef4 g     F .text	000001c4 checkDutyCycle(ACQ_Parameters_s*, short)
000054f4 g     F .text	000000d6 ExFatFile::mkdir(ExFatFile*, char const*, bool)
0000945c g     F .text	00000038 usb_serial_flush_input
00004e4c g     F .text	00000072 ExFatPartition::freeClusterCount()
00012088 g     F .text	00000130 __multiply
0000959c g     F .text	00000018 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
20019d78 g     O .bss	00000028 __malloc_current_mallinfo
00002e00  w    F .text	00000020 AudioControlSGTL5000::volume(float)
00012584 g     F .text	000000ba __d2b
20019d50 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
000097c4  w    F .text	00000006 can0_bus_off_isr
000081dc  w    F .text	0000000e SdioCard::~SdioCard()
00004170 g     F .text	000000ae ExFatFile::getName(char*, unsigned int)
20019c9d g     O .bss	00000001 usb_rx_memory_needed
000086c4 g     F .text	00000074 SdioCard::writeStart(unsigned long)
00012af4 g     F .text	00000024 _strtoul_r
00009d8c g     F .text	00000874 usb_isr
0000bc58 g     F .text	0000000c __cxa_atexit
0000430c g     F .text	000001a8 ExFatFile::read(void*, unsigned int)
0000acd4 g     F .text	00000030 AudioStream::update_setup()
20019604 g     O .bss	00000004 AudioInputI2S::block_right
0000b1e4 g     F .text	00000022 .hidden __aeabi_i2d
00003108  w    F .text	00000018 SDFile::peek()
0000414c g     F .text	0000000e FsCache::sync()
0000ae4c g     F .text	00000006 Stream::parseInt()
0000c370 g     F .text	00000062 memcmp
00013a64  w    O .text	00000028 vtable for usb_serial_class
000091b0 g     F .text	00000016 SdSpiArduinoDriver::send(unsigned char)
000097c4  w    F .text	00000006 uart3_error_isr
20013738 g     O .data	00000005 postfix
0000921c g     F .text	00000004 sdCsWrite(unsigned char, bool)
0000ad88 g     F .text	00000040 Stream::timedPeek()
0000c990 g     F .text	00000058 sscanf
0000bc54  w    F .text	00000002 .hidden __aeabi_ldiv0
000051b0 g     F .text	0000005a ExFatFile::rmdir()
20019678 g     O .bss	00000008 AudioInputI2SHex::dma
000097c4  w    F .text	00000006 porta_isr
0000b504 g     F .text	000001d0 .hidden __divdf3
00000d5c g     F .text	00000198 setWakeupCallandSleep(unsigned long)
000126a0 g     F .text	00000046 __copybits
200133d0 g     O .usbbuffers	00000360 usb_buffer_memory
00007b84 g     F .text	00000098 SdSpiCard::sectorCount()
000097c4  w    F .text	00000006 low_voltage_isr
20013f38 g     O .data	00000408 __malloc_av_
000097c4  w    F .text	00000006 can0_error_isr
00009a24 g     F .text	0000016c _init_Teensyduino_internal_
20013734 g     O .data	00000004 outptr
00003120  w    F .text	00000014 SDFile::flush()
0000b2b0 g     F .text	00000254 .hidden __muldf3
000095fc g     F .text	00000058 usb_serial_flush_output
000097c4  w    F .text	00000006 dma_ch12_isr
20019608 g     O .bss	00000008 AudioInputI2S::dma
0000c538 g     F .text	00000002 __malloc_lock
00000000  w      *UND*	00000000 __fini_array_start
00006db4 g     F .text	0000024c FatFile::parsePathName(char const*, fname_t*, char const**)
000097c4  w    F .text	00000006 can1_wakeup_isr
20013200 g     O .dmabuffers	000001d0 _VectorsRam
000091c8 g     F .text	00000052 SdSpiArduinoDriver::send(unsigned char const*, unsigned int)
00013044 g     F .text	0000005e _calloc_r
000097c4  w    F .text	00000006 pit3_isr
200195ec g     O .bss	00000004 getTimePtr
200138e0 g     O .data	00000001 yield_active_check_flags
000097c4  w    F .text	00000006 enet_rx_isr
00005350 g     F .text	0000005e ExFatFile::sync()
0000616c g     F .text	000001d4 FatFile::rename(FatFile*, char const*)
00008ff0 g     F .text	00000080 SdioCard::isBusy()
000097c4  w    F .text	00000006 portc_isr
00007cd8 g     F .text	00000038 SdSpiCard::readStop()
20019644 g     O .bss	00000008 AudioInputI2SQuad::dma
0000c49c g     F .text	0000009a memset
00002d98 g     F .text	00000066 AudioControlSGTL5000::volumeInteger(unsigned int)
0000aa2c g     F .text	00000010 main
20019688 g     O .bss	00000008 AudioOutputI2S::dma
20019d6c g     O .bss	00000004 __malloc_max_total_mem
00004b70 g     F .text	000000b4 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00002604 g     F .text	000000a0 now()
000057e8 g     F .text	00000264 ExFatFile::write(void const*, unsigned int)
0000977c  w    F .text	00000048 memmanage_fault_isr
20013740 g     O .data	00000020 snipParameters
00003294  w    F .text	00000058 SDFile::available()
00002f1c  w    F .text	0000000c File::close()
00002ad8 g     F .text	00000058 AudioControlSGTL5000::write(unsigned int, unsigned int)
0000ae60 g     F .text	0000007c usb_init_serialnumber
000010b8 g     F .text	00000042 setRTCTime(int, int, int, int, int, int)
0000dd68 g     F .text	00000024 _strtol_r
0000b8a0 g     F .text	0000009e .hidden __truncdfsf2
00013f64 g       .text	00000000 __init_array_end
00010598 g     F .text	00000e34 _dtoa_r
0000bd30 g     F .text	00000570 _malloc_r
20019d68 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
000097c4  w    F .text	00000006 debugmonitor_isr
00010360 g     F .text	0000001a __ascii_wctomb
000075e8 g     F .text	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000b254 g     F .text	0000005a .hidden __aeabi_l2d
20019b5c g     O .bss	00000004 FatVolume::m_cwv
20019660 g     O .bss	00000008 AudioInputI2SOct::dma
00012f6c g     F .text	00000078 __submore
00002338 g     F .text	00000008 SPIClass::transfer(void const*, void*, unsigned int)
61a4e1cb g       *ABS*	00000000 __rtc_localtime
00002d30 g     F .text	0000000c AudioControlSGTL5000::enable()
00009944 g     F .text	00000044 micros
00000000  w      *UND*	00000000 __libc_fini
00002f54  w    F .text	00000038 File::openNextFile(unsigned char)
0000087c g     F .text	0000019c c_uSD::init()
000097c4  w    F .text	00000006 cmp1_isr
000097c4  w    F .text	00000006 ftm0_isr
20013760 g     O .data	00000002 mustStore
0000520c g     F .text	00000144 ExFatFile::syncDir()
000113f4 g     F .text	0000009c _malloc_trim_r
20013980 g     O .data	00000004 string0
00009494 g     F .text	00000108 usb_serial_write
000097d8  w    F .text	00000002 startup_late_hook
0000a918  w    F .text	00000004 usb_serial_class::available()
00000a18 g     F .text	00000108 c_uSD::close()
200138f4 g     O .data	00000001 _serialEvent_default
000065a4 g     F .text	0000000c FatFile::sync()
00003d74  w    F .text	00000050 SDClass::mkdir(char const*)
20013968  w    O .data	00000016 usb_string_product_name
00009988 g     F .text	0000009c delay
0000b6e4 g     F .text	0000007a .hidden __nedf2
000097c4  w    F .text	00000006 tpm0_isr
20019cb2 g     O .bss	00000002 dma_channel_allocated_mask
00013f64 g     F .fini	00000000 _fini
00002f34  w    F .text	00000014 File::name()
000036e0 g     F .text	00000026 TwoWire::write(unsigned char)
20019614 g     O .bss	00000008 AudioOutputPT8211::dma
00002724 g     F .text	00000020 month()
00001a54 g     F .text	0000010c c_uSD::write(short*, long)
00007c1c g     F .text	00000050 SdSpiCard::readStart(unsigned long)
00004ad0 g     F .text	00000040 ExFatFile::openNext(ExFatFile*, int)
0000a990 g     F .text	0000001c Print::printf(char const*, ...)
0000c944 g     F .text	0000004c sprintf
000097c4  w    F .text	00000006 i2s0_rx_isr
000097c4  w    F .text	00000006 uart4_error_isr
00005c00 g     F .text	0000001e FatFile::close()
00002efc  w    F .text	00000010 File::position()
00003398  w    F .text	00000064 SDFile::~SDFile()
00010460 g     F .text	0000000c atexit
00008164  w    F .text	00000002 SdioCard::~SdioCard()
00000684  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::peek()
00002fc4  w    F .text	00000018 File::write(unsigned char)
0001037c g     F .text	0000002c _write_r
2001969c g     O .bss	000004b8 SD
00008458 g     F .text	000000ec SdioCard::erase(unsigned long, unsigned long)
0000ab50 g     F .text	00000054 AudioStream::release(audio_block_struct*)
000097c4  w    F .text	00000006 can0_message_isr
0000af28 g     F .text	0000000c nanf
20013dc8 g     O .data	00000004 _impure_ptr
000135e0  w    O .text	00000024 vtable for Stream
000097c4  w    F .text	00000006 can1_message_isr
000044b4 g     F .text	0000002e ExFatFile::peek()
000130bc  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
20019690 g     O .bss	00000008 AudioOutputSPDIF::dma
00011e04 g     F .text	0000005c _mbrtowc_r
000097c4  w    F .text	00000006 nmi_isr
200137fc g     O .data	0000006c Wire
00007128 g     F .text	000000b6 FatFile::lfnUniqueSfn(fname_t*)
00003280  w    F .text	00000014 SDFile::write(void const*, unsigned int)
0000aba4 g     F .text	00000034 AudioStream::transmit(audio_block_struct*, unsigned char)
00007830 g     F .text	00000028 FsVolume::open(char const*, int)
00008104 g     F .text	0000000c SdioCard::errorCode() const
200195a0 g     O .bss	0000000c audioShield
00005ef4 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
000006e8  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
00013f10 g       .text	00000000 __preinit_array_end
00000498 g     F .text	00000098 dateTime(unsigned short*, unsigned short*, unsigned char*)
00007878  w    F .text	00000002 SdSpiCard::~SdSpiCard()
20019670 g     O .bss	00000008 AudioInputTDM::dma
000097c4  w    F .text	00000006 sdhc_isr
000026c4 g     F .text	00000020 minute()
00000530  w    F .text	00000018 FsFile::~FsFile()
00004ec0 g     F .text	000000e0 ExFatPartition::init(BlockDeviceInterface*, unsigned char)
000055cc g     F .text	0000008a ExFatFile::preAllocate(unsigned long long)
00004d08 g     F .text	00000034 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00007d7c g     F .text	000000b8 SdSpiCard::erase(unsigned long, unsigned long)
0000c2a0 g     F .text	0000002a __ascii_mbtowc
00007944 g     F .text	0000004e SdSpiCard::isBusy()
00012460 g     F .text	00000054 __ulp
000137b4 g     O .text	00000058 vtable for SdSpiCard
0000aaa8 g     F .text	000000a8 AudioStream::allocate()
200150a8 g     O .bss	00000200 header
00007b7c  w    F .text	00000008 SdSpiCard::readCID(CID*)
00003688  w    F .text	00000016 TwoWire::peek()
000036a0  w    F .text	00000002 TwoWire::flush()
000017c0 g     F .text	000001d4 setup
00013a94 g     O .text	00000054 usb_descriptor_list
00009c1c g     F .text	0000003c usb_rx
00008294 g     F .text	00000020 SdioCard::status()
000097c4  w    F .text	00000006 dma_ch10_isr
00000470  w    F .text	00000002 Print::flush()
0000b860 g     F .text	00000040 .hidden __aeabi_d2uiz
00000b20 g     F .text	00000128 c_uSD::storeConfig(unsigned long*, int, long*, int)
000097c4  w    F .text	00000006 uart0_error_isr
00002f0c  w    F .text	00000010 File::size()
2001933c g     O .bss	00000014 patchCord4
00003e64  w    F .text	00000062 SDClass::rmdir(char const*)
00009b90 g     F .text	00000040 usb_malloc
00005f60 g     F .text	0000019e FatFile::read(void*, unsigned int)
000097c4  w    F .text	00000006 i2s0_isr
00005f04 g     F .text	0000000c FatFile::openRoot(FatVolume*)
20019b58 g     O .bss	00000004 ExFatVolume::m_cwv
20030000 g       .bss	00000000 _estack
00007858 g     F .text	00000004 operator new(unsigned int, unsigned long*)
00007b74  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
0000a87c g     F .text	00000038 DMAChannel::release()
00002f98  w    F .text	0000002c File::read()
000095b4 g     F .text	00000048 usb_serial_write_buffer_free
00007a14 g     F .text	0000003c SdSpiCard::waitNotBusy(unsigned short)
000097c4  w    F .text	00000006 enet_timer_isr
0000abf0 g     F .text	00000068 AudioConnection::connect()
0000b780 g     F .text	00000012 .hidden __aeabi_dcmpeq
00002508 g     F .text	000000fc makeTime(tmElements_t const&)
20019680 g     O .bss	00000008 AudioInputPDM::dma
000036a4 g     F .text	0000003a TwoWire::write(unsigned char const*, unsigned int)
000033fc  w    F .text	00000030 File::~File()
0000a980  w    F .text	0000000e _write
20014348 g       .data	00000000 _edata
00004da8 g     F .text	00000024 ExFatPartition::fatPut(unsigned long, unsigned long)
00008164  w    F .text	00000002 SdioCard::~SdioCard()
000097c4  w    F .text	00000006 i2s0_tx_isr
000097c4  w    F .text	00000006 adc1_isr
00007d10 g     F .text	0000001c SdSpiCard::syncDevice()
00005ab4 g     F .text	00000098 FatFile::addDirCluster()
00002e98  w    F .text	0000000c File::read(void*, unsigned int)
0000a920  w    F .text	00000004 usb_serial_class::availableForWrite()
000097c4  w    F .text	00000006 cmp0_isr
00002ed8  w    F .text	0000000c File::truncate(unsigned long long)
0000aedc g     F .text	0000004c ultoa
00003d0c  w    F .text	00000002 SDClass::~SDClass()
000026e4 g     F .text	00000020 second()
00003708 g     F .text	00000094 TwoWire::begin()
00001994  w    F .text	00000098 SdBase<FsVolume>::errorHalt(Print*)
00007688 g     F .text	00000080 FsBaseFile::open(FsVolume*, char const*, int)
0000ae58 g     F .text	00000004 operator new(unsigned int)
0000a8b4 g     F .text	00000044 EventResponder::runFromInterrupt()
20014340 g     O .data	00000004 __malloc_trim_threshold
0000a910  w    F .text	00000004 usb_serial_class::peek()
0000ac58 g     F .text	0000007a AudioConnection::disconnect()
00002b30 g     F .text	00000200 AudioControlSGTL5000::enable(unsigned int, unsigned long)
0001234c g     F .text	00000114 __mdiff
00008154 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000b810 g     F .text	0000004e .hidden __aeabi_d2iz
00004d3c g     F .text	00000058 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
20019bb0 g     O .bss	00000001 usb_cdc_transmit_flush_timer
20019d4e g     O .bss	00000002 AudioStream::cpu_cycles_total
000097c4  w    F .text	00000006 pit_isr
000026a4 g     F .text	00000020 hour()
0000859c g     F .text	0000008c SdioCard::writeStop()
00007f64  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00012748 g     F .text	00000072 __sccl
0000415c g     F .text	00000014 ExFatFile::close()
00013bf0 g     O .text	00000101 _ctype_
000097c4  w    F .text	00000006 dac0_isr
00007864  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00013f10 g       .text	00000000 __init_array_start
0000bc54  w    F .text	00000002 .hidden __aeabi_idiv0
000097c4  w    F .text	00000006 can1_tx_warn_isr
0000b7e4 g     F .text	0000002c .hidden __unorddf2
00003ec8  w    F .text	00000074 SDClass::rename(char const*, char const*)
000097c4  w    F .text	00000006 uart0_status_isr
20019600 g     O .bss	00000002 AudioInputI2S::block_offset
000097c4  w    F .text	00000006 mcg_isr
0000adf0 g     F .text	0000005a Stream::parseInt(char)
00000400 g     O .text	00000010 flashconfigbytes
0000a7b0 g     F .text	000000cc DMAChannel::begin(bool)
0000cb80 g     F .text	000000dc strlen
00006c98 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000bcf4 g     F .text	00000006 __locale_ctype_ptr_l
0000b770 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000b6d4 g     F .text	0000008a .hidden __gedf2
0000639c g     F .text	000000b0 FatFile::seekSet(unsigned long)
00011708 g     F .text	00000510 __gethex
20013968 g     O .data	00000016 usb_string_product_name_default
20019658 g     O .bss	00000008 AudioOutputI2SQuad::dma
00010348 g     F .text	00000018 vdprintf
000097c4  w    F .text	00000006 dma_ch1_isr
000083ec g     F .text	0000006c SdioCard::sectorCount()
00007768 g     F .text	000000c8 FsVolume::begin(BlockDeviceInterface*)
00000548  w    F .text	0000001c c_uSD::~c_uSD()
00009c58 g     F .text	0000002c usb_tx_packet_count
00006524 g     F .text	00000080 FatFile::openNext(FatFile*, int)
0000c9ec g     F .text	000000ce strchr
0001380c g     O .text	00000058 vtable for SdioCard
0000b208 g     F .text	0000003a .hidden __aeabi_f2d
000097c4  w    F .text	00000006 dma_ch5_isr
00006cc8 g     F .text	000000ec FatFile::getName(char*, unsigned int)
000097c4  w    F .text	00000006 can0_rx_warn_isr
000097c4  w    F .text	00000006 can0_tx_warn_isr
000097c4  w    F .text	00000006 uart4_status_isr
00008e24 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
20019624 g     O .bss	00000008 AudioInputAnalog::dma
20019d48 g     O .bss	00000002 AudioStream::cpu_cycles_total_max
0000909c g     F .text	00000090 SdSpiArduinoDriver::activate()
0000af48 g     F .text	0000027a .hidden __subdf3
00013f10 g       .text	00000000 __preinit_array_start
000130a4  w    O .text	0000000c vtable for AudioStream
00004c24 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
0000300c  w    F .text	00000028 File::whoami()
00012018 g     F .text	0000005a __lo0bits
00004ccc g     F .text	0000003a ExFatPartition::chainSize(unsigned long)
0000644c g     F .text	000000d6 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
0000af34 g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
00000530  w    F .text	00000018 FsFile::~FsFile()
000098e0 g     F .text	0000000c rtc_get
000050d8 g     F .text	000000d6 ExFatFile::remove()
000097c4  w    F .text	00000006 cmp2_isr
0000a8f8 g     F .text	00000004 pendablesrvreq_isr
00003f3c  w    F .text	00000034 SDClass::totalSize()
00000568  w    F .text	0000000c AudioConnection::~AudioConnection()
0000046c  w    F .text	00000004 Print::availableForWrite()
20013dcc g     O .data	0000016c __global_locale
000097c4  w    F .text	00000006 wakeup_isr
000089c4 g     F .text	00000394 SdioCard::begin(SdioConfig)
20019610 g     O .bss	00000004 AudioInputI2S::block_left
000097c4  w    F .text	00000006 cmp3_isr
00002340 g     F .text	000001b0 breakTime(long, tmElements_t&)
0000a9ac g     F .text	0000007e Print::printNumber(unsigned long, unsigned char, unsigned char)
00006840 g     F .text	0000006e FatPartition::fatGet(unsigned long, unsigned long*)
0000bd20 g     F .text	00000010 free
000097c4  w    F .text	00000006 tpm2_isr
00011ec0 g     F .text	00000080 __multadd
00011eac g     F .text	00000012 _Bfree
00003208  w    F .text	0000001a SDFile::size()
000097c4  w    F .text	00000006 dma_ch0_isr
0000342c  w    F .text	0000005c SDFile::~SDFile()
20013984  w    O .data	00000016 usb_string_serial_number
000097c4  w    F .text	00000006 enet_tx_isr
00005010 g     F .text	0000003a exFatHashName(char const*, unsigned int, unsigned short)
00008e98 g     F .text	000000f0 SdioCard::readSector(unsigned long, unsigned char*)
00008138 g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  str = fsFmtField(str, 2*(time & 31) + (sec100 < 100 ? 0 : 1), 0);
  *--str = ':';
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
       0:	... ........}...
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      10:	}...}...}...}...
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
      20:	}...}...}.......
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      30:	....}...........
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
      40:	................
  }
  str = fmtBase10(str, n);
  if (n < 10) {
    *--str = '0';
      50:	................
      tz = -tz;
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      60:	................
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      *--str = sign;
    }
    *--str = 'C';
    *--str = 'T';
      70:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      80:	................
      90:	................
      a0:	.<...<..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	................
     150:	................
     160:	.........=......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	97cc <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
     1ea:	mov.w	r2, #184549376	; 0xb000000
     1ee:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	ldr	r2, [pc, #332]	; (340 <ResetHandler+0x170>)
     1f2:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	ldr	r2, [pc, #332]	; (344 <ResetHandler+0x174>)
     1f6:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	ldr	r3, [pc, #332]	; (348 <ResetHandler+0x178>)
     1fa:	mov.w	r2, #15728640	; 0xf00000
     1fe:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	ldr	r3, [pc, #328]	; (34c <ResetHandler+0x17c>)
     202:	ldr	r2, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	ldr	r3, [pc, #332]	; (354 <ResetHandler+0x184>)
     208:	ldrb	r2, [r3, #0]
     20a:	lsls	r1, r2, #28
     20c:	bpl.n	216 <ResetHandler+0x46>
     20e:	ldrb	r2, [r3, #0]
     210:	orr.w	r2, r2, #8
     214:	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	ldr	r3, [pc, #320]	; (358 <ResetHandler+0x188>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	ldr	r1, [pc, #320]	; (35c <ResetHandler+0x18c>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r1, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r2, #0
     236:	cmp	r3, r1
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r2, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r1, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r2, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r0, [r2, r3, lsl #2]
     24a:	str.w	r0, [r1, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r2, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r4, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r0, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r2, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r1, [r2, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r1, r1, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
     2d4:	bne.n	2de <ResetHandler+0x10e>
		RTC_SR = 0;
     2d6:	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	mov.w	r3, #5376	; 0x1500
     2dc:	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	9a24 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	98ec <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	98ec <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     328:	bl	bc70 <__libc_init_array>

	startup_late_hook();
     32c:	bl	97d8 <startup_late_hook>
	main();
     330:	bl	aa2c <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x00043f82
     344:	.word	0x2b000001
     348:	.word	0xe000ed88
     34c:	.word	0xe0082000
     350:	.word	0x85000003
     354:	.word	0x4007d002
     358:	.word	0x4007e000
     35c:	.word	0x20014348
     360:	.word	0x00013f6c
     364:	.word	0x20013730
     368:	.word	0x20014348
     36c:	.word	0x20019db8
     370:	.word	0x20013200
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x61a4e1cb
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x20014348
     42c:	.word	0x00000000
     430:	.word	0x00013f68

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x2001434c
     460:	.word	0x00013f68
     464:	.word	0x20014348
     468:	.word	0x00000000

0000046c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     46c:	movs	r0, #0
     46e:	bx	lr

00000470 <Print::flush()>:
	virtual void flush()				{ }
     470:	bx	lr
     472:	nop

00000474 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
     474:	mov.w	r0, #4294967295
     478:	bx	lr
     47a:	nop

0000047c <llwuISR()>:

static void llwuISR(void)
{
    //
#if defined(HAS_KINETIS_LLWU_32CH)
    LLWU_MF5 |= LLWU_MF5_MWUF5_MASK; // clear source in LLWU Flag register
     47c:	ldr	r2, [pc, #16]	; (490 <llwuISR()+0x14>)
#else
    LLWU_F3 |= LLWU_F3_MWUF5_MASK; // clear source in LLWU Flag register
#endif
    //
    RTC_IER = 0;// clear RTC interrupts
     47e:	ldr	r1, [pc, #20]	; (494 <llwuISR()+0x18>)

static void llwuISR(void)
{
    //
#if defined(HAS_KINETIS_LLWU_32CH)
    LLWU_MF5 |= LLWU_MF5_MWUF5_MASK; // clear source in LLWU Flag register
     480:	ldrb	r3, [r2, #0]
#else
    LLWU_F3 |= LLWU_F3_MWUF5_MASK; // clear source in LLWU Flag register
#endif
    //
    RTC_IER = 0;// clear RTC interrupts
     482:	movs	r0, #0

static void llwuISR(void)
{
    //
#if defined(HAS_KINETIS_LLWU_32CH)
    LLWU_MF5 |= LLWU_MF5_MWUF5_MASK; // clear source in LLWU Flag register
     484:	orr.w	r3, r3, #32
     488:	strb	r3, [r2, #0]
#else
    LLWU_F3 |= LLWU_F3_MWUF5_MASK; // clear source in LLWU Flag register
#endif
    //
    RTC_IER = 0;// clear RTC interrupts
     48a:	str	r0, [r1, #0]
     48c:	bx	lr
     48e:	nop
     490:	.word	0x4007c00d
     494:	.word	0x4003d01c

00000498 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:

#include <TimeLib.h>

// Call back for file timestamps (used by FS).  Only called for file create and sync().
  void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{
     498:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     49c:	mov	r7, r1
     49e:	mov	r6, r2
     4a0:	mov	r8, r0
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());
     4a2:	bl	2744 <year()>
     4a6:	mov	r4, r0
     4a8:	bl	2724 <month()>
     4ac:	mov	r5, r0
     4ae:	bl	2704 <day()>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
     4b2:	subw	r3, r4, #1980	; 0x7bc
     4b6:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
     4b8:	cmp	r3, #127	; 0x7f
     4ba:	bhi.n	4c2 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     4bc:	uxtb	r2, r5
     4be:	cmp	r2, #12
     4c0:	bls.n	51a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x82>
         year << 9 | month << 5 | day;
     4c2:	movs	r3, #0
     4c4:	strh.w	r3, [r8]

  // Return time using FS_TIME macro to format fields.
  *time = FS_TIME(hour(), minute(), second());
     4c8:	bl	26a4 <hour()>
     4cc:	mov	r4, r0
     4ce:	bl	26c4 <minute()>
     4d2:	mov	r5, r0
     4d4:	bl	26e4 <second()>
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
     4d8:	uxtb	r3, r4
     4da:	cmp	r3, #23
     4dc:	bhi.n	4e4 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     4de:	uxtb	r3, r5
     4e0:	cmp	r3, #59	; 0x3b
     4e2:	bls.n	4fc <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
     4e4:	movs	r3, #0
     4e6:	strh	r3, [r7, #0]

  // Return low time bits in units of 10 ms.
  *ms10 = second() & 1 ? 100 : 0;
     4e8:	bl	26e4 <second()>
     4ec:	tst.w	r0, #1
     4f0:	ite	ne
     4f2:	movne	r3, #100	; 0x64
     4f4:	moveq	r3, #0
     4f6:	strb	r3, [r6, #0]
     4f8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     4fc:	uxtb	r3, r0
     4fe:	cmp	r3, #59	; 0x3b
     500:	bhi.n	4e4 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
         hour << 11 | minute << 5 | second >> 1;
     502:	lsls	r4, r4, #11
     504:	lsls	r3, r5, #5
     506:	and.w	r4, r4, #522240	; 0x7f800
     50a:	and.w	r3, r3, #8160	; 0x1fe0
     50e:	orrs	r3, r4
     510:	ubfx	r0, r0, #1, #7
     514:	orrs	r3, r0
     516:	uxth	r3, r3
     518:	b.n	4e6 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4e>

// Call back for file timestamps (used by FS).  Only called for file create and sync().
  void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());
     51a:	uxtb	r0, r0
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     51c:	cmp	r0, #31
     51e:	bhi.n	4c2 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
         year << 9 | month << 5 | day;
     520:	lsls	r5, r5, #5
     522:	and.w	r5, r5, #8160	; 0x1fe0
     526:	orrs	r0, r5
     528:	orr.w	r3, r0, r3, lsl #9
     52c:	uxth	r3, r3
     52e:	b.n	4c4 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2c>

00000530 <FsFile::~FsFile()>:
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     530:	push	{r4, lr}
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     532:	ldr	r3, [pc, #16]	; (544 <FsFile::~FsFile()+0x14>)
     534:	mov	r4, r0
     536:	str.w	r3, [r0], #16
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     53a:	bl	7660 <FsBaseFile::close()>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     53e:	mov	r0, r4
     540:	pop	{r4, pc}
     542:	nop
     544:	.word	0x000130c4

00000548 <c_uSD::~c_uSD()>:
int16_t diskBuffer[BUFFERSIZE];
int16_t *outptr = diskBuffer;

char header[512];

class c_uSD
     548:	push	{r4, lr}
     54a:	ldr	r3, [pc, #20]	; (560 <c_uSD::~c_uSD()+0x18>)
     54c:	str.w	r3, [r0, #1204]	; 0x4b4
     550:	mov	r4, r0
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     552:	addw	r0, r0, #1220	; 0x4c4
     556:	bl	7660 <FsBaseFile::close()>
     55a:	mov	r0, r4
     55c:	pop	{r4, pc}
     55e:	nop
     560:	.word	0x000130c4

00000564 <getTeensy3Time()>:
#ifdef __cplusplus
}
class teensy3_clock_class
{
public:
	static unsigned long get(void) __attribute__((always_inline)) { return rtc_get(); }
     564:	b.w	98e0 <rtc_get>

00000568 <AudioConnection::~AudioConnection()>:
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
		{ isConnected = false;
		  connect(); }
	friend class AudioStream;
	~AudioConnection() {
     568:	push	{r4, lr}
     56a:	mov	r4, r0
		disconnect();
     56c:	bl	ac58 <AudioConnection::disconnect()>
	}
     570:	mov	r0, r4
     572:	pop	{r4, pc}

00000574 <mRecordQueue<250>::update()>:
	release(userblock);
	userblock = NULL;
}

template <int mq>
void mRecordQueue<mq>::update(void)
     574:	push	{r4, lr}
{
	audio_block_t *block;
	uint16_t h;

	block = receiveReadOnly();
     576:	movs	r1, #0
	release(userblock);
	userblock = NULL;
}

template <int mq>
void mRecordQueue<mq>::update(void)
     578:	mov	r4, r0
{
	audio_block_t *block;
	uint16_t h;

	block = receiveReadOnly();
     57a:	bl	abd8 <AudioStream::receiveReadOnly(unsigned int)>
	if (!block) return;
     57e:	cbz	r0, 5ac <mRecordQueue<250>::update()+0x38>
	if (!enabled) {
     580:	ldrh.w	r3, [r4, #1040]	; 0x410
     584:	uxth	r3, r3
     586:	cbz	r3, 5ae <mRecordQueue<250>::update()+0x3a>
		release(block);
		return;
	}
	h = head + 1;
     588:	ldrh.w	r3, [r4, #1036]	; 0x40c
	if (h >= mq) h = 0;
	if (h == tail) {
     58c:	ldrh.w	r2, [r4, #1038]	; 0x40e
	if (!block) return;
	if (!enabled) {
		release(block);
		return;
	}
	h = head + 1;
     590:	adds	r3, #1
     592:	uxth	r3, r3
	if (h >= mq) h = 0;
     594:	cmp	r3, #250	; 0xfa
     596:	it	cs
     598:	movcs	r3, #0
	if (h == tail) {
     59a:	uxth	r2, r2
     59c:	cmp	r3, r2
     59e:	beq.n	5b6 <mRecordQueue<250>::update()+0x42>
		release(block); // drop incomming data
    dropCount++; // flag for main to know
	} else {
		queue[h] = block; // store incomming data
     5a0:	add.w	r2, r3, #8
     5a4:	str.w	r0, [r4, r2, lsl #2]
		head = h;
     5a8:	strh.w	r3, [r4, #1036]	; 0x40c
     5ac:	pop	{r4, pc}
	}
}
     5ae:	ldmia.w	sp!, {r4, lr}
	uint16_t h;

	block = receiveReadOnly();
	if (!block) return;
	if (!enabled) {
		release(block);
     5b2:	b.w	ab50 <AudioStream::release(audio_block_struct*)>
		return;
	}
	h = head + 1;
	if (h >= mq) h = 0;
	if (h == tail) {
		release(block); // drop incomming data
     5b6:	bl	ab50 <AudioStream::release(audio_block_struct*)>
    dropCount++; // flag for main to know
     5ba:	ldr	r3, [r4, #24]
     5bc:	adds	r3, #1
     5be:	str	r3, [r4, #24]
     5c0:	pop	{r4, pc}
     5c2:	nop

000005c4 <getTime(char*) [clone .constprop.34]>:
{
    sprintf(text,"%04d/%02d/%02d",year(), month(), day());
    return text;  
}

static char * getTime(char *text)
     5c4:	push	{r4, r5, r6, lr}
     5c6:	sub	sp, #8
{
    sprintf(text,"%02d:%02d:%02d",hour(),minute(),second());
     5c8:	bl	26a4 <hour()>
     5cc:	mov	r5, r0
     5ce:	bl	26c4 <minute()>
     5d2:	mov	r6, r0
     5d4:	bl	26e4 <second()>
     5d8:	ldr	r4, [pc, #20]	; (5f0 <getTime(char*) [clone .constprop.34]+0x2c>)
     5da:	str	r0, [sp, #0]
     5dc:	mov	r3, r6
     5de:	mov	r2, r5
     5e0:	mov	r0, r4
     5e2:	ldr	r1, [pc, #16]	; (5f4 <getTime(char*) [clone .constprop.34]+0x30>)
     5e4:	bl	c944 <sprintf>
    return text;
}
     5e8:	mov	r0, r4
     5ea:	add	sp, #8
     5ec:	pop	{r4, r5, r6, pc}
     5ee:	nop
     5f0:	.word	0x200192d4
     5f4:	.word	0x00013104

000005f8 <getDate(char*) [clone .constprop.35]>:
*/


#include <TimeLib.h>

static char * getDate(char *text)
     5f8:	push	{r4, r5, r6, lr}
     5fa:	sub	sp, #8
{
    sprintf(text,"%04d/%02d/%02d",year(), month(), day());
     5fc:	bl	2744 <year()>
     600:	mov	r5, r0
     602:	bl	2724 <month()>
     606:	mov	r6, r0
     608:	bl	2704 <day()>
     60c:	ldr	r4, [pc, #20]	; (624 <getDate(char*) [clone .constprop.35]+0x2c>)
     60e:	str	r0, [sp, #0]
     610:	mov	r3, r6
     612:	mov	r2, r5
     614:	mov	r0, r4
     616:	ldr	r1, [pc, #16]	; (628 <getDate(char*) [clone .constprop.35]+0x30>)
     618:	bl	c944 <sprintf>
    return text;  
}
     61c:	mov	r0, r4
     61e:	add	sp, #8
     620:	pop	{r4, r5, r6, pc}
     622:	nop
     624:	.word	0x200192d4
     628:	.word	0x00013114

0000062c <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     62c:	ldr	r2, [r0, #72]	; 0x48
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     62e:	cbz	r2, 64a <StreamFile<FsBaseFile, unsigned long long>::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     630:	ldrb	r3, [r2, #0]
     632:	and.w	r3, r3, #8
     636:	and.w	r0, r3, #255	; 0xff
     63a:	cbz	r3, 67e <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     63c:	ldr	r3, [r2, #28]
     63e:	ldr	r0, [r2, #20]
     640:	subs	r0, r3, r0
     642:	it	mi
     644:	mvnmi.w	r0, #2147483648	; 0x80000000
     648:	bx	lr
     64a:	ldr	r1, [r0, #76]	; 0x4c
     64c:	cbz	r1, 680 <StreamFile<FsBaseFile, unsigned long long>::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     64e:	ldrb.w	r3, [r1, #49]	; 0x31
     652:	and.w	r3, r3, #8
     656:	and.w	r0, r3, #255	; 0xff
     65a:	cbz	r3, 67e <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     65c:	ldrd	r2, r3, [r1, #16]
     660:	ldrd	r0, r1, [r1]
     664:	subs	r0, r2, r0
     666:	push	{r4, r5}
     668:	sbc.w	r1, r3, r1
     66c:	movs	r5, #0
     66e:	mvn.w	r4, #2147483648	; 0x80000000
     672:	cmp	r5, r1
     674:	it	eq
     676:	cmpeq	r4, r0
     678:	bcs.n	67c <StreamFile<FsBaseFile, unsigned long long>::available()+0x50>
     67a:	mov	r0, r4
    return BaseFile::available();
  }
     67c:	pop	{r4, r5}
     67e:	bx	lr
     680:	mov	r0, r1
     682:	bx	lr

00000684 <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     684:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     686:	cbz	r3, 68e <StreamFile<FsBaseFile, unsigned long long>::peek()+0xa>
     688:	mov	r0, r3
     68a:	b.w	6100 <FatFile::peek()>
     68e:	ldr	r0, [r0, #76]	; 0x4c
     690:	cbz	r0, 696 <StreamFile<FsBaseFile, unsigned long long>::peek()+0x12>
     692:	b.w	44b4 <ExFatFile::peek()>
    return BaseFile::peek();
  }
     696:	mov.w	r0, #4294967295
     69a:	bx	lr

0000069c <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     69c:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     69e:	cbz	r3, 6a6 <StreamFile<FsBaseFile, unsigned long long>::flush()+0xa>
     6a0:	mov	r0, r3
     6a2:	b.w	65a4 <FatFile::sync()>
     6a6:	ldr	r0, [r0, #76]	; 0x4c
     6a8:	cbz	r0, 6ae <StreamFile<FsBaseFile, unsigned long long>::flush()+0x12>
     6aa:	b.w	5350 <ExFatFile::sync()>
     6ae:	bx	lr

000006b0 <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     6b0:	push	{lr}
     6b2:	ldr	r3, [r0, #72]	; 0x48
     6b4:	sub	sp, #12
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     6b6:	cbz	r3, 6d2 <StreamFile<FsBaseFile, unsigned long long>::read()+0x22>
     6b8:	mov	r0, r3
     6ba:	movs	r2, #1
     6bc:	add.w	r1, sp, #7
     6c0:	bl	5f60 <FatFile::read(void*, unsigned int)>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     6c4:	cmp	r0, #1
     6c6:	bne.n	6e2 <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     6c8:	ldrb.w	r0, [sp, #7]
    return BaseFile::read();
  }
     6cc:	add	sp, #12
     6ce:	ldr.w	pc, [sp], #4
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     6d2:	ldr	r0, [r0, #76]	; 0x4c
     6d4:	cbz	r0, 6e2 <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     6d6:	movs	r2, #1
     6d8:	add.w	r1, sp, #7
     6dc:	bl	430c <ExFatFile::read(void*, unsigned int)>
     6e0:	b.n	6c4 <StreamFile<FsBaseFile, unsigned long long>::read()+0x14>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     6e2:	mov.w	r0, #4294967295
     6e6:	b.n	6cc <StreamFile<FsBaseFile, unsigned long long>::read()+0x1c>

000006e8 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     6e8:	ldr	r3, [r0, #72]	; 0x48
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     6ea:	cbz	r3, 6f2 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0xa>
     6ec:	mov	r0, r3
     6ee:	b.w	6628 <FatFile::write(void const*, unsigned int)>
     6f2:	ldr	r0, [r0, #76]	; 0x4c
     6f4:	cbz	r0, 6fa <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0x12>
     6f6:	b.w	57e8 <ExFatFile::write(void const*, unsigned int)>
    return BaseFile::write(buffer, size);
  }
     6fa:	bx	lr

000006fc <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     6fc:	push	{lr}
     6fe:	ldr	r3, [r0, #72]	; 0x48
     700:	sub	sp, #12
     702:	strb.w	r1, [sp, #7]
     706:	cbz	r3, 71a <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x1e>
     708:	mov	r0, r3
     70a:	movs	r2, #1
     70c:	add.w	r1, sp, #7
     710:	bl	6628 <FatFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     714:	add	sp, #12
     716:	ldr.w	pc, [sp], #4
     71a:	ldr	r0, [r0, #76]	; 0x4c
     71c:	cmp	r0, #0
     71e:	beq.n	714 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x18>
     720:	movs	r2, #1
     722:	add.w	r1, sp, #7
     726:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     72a:	add	sp, #12
     72c:	ldr.w	pc, [sp], #4

00000730 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     730:	push	{r4, r5, r6, lr}
     732:	mov	r4, r0
     734:	mov	r0, r1
     736:	mov	r5, r1
     738:	bl	cb80 <strlen>
     73c:	ldr	r3, [r4, #0]
     73e:	mov	r2, r0
     740:	mov	r1, r5
     742:	mov	r0, r4
     744:	ldr	r3, [r3, #4]
     746:	ldmia.w	sp!, {r4, r5, r6, lr}
     74a:	bx	r3

0000074c <Print::println(__FlashStringHelper const*)>:
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     74c:	push	{r3, r4, r5, lr}
     74e:	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     750:	mov	r0, r1
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     752:	mov	r5, r1
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     754:	bl	cb80 <strlen>
     758:	ldr	r3, [r4, #0]
     75a:	mov	r2, r0
     75c:	mov	r1, r5
     75e:	ldr	r3, [r3, #4]
     760:	mov	r0, r4
     762:	blx	r3
     764:	mov	r5, r0
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     766:	mov	r0, r4
     768:	bl	a960 <Print::println()>
     76c:	add	r0, r5
     76e:	pop	{r3, r4, r5, pc}

00000770 <makeFilename(char*)>:
  // Return low time bits in units of 10 ms.
  *ms10 = second() & 1 ? 100 : 0;
}

char *makeFilename(char * prefix)
{ static char filename[40];
     770:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     774:	sub	sp, #28
     776:	mov	r4, r0

  sprintf(filename, "%s_%04d_%02d_%02d_%02d_%02d_%02d%s", prefix, 
     778:	bl	2744 <year()>
     77c:	mov	r5, r0
     77e:	bl	2724 <month()>
     782:	mov	r9, r0
     784:	bl	2704 <day()>
     788:	mov	r6, r0
     78a:	bl	26a4 <hour()>
     78e:	mov	r7, r0
     790:	bl	26c4 <minute()>
     794:	mov	r8, r0
     796:	bl	26e4 <second()>
                    year(), month(), day(), hour(), minute(), second(), postfix);
     79a:	ldr	r1, [pc, #96]	; (7fc <makeFilename(char*)+0x8c>)
     79c:	str	r0, [sp, #16]
     79e:	mov	r2, r4
     7a0:	mov	r3, r5
     7a2:	str	r1, [sp, #20]
     7a4:	str.w	r9, [sp]
     7a8:	ldr	r1, [pc, #84]	; (800 <makeFilename(char*)+0x90>)
     7aa:	str.w	r8, [sp, #12]
     7ae:	str	r7, [sp, #8]
     7b0:	str	r6, [sp, #4]
     7b2:	ldr	r0, [pc, #80]	; (804 <makeFilename(char*)+0x94>)
     7b4:	bl	c944 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     7b8:	ldr	r0, [pc, #72]	; (804 <makeFilename(char*)+0x94>)
     7ba:	bl	cb80 <strlen>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     7be:	mov	r1, r0
     7c0:	ldr	r0, [pc, #64]	; (804 <makeFilename(char*)+0x94>)
     7c2:	bl	9494 <usb_serial_write>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     7c6:	ldr	r0, [pc, #64]	; (808 <makeFilename(char*)+0x98>)
     7c8:	bl	a960 <Print::println()>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     7cc:	ldr	r0, [pc, #52]	; (804 <makeFilename(char*)+0x94>)
     7ce:	bl	cb80 <strlen>
     7d2:	ldr	r1, [pc, #56]	; (80c <makeFilename(char*)+0x9c>)
     7d4:	mov	r2, r0
     7d6:	ldr	r0, [r1, #72]	; 0x48
     7d8:	cbz	r0, 7ee <makeFilename(char*)+0x7e>
     7da:	ldr	r1, [pc, #40]	; (804 <makeFilename(char*)+0x94>)
     7dc:	bl	6628 <FatFile::write(void const*, unsigned int)>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     7e0:	ldr	r0, [pc, #40]	; (80c <makeFilename(char*)+0x9c>)
     7e2:	bl	a960 <Print::println()>
  #endif
  #if DO_DEBUG>1
    logFile.println(filename);
  #endif
  return filename;  
}
     7e6:	ldr	r0, [pc, #28]	; (804 <makeFilename(char*)+0x94>)
     7e8:	add	sp, #28
     7ea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     7ee:	ldr	r0, [r1, #76]	; 0x4c
     7f0:	cmp	r0, #0
     7f2:	beq.n	7e0 <makeFilename(char*)+0x70>
     7f4:	ldr	r1, [pc, #12]	; (804 <makeFilename(char*)+0x94>)
     7f6:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     7fa:	b.n	7e0 <makeFilename(char*)+0x70>
     7fc:	.word	0x20013738
     800:	.word	0x0001313c
     804:	.word	0x200192a8
     808:	.word	0x200138e4
     80c:	.word	0x20019550

00000810 <wavHeader(unsigned long)>:

  int nsamp=(fileSize-44)/(nbytes*nchan);
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
     810:	ldr	r3, [pc, #80]	; (864 <wavHeader(unsigned long)+0x54>)
     812:	ldr	r1, [pc, #84]	; (868 <wavHeader(unsigned long)+0x58>)
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
     814:	ldr	r2, [pc, #84]	; (86c <wavHeader(unsigned long)+0x5c>)

	return header;
}

char * wavHeader(uint32_t fileSize)
{
     816:	push	{r4, r5, r6, r7}
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
     818:	str	r2, [r3, #28]

	return header;
}

char * wavHeader(uint32_t fileSize)
{
     81a:	mov	r2, r0

  int nsamp=(fileSize-44)/(nbytes*nchan);
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
     81c:	ldmia	r1, {r0, r1}
  strcpy(wheader+8,"WAVE");
     81e:	ldr	r6, [pc, #80]	; (870 <wavHeader(unsigned long)+0x60>)

  int nsamp=(fileSize-44)/(nbytes*nchan);
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
     820:	str	r0, [r3, #0]
  strcpy(wheader+8,"WAVE");
     822:	ldmia.w	r6, {r0, r1}
  strcpy(wheader+12,"fmt ");
     826:	ldr	r5, [pc, #76]	; (874 <wavHeader(unsigned long)+0x64>)
  int nsamp=(fileSize-44)/(nbytes*nchan);
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
     828:	str	r0, [r3, #8]
  strcpy(wheader+12,"fmt ");
     82a:	ldmia.w	r5, {r0, r1}
  strcpy(wheader+36,"data");
     82e:	ldr	r4, [pc, #72]	; (878 <wavHeader(unsigned long)+0x68>)
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
     830:	str	r0, [r3, #12]
  strcpy(wheader+36,"data");
     832:	ldmia.w	r4, {r0, r1}
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
     836:	subs	r2, #44	; 0x2c
     838:	bic.w	r2, r2, #3
  *(int32_t*)(wheader+4)=36+nsamp*nchan*nbytes; 
     83c:	add.w	r7, r2, #36	; 0x24
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
     840:	movs	r6, #1
  *(int16_t*)(wheader+22)=nchan;// numChannels 
     842:	movs	r5, #2
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
     844:	movw	r4, #48000	; 0xbb80
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
     848:	str	r0, [r3, #36]	; 0x24
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
     84a:	movs	r1, #4
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
     84c:	str	r2, [r3, #40]	; 0x28
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
     84e:	movs	r2, #16
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
  *(int32_t*)(wheader+4)=36+nsamp*nchan*nbytes; 
     850:	str	r7, [r3, #4]
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
     852:	strh	r6, [r3, #20]
  *(int16_t*)(wheader+22)=nchan;// numChannels 
     854:	strh	r5, [r3, #22]
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
     856:	str	r4, [r3, #24]
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
  *(int32_t*)(wheader+4)=36+nsamp*nchan*nbytes; 

   return wheader;
}
     858:	mov	r0, r3
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
     85a:	strh	r1, [r3, #32]
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
     85c:	str	r2, [r3, #16]
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
     85e:	strh	r2, [r3, #34]	; 0x22
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
  *(int32_t*)(wheader+4)=36+nsamp*nchan*nbytes; 

   return wheader;
}
     860:	pop	{r4, r5, r6, r7}
     862:	bx	lr
     864:	.word	0x200192f8
     868:	.word	0x00013180
     86c:	.word	0x00017700
     870:	.word	0x00013188
     874:	.word	0x00013190
     878:	.word	0x00013198

0000087c <c_uSD::init()>:
  nbuf=0;
  state=0;
}
*/
void c_uSD::init()
{
     87c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     880:	mov	r9, r0
     882:	sub	sp, #68	; 0x44
  delay(200);
     884:	movs	r0, #200	; 0xc8
     886:	bl	9988 <delay>
			} else if (pin == 11) {
				CORE_PIN11_PORTSET = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTSET = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTSET = CORE_PIN13_BITMASK;
     88a:	movs	r4, #32
     88c:	ldr	r7, [pc, #348]	; (9ec <c_uSD::init()+0x170>)
			} else if (pin == 11) {
				CORE_PIN11_PORTCLEAR = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTCLEAR = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTCLEAR = CORE_PIN13_BITMASK;
     88e:	ldr	r6, [pc, #352]	; (9f0 <c_uSD::init()+0x174>)
     890:	add.w	r8, r9, #1168	; 0x490
			} else if (pin == 11) {
				CORE_PIN11_PORTSET = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTSET = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTSET = CORE_PIN13_BITMASK;
     894:	mov	r5, r4
  int SD_success = 0;
     896:	mov.w	sl, #0
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
     89a:	mov.w	r1, #0
     89e:	mov	r0, r8
     8a0:	bl	89c4 <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
     8a4:	str.w	r8, [r9, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
     8a8:	cmp.w	r8, #0
     8ac:	beq.n	8b6 <c_uSD::init()+0x3a>
     8ae:	mov	r0, r8
     8b0:	bl	8104 <SdioCard::errorCode() const>
     8b4:	cbz	r0, 8ee <c_uSD::init()+0x72>
  char SD_filename[24];

  while (!sd.begin(SD_CONFIG))
  {
     // configure pin 13 for LED      
     pinMode(13,OUTPUT);
     8b6:	movs	r1, #1
     8b8:	movs	r0, #13
     8ba:	bl	9938 <pinMode>
     8be:	mov.w	fp, #8
     for(int idx = 0; idx < 8; idx++)
     {
         digitalWriteFast(13,HIGH);
         delay(200);
     8c2:	movs	r0, #200	; 0xc8
     8c4:	str	r5, [r7, #0]
     8c6:	bl	9988 <delay>
			} else if (pin == 11) {
				CORE_PIN11_PORTCLEAR = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTCLEAR = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTCLEAR = CORE_PIN13_BITMASK;
     8ca:	str	r4, [r6, #0]
         digitalWriteFast(13,LOW);
         delay(200);
     8cc:	movs	r0, #200	; 0xc8
     8ce:	bl	9988 <delay>

  while (!sd.begin(SD_CONFIG))
  {
     // configure pin 13 for LED      
     pinMode(13,OUTPUT);
     for(int idx = 0; idx < 8; idx++)
     8d2:	subs.w	fp, fp, #1
     8d6:	bne.n	8c2 <c_uSD::init()+0x46>
         digitalWriteFast(13,HIGH);
         delay(200);
         digitalWriteFast(13,LOW);
         delay(200);
     }
     delay(5000);
     8d8:	movw	r0, #5000	; 0x1388
     8dc:	bl	9988 <delay>
     SD_success++;
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
     8e0:	ldr	r2, [pc, #272]	; (9f4 <c_uSD::init()+0x178>)
     8e2:	mov.w	r3, #1024	; 0x400
         delay(200);
         digitalWriteFast(13,LOW);
         delay(200);
     }
     delay(5000);
     SD_success++;
     8e6:	add.w	sl, sl, #1
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
     8ea:	str	r3, [r2, #0]
  delay(200);
  int SD_success = 0;
  char text[32];
  char SD_filename[24];

  while (!sd.begin(SD_CONFIG))
     8ec:	b.n	89a <c_uSD::init()+0x1e>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    return cardBegin(sdioConfig) && Vol::begin(m_card);
     8ee:	ldr.w	r1, [r9, #1164]	; 0x48c
     8f2:	mov	r0, r9
     8f4:	bl	7768 <FsVolume::begin(BlockDeviceInterface*)>
     8f8:	cmp	r0, #0
     8fa:	beq.n	8b6 <c_uSD::init()+0x3a>
     SD_success++;
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
  }

  sprintf(SD_filename, "SD_s_%s.txt", acqParameters.name);
     8fc:	ldr	r1, [pc, #248]	; (9f8 <c_uSD::init()+0x17c>)
     8fe:	ldr	r2, [pc, #252]	; (9fc <c_uSD::init()+0x180>)
     900:	add	r0, sp, #8
     902:	bl	c944 <sprintf>
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
     906:	ldr	r3, [pc, #248]	; (a00 <c_uSD::init()+0x184>)
     908:	ldr	r1, [r3, #0]
  file.open(SD_filename, O_CREAT|O_WRITE|O_APPEND);
     90a:	addw	r4, r9, #1220	; 0x4c4
     90e:	cbz	r1, 91c <c_uSD::init()+0xa0>
     910:	add	r2, sp, #8
     912:	movw	r3, #521	; 0x209
     916:	mov	r0, r4
     918:	bl	7688 <FsBaseFile::open(FsVolume*, char const*, int)>
    sprintf(text, "%04d_%02d_%02d,", year(), month(), day());  file.write((char*)text, strlen(text));
     91c:	bl	2744 <year()>
     920:	mov	r5, r0
     922:	bl	2724 <month()>
     926:	mov	r6, r0
     928:	bl	2704 <day()>
     92c:	mov	r2, r5
     92e:	str	r0, [sp, #0]
     930:	mov	r3, r6
     932:	ldr	r1, [pc, #208]	; (a04 <c_uSD::init()+0x188>)
     934:	add	r0, sp, #32
     936:	bl	c944 <sprintf>
     93a:	add	r0, sp, #32
     93c:	bl	cb80 <strlen>
     940:	mov	r2, r0
     942:	ldr.w	r0, [r9, #1276]	; 0x4fc
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     946:	cmp	r0, #0
     948:	beq.n	9bc <c_uSD::init()+0x140>
     94a:	add	r1, sp, #32
     94c:	bl	6628 <FatFile::write(void const*, unsigned int)>
    sprintf(text, "%02d_%02d_%02d,", hour(), minute(), second());   file.write((char*)text, strlen(text));
     950:	bl	26a4 <hour()>
     954:	mov	r5, r0
     956:	bl	26c4 <minute()>
     95a:	mov	r6, r0
     95c:	bl	26e4 <second()>
     960:	mov	r2, r5
     962:	mov	r3, r6
     964:	str	r0, [sp, #0]
     966:	ldr	r1, [pc, #160]	; (a08 <c_uSD::init()+0x18c>)
     968:	add	r0, sp, #32
     96a:	bl	c944 <sprintf>
     96e:	add	r0, sp, #32
     970:	bl	cb80 <strlen>
     974:	mov	r2, r0
     976:	ldr.w	r0, [r9, #1276]	; 0x4fc
     97a:	cbz	r0, 9dc <c_uSD::init()+0x160>
     97c:	add	r1, sp, #32
     97e:	bl	6628 <FatFile::write(void const*, unsigned int)>
    sprintf(text, "%10d\r\n", SD_success);          file.write((char*)text, strlen(text));
     982:	mov	r2, sl
     984:	ldr	r1, [pc, #132]	; (a0c <c_uSD::init()+0x190>)
     986:	add	r0, sp, #32
     988:	bl	c944 <sprintf>
     98c:	add	r0, sp, #32
     98e:	bl	cb80 <strlen>
     992:	mov	r2, r0
     994:	ldr.w	r0, [r9, #1276]	; 0x4fc
     998:	cbz	r0, 9cc <c_uSD::init()+0x150>
     99a:	add	r1, sp, #32
     99c:	bl	6628 <FatFile::write(void const*, unsigned int)>
  file.close(); 
     9a0:	mov	r0, r4
     9a2:	bl	7660 <FsBaseFile::close()>
  
  // Set Time callback
  FsDateTime::callback = dateTime;
     9a6:	ldr	r3, [pc, #104]	; (a10 <c_uSD::init()+0x194>)
     9a8:	ldr	r2, [pc, #104]	; (a14 <c_uSD::init()+0x198>)
     9aa:	str	r2, [r3, #0]
  //
  nbuf=0;
     9ac:	movs	r3, #0
     9ae:	strh.w	r3, [r9, #1286]	; 0x506
  state=0;
     9b2:	strh.w	r3, [r9, #1284]	; 0x504
}
     9b6:	add	sp, #68	; 0x44
     9b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     9bc:	ldr.w	r0, [r9, #1280]	; 0x500
     9c0:	cmp	r0, #0
     9c2:	beq.n	950 <c_uSD::init()+0xd4>
     9c4:	add	r1, sp, #32
     9c6:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     9ca:	b.n	950 <c_uSD::init()+0xd4>
     9cc:	ldr.w	r0, [r9, #1280]	; 0x500
     9d0:	cmp	r0, #0
     9d2:	beq.n	9a0 <c_uSD::init()+0x124>
     9d4:	add	r1, sp, #32
     9d6:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     9da:	b.n	9a0 <c_uSD::init()+0x124>
     9dc:	ldr.w	r0, [r9, #1280]	; 0x500
     9e0:	cmp	r0, #0
     9e2:	beq.n	982 <c_uSD::init()+0x106>
     9e4:	add	r1, sp, #32
     9e6:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     9ea:	b.n	982 <c_uSD::init()+0x106>
     9ec:	.word	0x400ff084
     9f0:	.word	0x400ff088
     9f4:	.word	0x4004b014
     9f8:	.word	0x000131c8
     9fc:	.word	0x20013784
     a00:	.word	0x20019b60
     a04:	.word	0x000131a0
     a08:	.word	0x000131b0
     a0c:	.word	0x000131c0
     a10:	.word	0x20019b54
     a14:	.word	0x00000499

00000a18 <c_uSD::close()>:
    state=close();
  }
  return state;
}
int16_t c_uSD::close(void)
{   // close file
     a18:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     a1c:	mov	r5, r0
     a1e:	ldr.w	r0, [r0, #1276]	; 0x4fc
   *
   * \return true for success or false for failure.
   */
  bool truncate() {
    return m_fFile ? m_fFile->truncate() :
           m_xFile ? m_xFile->truncate() : false;
     a22:	cmp	r0, #0
     a24:	beq.n	aaa <c_uSD::close()+0x92>
     a26:	bl	65b0 <FatFile::truncate()>
     a2a:	ldr.w	r3, [r5, #1276]	; 0x4fc
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     a2e:	cmp	r3, #0
     a30:	beq.n	abc <c_uSD::close()+0xa4>
     a32:	ldr.w	sl, [r3, #28]
     a36:	mov.w	r9, #0
     a3a:	mov	r8, sl
    file.truncate();
    #ifdef GEN_WAV_FILE
       uint32_t fileSize = file.size();
       memcpy(header,wavHeader(fileSize),44);
     a3c:	mov	r0, sl
     a3e:	bl	810 <wavHeader(unsigned long)>
     a42:	ldr	r7, [pc, #216]	; (b1c <c_uSD::close()+0x104>)
     a44:	mov	r4, r0
     a46:	add.w	lr, r0, #32
     a4a:	ldr	r0, [r4, #0]
     a4c:	ldr	r1, [r4, #4]
     a4e:	ldr	r2, [r4, #8]
     a50:	ldr	r3, [r4, #12]
     a52:	mov	r6, r7
     a54:	stmia	r6!, {r0, r1, r2, r3}
     a56:	adds	r4, #16
     a58:	cmp	r4, lr
     a5a:	mov	r7, r6
     a5c:	bne.n	a4a <c_uSD::close()+0x32>
     a5e:	ldr	r0, [r4, #0]
     a60:	ldr	r1, [r4, #4]
     a62:	ldr	r2, [r4, #8]
     a64:	stmia	r7!, {r0, r1, r2}
     a66:	ldr.w	r0, [r5, #1276]	; 0x4fc
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     a6a:	cmp	r0, #0
     a6c:	beq.n	af0 <c_uSD::close()+0xd8>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     a6e:	movs	r1, #0
     a70:	bl	639c <FatFile::seekSet(unsigned long)>
     a74:	ldr.w	r0, [r5, #1276]	; 0x4fc
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     a78:	cbz	r0, ace <c_uSD::close()+0xb6>
     a7a:	mov.w	r2, #512	; 0x200
     a7e:	ldr	r1, [pc, #156]	; (b1c <c_uSD::close()+0x104>)
     a80:	bl	6628 <FatFile::write(void const*, unsigned int)>
     a84:	ldr.w	r0, [r5, #1276]	; 0x4fc
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     a88:	cbnz	r0, ae8 <c_uSD::close()+0xd0>
     a8a:	ldr.w	r0, [r5, #1280]	; 0x500
     a8e:	cbz	r0, a98 <c_uSD::close()+0x80>
     a90:	mov	r2, r8
     a92:	mov	r3, r9
     a94:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
       file.seek(0);
       file.write(header,512);
       file.seek(fileSize);
    #endif
    file.close();
     a98:	addw	r0, r5, #1220	; 0x4c4
     a9c:	bl	7660 <FsBaseFile::close()>
//#if DO_DEBUG>0
//    Serial.println("file Closed");    
//#endif
    state=0;  // flag to open new file
     aa0:	movs	r0, #0
     aa2:	strh.w	r0, [r5, #1284]	; 0x504
    return state;
}
     aa6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   *
   * \return true for success or false for failure.
   */
  bool truncate() {
    return m_fFile ? m_fFile->truncate() :
           m_xFile ? m_xFile->truncate() : false;
     aaa:	ldr.w	r0, [r5, #1280]	; 0x500
     aae:	cbz	r0, b02 <c_uSD::close()+0xea>
     ab0:	bl	5704 <ExFatFile::truncate()>
     ab4:	ldr.w	r3, [r5, #1276]	; 0x4fc
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     ab8:	cmp	r3, #0
     aba:	bne.n	a32 <c_uSD::close()+0x1a>
     abc:	ldr.w	r3, [r5, #1280]	; 0x500
     ac0:	cbz	r3, b0e <c_uSD::close()+0xf6>
     ac2:	ldrd	r8, r9, [r3, #16]
     ac6:	mov.w	r9, #0
     aca:	mov	sl, r8
     acc:	b.n	a3c <c_uSD::close()+0x24>
     ace:	ldr.w	r0, [r5, #1280]	; 0x500
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     ad2:	cmp	r0, #0
     ad4:	beq.n	a98 <c_uSD::close()+0x80>
     ad6:	mov.w	r2, #512	; 0x200
     ada:	ldr	r1, [pc, #64]	; (b1c <c_uSD::close()+0x104>)
     adc:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     ae0:	ldr.w	r0, [r5, #1276]	; 0x4fc
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     ae4:	cmp	r0, #0
     ae6:	beq.n	a8a <c_uSD::close()+0x72>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     ae8:	mov	r1, sl
     aea:	bl	639c <FatFile::seekSet(unsigned long)>
     aee:	b.n	a98 <c_uSD::close()+0x80>
           m_xFile ? m_xFile->seekSet(pos) : false;
     af0:	ldr.w	r0, [r5, #1280]	; 0x500
     af4:	cmp	r0, #0
     af6:	beq.n	a98 <c_uSD::close()+0x80>
     af8:	movs	r2, #0
     afa:	movs	r3, #0
     afc:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
     b00:	b.n	a74 <c_uSD::close()+0x5c>
   *
   * \return true for success or false for failure.
   */
  bool truncate() {
    return m_fFile ? m_fFile->truncate() :
           m_xFile ? m_xFile->truncate() : false;
     b02:	mov	sl, r0
     b04:	mov.w	r8, #0
     b08:	mov.w	r9, #0
     b0c:	b.n	a3c <c_uSD::close()+0x24>
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     b0e:	mov	sl, r3
     b10:	mov.w	r8, #0
     b14:	mov.w	r9, #0
     b18:	b.n	a3c <c_uSD::close()+0x24>
     b1a:	nop
     b1c:	.word	0x200150a8

00000b20 <c_uSD::storeConfig(unsigned long*, int, long*, int)>:

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
     b20:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
     b24:	ldr	r4, [pc, #272]	; (c38 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x118>)
     b26:	sub	sp, #44	; 0x2c
     b28:	ldr	r4, [r4, #0]
     b2a:	ldr.w	r9, [sp, #80]	; 0x50
     b2e:	str	r3, [sp, #4]
     b30:	mov	r5, r0
     b32:	mov	sl, r1
     b34:	mov	r8, r2
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
     b36:	addw	fp, r0, #1220	; 0x4c4
     b3a:	cbz	r4, b4a <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x2a>
     b3c:	mov	r1, r4
     b3e:	movw	r3, #1537	; 0x601
     b42:	ldr	r2, [pc, #248]	; (c3c <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x11c>)
     b44:	mov	r0, fp
     b46:	bl	7688 <FsBaseFile::open(FsVolume*, char const*, int)>
  for(int ii=0; ii<n1; ii++)
     b4a:	cmp.w	r8, #0
     b4e:	ble.n	c32 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x112>
     b50:	sub.w	r7, sl, #4
     b54:	movs	r6, #0
     b56:	add	r4, sp, #8
     b58:	b.n	b64 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x44>
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     b5a:	bl	6628 <FatFile::write(void const*, unsigned int)>
     b5e:	adds	r6, #1
     b60:	cmp	r8, r6
     b62:	beq.n	b9e <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x7e>
  { sprintf(text,"%10d\r\n",(int) param1[ii]); file.write((uint8_t*)text,strlen(text));
     b64:	ldr.w	r2, [r7, #4]!
     b68:	ldr	r1, [pc, #212]	; (c40 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x120>)
     b6a:	mov	r0, r4
     b6c:	bl	c944 <sprintf>
     b70:	mov	r0, r4
     b72:	bl	cb80 <strlen>
     b76:	ldr.w	r3, [r5, #1276]	; 0x4fc
     b7a:	mov	lr, r0
     b7c:	mov	r2, r0
     b7e:	mov	r1, r4
     b80:	mov	r0, r3
     b82:	cmp	r3, #0
     b84:	bne.n	b5a <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x3a>
     b86:	ldr.w	r3, [r5, #1280]	; 0x500
     b8a:	mov	r2, lr
     b8c:	mov	r1, r4
     b8e:	mov	r0, r3
     b90:	cmp	r3, #0
     b92:	beq.n	b5e <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x3e>
}

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
  for(int ii=0; ii<n1; ii++)
     b94:	adds	r6, #1
     b96:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     b9a:	cmp	r8, r6
     b9c:	bne.n	b64 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x44>
  { sprintf(text,"%10d\r\n",(int) param1[ii]); file.write((uint8_t*)text,strlen(text));
  }
//
  for(int ii=0; ii<n2; ii++)
     b9e:	cmp.w	r9, #0
     ba2:	ble.n	bf0 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0xd0>
     ba4:	ldr	r3, [sp, #4]
     ba6:	movs	r6, #0
     ba8:	subs	r7, r3, #4
     baa:	b.n	bb6 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x96>
     bac:	bl	6628 <FatFile::write(void const*, unsigned int)>
     bb0:	adds	r6, #1
     bb2:	cmp	r9, r6
     bb4:	beq.n	bf0 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0xd0>
  { sprintf(text,"%10d\r\n",(int) param2[ii]); file.write((uint8_t*)text,strlen(text));
     bb6:	ldr.w	r2, [r7, #4]!
     bba:	ldr	r1, [pc, #132]	; (c40 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x120>)
     bbc:	mov	r0, r4
     bbe:	bl	c944 <sprintf>
     bc2:	mov	r0, r4
     bc4:	bl	cb80 <strlen>
     bc8:	ldr.w	r3, [r5, #1276]	; 0x4fc
     bcc:	mov	lr, r0
     bce:	mov	r2, r0
     bd0:	mov	r1, r4
     bd2:	mov	r0, r3
     bd4:	cmp	r3, #0
     bd6:	bne.n	bac <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x8c>
     bd8:	ldr.w	r3, [r5, #1280]	; 0x500
     bdc:	mov	r2, lr
     bde:	mov	r1, r4
     be0:	mov	r0, r3
     be2:	cmp	r3, #0
     be4:	beq.n	bb0 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x90>
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
  for(int ii=0; ii<n1; ii++)
  { sprintf(text,"%10d\r\n",(int) param1[ii]); file.write((uint8_t*)text,strlen(text));
  }
//
  for(int ii=0; ii<n2; ii++)
     be6:	adds	r6, #1
     be8:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
     bec:	cmp	r9, r6
     bee:	bne.n	bb6 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x96>
  { sprintf(text,"%10d\r\n",(int) param2[ii]); file.write((uint8_t*)text,strlen(text));
  }
  sprintf(text,"%s\r\n",(char*) &param1[n1]);
     bf0:	add.w	r2, sl, r8, lsl #2
     bf4:	ldr	r1, [pc, #76]	; (c44 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x124>)
     bf6:	mov	r0, r4
     bf8:	bl	c944 <sprintf>
     bfc:	ldr.w	r0, [r5, #1276]	; 0x4fc
     c00:	cbz	r0, c16 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0xf6>
     c02:	mov	r1, r4
     c04:	movs	r2, #6
     c06:	bl	6628 <FatFile::write(void const*, unsigned int)>
  file.write((uint8_t *)text,6);

  file.close();
     c0a:	mov	r0, fp
     c0c:	bl	7660 <FsBaseFile::close()>
  
}
     c10:	add	sp, #44	; 0x2c
     c12:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     c16:	ldr.w	r0, [r5, #1280]	; 0x500
     c1a:	cmp	r0, #0
     c1c:	beq.n	c0a <c_uSD::storeConfig(unsigned long*, int, long*, int)+0xea>
     c1e:	mov	r1, r4
     c20:	movs	r2, #6
     c22:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
  { sprintf(text,"%10d\r\n",(int) param2[ii]); file.write((uint8_t*)text,strlen(text));
  }
  sprintf(text,"%s\r\n",(char*) &param1[n1]);
  file.write((uint8_t *)text,6);

  file.close();
     c26:	mov	r0, fp
     c28:	bl	7660 <FsBaseFile::close()>
  
}
     c2c:	add	sp, #44	; 0x2c
     c2e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     c32:	add	r4, sp, #8
     c34:	b.n	b9e <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x7e>
     c36:	nop
     c38:	.word	0x20019b60
     c3c:	.word	0x000131d4
     c40:	.word	0x000131c0
     c44:	.word	0x000131e0

00000c48 <c_uSD::loadConfig(unsigned long*, int, long*, int)>:

void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
     c48:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
     c4c:	ldr	r4, [pc, #252]	; (d4c <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x104>)
     c4e:	sub	sp, #44	; 0x2c
     c50:	ldr	r4, [r4, #0]
     c52:	ldr.w	r9, [sp, #80]	; 0x50
     c56:	cmp	r4, #0
     c58:	beq.n	cd6 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x8e>
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
     c5a:	addw	fp, r0, #1220	; 0x4c4
     c5e:	str	r3, [sp, #4]
     c60:	mov	r8, r2
     c62:	mov	sl, r1
     c64:	mov	r5, r0
     c66:	mov	r1, r4
     c68:	mov	r0, fp
     c6a:	movs	r3, #0
     c6c:	ldr	r2, [pc, #224]	; (d50 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x108>)
     c6e:	bl	7688 <FsBaseFile::open(FsVolume*, char const*, int)>
     c72:	cbz	r0, cd6 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x8e>
  //
  for(int ii=0; ii<n1; ii++)
     c74:	cmp.w	r8, #0
     c78:	ldr.w	r3, [r5, #1276]	; 0x4fc
     c7c:	ble.n	cdc <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x94>
     c7e:	mov	r7, sl
     c80:	movs	r6, #0
     c82:	add	r4, sp, #8
     c84:	b.n	ca6 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x5e>
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     c86:	bl	5f60 <FatFile::read(void*, unsigned int)>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
     c8a:	cmp	r0, #0
     c8c:	ldr	r1, [pc, #196]	; (d54 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x10c>)
     c8e:	ble.n	c98 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x50>
     c90:	mov	r2, r7
     c92:	mov	r0, r4
     c94:	bl	c990 <sscanf>
     c98:	ldr.w	r3, [r5, #1276]	; 0x4fc
void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
  //
  for(int ii=0; ii<n1; ii++)
     c9c:	adds	r6, #1
     c9e:	cmp	r8, r6
     ca0:	add.w	r7, r7, #4
     ca4:	beq.n	cde <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x96>
     ca6:	movs	r2, #12
     ca8:	mov	r1, r4
     caa:	mov	r0, r3
     cac:	cmp	r3, #0
     cae:	bne.n	c86 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x3e>
     cb0:	ldr.w	r0, [r5, #1280]	; 0x500
     cb4:	cmp	r0, #0
     cb6:	beq.n	c9c <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x54>
     cb8:	movs	r2, #12
     cba:	mov	r1, r4
     cbc:	bl	430c <ExFatFile::read(void*, unsigned int)>
     cc0:	b.n	c8a <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x42>
     cc2:	cbz	r3, d26 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xde>
     cc4:	mov	r0, r3
     cc6:	movs	r2, #6
     cc8:	mov	r1, r4
     cca:	bl	5f60 <FatFile::read(void*, unsigned int)>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
  }
  for(int ii=0; ii<n2; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
  }
  if(file.read((uint8_t *)text,6))
     cce:	cbnz	r0, d38 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xf0>
  { text[5]=0;
    sscanf(text,"%s",(char *) &param1[n1]);
  }  
  file.close();
     cd0:	mov	r0, fp
     cd2:	bl	7660 <FsBaseFile::close()>
}
     cd6:	add	sp, #44	; 0x2c
     cd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     cdc:	add	r4, sp, #8
  if(!file.open("Config.txt",O_RDONLY)) return;
  //
  for(int ii=0; ii<n1; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
  }
  for(int ii=0; ii<n2; ii++)
     cde:	cmp.w	r9, #0
     ce2:	ble.n	cc2 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x7a>
     ce4:	ldr	r6, [sp, #4]
     ce6:	movs	r7, #0
     ce8:	b.n	d0a <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xc2>
     cea:	bl	5f60 <FatFile::read(void*, unsigned int)>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
     cee:	cmp	r0, #0
     cf0:	ldr	r1, [pc, #96]	; (d54 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x10c>)
     cf2:	ble.n	cfc <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xb4>
     cf4:	mov	r2, r6
     cf6:	mov	r0, r4
     cf8:	bl	c990 <sscanf>
     cfc:	ldr.w	r3, [r5, #1276]	; 0x4fc
  if(!file.open("Config.txt",O_RDONLY)) return;
  //
  for(int ii=0; ii<n1; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
  }
  for(int ii=0; ii<n2; ii++)
     d00:	adds	r7, #1
     d02:	cmp	r9, r7
     d04:	add.w	r6, r6, #4
     d08:	beq.n	cc2 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x7a>
     d0a:	movs	r2, #12
     d0c:	mov	r1, r4
     d0e:	mov	r0, r3
     d10:	cmp	r3, #0
     d12:	bne.n	cea <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xa2>
     d14:	ldr.w	r0, [r5, #1280]	; 0x500
     d18:	cmp	r0, #0
     d1a:	beq.n	d00 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xb8>
     d1c:	movs	r2, #12
     d1e:	mov	r1, r4
     d20:	bl	430c <ExFatFile::read(void*, unsigned int)>
     d24:	b.n	cee <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xa6>
     d26:	ldr.w	r0, [r5, #1280]	; 0x500
     d2a:	cbz	r0, d38 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0xf0>
     d2c:	movs	r2, #6
     d2e:	mov	r1, r4
     d30:	bl	430c <ExFatFile::read(void*, unsigned int)>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
  }
  if(file.read((uint8_t *)text,6))
     d34:	cmp	r0, #0
     d36:	beq.n	cd0 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x88>
  { text[5]=0;
     d38:	movs	r3, #0
    sscanf(text,"%s",(char *) &param1[n1]);
     d3a:	add.w	r2, sl, r8, lsl #2
     d3e:	mov	r0, r4
     d40:	ldr	r1, [pc, #20]	; (d58 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x110>)
  }
  for(int ii=0; ii<n2; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
  }
  if(file.read((uint8_t *)text,6))
  { text[5]=0;
     d42:	strb.w	r3, [sp, #13]
    sscanf(text,"%s",(char *) &param1[n1]);
     d46:	bl	c990 <sscanf>
     d4a:	b.n	cd0 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x88>
     d4c:	.word	0x20019b60
     d50:	.word	0x000131d4
     d54:	.word	0x000131e8
     d58:	.word	0x0001315c

00000d5c <setWakeupCallandSleep(unsigned long)>:
   asm volatile( "wfi" );  // WFI instruction will start entry into STOP mode
   // will never return, but wake-up results in call to ResetHandler() in mk20dx128.c
}

void setWakeupCallandSleep(uint32_t nsec)
{  // set alarm to nsec secods in future and go to hibernate
     d5c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#define RTC_IER_TAIE_MASK       0x4u
#define RTC_SR_TAF_MASK         0x4u

void rtcSetup(void)
{
   SIM_SCGC6 |= SIM_SCGC6_RTC;// enable RTC clock
     d60:	ldr	r4, [pc, #308]	; (e98 <setWakeupCallandSleep(unsigned long)+0x13c>)
   RTC_CR |= RTC_CR_OSCE;// enable RTC
     d62:	ldr	r2, [pc, #312]	; (e9c <setWakeupCallandSleep(unsigned long)+0x140>)
#define RTC_IER_TAIE_MASK       0x4u
#define RTC_SR_TAF_MASK         0x4u

void rtcSetup(void)
{
   SIM_SCGC6 |= SIM_SCGC6_RTC;// enable RTC clock
     d64:	ldr	r3, [r4, #0]
    RTC_IER = 0;// clear RTC interrupts
}

static void llwuSetup(void)
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
     d66:	ldr	r1, [pc, #312]	; (ea0 <setWakeupCallandSleep(unsigned long)+0x144>)
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
//
    PORTA_PCR0 = PORT_PCR_MUX(0);
     d68:	ldr.w	r8, [pc, #376]	; ee4 <setWakeupCallandSleep(unsigned long)+0x188>

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     d6c:	ldr	r6, [pc, #308]	; (ea4 <setWakeupCallandSleep(unsigned long)+0x148>)
#define RTC_IER_TAIE_MASK       0x4u
#define RTC_SR_TAF_MASK         0x4u

void rtcSetup(void)
{
   SIM_SCGC6 |= SIM_SCGC6_RTC;// enable RTC clock
     d6e:	orr.w	r3, r3, #536870912	; 0x20000000
     d72:	str	r3, [r4, #0]
   RTC_CR |= RTC_CR_OSCE;// enable RTC
     d74:	ldr	r3, [r2, #0]
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
  NVIC_ENABLE_IRQ( IRQ_LLWU );
     d76:	ldr	r4, [pc, #304]	; (ea8 <setWakeupCallandSleep(unsigned long)+0x14c>)
#define RTC_SR_TAF_MASK         0x4u

void rtcSetup(void)
{
   SIM_SCGC6 |= SIM_SCGC6_RTC;// enable RTC clock
   RTC_CR |= RTC_CR_OSCE;// enable RTC
     d78:	orr.w	r3, r3, #256	; 0x100
   asm volatile( "wfi" );  // WFI instruction will start entry into STOP mode
   // will never return, but wake-up results in call to ResetHandler() in mk20dx128.c
}

void setWakeupCallandSleep(uint32_t nsec)
{  // set alarm to nsec secods in future and go to hibernate
     d7c:	mov	r7, r0
#define RTC_SR_TAF_MASK         0x4u

void rtcSetup(void)
{
   SIM_SCGC6 |= SIM_SCGC6_RTC;// enable RTC clock
   RTC_CR |= RTC_CR_OSCE;// enable RTC
     d7e:	str	r3, [r2, #0]
    RTC_IER = 0;// clear RTC interrupts
}

static void llwuSetup(void)
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
     d80:	movs	r0, #21
     d82:	bl	98d0 <attachInterruptVector>
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
     d86:	ldr	r3, [pc, #292]	; (eac <setWakeupCallandSleep(unsigned long)+0x150>)
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
     d88:	ldr.w	ip, [pc, #348]	; ee8 <setWakeupCallandSleep(unsigned long)+0x18c>
  NVIC_ENABLE_IRQ( IRQ_LLWU );
//
  LLWU_PE1 = 0;
  LLWU_PE2 = 0;
     d8c:	ldr	r1, [pc, #288]	; (eb0 <setWakeupCallandSleep(unsigned long)+0x154>)
  LLWU_PE3 = 0;
     d8e:	ldr	r0, [pc, #292]	; (eb4 <setWakeupCallandSleep(unsigned long)+0x158>)
  LLWU_PE4 = 0;
     d90:	ldr	r2, [pc, #292]	; (eb8 <setWakeupCallandSleep(unsigned long)+0x15c>)
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
  NVIC_ENABLE_IRQ( IRQ_LLWU );
//
  LLWU_PE1 = 0;
     d92:	ldr.w	lr, [pc, #344]	; eec <setWakeupCallandSleep(unsigned long)+0x190>
}

static void llwuSetup(void)
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
     d96:	movs	r5, #32
     d98:	strb	r5, [r3, #0]
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
     d9a:	mov.w	r3, #2097152	; 0x200000
     d9e:	str.w	r3, [ip]
  NVIC_ENABLE_IRQ( IRQ_LLWU );
     da2:	str	r3, [r4, #0]
  LLWU_PE1 = 0;
  LLWU_PE2 = 0;
  LLWU_PE3 = 0;
  LLWU_PE4 = 0;
#if defined(HAS_KINETIS_LLWU_32CH)
  LLWU_PE5 = 0;
     da4:	ldr	r3, [pc, #276]	; (ebc <setWakeupCallandSleep(unsigned long)+0x160>)
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
  NVIC_ENABLE_IRQ( IRQ_LLWU );
//
  LLWU_PE1 = 0;
     da6:	movs	r4, #0
     da8:	strb.w	r4, [lr]
  LLWU_PE7 = 0;
  LLWU_PE8 = 0;
#endif
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
     dac:	mvn.w	ip, #1020	; 0x3fc
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
  NVIC_ENABLE_IRQ( IRQ_LLWU );
//
  LLWU_PE1 = 0;
  LLWU_PE2 = 0;
     db0:	strb	r4, [r1, #0]
  LLWU_PE3 = 0;
     db2:	strb	r4, [r0, #0]
  LLWU_PE4 = 0;
     db4:	strb	r4, [r2, #0]
#if defined(HAS_KINETIS_LLWU_32CH)
  LLWU_PE5 = 0;
     db6:	strb	r4, [r3, #0]
  LLWU_PE6 = 0;
     db8:	strb	r4, [r1, #4]
  LLWU_PE7 = 0;
  LLWU_PE8 = 0;
#endif
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
     dba:	sub.w	r1, r1, #216064	; 0x34c00
     dbe:	add	r1, ip
  LLWU_PE3 = 0;
  LLWU_PE4 = 0;
#if defined(HAS_KINETIS_LLWU_32CH)
  LLWU_PE5 = 0;
  LLWU_PE6 = 0;
  LLWU_PE7 = 0;
     dc0:	strb	r4, [r0, #4]
  LLWU_PE8 = 0;
     dc2:	strb	r4, [r2, #4]
#endif
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
     dc4:	strb	r5, [r3, #4]
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
     dc6:	ldr	r3, [r1, #0]
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
     dc8:	ldr	r2, [pc, #244]	; (ec0 <setWakeupCallandSleep(unsigned long)+0x164>)
//
    PORTA_PCR0 = PORT_PCR_MUX(0);
    PORTA_PCR1 = PORT_PCR_MUX(0);
     dca:	ldr.w	ip, [pc, #292]	; ef0 <setWakeupCallandSleep(unsigned long)+0x194>
  LLWU_PE7 = 0;
  LLWU_PE8 = 0;
#endif
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
     dce:	orr.w	r3, r3, #67108864	; 0x4000000
     dd2:	str	r3, [r1, #0]
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
     dd4:	ldr	r3, [r2, #0]
     dd6:	orr.w	r3, r3, #1073741824	; 0x40000000
     dda:	str	r3, [r2, #0]
    PORTA_PCR0 = PORT_PCR_MUX(0);
    PORTA_PCR1 = PORT_PCR_MUX(0);
    PORTA_PCR2 = PORT_PCR_MUX(0);
    PORTA_PCR3 = PORT_PCR_MUX(0);

    PORTB_PCR2 = PORT_PCR_MUX(0);
     ddc:	add.w	r1, r1, #12288	; 0x3000
    PORTB_PCR3 = PORT_PCR_MUX(0);
     de0:	add.w	r2, r2, #12288	; 0x3000
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
//
    PORTA_PCR0 = PORT_PCR_MUX(0);
    PORTA_PCR1 = PORT_PCR_MUX(0);
    PORTA_PCR2 = PORT_PCR_MUX(0);
     de4:	sub.w	lr, lr, #207872	; 0x32c00
    PORTA_PCR3 = PORT_PCR_MUX(0);
     de8:	sub.w	r0, r0, #207872	; 0x32c00
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
//
    PORTA_PCR0 = PORT_PCR_MUX(0);
    PORTA_PCR1 = PORT_PCR_MUX(0);
    PORTA_PCR2 = PORT_PCR_MUX(0);
     dec:	sub.w	lr, lr, #1016	; 0x3f8
    PORTA_PCR3 = PORT_PCR_MUX(0);
     df0:	subw	r0, r0, #1014	; 0x3f6

    PORTB_PCR2 = PORT_PCR_MUX(0);
     df4:	adds	r1, #4
    PORTB_PCR3 = PORT_PCR_MUX(0);
     df6:	adds	r2, #12
   RTC_CR |= RTC_CR_OSCE;// enable RTC
}

void rtcSetAlarm(uint32_t nsec)
{ // set alarm nsec seconds in the future
   RTC_TAR = RTC_TSR + nsec;
     df8:	ldr	r3, [pc, #200]	; (ec4 <setWakeupCallandSleep(unsigned long)+0x168>)
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
//
    PORTA_PCR0 = PORT_PCR_MUX(0);
     dfa:	str.w	r4, [r8]
    PORTA_PCR1 = PORT_PCR_MUX(0);
     dfe:	str.w	r4, [ip]
    PORTA_PCR2 = PORT_PCR_MUX(0);
     e02:	str.w	r4, [lr]
    PORTA_PCR3 = PORT_PCR_MUX(0);
     e06:	str	r4, [r0, #0]

    PORTB_PCR2 = PORT_PCR_MUX(0);
     e08:	str	r4, [r1, #0]
    PORTB_PCR3 = PORT_PCR_MUX(0);
     e0a:	str	r4, [r2, #0]
   RTC_CR |= RTC_CR_OSCE;// enable RTC
}

void rtcSetAlarm(uint32_t nsec)
{ // set alarm nsec seconds in the future
   RTC_TAR = RTC_TSR + nsec;
     e0c:	ldr	r3, [r3, #0]
     e0e:	sub.w	r1, r1, #53248	; 0xd000
   RTC_IER |= RTC_IER_TAIE_MASK;
     e12:	sub.w	r2, r2, #52992	; 0xcf00
     e16:	subs	r2, #240	; 0xf0
   RTC_CR |= RTC_CR_OSCE;// enable RTC
}

void rtcSetAlarm(uint32_t nsec)
{ // set alarm nsec seconds in the future
   RTC_TAR = RTC_TSR + nsec;
     e18:	add	r3, r7
     e1a:	str	r3, [r1, #0]
   RTC_IER |= RTC_IER_TAIE_MASK;
     e1c:	ldr	r3, [r2, #0]
     e1e:	orr.w	r3, r3, #4
     e22:	str	r3, [r2, #0]
void setWakeupCallandSleep(uint32_t nsec)
{  // set alarm to nsec secods in future and go to hibernate
   rtcSetup();
   llwuSetup();  
   rtcSetAlarm(nsec);
   yield();
     e24:	bl	a6c4 <yield>
     e28:	mov	r3, r4
     e2a:	movs	r2, #10
     e2c:	mov	r1, r7
     e2e:	mov	r0, r6
     e30:	bl	a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
     e34:	mov	r0, r6
     e36:	bl	a960 <Print::println()>
#if DO_DEBUG>0
   Serial.println(nsec);
   pinMode(13,OUTPUT); digitalWriteFast(13,HIGH); delay(1000); digitalWriteFast(13,LOW);
     e3a:	movs	r1, #1
     e3c:	movs	r0, #13
     e3e:	bl	9938 <pinMode>
			} else if (pin == 11) {
				CORE_PIN11_PORTSET = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTSET = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTSET = CORE_PIN13_BITMASK;
     e42:	ldr	r3, [pc, #132]	; (ec8 <setWakeupCallandSleep(unsigned long)+0x16c>)

#define VLLS_MODE VLLS0
static void gotoSleep(void)
{  
//  /* Make sure clock monitor is off so we don't get spurious reset */
   MCG_C6 &= ~MCG_C6_CME0;
     e44:	ldr	r6, [pc, #132]	; (ecc <setWakeupCallandSleep(unsigned long)+0x170>)
     e46:	str	r5, [r3, #0]
   llwuSetup();  
   rtcSetAlarm(nsec);
   yield();
#if DO_DEBUG>0
   Serial.println(nsec);
   pinMode(13,OUTPUT); digitalWriteFast(13,HIGH); delay(1000); digitalWriteFast(13,LOW);
     e48:	mov.w	r0, #1000	; 0x3e8
     e4c:	bl	9988 <delay>
			} else if (pin == 11) {
				CORE_PIN11_PORTCLEAR = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTCLEAR = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTCLEAR = CORE_PIN13_BITMASK;
     e50:	ldr	r3, [pc, #124]	; (ed0 <setWakeupCallandSleep(unsigned long)+0x174>)
// is defined in kinetis.h and mk20dx128c
#if defined(HAS_KINETIS_HSRUN) && (F_CPU > 120000000)
    kinetis_hsrun_disable( );
#endif   
   /* Write to PMPROT to allow all possible power modes */
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
     e52:	ldr	r7, [pc, #128]	; (ed4 <setWakeupCallandSleep(unsigned long)+0x178>)
     e54:	str	r5, [r3, #0]

#define VLLS_MODE VLLS0
static void gotoSleep(void)
{  
//  /* Make sure clock monitor is off so we don't get spurious reset */
   MCG_C6 &= ~MCG_C6_CME0;
     e56:	ldrb	r2, [r6, #5]
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
   /* Set the STOPM field to 0b100 for VLLSx mode */
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
   SMC_PMCTRL |= SMC_PMCTRL_STOPM(0x4); // VLLSx

   SMC_VLLSCTRL =  SMC_VLLSCTRL_VLLSM(VLLS_MODE);
     e58:	ldr	r5, [pc, #124]	; (ed8 <setWakeupCallandSleep(unsigned long)+0x17c>)
   /*wait for write to complete to SMC before stopping core */
   (void) SMC_PMCTRL;

   SYST_CSR &= ~SYST_CSR_TICKINT;      // disable systick timer interrupt
     e5a:	ldr	r0, [pc, #128]	; (edc <setWakeupCallandSleep(unsigned long)+0x180>)
   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;  // Set the SLEEPDEEP bit to enable deep sleep mode (STOP)
     e5c:	ldr	r1, [pc, #128]	; (ee0 <setWakeupCallandSleep(unsigned long)+0x184>)
    kinetis_hsrun_disable( );
#endif   
   /* Write to PMPROT to allow all possible power modes */
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
   /* Set the STOPM field to 0b100 for VLLSx mode */
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
     e5e:	sub.w	r3, r3, #528384	; 0x81000

#define VLLS_MODE VLLS0
static void gotoSleep(void)
{  
//  /* Make sure clock monitor is off so we don't get spurious reset */
   MCG_C6 &= ~MCG_C6_CME0;
     e62:	and.w	r2, r2, #223	; 0xdf
     e66:	strb	r2, [r6, #5]
    kinetis_hsrun_disable( );
#endif   
   /* Write to PMPROT to allow all possible power modes */
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
   /* Set the STOPM field to 0b100 for VLLSx mode */
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
     e68:	subs	r3, #135	; 0x87
// is defined in kinetis.h and mk20dx128c
#if defined(HAS_KINETIS_HSRUN) && (F_CPU > 120000000)
    kinetis_hsrun_disable( );
#endif   
   /* Write to PMPROT to allow all possible power modes */
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
     e6a:	movs	r2, #2
     e6c:	strb	r2, [r7, #0]
   /* Set the STOPM field to 0b100 for VLLSx mode */
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
     e6e:	ldrb	r2, [r3, #0]
     e70:	and.w	r2, r2, #248	; 0xf8
     e74:	strb	r2, [r3, #0]
   SMC_PMCTRL |= SMC_PMCTRL_STOPM(0x4); // VLLSx
     e76:	ldrb	r2, [r3, #0]
     e78:	orr.w	r2, r2, #4
     e7c:	strb	r2, [r3, #0]

   SMC_VLLSCTRL =  SMC_VLLSCTRL_VLLSM(VLLS_MODE);
     e7e:	strb	r4, [r5, #0]
   /*wait for write to complete to SMC before stopping core */
   (void) SMC_PMCTRL;
     e80:	ldrb	r3, [r3, #0]

   SYST_CSR &= ~SYST_CSR_TICKINT;      // disable systick timer interrupt
     e82:	ldr	r3, [r0, #0]
     e84:	bic.w	r3, r3, #2
     e88:	str	r3, [r0, #0]
   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;  // Set the SLEEPDEEP bit to enable deep sleep mode (STOP)
     e8a:	ldr	r3, [r1, #0]
     e8c:	orr.w	r3, r3, #4
     e90:	str	r3, [r1, #0]
   
   asm volatile( "wfi" );  // WFI instruction will start entry into STOP mode
     e92:	wfi
     e94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     e98:	.word	0x4004803c
     e9c:	.word	0x4003d010
     ea0:	.word	0x0000047d
     ea4:	.word	0x200138e4
     ea8:	.word	0xe000e100
     eac:	.word	0xe000e415
     eb0:	.word	0x4007c001
     eb4:	.word	0x4007c002
     eb8:	.word	0x4007c003
     ebc:	.word	0x4007c004
     ec0:	.word	0x40047000
     ec4:	.word	0x4003d000
     ec8:	.word	0x400ff084
     ecc:	.word	0x40064000
     ed0:	.word	0x400ff088
     ed4:	.word	0x4007e000
     ed8:	.word	0x4007e002
     edc:	.word	0xe000e010
     ee0:	.word	0xe000ed10
     ee4:	.word	0x40049000
     ee8:	.word	0xe000e280
     eec:	.word	0x4007c000
     ef0:	.word	0x40049004

00000ef4 <checkDutyCycle(ACQ_Parameters_s*, short)>:
  #define ShortSleepDuration 60   // i.e. wake up every 'ShortSleepDuration' seconds
#endif
//
// flag can be 0 file to be open // time to shutdown if required
int32_t checkDutyCycle(ACQ_Parameters_s *acqParameters,int16_t flag)
{	static uint32_t t_start = 0;  // start of actual file
     ef4:	push	{r3, r4, r5, r6, r7, lr}
     ef6:	mov	r6, r0
     ef8:	mov	r5, r1
  static uint16_t recording = 0;  // acquisition has started

  uint32_t tt = now();
     efa:	bl	2604 <now()>
     efe:	mov	r4, r0
  uint16_t to = hour();
     f00:	bl	26a4 <hour()>
  
  // check if we should sleep longer
  // sleep time between T2 and T3 and T4 and T1 (values are in hours)
  
  uint16_t T1 = acqParameters->T1;
     f04:	ldrh	r7, [r6, #12]
  uint16_t T2 = acqParameters->T2;
  uint16_t T3 = acqParameters->T3;
  uint16_t T4 = acqParameters->T4;
     f06:	ldrh.w	lr, [r6, #24]
  
  // check if we should sleep longer
  // sleep time between T2 and T3 and T4 and T1 (values are in hours)
  
  uint16_t T1 = acqParameters->T1;
  uint16_t T2 = acqParameters->T2;
     f0a:	ldrh	r3, [r6, #16]
  uint16_t T3 = acqParameters->T3;
     f0c:	ldrh	r1, [r6, #20]
  uint16_t T4 = acqParameters->T4;
  uint16_t doRecording=1;
  if (T4<T1) // e.g. 3-4, 23-1 (work over midnight)
     f0e:	cmp	r7, lr
int32_t checkDutyCycle(ACQ_Parameters_s *acqParameters,int16_t flag)
{	static uint32_t t_start = 0;  // start of actual file
  static uint16_t recording = 0;  // acquisition has started

  uint32_t tt = now();
  uint16_t to = hour();
     f10:	uxth	r0, r0
  uint16_t T1 = acqParameters->T1;
  uint16_t T2 = acqParameters->T2;
  uint16_t T3 = acqParameters->T3;
  uint16_t T4 = acqParameters->T4;
  uint16_t doRecording=1;
  if (T4<T1) // e.g. 3-4, 23-1 (work over midnight)
     f12:	bls.n	f30 <checkDutyCycle(ACQ_Parameters_s*, short)+0x3c>
    doRecording =   ((to>=T3) || (to<T4) || ((to>=T1) && (to<T2)));
     f14:	cmp	r0, r1
     f16:	bcc.n	f8e <checkDutyCycle(ACQ_Parameters_s*, short)+0x9a>
      uint16_t t_on = acqParameters->on;
      uint16_t t_dur = acqParameters->ad;
      uint16_t t_rep = acqParameters->ar;
      uint32_t t_rec = acqParameters->rec;
      
    if(flag>=0)
     f18:	cmp	r5, #0
     f1a:	blt.n	f2c <checkDutyCycle(ACQ_Parameters_s*, short)+0x38>
    { 
      if((flag>0) && (tt >= t_start + t_dur)) //we are indeed still recording
     f1c:	beq.n	fa4 <checkDutyCycle(ACQ_Parameters_s*, short)+0xb0>
     f1e:	ldr	r5, [pc, #372]	; (1094 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1a0>)
     f20:	ldrh	r2, [r6, #4]
     f22:	ldr	r3, [r5, #0]
     f24:	add	r3, r2
     f26:	cmp	r4, r3
     f28:	bcs.w	1058 <checkDutyCycle(ACQ_Parameters_s*, short)+0x164>
    Serial.println(nsec); 
    Serial.println("Hibernate now 3");
#endif
    return nsec;
  }
  return 0;
     f2c:	movs	r0, #0
     f2e:	pop	{r3, r4, r5, r6, r7, pc}
  uint16_t T4 = acqParameters->T4;
  uint16_t doRecording=1;
  if (T4<T1) // e.g. 3-4, 23-1 (work over midnight)
    doRecording =   ((to>=T3) || (to<T4) || ((to>=T1) && (to<T2)));
  else		// e.g. 3-4, 23-24
    doRecording = (((to>=T1) && (to<T2)) || ((to>=T3) && (to<T4)));
     f30:	cmp	r0, r7
     f32:	bcc.n	f38 <checkDutyCycle(ACQ_Parameters_s*, short)+0x44>
     f34:	cmp	r0, r3
     f36:	bcc.n	f18 <checkDutyCycle(ACQ_Parameters_s*, short)+0x24>
     f38:	cmp	r0, r1
     f3a:	bcs.n	fbe <checkDutyCycle(ACQ_Parameters_s*, short)+0xca>
    }
    */
  }
  else
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
     f3c:	ldr	r2, [pc, #344]	; (1098 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1a4>)
     f3e:	ldr	r5, [pc, #348]	; (109c <checkDutyCycle(ACQ_Parameters_s*, short)+0x1a8>)
     f40:	umull	r6, r2, r2, r4
     f44:	lsrs	r2, r2, #16
    nsec=0;
    // estimate next start time
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
     f46:	cmp	r0, r3
    }
    */
  }
  else
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
     f48:	mls	r2, r5, r2, r4
    nsec=0;
    // estimate next start time
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
     f4c:	bcc.n	f52 <checkDutyCycle(ACQ_Parameters_s*, short)+0x5e>
     f4e:	cmp	r0, r1
     f50:	bcc.n	fdc <checkDutyCycle(ACQ_Parameters_s*, short)+0xe8>
    */
  }
  else
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
    nsec=0;
     f52:	movs	r4, #0
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
    { if(tto < T3 * 3600) 
      nsec = T3 * 3600 - tto;
    }
    //
    if((to>=T4) && (T4>T1)) // sleep over midnight to T1 //eg: to=21: T1=4; T2=9; T3=16; T4=20
     f54:	cmp	r0, lr
     f56:	bcc.n	f5c <checkDutyCycle(ACQ_Parameters_s*, short)+0x68>
     f58:	cmp	r7, lr
     f5a:	bcc.n	fcc <checkDutyCycle(ACQ_Parameters_s*, short)+0xd8>
    {  nsec = (T1+24) * 3600 - tto;
    }
    //
    if(to<T1)                                            //eg: to=2:  T1=4; T2=9; T3=16; T4=20
     f5c:	cmp	r0, r7
     f5e:	bcs.n	f6a <checkDutyCycle(ACQ_Parameters_s*, short)+0x76>
    { nsec = T1 * 3600 - tto;
     f60:	mov.w	r0, #3600	; 0xe10
     f64:	mul.w	r0, r0, r7
     f68:	subs	r4, r0, r2

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     f6a:	movs	r3, #0
     f6c:	movs	r2, #10
     f6e:	mov	r1, r4
     f70:	ldr	r0, [pc, #300]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
     f72:	bl	a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
     f76:	ldr	r0, [pc, #296]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
     f78:	bl	a960 <Print::println()>
     f7c:	movs	r1, #15
     f7e:	ldr	r0, [pc, #292]	; (10a4 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1b0>)
     f80:	bl	9494 <usb_serial_write>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     f84:	ldr	r0, [pc, #280]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
     f86:	bl	a960 <Print::println()>
    
#if DO_DEBUG>0
    Serial.println(nsec); 
    Serial.println("Hibernate now 3");
#endif
    return nsec;
     f8a:	mov	r0, r4
     f8c:	pop	{r3, r4, r5, r6, r7, pc}
  uint16_t T2 = acqParameters->T2;
  uint16_t T3 = acqParameters->T3;
  uint16_t T4 = acqParameters->T4;
  uint16_t doRecording=1;
  if (T4<T1) // e.g. 3-4, 23-1 (work over midnight)
    doRecording =   ((to>=T3) || (to<T4) || ((to>=T1) && (to<T2)));
     f8e:	cmp	r0, lr
     f90:	bcc.n	f18 <checkDutyCycle(ACQ_Parameters_s*, short)+0x24>
     f92:	cmp	r0, r7
     f94:	bcc.n	f3c <checkDutyCycle(ACQ_Parameters_s*, short)+0x48>
     f96:	cmp	r0, r3
     f98:	ite	cs
     f9a:	movcs	r2, #0
     f9c:	movcc	r2, #1
  else		// e.g. 3-4, 23-24
    doRecording = (((to>=T1) && (to<T2)) || ((to>=T3) && (to<T4)));

  uint32_t nsec=0;
  if (doRecording) // we can record
     f9e:	cmp	r2, #0
     fa0:	beq.n	f3c <checkDutyCycle(ACQ_Parameters_s*, short)+0x48>
     fa2:	b.n	f18 <checkDutyCycle(ACQ_Parameters_s*, short)+0x24>
        return -1; // flag to close acquisition
      }
      
      if( flag==0 )  // file is closed new file
      { 
        if(!recording) // we are at the beginning of an acquisition cycle
     fa4:	ldr	r3, [pc, #256]	; (10a8 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1b4>)
     fa6:	ldrh	r2, [r3, #0]
     fa8:	cbz	r2, fec <checkDutyCycle(ACQ_Parameters_s*, short)+0xf8>
          // the following is for each new file
          t_start = tt; // beginning of each file
        }
        else
        // check is we end acquisition cycle
        if ((t_rep>t_on) && (tt >= t_rec + t_on))
     faa:	ldrh	r3, [r6, #0]
     fac:	ldrh	r0, [r6, #8]
     fae:	cmp	r3, r0
     fb0:	bcs.n	fba <checkDutyCycle(ACQ_Parameters_s*, short)+0xc6>
  if (doRecording) // we can record
  {
      uint16_t t_on = acqParameters->on;
      uint16_t t_dur = acqParameters->ad;
      uint16_t t_rep = acqParameters->ar;
      uint32_t t_rec = acqParameters->rec;
     fb2:	ldr	r2, [r6, #28]
          // the following is for each new file
          t_start = tt; // beginning of each file
        }
        else
        // check is we end acquisition cycle
        if ((t_rep>t_on) && (tt >= t_rec + t_on))
     fb4:	add	r3, r2
     fb6:	cmp	r4, r3
     fb8:	bcs.n	ffa <checkDutyCycle(ACQ_Parameters_s*, short)+0x106>
    Serial.println(nsec); 
    Serial.println("Hibernate now 3");
#endif
    return nsec;
  }
  return 0;
     fba:	mov	r0, r5
}
     fbc:	pop	{r3, r4, r5, r6, r7, pc}
     fbe:	cmp	r0, lr
     fc0:	ite	cs
     fc2:	movcs	r2, #0
     fc4:	movcc	r2, #1
    doRecording =   ((to>=T3) || (to<T4) || ((to>=T1) && (to<T2)));
  else		// e.g. 3-4, 23-24
    doRecording = (((to>=T1) && (to<T2)) || ((to>=T3) && (to<T4)));

  uint32_t nsec=0;
  if (doRecording) // we can record
     fc6:	cmp	r2, #0
     fc8:	beq.n	f3c <checkDutyCycle(ACQ_Parameters_s*, short)+0x48>
     fca:	b.n	f18 <checkDutyCycle(ACQ_Parameters_s*, short)+0x24>
    { if(tto < T3 * 3600) 
      nsec = T3 * 3600 - tto;
    }
    //
    if((to>=T4) && (T4>T1)) // sleep over midnight to T1 //eg: to=21: T1=4; T2=9; T3=16; T4=20
    {  nsec = (T1+24) * 3600 - tto;
     fcc:	add.w	r4, r7, #24
     fd0:	mov.w	r3, #3600	; 0xe10
     fd4:	mul.w	r3, r3, r4
     fd8:	subs	r4, r3, r2
     fda:	b.n	f5c <checkDutyCycle(ACQ_Parameters_s*, short)+0x68>
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
    nsec=0;
    // estimate next start time
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
    { if(tto < T3 * 3600) 
     fdc:	mov.w	r3, #3600	; 0xe10
     fe0:	mul.w	r3, r3, r1
     fe4:	cmp	r2, r3
     fe6:	bcs.n	f52 <checkDutyCycle(ACQ_Parameters_s*, short)+0x5e>
      nsec = T3 * 3600 - tto;
     fe8:	subs	r4, r3, r2
     fea:	b.n	f54 <checkDutyCycle(ACQ_Parameters_s*, short)+0x60>
          { t_rec=tt; 
            acqParameters->rec=t_rec;
            recording=1; 
          } 
          // the following is for each new file
          t_start = tt; // beginning of each file
     fec:	ldr	r1, [pc, #164]	; (1094 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1a0>)
      if( flag==0 )  // file is closed new file
      { 
        if(!recording) // we are at the beginning of an acquisition cycle
        {
          { t_rec=tt; 
            acqParameters->rec=t_rec;
     fee:	str	r4, [r6, #28]
            recording=1; 
     ff0:	movs	r2, #1
    Serial.println(nsec); 
    Serial.println("Hibernate now 3");
#endif
    return nsec;
  }
  return 0;
     ff2:	mov	r0, r5
          { t_rec=tt; 
            acqParameters->rec=t_rec;
            recording=1; 
          } 
          // the following is for each new file
          t_start = tt; // beginning of each file
     ff4:	str	r4, [r1, #0]
      { 
        if(!recording) // we are at the beginning of an acquisition cycle
        {
          { t_rec=tt; 
            acqParameters->rec=t_rec;
            recording=1; 
     ff6:	strh	r2, [r3, #0]
     ff8:	pop	{r3, r4, r5, r6, r7, pc}
        }
        else
        // check is we end acquisition cycle
        if ((t_rep>t_on) && (tt >= t_rec + t_on))
        { // need to stop
          nsec = (t_rec + t_rep - tt);
     ffa:	add	r0, r2
     ffc:	subs	r4, r0, r4

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     ffe:	mov	r3, r5
    1000:	movs	r2, #10
    1002:	mov	r1, r4
    1004:	ldr	r0, [pc, #152]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
    1006:	ldr	r6, [pc, #164]	; (10ac <checkDutyCycle(ACQ_Parameters_s*, short)+0x1b8>)
    1008:	bl	a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    100c:	ldr	r0, [pc, #144]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
    100e:	bl	a960 <Print::println()>
    1012:	movs	r1, #15
    1014:	ldr	r0, [pc, #152]	; (10b0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1bc>)
    1016:	bl	9494 <usb_serial_write>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    101a:	ldr	r0, [pc, #132]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
    101c:	bl	a960 <Print::println()>

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1020:	mov	r3, r5
    1022:	mov	r1, r4
    1024:	movs	r2, #10
    1026:	mov	r0, r6
    1028:	bl	a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    102c:	mov	r0, r6
    102e:	bl	a960 <Print::println()>
    1032:	ldr	r0, [r6, #72]	; 0x48
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
    1034:	cbz	r0, 1048 <checkDutyCycle(ACQ_Parameters_s*, short)+0x154>
    1036:	movs	r2, #15
    1038:	ldr	r1, [pc, #116]	; (10b0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1bc>)
    103a:	bl	6628 <FatFile::write(void const*, unsigned int)>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    103e:	ldr	r0, [pc, #108]	; (10ac <checkDutyCycle(ACQ_Parameters_s*, short)+0x1b8>)
    1040:	bl	a960 <Print::println()>
          #endif
          #if DO_DEBUG>1
            logFile.println(nsec); 
            logFile.println("Hibernate now 1");
          #endif
          return nsec; 
    1044:	mov	r0, r4
    1046:	pop	{r3, r4, r5, r6, r7, pc}
    1048:	ldr	r0, [r6, #76]	; 0x4c
    104a:	cmp	r0, #0
    104c:	beq.n	103e <checkDutyCycle(ACQ_Parameters_s*, short)+0x14a>
    104e:	movs	r2, #15
    1050:	ldr	r1, [pc, #92]	; (10b0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1bc>)
    1052:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
    1056:	b.n	103e <checkDutyCycle(ACQ_Parameters_s*, short)+0x14a>
    1058:	movs	r1, #17
    105a:	ldr	r0, [pc, #88]	; (10b4 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1c0>)
    105c:	bl	9494 <usb_serial_write>
    1060:	ldr	r0, [pc, #60]	; (10a0 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1ac>)
    1062:	bl	a960 <Print::println()>
    1066:	ldr	r3, [pc, #68]	; (10ac <checkDutyCycle(ACQ_Parameters_s*, short)+0x1b8>)
    1068:	ldr	r0, [r3, #72]	; 0x48
    106a:	cbz	r0, 1082 <checkDutyCycle(ACQ_Parameters_s*, short)+0x18e>
    106c:	movs	r2, #17
    106e:	ldr	r1, [pc, #68]	; (10b4 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1c0>)
    1070:	bl	6628 <FatFile::write(void const*, unsigned int)>
    1074:	ldr	r0, [pc, #52]	; (10ac <checkDutyCycle(ACQ_Parameters_s*, short)+0x1b8>)
    1076:	bl	a960 <Print::println()>
            Serial.println("close acquisition");
        #endif
        #if DO_DEBUG>1
            logFile.println("close acquisition");
        #endif
        t_start = tt; // update start time for next file
    107a:	str	r4, [r5, #0]
        return -1; // flag to close acquisition
    107c:	mov.w	r0, #4294967295
    1080:	pop	{r3, r4, r5, r6, r7, pc}
    1082:	ldr	r0, [r3, #76]	; 0x4c
    1084:	cmp	r0, #0
    1086:	beq.n	1074 <checkDutyCycle(ACQ_Parameters_s*, short)+0x180>
    1088:	movs	r2, #17
    108a:	ldr	r1, [pc, #40]	; (10b4 <checkDutyCycle(ACQ_Parameters_s*, short)+0x1c0>)
    108c:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
    1090:	b.n	1074 <checkDutyCycle(ACQ_Parameters_s*, short)+0x180>
    1092:	nop
    1094:	.word	0x200192d0
    1098:	.word	0xc22e4507
    109c:	.word	0x00015180
    10a0:	.word	0x200138e4
    10a4:	.word	0x00013224
    10a8:	.word	0x200195ac
    10ac:	.word	0x20019550
    10b0:	.word	0x00013214
    10b4:	.word	0x00013200

000010b8 <setRTCTime(int, int, int, int, int, int)>:
{
    sprintf(text,"%02d:%02d:%02d",hour(),minute(),second());
    return text;
}

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    10b8:	push	{r4, r5, r6, lr}
    10ba:	sub	sp, #8
    10bc:	mov	r6, r0
    10be:	ldr	r4, [sp, #28]
    10c0:	ldr	r5, [sp, #24]
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
    10c2:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    10c6:	add	r0, sp, #8
}

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 //it is converted to years since 1970
  if( yr > 99)
    10c8:	cmp	r4, #99	; 0x63
      yr = yr - 1970;
    10ca:	ite	gt
    10cc:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    10d0:	addle	r4, #30
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    10d2:	strb.w	r2, [r0, #-8]!
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
    10d6:	strb.w	r1, [sp, #1]
      yr = yr - 1970;
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
    10da:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
    10de:	strb.w	r5, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
    10e2:	strb.w	r6, [sp, #2]
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    10e6:	bl	2508 <makeTime(tmElements_t const&)>
    10ea:	mov	r4, r0
}
class teensy3_clock_class
{
public:
	static unsigned long get(void) __attribute__((always_inline)) { return rtc_get(); }
	static void set(unsigned long t) __attribute__((always_inline)) { rtc_set(t); }
    10ec:	bl	98ec <rtc_set>
  Teensy3Clock.set(tt); // for RTC
  setTime(tt); // local
    10f0:	mov	r0, r4
    10f2:	bl	2768 <setTime(long)>
}
    10f6:	add	sp, #8
    10f8:	pop	{r4, r5, r6, pc}
    10fa:	nop

000010fc <doMenu()>:
      }
    }  
}

int16_t doMenu(void)
{
    10fc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
extern ACQ_Parameters_s acqParameters;
extern SNIP_Parameters_s snipParameters;

static void printAll(void)
{
  Serial.printf("%c %5d on_time\n\r",     'o',acqParameters.on);
    1100:	ldr	r5, [pc, #700]	; (13c0 <doMenu()+0x2c4>)
      }
    }  
}

int16_t doMenu(void)
{
    1102:	sub	sp, #12
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1104:	bl	9440 <usb_serial_available>
  int16_t ret=0;
  do
  {
    while(!Serial.available());
    1108:	cmp	r0, #0
    110a:	beq.n	1104 <doMenu()+0x8>
        virtual int read() { return usb_serial_getchar(); }
    110c:	bl	93c8 <usb_serial_getchar>
    1110:	uxtb	r4, r0
    char c=Serial.read();
    
    if (strchr("?!xa", c))
    1112:	mov	r1, r4
    1114:	ldr	r0, [pc, #684]	; (13c4 <doMenu()+0x2c8>)
    1116:	bl	c9ec <strchr>
    111a:	cmp	r0, #0
    111c:	beq.n	1104 <doMenu()+0x8>
    { switch (c)
    111e:	cmp	r4, #63	; 0x3f
    1120:	beq.n	1142 <doMenu()+0x46>
    1122:	ble.w	1278 <doMenu()+0x17c>
    1126:	cmp	r4, #97	; 0x61
    1128:	beq.w	13d0 <doMenu()+0x2d4>
    112c:	cmp	r4, #120	; 0x78
    112e:	bne.n	1104 <doMenu()+0x8>
      {
        case '?': doMenu1(); break;
        case '!': doMenu2(); break;
        case 'x': ret = Serial.parseInt(); break;
    1130:	ldr	r0, [pc, #660]	; (13c8 <doMenu()+0x2cc>)
    1132:	bl	ae4c <Stream::parseInt()>
    1136:	sxth	r0, r0
        case 'a': printAll(); break;
      }
    }
  } while(ret==0);
    1138:	cmp	r0, #0
    113a:	beq.n	1104 <doMenu()+0x8>
  return ret;
}
    113c:	add	sp, #12
    113e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1142:	bl	9440 <usb_serial_available>
  Serial.println();
}

static void doMenu1(void)
{ // for enquiries
    while(!Serial.available());
    1146:	cmp	r0, #0
    1148:	beq.n	1142 <doMenu()+0x46>
        virtual int read() { return usb_serial_getchar(); }
    114a:	bl	93c8 <usb_serial_getchar>
    114e:	uxtb	r4, r0
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    1150:	mov	r1, r4
    1152:	ldr	r0, [pc, #632]	; (13cc <doMenu()+0x2d0>)
    1154:	bl	c9ec <strchr>
    1158:	cmp	r0, #0
    115a:	beq.n	1104 <doMenu()+0x8>
    { switch (c)
    115c:	subs	r4, #49	; 0x31
    115e:	cmp	r4, #67	; 0x43
    1160:	bhi.n	1104 <doMenu()+0x8>
    1162:	add	r3, pc, #4	; (adr r3, 1168 <doMenu()+0x6c>)
    1164:	ldr.w	pc, [r3, r4, lsl #2]
    1168:	.word	0x00001535
    116c:	.word	0x00001541
    1170:	.word	0x0000154d
    1174:	.word	0x00001559
    1178:	.word	0x00001105
    117c:	.word	0x00001105
    1180:	.word	0x00001105
    1184:	.word	0x00001105
    1188:	.word	0x00001105
    118c:	.word	0x00001105
    1190:	.word	0x00001105
    1194:	.word	0x00001105
    1198:	.word	0x00001105
    119c:	.word	0x00001105
    11a0:	.word	0x00001105
    11a4:	.word	0x00001105
    11a8:	.word	0x00001105
    11ac:	.word	0x00001105
    11b0:	.word	0x00001105
    11b4:	.word	0x00001105
    11b8:	.word	0x00001105
    11bc:	.word	0x00001105
    11c0:	.word	0x00001105
    11c4:	.word	0x00001105
    11c8:	.word	0x00001105
    11cc:	.word	0x00001105
    11d0:	.word	0x00001105
    11d4:	.word	0x00001105
    11d8:	.word	0x00001105
    11dc:	.word	0x00001105
    11e0:	.word	0x00001105
    11e4:	.word	0x00001105
    11e8:	.word	0x00001105
    11ec:	.word	0x00001105
    11f0:	.word	0x00001105
    11f4:	.word	0x00001105
    11f8:	.word	0x00001105
    11fc:	.word	0x00001105
    1200:	.word	0x00001105
    1204:	.word	0x00001105
    1208:	.word	0x00001105
    120c:	.word	0x00001105
    1210:	.word	0x00001105
    1214:	.word	0x00001105
    1218:	.word	0x00001105
    121c:	.word	0x00001105
    1220:	.word	0x00001105
    1224:	.word	0x00001105
    1228:	.word	0x00001565
    122c:	.word	0x00001105
    1230:	.word	0x00001105
    1234:	.word	0x00001571
    1238:	.word	0x00001105
    123c:	.word	0x00001105
    1240:	.word	0x00001105
    1244:	.word	0x00001105
    1248:	.word	0x00001105
    124c:	.word	0x00001105
    1250:	.word	0x00001105
    1254:	.word	0x00001105
    1258:	.word	0x00001105
    125c:	.word	0x00001581
    1260:	.word	0x0000158d
    1264:	.word	0x00001105
    1268:	.word	0x00001105
    126c:	.word	0x00001599
    1270:	.word	0x00001105
    1274:	.word	0x000015a5
  {
    while(!Serial.available());
    char c=Serial.read();
    
    if (strchr("?!xa", c))
    { switch (c)
    1278:	cmp	r4, #33	; 0x21
    127a:	bne.w	1104 <doMenu()+0x8>
static void doMenu2(void)
{ // for settings
    uint16_t year,month,day,hour,minutes,seconds;
    int T1=acqParameters.T1;
    int T2=acqParameters.T2;
    int T3=acqParameters.T3;
    127e:	add.w	r6, r5, #12
    1282:	ldmia.w	r6, {r6, r7, r8}
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1286:	bl	9440 <usb_serial_available>
    //int T4=acqParameters.T4; not used
    //
    while(!Serial.available());
    128a:	cmp	r0, #0
    128c:	beq.n	1286 <doMenu()+0x18a>
        virtual int read() { return usb_serial_getchar(); }
    128e:	bl	93c8 <usb_serial_getchar>
    1292:	uxtb	r4, r0
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    1294:	mov	r1, r4
    1296:	ldr	r0, [pc, #308]	; (13cc <doMenu()+0x2d0>)
    1298:	bl	c9ec <strchr>
    129c:	cmp	r0, #0
    129e:	beq.w	1104 <doMenu()+0x8>
    { switch (c)
    12a2:	subs	r4, #49	; 0x31
    12a4:	cmp	r4, #67	; 0x43
    12a6:	bhi.w	1104 <doMenu()+0x8>
    12aa:	add	r3, pc, #4	; (adr r3, 12b0 <doMenu()+0x1b4>)
    12ac:	ldr.w	pc, [r3, r4, lsl #2]
    12b0:	.word	0x000015b5
    12b4:	.word	0x000015cd
    12b8:	.word	0x000015ed
    12bc:	.word	0x00001603
    12c0:	.word	0x00001105
    12c4:	.word	0x00001105
    12c8:	.word	0x00001105
    12cc:	.word	0x00001105
    12d0:	.word	0x00001105
    12d4:	.word	0x00001105
    12d8:	.word	0x00001105
    12dc:	.word	0x00001105
    12e0:	.word	0x00001105
    12e4:	.word	0x00001105
    12e8:	.word	0x00001105
    12ec:	.word	0x00001105
    12f0:	.word	0x00001105
    12f4:	.word	0x00001105
    12f8:	.word	0x00001105
    12fc:	.word	0x00001105
    1300:	.word	0x00001105
    1304:	.word	0x00001105
    1308:	.word	0x00001105
    130c:	.word	0x00001105
    1310:	.word	0x00001105
    1314:	.word	0x00001105
    1318:	.word	0x00001105
    131c:	.word	0x00001105
    1320:	.word	0x00001105
    1324:	.word	0x00001105
    1328:	.word	0x00001105
    132c:	.word	0x00001105
    1330:	.word	0x00001105
    1334:	.word	0x00001105
    1338:	.word	0x00001105
    133c:	.word	0x00001105
    1340:	.word	0x00001105
    1344:	.word	0x00001105
    1348:	.word	0x00001105
    134c:	.word	0x00001105
    1350:	.word	0x00001105
    1354:	.word	0x00001105
    1358:	.word	0x00001105
    135c:	.word	0x00001105
    1360:	.word	0x00001105
    1364:	.word	0x00001105
    1368:	.word	0x00001105
    136c:	.word	0x00001105
    1370:	.word	0x00001621
    1374:	.word	0x00001105
    1378:	.word	0x00001105
    137c:	.word	0x0000163d
    1380:	.word	0x00001105
    1384:	.word	0x00001105
    1388:	.word	0x00001105
    138c:	.word	0x00001105
    1390:	.word	0x00001105
    1394:	.word	0x00001105
    1398:	.word	0x00001105
    139c:	.word	0x00001105
    13a0:	.word	0x00001105
    13a4:	.word	0x0000169b
    13a8:	.word	0x00001711
    13ac:	.word	0x00001105
    13b0:	.word	0x00001105
    13b4:	.word	0x0000172b
    13b8:	.word	0x00001105
    13bc:	.word	0x000014db
    13c0:	.word	0x20013764
    13c4:	.word	0x00013234
    13c8:	.word	0x200138e4
    13cc:	.word	0x0001323c
extern ACQ_Parameters_s acqParameters;
extern SNIP_Parameters_s snipParameters;

static void printAll(void)
{
  Serial.printf("%c %5d on_time\n\r",     'o',acqParameters.on);
    13d0:	ldr	r3, [r5, #0]
    13d2:	ldr	r1, [pc, #736]	; (16b4 <doMenu()+0x5b8>)
    13d4:	ldr	r0, [pc, #736]	; (16b8 <doMenu()+0x5bc>)
    13d6:	movs	r2, #111	; 0x6f
    13d8:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d acq_time\n\r",    'a',acqParameters.ad);
    13dc:	mov	r2, r4
    13de:	ldr	r3, [r5, #4]
    13e0:	ldr	r1, [pc, #728]	; (16bc <doMenu()+0x5c0>)
    13e2:	ldr	r0, [pc, #724]	; (16b8 <doMenu()+0x5bc>)
    13e4:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d rep_rate\n\r",    'r',acqParameters.ar);
    13e8:	ldr	r3, [r5, #8]
    13ea:	ldr	r1, [pc, #724]	; (16c0 <doMenu()+0x5c4>)
    13ec:	ldr	r0, [pc, #712]	; (16b8 <doMenu()+0x5bc>)
    13ee:	movs	r2, #114	; 0x72
    13f0:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d first_hour\n\r",  '1',acqParameters.T1);
    13f4:	ldr	r3, [r5, #12]
    13f6:	ldr	r1, [pc, #716]	; (16c4 <doMenu()+0x5c8>)
    13f8:	ldr	r0, [pc, #700]	; (16b8 <doMenu()+0x5bc>)
    13fa:	movs	r2, #49	; 0x31
    13fc:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d second_hour\n\r", '2',acqParameters.T2);
    1400:	ldr	r3, [r5, #16]
    1402:	ldr	r1, [pc, #708]	; (16c8 <doMenu()+0x5cc>)
    1404:	ldr	r0, [pc, #688]	; (16b8 <doMenu()+0x5bc>)
    1406:	movs	r2, #50	; 0x32
    1408:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d third_hour\n\r",  '3',acqParameters.T3);
    140c:	ldr	r3, [r5, #20]
    140e:	ldr	r1, [pc, #700]	; (16cc <doMenu()+0x5d0>)
    1410:	ldr	r0, [pc, #676]	; (16b8 <doMenu()+0x5bc>)
    1412:	movs	r2, #51	; 0x33
    1414:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d last_hour\n\r",   '4',acqParameters.T4);
    1418:	ldr	r3, [r5, #24]
    141a:	ldr	r1, [pc, #692]	; (16d0 <doMenu()+0x5d4>)
    141c:	ldr	r0, [pc, #664]	; (16b8 <doMenu()+0x5bc>)
    141e:	movs	r2, #52	; 0x34
    1420:	bl	a990 <Print::printf(char const*, ...)>
  Serial.println();
    1424:	ldr	r0, [pc, #656]	; (16b8 <doMenu()+0x5bc>)
    1426:	bl	a960 <Print::println()>
  Serial.printf("%c %s name\n\r",         'n',acqParameters.name);
    142a:	ldr	r3, [pc, #680]	; (16d4 <doMenu()+0x5d8>)
    142c:	ldr	r1, [pc, #680]	; (16d8 <doMenu()+0x5dc>)
    142e:	ldr	r0, [pc, #648]	; (16b8 <doMenu()+0x5bc>)
    1430:	movs	r2, #110	; 0x6e
    1432:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %s date\n\r",         'd',getDate(text));
    1436:	bl	5f8 <getDate(char*) [clone .constprop.35]>
    143a:	movs	r2, #100	; 0x64
    143c:	mov	r3, r0
    143e:	ldr	r1, [pc, #668]	; (16dc <doMenu()+0x5e0>)
    1440:	ldr	r0, [pc, #628]	; (16b8 <doMenu()+0x5bc>)
    1442:	bl	a990 <Print::printf(char const*, ...)>
  Serial.printf("%c %s time\n\r",         't',getTime(text));
    1446:	bl	5c4 <getTime(char*) [clone .constprop.34]>
    144a:	movs	r2, #116	; 0x74
    144c:	mov	r3, r0
    144e:	ldr	r1, [pc, #656]	; (16e0 <doMenu()+0x5e4>)
    1450:	ldr	r0, [pc, #612]	; (16b8 <doMenu()+0x5bc>)
    1452:	bl	a990 <Print::printf(char const*, ...)>
  Serial.println();
    1456:	ldr	r0, [pc, #608]	; (16b8 <doMenu()+0x5bc>)
    1458:	bl	a960 <Print::println()>
  Serial.printf("%c %5d inhibit window\r\n",        'i',snipParameters.inhib);
  Serial.printf("%c %5d noise repetition rate\r\n", 'k',snipParameters.nrep);
  Serial.printf("%c %5d pre trigger delay\r\n",     'p',snipParameters.ndel);
  #endif
  //
  Serial.println();
    145c:	ldr	r0, [pc, #600]	; (16b8 <doMenu()+0x5bc>)
    145e:	bl	a960 <Print::println()>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1462:	movs	r1, #23
    1464:	ldr	r0, [pc, #636]	; (16e4 <doMenu()+0x5e8>)
    1466:	bl	9494 <usb_serial_write>
    146a:	ldr	r0, [pc, #588]	; (16b8 <doMenu()+0x5bc>)
    146c:	bl	a960 <Print::println()>
    1470:	movs	r1, #64	; 0x40
    1472:	ldr	r0, [pc, #628]	; (16e8 <doMenu()+0x5ec>)
    1474:	bl	9494 <usb_serial_write>
    1478:	ldr	r0, [pc, #572]	; (16b8 <doMenu()+0x5bc>)
    147a:	bl	a960 <Print::println()>
    147e:	movs	r1, #32
    1480:	ldr	r0, [pc, #616]	; (16ec <doMenu()+0x5f0>)
    1482:	bl	9494 <usb_serial_write>
    1486:	ldr	r0, [pc, #560]	; (16b8 <doMenu()+0x5bc>)
    1488:	bl	a960 <Print::println()>
    148c:	movs	r1, #88	; 0x58
    148e:	ldr	r0, [pc, #608]	; (16f0 <doMenu()+0x5f4>)
    1490:	bl	9494 <usb_serial_write>
    1494:	ldr	r0, [pc, #544]	; (16b8 <doMenu()+0x5bc>)
    1496:	bl	a960 <Print::println()>
    149a:	movs	r1, #38	; 0x26
    149c:	ldr	r0, [pc, #596]	; (16f4 <doMenu()+0x5f8>)
    149e:	bl	9494 <usb_serial_write>
    14a2:	ldr	r0, [pc, #532]	; (16b8 <doMenu()+0x5bc>)
    14a4:	bl	a960 <Print::println()>
    14a8:	movs	r1, #69	; 0x45
    14aa:	ldr	r0, [pc, #588]	; (16f8 <doMenu()+0x5fc>)
    14ac:	bl	9494 <usb_serial_write>
    14b0:	ldr	r0, [pc, #516]	; (16b8 <doMenu()+0x5bc>)
    14b2:	bl	a960 <Print::println()>
    14b6:	movs	r1, #50	; 0x32
    14b8:	ldr	r0, [pc, #576]	; (16fc <doMenu()+0x600>)
    14ba:	bl	9494 <usb_serial_write>
    14be:	ldr	r0, [pc, #504]	; (16b8 <doMenu()+0x5bc>)
    14c0:	bl	a960 <Print::println()>
    14c4:	movs	r1, #43	; 0x2b
    14c6:	ldr	r0, [pc, #568]	; (1700 <doMenu()+0x604>)
    14c8:	bl	9494 <usb_serial_write>
    14cc:	ldr	r0, [pc, #488]	; (16b8 <doMenu()+0x5bc>)
    14ce:	bl	a960 <Print::println()>
  Serial.println("exter '!cval' to read value c=(0,a,r,1,2,3,4,n,d,t,c,h,w,s,m,i,k,p) and val is new value");
  Serial.println("  e.g.: !110 will set first hour to 10");
  Serial.println("exter 'xval' to exit menu (x is delay in minutes, -1 means immediate)");
  Serial.println("  e.g.: x10 will exit and hibernate for 10 minutes");
  Serial.println("        x-1 with exit and start immediately");
  Serial.println();
    14d2:	ldr	r0, [pc, #484]	; (16b8 <doMenu()+0x5bc>)
    14d4:	bl	a960 <Print::println()>
    14d8:	b.n	1104 <doMenu()+0x8>
                  month=  boundaryCheck(Serial.parseInt(),1,12);
                  day=    boundaryCheck(Serial.parseInt(),1,31);
                  setDate(year,month,day);
                  break;
        case 't': 
                  hour=     boundaryCheck(Serial.parseInt(),0,23);
    14da:	ldr	r0, [pc, #476]	; (16b8 <doMenu()+0x5bc>)
    14dc:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    14e0:	subs	r4, r0, #0
    14e2:	blt.w	17a0 <doMenu()+0x6a4>
    if(val>maxVal) val=maxVal;
    14e6:	cmp	r4, #23
    14e8:	it	ge
    14ea:	movge	r4, #23
                  day=    boundaryCheck(Serial.parseInt(),1,31);
                  setDate(year,month,day);
                  break;
        case 't': 
                  hour=     boundaryCheck(Serial.parseInt(),0,23);
                  minutes=  boundaryCheck(Serial.parseInt(),0,59);
    14ec:	ldr	r0, [pc, #456]	; (16b8 <doMenu()+0x5bc>)
    14ee:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    14f2:	subs	r6, r0, #0
    14f4:	blt.w	1798 <doMenu()+0x69c>
    if(val>maxVal) val=maxVal;
    14f8:	cmp	r6, #59	; 0x3b
    14fa:	it	ge
    14fc:	movge	r6, #59	; 0x3b
                  setDate(year,month,day);
                  break;
        case 't': 
                  hour=     boundaryCheck(Serial.parseInt(),0,23);
                  minutes=  boundaryCheck(Serial.parseInt(),0,59);
                  seconds=  boundaryCheck(Serial.parseInt(),0,59);
    14fe:	ldr	r0, [pc, #440]	; (16b8 <doMenu()+0x5bc>)
    1500:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1504:	subs	r7, r0, #0
    1506:	blt.w	1794 <doMenu()+0x698>
    if(val>maxVal) val=maxVal;
    150a:	cmp	r7, #59	; 0x3b
    150c:	it	ge
    150e:	movge	r7, #59	; 0x3b
    setRTCTime(hour(),minute(),second(),day, month, year);
}

static void setTime(uint16_t hour, uint16_t minutes, uint16_t seconds)
{
    setRTCTime(hour,minutes,seconds,day(),month(),year());
    1510:	bl	2704 <day()>
    1514:	mov	r8, r0
    1516:	bl	2724 <month()>
    151a:	mov	r9, r0
    151c:	bl	2744 <year()>
    1520:	str.w	r9, [sp]
    1524:	str	r0, [sp, #4]
    1526:	mov	r3, r8
    1528:	mov	r2, r7
    152a:	mov	r1, r6
    152c:	mov	r0, r4
    152e:	bl	10b8 <setRTCTime(int, int, int, int, int, int)>
    1532:	b.n	1104 <doMenu()+0x8>
    { switch (c)
      {
        case 'o': Serial.printf("%02d\r\n",acqParameters.on); break;
        case 'a': Serial.printf("%02d\r\n",acqParameters.ad); break;
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
        case '1': Serial.printf("%02d\r\n",acqParameters.T1);break;
    1534:	ldr	r2, [r5, #12]
    1536:	ldr	r1, [pc, #460]	; (1704 <doMenu()+0x608>)
    1538:	ldr	r0, [pc, #380]	; (16b8 <doMenu()+0x5bc>)
    153a:	bl	a990 <Print::printf(char const*, ...)>
    153e:	b.n	1104 <doMenu()+0x8>
        case '2': Serial.printf("%02d\r\n",acqParameters.T2);break;
    1540:	ldr	r2, [r5, #16]
    1542:	ldr	r1, [pc, #448]	; (1704 <doMenu()+0x608>)
    1544:	ldr	r0, [pc, #368]	; (16b8 <doMenu()+0x5bc>)
    1546:	bl	a990 <Print::printf(char const*, ...)>
    154a:	b.n	1104 <doMenu()+0x8>
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
    154c:	ldr	r2, [r5, #20]
    154e:	ldr	r1, [pc, #436]	; (1704 <doMenu()+0x608>)
    1550:	ldr	r0, [pc, #356]	; (16b8 <doMenu()+0x5bc>)
    1552:	bl	a990 <Print::printf(char const*, ...)>
    1556:	b.n	1104 <doMenu()+0x8>
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
    1558:	ldr	r2, [r5, #24]
    155a:	ldr	r1, [pc, #424]	; (1704 <doMenu()+0x608>)
    155c:	ldr	r0, [pc, #344]	; (16b8 <doMenu()+0x5bc>)
    155e:	bl	a990 <Print::printf(char const*, ...)>
    1562:	b.n	1104 <doMenu()+0x8>
    
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      {
        case 'o': Serial.printf("%02d\r\n",acqParameters.on); break;
        case 'a': Serial.printf("%02d\r\n",acqParameters.ad); break;
    1564:	ldr	r2, [r5, #4]
    1566:	ldr	r1, [pc, #412]	; (1704 <doMenu()+0x608>)
    1568:	ldr	r0, [pc, #332]	; (16b8 <doMenu()+0x5bc>)
    156a:	bl	a990 <Print::printf(char const*, ...)>
    156e:	b.n	1104 <doMenu()+0x8>
        case '2': Serial.printf("%02d\r\n",acqParameters.T2);break;
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
        case 'n': Serial.printf("%s\r\n",acqParameters.name);break; 
        
        case 'd': Serial.printf("%s\r\n",getDate(text));break;
    1570:	bl	5f8 <getDate(char*) [clone .constprop.35]>
    1574:	ldr	r1, [pc, #400]	; (1708 <doMenu()+0x60c>)
    1576:	mov	r2, r0
    1578:	ldr	r0, [pc, #316]	; (16b8 <doMenu()+0x5bc>)
    157a:	bl	a990 <Print::printf(char const*, ...)>
    157e:	b.n	1104 <doMenu()+0x8>
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
        case '1': Serial.printf("%02d\r\n",acqParameters.T1);break;
        case '2': Serial.printf("%02d\r\n",acqParameters.T2);break;
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
        case 'n': Serial.printf("%s\r\n",acqParameters.name);break; 
    1580:	ldr	r2, [pc, #336]	; (16d4 <doMenu()+0x5d8>)
    1582:	ldr	r1, [pc, #388]	; (1708 <doMenu()+0x60c>)
    1584:	ldr	r0, [pc, #304]	; (16b8 <doMenu()+0x5bc>)
    1586:	bl	a990 <Print::printf(char const*, ...)>
    158a:	b.n	1104 <doMenu()+0x8>
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      {
        case 'o': Serial.printf("%02d\r\n",acqParameters.on); break;
    158c:	ldr	r2, [r5, #0]
    158e:	ldr	r1, [pc, #372]	; (1704 <doMenu()+0x608>)
    1590:	ldr	r0, [pc, #292]	; (16b8 <doMenu()+0x5bc>)
    1592:	bl	a990 <Print::printf(char const*, ...)>
    1596:	b.n	1104 <doMenu()+0x8>
        case 'a': Serial.printf("%02d\r\n",acqParameters.ad); break;
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
    1598:	ldr	r2, [r5, #8]
    159a:	ldr	r1, [pc, #360]	; (1704 <doMenu()+0x608>)
    159c:	ldr	r0, [pc, #280]	; (16b8 <doMenu()+0x5bc>)
    159e:	bl	a990 <Print::printf(char const*, ...)>
    15a2:	b.n	1104 <doMenu()+0x8>
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
        case 'n': Serial.printf("%s\r\n",acqParameters.name);break; 
        
        case 'd': Serial.printf("%s\r\n",getDate(text));break;
        case 't': Serial.printf("%s\r\n",getTime(text));break;
    15a4:	bl	5c4 <getTime(char*) [clone .constprop.34]>
    15a8:	ldr	r1, [pc, #348]	; (1708 <doMenu()+0x60c>)
    15aa:	mov	r2, r0
    15ac:	ldr	r0, [pc, #264]	; (16b8 <doMenu()+0x5bc>)
    15ae:	bl	a990 <Print::printf(char const*, ...)>
    15b2:	b.n	1104 <doMenu()+0x8>
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
    15b4:	ldr	r0, [pc, #256]	; (16b8 <doMenu()+0x5bc>)
    15b6:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    15ba:	cmp	r0, #0
    15bc:	blt.w	179c <doMenu()+0x6a0>
    15c0:	cmp	r0, #24
    15c2:	mov	r3, r0
    15c4:	it	ge
    15c6:	movge	r3, #24
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
    15c8:	str	r3, [r5, #12]
    15ca:	b.n	1104 <doMenu()+0x8>
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
    15cc:	ldr	r0, [pc, #232]	; (16b8 <doMenu()+0x5bc>)
    15ce:	bl	ae4c <Stream::parseInt()>
    }
}
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
    15d2:	cmp	r6, #23
    15d4:	bgt.w	1754 <doMenu()+0x658>
  {
    if(val<minVal) val=minVal;
    15d8:	cmp	r6, r0
    15da:	bgt.n	15e8 <doMenu()+0x4ec>
    if(val>maxVal) val=maxVal;
    15dc:	cmp	r0, #24
    15de:	it	gt
    15e0:	movgt	r0, #24
    15e2:	bgt.w	175a <doMenu()+0x65e>
    15e6:	mov	r6, r0
    15e8:	mov	r0, r6
    15ea:	b.n	175a <doMenu()+0x65e>
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
    15ec:	ldr	r0, [pc, #200]	; (16b8 <doMenu()+0x5bc>)
    15ee:	bl	ae4c <Stream::parseInt()>
    }
}
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
    15f2:	cmp	r7, #23
    15f4:	bgt.w	174a <doMenu()+0x64e>
  {
    if(val<minVal) val=minVal;
    15f8:	cmp	r7, r0
    15fa:	ble.w	1788 <doMenu()+0x68c>
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
    15fe:	str	r7, [r5, #20]
    1600:	b.n	1104 <doMenu()+0x8>
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
    1602:	ldr	r0, [pc, #180]	; (16b8 <doMenu()+0x5bc>)
    1604:	bl	ae4c <Stream::parseInt()>
  }
  return val; 
}
int boundaryCheck2(int val, int minVal, int maxVal, int modVal)
{
  if(minVal < maxVal) // standard case
    1608:	cmp	r6, r8
static void doMenu2(void)
{ // for settings
    uint16_t year,month,day,hour,minutes,seconds;
    int T1=acqParameters.T1;
    int T2=acqParameters.T2;
    int T3=acqParameters.T3;
    160a:	mov	r4, r8
  }
  return val; 
}
int boundaryCheck2(int val, int minVal, int maxVal, int modVal)
{
  if(minVal < maxVal) // standard case
    160c:	ble.w	175e <doMenu()+0x662>
  {
    if(val<minVal) val=minVal;
    1610:	cmp	r8, r0
    1612:	bgt.n	161c <doMenu()+0x520>
    if(val>maxVal) val=maxVal;
    1614:	cmp	r6, r0
    1616:	blt.w	1784 <doMenu()+0x688>
    161a:	mov	r4, r0
  }
  else // wrap around when checking hours
  {
    if(val<0) val=0;
    if(val>modVal) val=modVal;
    161c:	mov	r6, r4
    161e:	b.n	1784 <doMenu()+0x688>
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    1620:	ldr	r0, [pc, #148]	; (16b8 <doMenu()+0x5bc>)
    1622:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1626:	cmp	r0, #0
    1628:	blt.w	17b4 <doMenu()+0x6b8>
    162c:	cmp.w	r0, #131072	; 0x20000
    1630:	mov	r3, r0
    1632:	it	ge
    1634:	movge.w	r3, #131072	; 0x20000
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    1638:	str	r3, [r5, #4]
    163a:	b.n	1104 <doMenu()+0x8>
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
        case 'n': for(int ii=0; ii<4;ii++) acqParameters.name[ii] = Serial.read();
                  acqParameters.name[4]=0; break;
        case 'd':     
                  year=   boundaryCheck(Serial.parseInt(),2000,3000);
    163c:	ldr	r0, [pc, #120]	; (16b8 <doMenu()+0x5bc>)
    163e:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1642:	cmp.w	r0, #2000	; 0x7d0
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
        case 'n': for(int ii=0; ii<4;ii++) acqParameters.name[ii] = Serial.read();
                  acqParameters.name[4]=0; break;
        case 'd':     
                  year=   boundaryCheck(Serial.parseInt(),2000,3000);
    1646:	mov	r4, r0
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1648:	blt.n	1744 <doMenu()+0x648>
    if(val>maxVal) val=maxVal;
    164a:	movw	r3, #3000	; 0xbb8
    164e:	cmp	r0, r3
    1650:	it	ge
    1652:	movge	r4, r3
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
        case 'n': for(int ii=0; ii<4;ii++) acqParameters.name[ii] = Serial.read();
                  acqParameters.name[4]=0; break;
        case 'd':     
                  year=   boundaryCheck(Serial.parseInt(),2000,3000);
                  month=  boundaryCheck(Serial.parseInt(),1,12);
    1654:	ldr	r0, [pc, #96]	; (16b8 <doMenu()+0x5bc>)
    1656:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    165a:	subs	r7, r0, #0
    165c:	ble.w	17b0 <doMenu()+0x6b4>
    if(val>maxVal) val=maxVal;
    1660:	cmp	r7, #12
    1662:	it	ge
    1664:	movge	r7, #12
        case 'n': for(int ii=0; ii<4;ii++) acqParameters.name[ii] = Serial.read();
                  acqParameters.name[4]=0; break;
        case 'd':     
                  year=   boundaryCheck(Serial.parseInt(),2000,3000);
                  month=  boundaryCheck(Serial.parseInt(),1,12);
                  day=    boundaryCheck(Serial.parseInt(),1,31);
    1666:	ldr	r0, [pc, #80]	; (16b8 <doMenu()+0x5bc>)
    1668:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    166c:	subs	r6, r0, #0
    166e:	ble.w	17ac <doMenu()+0x6b0>
    if(val>maxVal) val=maxVal;
    1672:	cmp	r6, #31
    1674:	it	ge
    1676:	movge	r6, #31
  setTime(tt); // local
}

static void setDate(uint16_t year, uint16_t month, uint16_t day)
{
    setRTCTime(hour(),minute(),second(),day, month, year);
    1678:	bl	26a4 <hour()>
    167c:	mov	r8, r0
    167e:	bl	26c4 <minute()>
    1682:	mov	r9, r0
    1684:	bl	26e4 <second()>
    1688:	mov	r1, r9
    168a:	mov	r2, r0
    168c:	str	r4, [sp, #4]
    168e:	mov	r0, r8
    1690:	str	r7, [sp, #0]
    1692:	mov	r3, r6
    1694:	bl	10b8 <setRTCTime(int, int, int, int, int, int)>
    1698:	b.n	1104 <doMenu()+0x8>
    169a:	ldr	r4, [pc, #112]	; (170c <doMenu()+0x610>)
    169c:	adds	r6, r4, #4
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    169e:	bl	93c8 <usb_serial_getchar>
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
        case 'n': for(int ii=0; ii<4;ii++) acqParameters.name[ii] = Serial.read();
    16a2:	strb.w	r0, [r4, #1]!
    16a6:	cmp	r4, r6
    16a8:	bne.n	169e <doMenu()+0x5a2>
                  acqParameters.name[4]=0; break;
    16aa:	movs	r3, #0
    16ac:	strb.w	r3, [r5, #36]	; 0x24
    16b0:	b.n	1104 <doMenu()+0x8>
    16b2:	nop
    16b4:	.word	0x00013258
    16b8:	.word	0x200138e4
    16bc:	.word	0x0001326c
    16c0:	.word	0x00013280
    16c4:	.word	0x00013294
    16c8:	.word	0x000132a8
    16cc:	.word	0x000132c0
    16d0:	.word	0x000132d4
    16d4:	.word	0x20013784
    16d8:	.word	0x000132e8
    16dc:	.word	0x000132f8
    16e0:	.word	0x00013308
    16e4:	.word	0x00013318
    16e8:	.word	0x00013330
    16ec:	.word	0x00013374
    16f0:	.word	0x00013398
    16f4:	.word	0x000133f4
    16f8:	.word	0x0001341c
    16fc:	.word	0x00013464
    1700:	.word	0x00013498
    1704:	.word	0x00013250
    1708:	.word	0x000131e0
    170c:	.word	0x20013783
    while(!Serial.available());
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    1710:	ldr	r0, [pc, #168]	; (17bc <doMenu()+0x6c0>)
    1712:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1716:	cmp	r0, #0
    1718:	blt.n	17a8 <doMenu()+0x6ac>
    171a:	cmp.w	r0, #131072	; 0x20000
    171e:	mov	r3, r0
    1720:	it	ge
    1722:	movge.w	r3, #131072	; 0x20000
    while(!Serial.available());
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    1726:	str	r3, [r5, #0]
    1728:	b.n	1104 <doMenu()+0x8>
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    172a:	ldr	r0, [pc, #144]	; (17bc <doMenu()+0x6c0>)
    172c:	bl	ae4c <Stream::parseInt()>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1730:	cmp	r0, #0
    1732:	blt.n	17a4 <doMenu()+0x6a8>
    1734:	cmp.w	r0, #131072	; 0x20000
    1738:	mov	r3, r0
    173a:	it	ge
    173c:	movge.w	r3, #131072	; 0x20000
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    1740:	str	r3, [r5, #8]
    1742:	b.n	1104 <doMenu()+0x8>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1744:	mov.w	r4, #2000	; 0x7d0
    1748:	b.n	1654 <doMenu()+0x558>
    if(val>maxVal) val=maxVal;
  }
  else // wrap around when checking hours
  {
    if((val>maxVal) && (val<minVal)) val=maxVal;
    174a:	cmp	r0, #24
    174c:	it	ge
    174e:	movge	r0, #24
    1750:	mov	r7, r0
    1752:	b.n	15fe <doMenu()+0x502>
    1754:	cmp	r0, #24
    1756:	it	ge
    1758:	movge	r0, #24
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
    175a:	str	r0, [r5, #16]
    175c:	b.n	1104 <doMenu()+0x8>
    if(val<minVal) val=minVal;
    if(val>maxVal) val=maxVal;
  }
  else // wrap around when checking hours
  {
    if(val<0) val=0;
    175e:	cmp	r0, #0
    1760:	blt.n	17b8 <doMenu()+0x6bc>
    if(val>modVal) val=modVal;
    1762:	cmp	r0, #24
    1764:	it	ge
    1766:	movge	r0, #24
    // shift data to next good value
    if((val>maxVal) && (val<minVal))
    1768:	cmp	r6, r0
    176a:	bge.n	1782 <doMenu()+0x686>
    176c:	cmp	r8, r0
    176e:	ble.n	1782 <doMenu()+0x686>
    { if(val>(minVal+maxVal)/2) val = minVal; else val=maxVal;
    1770:	add.w	r3, r6, r8
    1774:	add.w	r3, r3, r3, lsr #31
    1778:	cmp.w	r0, r3, asr #1
    177c:	it	gt
    177e:	movgt	r6, r8
    1780:	b.n	1784 <doMenu()+0x688>
  else // wrap around when checking hours
  {
    if(val<0) val=0;
    if(val>modVal) val=modVal;
    // shift data to next good value
    if((val>maxVal) && (val<minVal))
    1782:	mov	r6, r0
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
    1784:	str	r6, [r5, #24]
    1786:	b.n	1104 <doMenu()+0x8>
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    if(val>maxVal) val=maxVal;
    1788:	cmp	r0, #24
    178a:	it	gt
    178c:	movgt	r7, #24
    178e:	bgt.w	15fe <doMenu()+0x502>
    1792:	b.n	1750 <doMenu()+0x654>
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
  {
    if(val<minVal) val=minVal;
    1794:	movs	r7, #0
    1796:	b.n	1510 <doMenu()+0x414>
    1798:	movs	r6, #0
    179a:	b.n	14fe <doMenu()+0x402>
    179c:	movs	r3, #0
    179e:	b.n	15c8 <doMenu()+0x4cc>
    17a0:	movs	r4, #0
    17a2:	b.n	14ec <doMenu()+0x3f0>
    17a4:	movs	r3, #0
    17a6:	b.n	1740 <doMenu()+0x644>
    17a8:	movs	r3, #0
    17aa:	b.n	1726 <doMenu()+0x62a>
    17ac:	movs	r6, #1
    17ae:	b.n	1678 <doMenu()+0x57c>
    17b0:	movs	r7, #1
    17b2:	b.n	1666 <doMenu()+0x56a>
    17b4:	movs	r3, #0
    17b6:	b.n	1638 <doMenu()+0x53c>
    if(val<minVal) val=minVal;
    if(val>maxVal) val=maxVal;
  }
  else // wrap around when checking hours
  {
    if(val<0) val=0;
    17b8:	movs	r0, #0
    17ba:	b.n	1768 <doMenu()+0x66c>
    17bc:	.word	0x200138e4

000017c0 <setup>:
//extern void rtc_set(unsigned long t);

time_t getTeensy3Time(){  return Teensy3Clock.get();}
//__________________________General Arduino Routines_____________________________________
//int started=0;
extern "C" void setup() {
    17c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // put your setup code here, to run once:
  pinMode(3,INPUT_PULLUP); // needed to enter menu if grounded
    17c4:	movs	r0, #3
//extern void rtc_set(unsigned long t);

time_t getTeensy3Time(){  return Teensy3Clock.get();}
//__________________________General Arduino Routines_____________________________________
//int started=0;
extern "C" void setup() {
    17c6:	sub	sp, #12
  // put your setup code here, to run once:
  pinMode(3,INPUT_PULLUP); // needed to enter menu if grounded
    17c8:	movs	r1, #2
    17ca:	bl	9938 <pinMode>

  // set the Time library to use Teensy 3.0's RTC to keep time
  setSyncProvider(getTeensy3Time);
    17ce:	ldr	r0, [pc, #372]	; (1944 <setup+0x184>)
    17d0:	ldr	r4, [pc, #372]	; (1948 <setup+0x188>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    17d2:	ldr	r5, [pc, #376]	; (194c <setup+0x18c>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    17d4:	ldr	r7, [pc, #376]	; (1950 <setup+0x190>)
    17d6:	ldr	r6, [pc, #380]	; (1954 <setup+0x194>)
    17d8:	bl	27ac <setSyncProvider(long (*)())>
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    17dc:	ldrb	r3, [r4, #0]

#if DO_DEBUG>0
   while(!Serial && !digitalRead(3));
    17de:	movs	r0, #3
    17e0:	cmp	r3, #0
    17e2:	beq.w	1932 <setup+0x172>
    17e6:	ldrb	r3, [r5, #0]
    17e8:	lsls	r2, r3, #31
    17ea:	bpl.w	1932 <setup+0x172>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    17ee:	ldr	r3, [r7, #0]
    17f0:	ldr	r2, [r6, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    17f2:	subs	r3, r3, r2
    17f4:	cmp	r3, #14
    17f6:	bls.w	1932 <setup+0x172>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    17fa:	movs	r1, #18
    17fc:	ldr	r0, [pc, #344]	; (1958 <setup+0x198>)
    17fe:	bl	9494 <usb_serial_write>
    1802:	ldr	r0, [pc, #344]	; (195c <setup+0x19c>)
    1804:	bl	a960 <Print::println()>
  // for 16bit resolution
  temperature = -0.0293 * analogRead(70) + 440.5;
*/

#define MAUDIO (MAX_Q+MDEL+50)
	AudioMemory (MAUDIO); // 600 blocks use about 200 kB (requires Teensy 3.6)
    1808:	movw	r1, #549	; 0x225
    180c:	ldr	r0, [pc, #336]	; (1960 <setup+0x1a0>)
    180e:	bl	aa3c <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>

  //
  uSD.init();

  // always load config first
  uSD.loadConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1812:	movs	r4, #8
//  uint32_t t0=rtc_get();
//  uint32_t t1=(uint32_t)&__rtc_localtime;
//  if((t1-t0)>100) rtc_set(t1);

  //
  uSD.init();
    1814:	ldr	r0, [pc, #332]	; (1964 <setup+0x1a4>)
    1816:	bl	87c <c_uSD::init()>

  // always load config first
  uSD.loadConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    181a:	ldr	r3, [pc, #332]	; (1968 <setup+0x1a8>)
    181c:	str	r4, [sp, #0]
    181e:	mov	r2, r4
    1820:	ldr	r1, [pc, #328]	; (196c <setup+0x1ac>)
    1822:	ldr	r0, [pc, #320]	; (1964 <setup+0x1a4>)
    1824:	bl	c48 <c_uSD::loadConfig(unsigned long*, int, long*, int)>
		} else if (pin == 1) {
			return (CORE_PIN1_PINREG & CORE_PIN1_BITMASK) ? 1 : 0;
		} else if (pin == 2) {
			return (CORE_PIN2_PINREG & CORE_PIN2_BITMASK) ? 1 : 0;
		} else if (pin == 3) {
			return (CORE_PIN3_PINREG & CORE_PIN3_BITMASK) ? 1 : 0;
    1828:	ldr	r3, [pc, #324]	; (1970 <setup+0x1b0>)
    182a:	ldr	r3, [r3, #0]
    182c:	lsls	r3, r3, #19
    182e:	bmi.n	1852 <setup+0x92>
  }
*/
  // if pin3 is connected to GND enter menu mode
  int ret;
  if(!digitalReadFast(3))
  { ret=doMenu();
    1830:	bl	10fc <doMenu()>
      
    // should here save parameters to disk if modified
    uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1834:	str	r4, [sp, #0]
  }
*/
  // if pin3 is connected to GND enter menu mode
  int ret;
  if(!digitalReadFast(3))
  { ret=doMenu();
    1836:	mov	r5, r0
      
    // should here save parameters to disk if modified
    uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1838:	mov	r2, r4
    183a:	ldr	r3, [pc, #300]	; (1968 <setup+0x1a8>)
    183c:	ldr	r1, [pc, #300]	; (196c <setup+0x1ac>)
    183e:	ldr	r0, [pc, #292]	; (1964 <setup+0x1a4>)
    1840:	bl	b20 <c_uSD::storeConfig(unsigned long*, int, long*, int)>

    if(ret>0) 
    1844:	cmp	r5, #0
    1846:	ble.n	1852 <setup+0x92>
    setWakeupCallandSleep(ret*60);  // should shutdown now and wait for start
    1848:	rsb	r0, r5, r5, lsl #4
    184c:	lsls	r0, r0, #2
    184e:	bl	d5c <setWakeupCallandSleep(unsigned long)>
  }
  //
  #if MDEL<0
    // check if it is our time to record
    int32_t nsec;
    nsec=checkDutyCycle(&acqParameters, -1);
    1852:	mov.w	r1, #4294967295
    1856:	ldr	r0, [pc, #276]	; (196c <setup+0x1ac>)
    1858:	bl	ef4 <checkDutyCycle(ACQ_Parameters_s*, short)>
    if(nsec>0) 
    185c:	cmp	r0, #0
    185e:	ble.n	1864 <setup+0xa4>
    { 
      #if ((ACQ == _I2S) || (ACQ == _I2S_QUAD) || (ACQ == _I2S_32) || (ACQ == _I2S_32_MONO) || (ACQ == _I2S_TYMPAN) || (ACQ == _I2S_TDM))
        I2S_stopClock();
      #endif
      setWakeupCallandSleep(nsec); // will not return if we should not continue with acquisition 
    1860:	bl	d5c <setWakeupCallandSleep(unsigned long)>
    // the lower 16 bit are always maintained for further processing
    // typical shift value is between 8 and 12 as lower ADC bits are only noise
    int16_t nbits=NSHIFT; 
    acq.digitalShift(nbits); 
  #elif ACQ == _I2S_SGTL5000
    audioShield.enable();
    1864:	ldr	r4, [pc, #268]	; (1974 <setup+0x1b4>)
    1866:	mov	r0, r4
    1868:	bl	2d30 <AudioControlSGTL5000::enable()>
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
	void setAddress(uint8_t level);
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
    186c:	movs	r1, #64	; 0x40
    186e:	mov	r0, r4
    1870:	bl	2d98 <AudioControlSGTL5000::volumeInteger(unsigned int)>
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
    1874:	mov	r0, r4
    1876:	movs	r2, #85	; 0x55
    1878:	movs	r1, #32
    187a:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
    187e:	cbz	r0, 1890 <setup+0xd0>
    1880:	ldrh	r2, [r4, #6]
    1882:	orr.w	r2, r2, #4
    1886:	uxth	r2, r2
    1888:	mov	r0, r4
    188a:	movs	r1, #36	; 0x24
    188c:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
  state=0;
}

void c_uSD::setPrefix(char *prefix)
{
  strcpy(name,prefix);
    1890:	ldr	r1, [pc, #228]	; (1978 <setup+0x1b8>)
    1892:	ldr	r0, [pc, #232]	; (197c <setup+0x1bc>)
    1894:	ldr	r7, [pc, #232]	; (1980 <setup+0x1c0>)
    1896:	bl	cabc <strcpy>
  // lets start
  #if MDET
    process1.begin(&snipParameters); 
  #endif

  for(int ii=0; ii<NCH; ii++) queue[ii].begin();
    189a:	mov.w	r8, #0
    189e:	mov	r9, r7
{
	uint16_t t;

	if (userblock) {
		release(userblock);
		userblock = NULL;
    18a0:	mov	fp, r8
	}
	t = tail;
    18a2:	movw	sl, #1044	; 0x414
template <int mq>
void mRecordQueue<mq>::clear(void)
{
	uint16_t t;

	if (userblock) {
    18a6:	ldr.w	r0, [r9, #1032]	; 0x408
    18aa:	cbz	r0, 18b4 <setup+0xf4>
		release(userblock);
    18ac:	bl	ab50 <AudioStream::release(audio_block_struct*)>
		userblock = NULL;
    18b0:	str.w	fp, [r9, #1032]	; 0x408
	}
	t = tail;
    18b4:	mla	r5, sl, r8, r7
    18b8:	ldrh.w	r4, [r5, #1038]	; 0x40e
	while (t != head) {
    18bc:	ldrh.w	r3, [r5, #1036]	; 0x40c

	if (userblock) {
		release(userblock);
		userblock = NULL;
	}
	t = tail;
    18c0:	uxth	r4, r4
	while (t != head) {
    18c2:	uxth	r3, r3
    18c4:	cmp	r3, r4
    18c6:	beq.n	18f2 <setup+0x132>
		if (++t >= mq) t = 0;
		release(queue[t]);
    18c8:	add.w	r6, r8, r8, lsl #6
    18cc:	add.w	r6, r8, r6, lsl #2
		release(userblock);
		userblock = NULL;
	}
	t = tail;
	while (t != head) {
		if (++t >= mq) t = 0;
    18d0:	adds	r4, #1
    18d2:	uxth	r4, r4
    18d4:	cmp	r4, #249	; 0xf9
    18d6:	it	hi
    18d8:	movhi	r4, #0
    18da:	mov	r3, r4
		release(queue[t]);
    18dc:	add	r3, r6
    18de:	adds	r3, #8
    18e0:	ldr.w	r0, [r7, r3, lsl #2]
    18e4:	bl	ab50 <AudioStream::release(audio_block_struct*)>
	if (userblock) {
		release(userblock);
		userblock = NULL;
	}
	t = tail;
	while (t != head) {
    18e8:	ldrh.w	r3, [r5, #1036]	; 0x40c
    18ec:	uxth	r3, r3
    18ee:	cmp	r3, r4
    18f0:	bne.n	18d0 <setup+0x110>
{
public:
	mRecordQueue(void) : AudioStream(1, inputQueueArray),
		userblock(NULL), head(0), tail(0), enabled(0) { }
   
	void begin(void) { clear();	enabled = 1;}
    18f2:	movs	r2, #1
	t = tail;
	while (t != head) {
		if (++t >= mq) t = 0;
		release(queue[t]);
	}
	tail = t;
    18f4:	mla	r3, sl, r8, r7
    18f8:	add	r8, r2
    18fa:	cmp.w	r8, #2
    18fe:	strh.w	r4, [r3, #1038]	; 0x40e
    1902:	addw	r9, r9, #1044	; 0x414
{
public:
	mRecordQueue(void) : AudioStream(1, inputQueueArray),
		userblock(NULL), head(0), tail(0), enabled(0) { }
   
	void begin(void) { clear();	enabled = 1;}
    1906:	strh.w	r2, [r3, #1040]	; 0x410
    190a:	bne.n	18a6 <setup+0xe6>
    190c:	movs	r1, #12
    190e:	ldr	r0, [pc, #116]	; (1984 <setup+0x1c4>)
    1910:	bl	9494 <usb_serial_write>
    1914:	ldr	r0, [pc, #68]	; (195c <setup+0x19c>)
    1916:	bl	a960 <Print::println()>
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
    191a:	ldr	r3, [pc, #108]	; (1988 <setup+0x1c8>)
    191c:	ldr	r1, [r3, #0]
    191e:	cbz	r1, 193e <setup+0x17e>
    1920:	ldr	r2, [pc, #104]	; (198c <setup+0x1cc>)
    1922:	ldr	r0, [pc, #108]	; (1990 <setup+0x1d0>)
    1924:	movw	r3, #522	; 0x20a
  Serial.println("End of Setup");
//  started=0;  
  #if DO_DEBUG>1
    logFile.open("logFile.txt", O_CREAT | O_RDWR | O_APPEND);
  #endif
}
    1928:	add	sp, #12
    192a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    192e:	b.w	7688 <FsBaseFile::open(FsVolume*, char const*, int)>

  // set the Time library to use Teensy 3.0's RTC to keep time
  setSyncProvider(getTeensy3Time);

#if DO_DEBUG>0
   while(!Serial && !digitalRead(3));
    1932:	bl	991c <digitalRead>
    1936:	cmp	r0, #0
    1938:	beq.w	17dc <setup+0x1c>
    193c:	b.n	17fa <setup+0x3a>
  Serial.println("End of Setup");
//  started=0;  
  #if DO_DEBUG>1
    logFile.open("logFile.txt", O_CREAT | O_RDWR | O_APPEND);
  #endif
}
    193e:	add	sp, #12
    1940:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1944:	.word	0x00000565
    1948:	.word	0x20019ca8
    194c:	.word	0x20019bc0
    1950:	.word	0x20019bc4
    1954:	.word	0x20019da8
    1958:	.word	0x000134c4
    195c:	.word	0x200138e4
    1960:	.word	0x1fff0200
    1964:	.word	0x20014364
    1968:	.word	0x20013740
    196c:	.word	0x20013764
    1970:	.word	0x400ff010
    1974:	.word	0x200195a0
    1978:	.word	0x20013784
    197c:	.word	0x2001486e
    1980:	.word	0x20014880
    1984:	.word	0x000134d8
    1988:	.word	0x20019b60
    198c:	.word	0x000134e8
    1990:	.word	0x20019560

00001994 <SdBase<FsVolume>::errorHalt(Print*)>:
  //----------------------------------------------------------------------------
  /** %Print error info and halt.
   *
   * \param[in] pr Print destination.
   */
  void errorHalt(print_t* pr) {
    1994:	mov	r5, r0
    1996:	ldr.w	r0, [r0, #1164]	; 0x48c
    199a:	push	{r3, lr}
    199c:	mov	r4, r1
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    199e:	cbz	r0, 19d0 <SdBase<FsVolume>::errorHalt(Print*)+0x3c>
      return m_card->errorCode();
    19a0:	ldr	r3, [r0, #0]
    19a2:	ldr	r3, [r3, #40]	; 0x28
    19a4:	blx	r3
  /** %Print error info and halt.
   *
   * \param[in] pr Print destination.
   */
  void errorHalt(print_t* pr) {
    if (sdErrorCode()) {
    19a6:	cbnz	r0, 19d0 <SdBase<FsVolume>::errorHalt(Print*)+0x3c>
    19a8:	ldr.w	r3, [r5, #1152]	; 0x480
  /** \return Partition type, FAT_TYPE_EXFAT, FAT_TYPE_FAT32,
   *          FAT_TYPE_FAT16, or zero for error.
   */
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
    19ac:	cbz	r3, 19b8 <SdBase<FsVolume>::errorHalt(Print*)+0x24>
    19ae:	ldrb	r3, [r3, #7]
      pr->print(F("SdError: 0X"));
      pr->print(sdErrorCode(), HEX);
      pr->print(F(",0X"));
      pr->println(sdErrorData(), HEX);
    } else if (!Vol::fatType()) {
    19b0:	cbz	r3, 19c6 <SdBase<FsVolume>::errorHalt(Print*)+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    19b2:	bl	a6c4 <yield>
    19b6:	b.n	19b2 <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
    19b8:	ldr.w	r3, [r5, #1156]	; 0x484
    19bc:	cbz	r3, 19c6 <SdBase<FsVolume>::errorHalt(Print*)+0x32>
    19be:	ldrb.w	r3, [r3, #1092]	; 0x444
    19c2:	cmp	r3, #0
    19c4:	bne.n	19b2 <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
      pr->println(F("Check SD format."));
    19c6:	mov	r0, r4
    19c8:	ldr	r1, [pc, #84]	; (1a20 <SdBase<FsVolume>::errorHalt(Print*)+0x8c>)
    19ca:	bl	74c <Print::println(__FlashStringHelper const*)>
    19ce:	b.n	19b2 <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    19d0:	ldr	r1, [pc, #80]	; (1a24 <SdBase<FsVolume>::errorHalt(Print*)+0x90>)
    19d2:	mov	r0, r4
    19d4:	bl	730 <Print::write(char const*)>
    19d8:	ldr.w	r0, [r5, #1164]	; 0x48c
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    19dc:	cbz	r0, 1a1c <SdBase<FsVolume>::errorHalt(Print*)+0x88>
      return m_card->errorCode();
    19de:	ldr	r3, [r0, #0]
    19e0:	ldr	r3, [r3, #40]	; 0x28
    19e2:	blx	r3
    19e4:	mov	r1, r0
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    19e6:	movs	r3, #0
    19e8:	movs	r2, #16
    19ea:	mov	r0, r4
    19ec:	bl	a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    19f0:	ldr	r1, [pc, #52]	; (1a28 <SdBase<FsVolume>::errorHalt(Print*)+0x94>)
    19f2:	mov	r0, r4
    19f4:	bl	730 <Print::write(char const*)>
    19f8:	ldr.w	r0, [r5, #1164]	; 0x48c
    }
    return SD_CARD_ERROR_INVALID_CARD_CONFIG;
  }
  //----------------------------------------------------------------------------
  /** \return SD card error data. */
  uint8_t sdErrorData() {return m_card ? m_card->errorData() : 0;}
    19fc:	cbz	r0, 1a18 <SdBase<FsVolume>::errorHalt(Print*)+0x84>
    19fe:	ldr	r3, [r0, #0]
    1a00:	ldr	r3, [r3, #44]	; 0x2c
    1a02:	blx	r3
    1a04:	uxtb	r1, r0
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1a06:	movs	r3, #0
    1a08:	movs	r2, #16
    1a0a:	mov	r0, r4
    1a0c:	bl	a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
    1a10:	mov	r0, r4
    1a12:	bl	a960 <Print::println()>
    1a16:	b.n	19b2 <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
    1a18:	mov	r1, r0
    1a1a:	b.n	1a06 <SdBase<FsVolume>::errorHalt(Print*)+0x72>
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    1a1c:	movs	r1, #42	; 0x2a
    1a1e:	b.n	19e6 <SdBase<FsVolume>::errorHalt(Print*)+0x52>
    1a20:	.word	0x00013504
    1a24:	.word	0x000134f4
    1a28:	.word	0x00013500

00001a2c <SdBase<FsVolume>::errorHalt(char const*)>:
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    1a2c:	ldr	r4, [pc, #28]	; (1a4c <SdBase<FsVolume>::errorHalt(char const*)+0x20>)
  //----------------------------------------------------------------------------
  /** %Print error info and halt.
   *
   * \param[in] msg Message to print.
   */
  void errorHalt(const char* msg) {errorHalt(&Serial, msg);}
    1a2e:	push	{r3, lr}
    1a30:	mov	r5, r0
    1a32:	mov	r6, r1
    1a34:	mov	r0, r4
    1a36:	ldr	r1, [pc, #24]	; (1a50 <SdBase<FsVolume>::errorHalt(char const*)+0x24>)
    1a38:	bl	730 <Print::write(char const*)>
   * \param[in] pr Print destination.
   * \param[in] msg Message to print.
   */
  void errorHalt(print_t* pr, const char* msg) {
    pr->print(F("error: "));
    pr->println(msg);
    1a3c:	mov	r1, r6
    1a3e:	mov	r0, r4
    1a40:	bl	74c <Print::println(__FlashStringHelper const*)>
    errorHalt(pr);
    1a44:	mov	r1, r4
    1a46:	mov	r0, r5
    1a48:	bl	1994 <SdBase<FsVolume>::errorHalt(Print*)>
    1a4c:	.word	0x200138e4
    1a50:	.word	0x00013518

00001a54 <c_uSD::write(short*, long)>:
}

int16_t c_uSD::write(int16_t *data, int32_t ndat)
{
    1a54:	push	{r4, r5, r6, lr}
    1a56:	mov	r4, r0
  if(state == 0)
    1a58:	ldrsh.w	r0, [r0, #1284]	; 0x504
{
  strcpy(name,prefix);
}

int16_t c_uSD::write(int16_t *data, int32_t ndat)
{
    1a5c:	mov	r6, r1
    1a5e:	mov	r5, r2
  if(state == 0)
    1a60:	cbz	r0, 1a70 <c_uSD::write(short*, long)+0x1c>
    #endif
    state=1; // flag that file is open
    nbuf=0;
  }
  
  if(state == 1 || state == 2)
    1a62:	subs	r3, r0, #1
    1a64:	uxth	r3, r3
    1a66:	cmp	r3, #1
    1a68:	bls.n	1ab6 <c_uSD::write(short*, long)+0x62>
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    nbuf++;
    if(closing) {closing=0; state=3;}
  }
  
  if(state == 3)
    1a6a:	cmp	r0, #3
    1a6c:	beq.n	1b28 <c_uSD::write(short*, long)+0xd4>
  {
    state=close();
  }
  return state;
}
    1a6e:	pop	{r4, r5, r6, pc}

int16_t c_uSD::write(int16_t *data, int32_t ndat)
{
  if(state == 0)
  { // open file
    char *filename = makeFilename(name);
    1a70:	addw	r0, r4, #1290	; 0x50a
    1a74:	bl	770 <makeFilename(char*)>
    if(!filename) {state=-1; return state;} // flag to do not anything
    1a78:	cmp	r0, #0
    1a7a:	beq.n	1b34 <c_uSD::write(short*, long)+0xe0>
    1a7c:	ldr	r3, [pc, #204]	; (1b4c <c_uSD::write(short*, long)+0xf8>)
    1a7e:	ldr	r1, [r3, #0]
    1a80:	cmp	r1, #0
    1a82:	beq.n	1b02 <c_uSD::write(short*, long)+0xae>
    1a84:	mov	r2, r0
    1a86:	movw	r3, #1538	; 0x602
    1a8a:	addw	r0, r4, #1220	; 0x4c4
    1a8e:	bl	7688 <FsBaseFile::open(FsVolume*, char const*, int)>
    1a92:	cbz	r0, 1b02 <c_uSD::write(short*, long)+0xae>
    1a94:	ldr.w	r0, [r4, #1276]	; 0x4fc
   * \param[in] length size of the file in bytes.
   * \return true for success or false for failure.
   */
  bool preAllocate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->preAllocate(length) :
           m_xFile ? m_xFile->preAllocate(length) : false;
    1a98:	cbz	r0, 1ae6 <c_uSD::write(short*, long)+0x92>
   *
   * \param[in] length size of the file in bytes.
   * \return true for success or false for failure.
   */
  bool preAllocate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->preAllocate(length) :
    1a9a:	mov.w	r1, #41943040	; 0x2800000
    1a9e:	bl	5f10 <FatFile::preAllocate(unsigned long)>
    1aa2:	cbz	r0, 1afa <c_uSD::write(short*, long)+0xa6>
    //
    if (!file.open(filename, O_CREAT | O_TRUNC |O_RDWR)) sd.errorHalt("file.open failed");
    if (!file.preAllocate(PRE_ALLOCATE_SIZE)) sd.errorHalt("file.preAllocate failed");
    #ifdef  GEN_WAV_FILE // keep first record
          memcpy(header,(const char *)data,512);
    1aa4:	mov.w	r2, #512	; 0x200
    1aa8:	mov	r1, r6
    1aaa:	ldr	r0, [pc, #164]	; (1b50 <c_uSD::write(short*, long)+0xfc>)
    1aac:	bl	9220 <memcpy>
    #endif
    state=1; // flag that file is open
    nbuf=0;
    1ab0:	movs	r3, #0
    1ab2:	strh.w	r3, [r4, #1286]	; 0x506
    1ab6:	ldr.w	r0, [r4, #1276]	; 0x4fc
  }
  
  if(state == 1 || state == 2)
  {  // write to disk
    state=2;
    1aba:	movs	r3, #2
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    1abc:	lsls	r5, r5, #1
    nbuf=0;
  }
  
  if(state == 1 || state == 2)
  {  // write to disk
    state=2;
    1abe:	strh.w	r3, [r4, #1284]	; 0x504
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
    1ac2:	cbz	r0, 1b0a <c_uSD::write(short*, long)+0xb6>
    1ac4:	mov	r1, r6
    1ac6:	mov	r2, r5
    1ac8:	bl	6628 <FatFile::write(void const*, unsigned int)>
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    1acc:	cmp	r0, r5
    1ace:	bne.n	1b42 <c_uSD::write(short*, long)+0xee>
    nbuf++;
    1ad0:	ldrh.w	r3, [r4, #1286]	; 0x506
    if(closing) {closing=0; state=3;}
    1ad4:	ldrsh.w	r2, [r4, #1288]	; 0x508
  
  if(state == 1 || state == 2)
  {  // write to disk
    state=2;
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    nbuf++;
    1ad8:	adds	r3, #1
    1ada:	strh.w	r3, [r4, #1286]	; 0x506
    if(closing) {closing=0; state=3;}
    1ade:	cbnz	r2, 1b1c <c_uSD::write(short*, long)+0xc8>
    1ae0:	ldrsh.w	r0, [r4, #1284]	; 0x504
    1ae4:	b.n	1a6a <c_uSD::write(short*, long)+0x16>
   * \param[in] length size of the file in bytes.
   * \return true for success or false for failure.
   */
  bool preAllocate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->preAllocate(length) :
           m_xFile ? m_xFile->preAllocate(length) : false;
    1ae6:	ldr.w	r0, [r4, #1280]	; 0x500
    1aea:	cbz	r0, 1afa <c_uSD::write(short*, long)+0xa6>
    1aec:	mov.w	r2, #41943040	; 0x2800000
    1af0:	movs	r3, #0
    1af2:	bl	55cc <ExFatFile::preAllocate(unsigned long long)>
  { // open file
    char *filename = makeFilename(name);
    if(!filename) {state=-1; return state;} // flag to do not anything
    //
    if (!file.open(filename, O_CREAT | O_TRUNC |O_RDWR)) sd.errorHalt("file.open failed");
    if (!file.preAllocate(PRE_ALLOCATE_SIZE)) sd.errorHalt("file.preAllocate failed");
    1af6:	cmp	r0, #0
    1af8:	bne.n	1aa4 <c_uSD::write(short*, long)+0x50>
    1afa:	mov	r0, r4
    1afc:	ldr	r1, [pc, #84]	; (1b54 <c_uSD::write(short*, long)+0x100>)
    1afe:	bl	1a2c <SdBase<FsVolume>::errorHalt(char const*)>
  if(state == 0)
  { // open file
    char *filename = makeFilename(name);
    if(!filename) {state=-1; return state;} // flag to do not anything
    //
    if (!file.open(filename, O_CREAT | O_TRUNC |O_RDWR)) sd.errorHalt("file.open failed");
    1b02:	mov	r0, r4
    1b04:	ldr	r1, [pc, #80]	; (1b58 <c_uSD::write(short*, long)+0x104>)
    1b06:	bl	1a2c <SdBase<FsVolume>::errorHalt(char const*)>
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
    1b0a:	ldr.w	r0, [r4, #1280]	; 0x500
    1b0e:	cmp	r0, #0
    1b10:	beq.n	1acc <c_uSD::write(short*, long)+0x78>
    1b12:	mov	r1, r6
    1b14:	mov	r2, r5
    1b16:	bl	57e8 <ExFatFile::write(void const*, unsigned int)>
    1b1a:	b.n	1acc <c_uSD::write(short*, long)+0x78>
  if(state == 1 || state == 2)
  {  // write to disk
    state=2;
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    nbuf++;
    if(closing) {closing=0; state=3;}
    1b1c:	movs	r2, #0
    1b1e:	movs	r3, #3
    1b20:	strh.w	r2, [r4, #1288]	; 0x508
    1b24:	strh.w	r3, [r4, #1284]	; 0x504
  }
  
  if(state == 3)
  {
    state=close();
    1b28:	mov	r0, r4
    1b2a:	bl	a18 <c_uSD::close()>
    1b2e:	strh.w	r0, [r4, #1284]	; 0x504
  }
  return state;
    1b32:	pop	{r4, r5, r6, pc}
int16_t c_uSD::write(int16_t *data, int32_t ndat)
{
  if(state == 0)
  { // open file
    char *filename = makeFilename(name);
    if(!filename) {state=-1; return state;} // flag to do not anything
    1b34:	movw	r3, #65535	; 0xffff
    1b38:	strh.w	r3, [r4, #1284]	; 0x504
    1b3c:	mov.w	r0, #4294967295
    1b40:	pop	{r4, r5, r6, pc}
  }
  
  if(state == 1 || state == 2)
  {  // write to disk
    state=2;
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    1b42:	mov	r0, r4
    1b44:	ldr	r1, [pc, #20]	; (1b5c <c_uSD::write(short*, long)+0x108>)
    1b46:	bl	1a2c <SdBase<FsVolume>::errorHalt(char const*)>
    1b4a:	nop
    1b4c:	.word	0x20019b60
    1b50:	.word	0x200150a8
    1b54:	.word	0x0001354c
    1b58:	.word	0x00013538
    1b5c:	.word	0x00013520

00001b60 <loop>:
  int16_t mustStore=1;
#else
  int16_t mustStore=0;
#endif

extern "C" void loop() {
    1b60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
template <int mq>
uint16_t mRecordQueue<mq>::available(void)
{
  uint16_t h, t;

  h = head;
    1b64:	ldr	r6, [pc, #668]	; (1e04 <loop+0x2a4>)
    1b66:	ldrh.w	r3, [r6, #1036]	; 0x40c
  t = tail;
    1b6a:	ldrh.w	r1, [r6, #1038]	; 0x40e
template <int mq>
uint16_t mRecordQueue<mq>::available(void)
{
  uint16_t h, t;

  h = head;
    1b6e:	uxth	r3, r3
  t = tail;
    1b70:	uxth	r1, r1
  if (h >= t) return h - t;
    1b72:	cmp	r3, r1
  return mq + h - t;
    1b74:	itte	cc
    1b76:	addcc.w	r2, r3, #250	; 0xfa
    1b7a:	subcc	r3, r2, r1
{
  uint16_t h, t;

  h = head;
  t = tail;
  if (h >= t) return h - t;
    1b7c:	subcs	r3, r3, r1
template <int mq>
uint16_t mRecordQueue<mq>::available(void)
{
  uint16_t h, t;

  h = head;
    1b7e:	ldrh.w	r2, [r6, #2080]	; 0x820
  t = tail;
    1b82:	ldrh.w	r1, [r6, #2082]	; 0x822
  if (h >= t) return h - t;
    1b86:	uxth	r3, r3
template <int mq>
uint16_t mRecordQueue<mq>::available(void)
{
  uint16_t h, t;

  h = head;
    1b88:	uxth	r2, r2
  t = tail;
    1b8a:	uxth	r1, r1
  // put your main code here, to run repeatedly:
  uint32_t to=0,t1,t2;
  static uint32_t t3,t4;
  static int16_t state=0; // 0: open new file, -1: last file

  int have_data=1;
    1b8c:	adds	r3, #0
    1b8e:	it	ne
    1b90:	movne	r3, #1
  if (h >= t) return h - t;
    1b92:	cmp	r2, r1
  return mq + h - t;
    1b94:	it	cc
    1b96:	addcc	r2, #250	; 0xfa
    1b98:	subs	r2, r2, r1
    1b9a:	uxth	r2, r2
  int16_t mustStore=1;
#else
  int16_t mustStore=0;
#endif

extern "C" void loop() {
    1b9c:	sub	sp, #32
  uint32_t to=0,t1,t2;
  static uint32_t t3,t4;
  static int16_t state=0; // 0: open new file, -1: last file

  int have_data=1;
  for(int ii=0;ii<NCH;ii++) if(queue[ii].available()==0) have_data=0;
    1b9e:	cmp	r2, #0
    1ba0:	beq.w	1d00 <loop+0x1a0>

  if(have_data)
    1ba4:	cmp	r3, #0
    1ba6:	beq.w	1d00 <loop+0x1a0>
  { // have data on queue
//    started=1; // flag that we have now data
    #if MDEL<0
      int32_t nsec;
      nsec=checkDutyCycle(&acqParameters, state);
    1baa:	ldr	r4, [pc, #604]	; (1e08 <loop+0x2a8>)
    1bac:	ldr	r0, [pc, #604]	; (1e0c <loop+0x2ac>)
    1bae:	ldrsh.w	r1, [r4]
    1bb2:	bl	ef4 <checkDutyCycle(ACQ_Parameters_s*, short)>
      if(nsec<0) { uSD.setClosing();} // this will be last record in file
    1bb6:	subs	r5, r0, #0
    1bb8:	blt.w	1dfa <loop+0x29a>
      if(nsec>0) 
    1bbc:	beq.n	1bca <loop+0x6a>
      { 
        #if ((ACQ == _I2S) || (ACQ == _I2S_QUAD) || (ACQ == _I2S_32) || (ACQ == _I2S_32_MONO) || (ACQ == _I2S_TYMPAN) || (ACQ == _I2S_TDM))
          I2S_stopClock();
        #endif
        #if DO_DEBUG>1
          logFile.close();
    1bbe:	ldr	r0, [pc, #592]	; (1e10 <loop+0x2b0>)
    1bc0:	bl	7660 <FsBaseFile::close()>
        #endif
        setWakeupCallandSleep(nsec); // file closed sleep now
    1bc4:	mov	r0, r5
    1bc6:	bl	d5c <setWakeupCallandSleep(unsigned long)>
    1bca:	ldr	r1, [pc, #568]	; (1e04 <loop+0x2a4>)
  int16_t mustStore=1;
#else
  int16_t mustStore=0;
#endif

extern "C" void loop() {
    1bcc:	movs	r2, #0
    1bce:	add	r0, sp, #24
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
    1bd0:	movw	r5, #1044	; 0x414
template <int mq>
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
    1bd4:	ldr.w	r3, [r1, #1032]	; 0x408
    1bd8:	cmp	r3, #0
    1bda:	beq.w	1eb8 <loop+0x358>
    1bde:	movs	r3, #0
      
    #endif
    //
    // fetch data from queues
    int16_t * data[NCH];
    for(int ii=0; ii<NCH; ii++) data[ii] = (int16_t *)queue[ii].readBuffer();
    1be0:	str.w	r3, [r0, r2, lsl #2]
    1be4:	adds	r2, #1
    1be6:	cmp	r2, #2
    1be8:	addw	r1, r1, #1044	; 0x414
    1bec:	bne.n	1bd4 <loop+0x74>
    1bee:	ldr	r3, [pc, #548]	; (1e14 <loop+0x2b4>)
    1bf0:	ldr	r1, [sp, #24]
    1bf2:	ldr	r2, [sp, #28]
    1bf4:	add.w	r5, r3, #512	; 0x200
    1bf8:	subs	r1, #2
    1bfa:	subs	r2, #2
    // multiplex data
    int16_t *tmp = tempBuffer;
    for(int ii=0;ii<AUDIO_BLOCK_SAMPLES;ii++) for(int jj=0; jj<NCH; jj++) *tmp++ = *data[jj]++;
    1bfc:	ldrsh.w	r0, [r1, #2]!
    1c00:	strh.w	r0, [r3, #-4]
    1c04:	ldrsh.w	r0, [r2, #2]!
    1c08:	strh.w	r0, [r3, #-2]
    1c0c:	adds	r3, #4
    1c0e:	cmp	r3, r5
    1c10:	bne.n	1bfc <loop+0x9c>
}

template <int mq>
void mRecordQueue<mq>::freeBuffer(void)
{
	if (userblock == NULL) return;
    1c12:	ldr.w	r0, [r6, #1032]	; 0x408
    1c16:	ldr	r5, [pc, #492]	; (1e04 <loop+0x2a4>)
    1c18:	cbz	r0, 1c24 <loop+0xc4>
	release(userblock);
    1c1a:	bl	ab50 <AudioStream::release(audio_block_struct*)>
	userblock = NULL;
    1c1e:	movs	r3, #0
    1c20:	str.w	r3, [r5, #1032]	; 0x408
}

template <int mq>
void mRecordQueue<mq>::freeBuffer(void)
{
	if (userblock == NULL) return;
    1c24:	ldr.w	r0, [r6, #2076]	; 0x81c
    1c28:	ldr	r5, [pc, #472]	; (1e04 <loop+0x2a4>)
    1c2a:	cbz	r0, 1c36 <loop+0xd6>
	release(userblock);
    1c2c:	bl	ab50 <AudioStream::release(audio_block_struct*)>
	userblock = NULL;
    1c30:	movs	r3, #0
    1c32:	str.w	r3, [r5, #2076]	; 0x81c

    #if(MDET)
      mustStore = process1.getSigCount() >  0;
    #endif

    if(mustStore)
    1c36:	ldr	r3, [pc, #480]	; (1e18 <loop+0x2b8>)
    1c38:	ldrsh.w	r3, [r3]
    1c3c:	cmp	r3, #0
    1c3e:	beq.w	1da8 <loop+0x248>
    {
      if(state==0)
    1c42:	ldrsh.w	r0, [r4]
      { // generate header before file is opened
        #ifdef GEN_WAV_FILE // is declared in audio_logger_if.h
          uint32_t *header=(uint32_t *) wavHeader(0); // call initially with zero filesize
          //
          int ndat=outptr-diskBuffer;
    1c46:	ldr	r5, [pc, #468]	; (1e1c <loop+0x2bc>)
      mustStore = process1.getSigCount() >  0;
    #endif

    if(mustStore)
    {
      if(state==0)
    1c48:	cmp	r0, #0
    1c4a:	beq.w	1e70 <loop+0x310>
    1c4e:	ldr	r6, [r5, #0]
      
      // number of data in tempBuffer
      int32_t ndat = AUDIO_BLOCK_SAMPLES*NCH;
      
      // number of free samples on diskbuffer
      int32_t nout = diskBuffer+BUFFERSIZE - outptr;
    1c50:	ldr	r7, [pc, #460]	; (1e20 <loop+0x2c0>)
    1c52:	subs	r7, r7, r6
    1c54:	asrs	r7, r7, #1

      tmp = tempBuffer;
      if (nout>ndat)
    1c56:	cmp.w	r7, #256	; 0x100
      
      // number of data in tempBuffer
      int32_t ndat = AUDIO_BLOCK_SAMPLES*NCH;
      
      // number of free samples on diskbuffer
      int32_t nout = diskBuffer+BUFFERSIZE - outptr;
    1c5a:	mov	r8, r6

      tmp = tempBuffer;
      if (nout>ndat)
    1c5c:	bgt.w	1de0 <loop+0x280>
    1c60:	ldr	r3, [pc, #448]	; (1e24 <loop+0x2c4>)
        ndat=0;
      }
      else
      { // fill up disk buffer
        int nbuf=nout;
        if(uSD.isClosing()) nbuf=(nbuf/NCH)*NCH; // is last record of file 
    1c62:	ldrsh.w	r3, [r3, #1288]	; 0x508
    1c66:	cmp	r3, #0
    1c68:	bne.w	1f08 <loop+0x3a8>
        for(int ii=0;ii<nbuf;ii++) *ptr++ = *tmp++;
    1c6c:	cmp	r7, #0
    1c6e:	ble.w	1f1e <loop+0x3be>
    1c72:	ldr.w	lr, [pc, #496]	; 1e64 <loop+0x304>
    1c76:	mov	r3, r6
    1c78:	lsls	r6, r7, #1
    1c7a:	adds	r0, r3, r6
    1c7c:	mov	r2, lr
    1c7e:	ldrsh.w	r1, [r2], #2
    1c82:	strh.w	r1, [r3], #2
    1c86:	cmp	r0, r3
    1c88:	bne.n	1c7e <loop+0x11e>
    1c8a:	add	r6, lr
    1c8c:	mov	r8, r0
      }
      
      if(nout==0) //buffer has been filled, so write to disk
      { int32_t nbuf=ptr-diskBuffer;
      
        to=micros();
    1c8e:	bl	9944 <micros>
        state=uSD.write(diskBuffer,nbuf); // this is blocking
    1c92:	ldr.w	r9, [pc, #412]	; 1e30 <loop+0x2d0>
    1c96:	rsb	r2, r9, r8
    1c9a:	asrs	r2, r2, #1
      }
      
      if(nout==0) //buffer has been filled, so write to disk
      { int32_t nbuf=ptr-diskBuffer;
      
        to=micros();
    1c9c:	mov	sl, r0
        state=uSD.write(diskBuffer,nbuf); // this is blocking
    1c9e:	mov	r1, r9
    1ca0:	ldr	r0, [pc, #384]	; (1e24 <loop+0x2c4>)
    1ca2:	bl	1a54 <c_uSD::write(short*, long)>
    1ca6:	strh	r0, [r4, #0]
        t1=micros();
    1ca8:	bl	9944 <micros>
        t2=t1-to;
        if(t2<t3) t3=t2; // accumulate some time statistics
    1cac:	ldr	r2, [pc, #376]	; (1e28 <loop+0x2c8>)
    1cae:	ldr	r3, [r2, #0]
      { int32_t nbuf=ptr-diskBuffer;
      
        to=micros();
        state=uSD.write(diskBuffer,nbuf); // this is blocking
        t1=micros();
        t2=t1-to;
    1cb0:	rsb	r0, sl, r0
        if(t2<t3) t3=t2; // accumulate some time statistics
    1cb4:	cmp	r0, r3
        if(t2>t4) t4=t2;
    1cb6:	ldr	r3, [pc, #372]	; (1e2c <loop+0x2cc>)
      
        to=micros();
        state=uSD.write(diskBuffer,nbuf); // this is blocking
        t1=micros();
        t2=t1-to;
        if(t2<t3) t3=t2; // accumulate some time statistics
    1cb8:	it	cc
    1cba:	strcc	r0, [r2, #0]
        if(t2>t4) t4=t2;
    1cbc:	ldr	r2, [r3, #0]
      else
      { // fill up disk buffer
        int nbuf=nout;
        if(uSD.isClosing()) nbuf=(nbuf/NCH)*NCH; // is last record of file 
        for(int ii=0;ii<nbuf;ii++) *ptr++ = *tmp++;
        ndat-=nbuf;
    1cbe:	rsb	r7, r7, #256	; 0x100
        to=micros();
        state=uSD.write(diskBuffer,nbuf); // this is blocking
        t1=micros();
        t2=t1-to;
        if(t2<t3) t3=t2; // accumulate some time statistics
        if(t2>t4) t4=t2;
    1cc2:	cmp	r0, r2
    1cc4:	it	hi
    1cc6:	strhi	r0, [r3, #0]
    1cc8:	ldr	r2, [pc, #356]	; (1e30 <loop+0x2d0>)

        ptr=(int16_t *)diskBuffer;
      }

      if(ndat>0) // save residual data
    1cca:	cbz	r7, 1cdc <loop+0x17c>
    1ccc:	movs	r3, #0
      {
        for(int ii=0;ii<ndat;ii++) *ptr++ = *tmp++;
    1cce:	adds	r3, #1
    1cd0:	ldrh.w	r1, [r6], #2
    1cd4:	strh.w	r1, [r2], #2
    1cd8:	cmp	r7, r3
    1cda:	bgt.n	1cce <loop+0x16e>
      }
      
      // all data are copied
      outptr=(int16_t *)ptr; // save actual write position

      if(!state)
    1cdc:	ldrsh.w	r3, [r4]
      {
        for(int ii=0;ii<ndat;ii++) *ptr++ = *tmp++;
      }
      
      // all data are copied
      outptr=(int16_t *)ptr; // save actual write position
    1ce0:	str	r2, [r5, #0]

      if(!state)
    1ce2:	cbnz	r3, 1d00 <loop+0x1a0>
      { // store config again if you wanted time of latest file stored
        uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1ce4:	movs	r2, #8
    1ce6:	str	r2, [sp, #0]
    1ce8:	ldr	r3, [pc, #328]	; (1e34 <loop+0x2d4>)
    1cea:	ldr	r1, [pc, #288]	; (1e0c <loop+0x2ac>)
    1cec:	ldr	r0, [pc, #308]	; (1e24 <loop+0x2c4>)
    1cee:	bl	b20 <c_uSD::storeConfig(unsigned long*, int, long*, int)>
    1cf2:	movs	r1, #6
    1cf4:	ldr	r0, [pc, #320]	; (1e38 <loop+0x2d8>)
    1cf6:	bl	9494 <usb_serial_write>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    1cfa:	ldr	r0, [pc, #320]	; (1e3c <loop+0x2dc>)
    1cfc:	bl	a960 <Print::println()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d00:	ldr.w	lr, [pc, #356]	; 1e68 <loop+0x308>
#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
    1d04:	ldr	r0, [pc, #312]	; (1e40 <loop+0x2e0>)
    1d06:	ldr.w	r3, [lr]

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d0a:	ldr	r5, [pc, #312]	; (1e44 <loop+0x2e4>)
    1d0c:	str	r3, [sp, #20]
  if(millis()>t0+1000)
    1d0e:	ldr	r3, [r0, #0]

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d10:	ldr	r2, [r5, #0]
	return ret;
    1d12:	ldr	r1, [sp, #20]
  if(millis()>t0+1000)
    1d14:	add.w	r3, r3, #1000	; 0x3e8

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d18:	adds	r2, #1
  if(millis()>t0+1000)
    1d1a:	cmp	r3, r1

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d1c:	str	r2, [r5, #0]
  if(millis()>t0+1000)
    1d1e:	bcs.n	1da0 <loop+0x240>
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
    1d20:	ldr	r7, [pc, #260]	; (1e28 <loop+0x2c8>)
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
    1d22:	ldr.w	r8, [pc, #328]	; 1e6c <loop+0x30c>
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
    1d26:	ldr	r1, [r7, #0]
    1d28:	ldr.w	r9, [pc, #248]	; 1e24 <loop+0x2c4>
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
    1d2c:	ldr	r4, [pc, #280]	; (1e48 <loop+0x2e8>)
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d2e:	ldr.w	lr, [lr]
    1d32:	ldrh.w	r3, [r9, #1286]	; 0x506
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
    1d36:	ldr	r6, [pc, #244]	; (1e2c <loop+0x2cc>)
    1d38:	str.w	lr, [sp, #24]
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
    1d3c:	cmp	r1, r8
    1d3e:	it	hi
    1d40:	movhi.w	r1, #4294967295
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
    1d44:	str	r1, [sp, #0]
    1d46:	ldrh	r1, [r4, #0]
    1d48:	str	r1, [sp, #8]
	return ret;
    1d4a:	ldr.w	lr, [sp, #24]
    1d4e:	ldr	r1, [r6, #0]
    1d50:	str	r1, [sp, #4]
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();
    1d52:	str.w	lr, [r0]

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
    1d56:	ldr	r1, [pc, #244]	; (1e4c <loop+0x2ec>)
    1d58:	ldr	r0, [pc, #224]	; (1e3c <loop+0x2dc>)
    1d5a:	bl	a990 <Print::printf(char const*, ...)>
      //
    #if DO_DEBUG>1  
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
    1d5e:	ldr	r1, [r7, #0]
            AudioMemoryUsageMax());
    1d60:	ldrh	r0, [r4, #0]
    1d62:	ldr	r2, [r5, #0]
    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
      //
    #if DO_DEBUG>1  
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
    1d64:	ldrh.w	r3, [r9, #1286]	; 0x506
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    1d68:	str	r0, [sp, #8]
    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
      //
    #if DO_DEBUG>1  
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
    1d6a:	cmp	r1, r8
    1d6c:	it	hi
    1d6e:	movhi.w	r1, #4294967295
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    1d72:	str	r1, [sp, #0]
    1d74:	ldr	r1, [r6, #0]
    1d76:	str	r1, [sp, #4]
    1d78:	ldr	r0, [pc, #212]	; (1e50 <loop+0x2f0>)
    1d7a:	ldr	r1, [pc, #216]	; (1e54 <loop+0x2f4>)
    1d7c:	bl	a990 <Print::printf(char const*, ...)>
    #endif

    AudioMemoryUsageMaxReset();
    1d80:	ldr	r3, [pc, #212]	; (1e58 <loop+0x2f8>)
  #endif

  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    1d82:	ldr	r0, [pc, #184]	; (1e3c <loop+0x2dc>)
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    #endif

    AudioMemoryUsageMaxReset();
    1d84:	ldrh	r3, [r3, #0]
    1d86:	strh	r3, [r4, #0]
    t3=1<<31;
    t4=0;
    1d88:	movs	r4, #0
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    #endif

    AudioMemoryUsageMaxReset();
    t3=1<<31;
    1d8a:	mov.w	r3, #2147483648	; 0x80000000
    1d8e:	str	r3, [r7, #0]
    t4=0;
    1d90:	str	r4, [r6, #0]
  #endif

  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    1d92:	bl	a960 <Print::println()>
    loopCount=0;
    maxValue=0;
    1d96:	ldr	r2, [pc, #196]	; (1e5c <loop+0x2fc>)
    maxNoise=0;
    1d98:	ldr	r3, [pc, #196]	; (1e60 <loop+0x300>)
  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    loopCount=0;
    maxValue=0;
    1d9a:	str	r4, [r2, #0]

  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    loopCount=0;
    1d9c:	str	r4, [r5, #0]
    maxValue=0;
    maxNoise=0;
    1d9e:	str	r4, [r3, #0]
  }

#endif

  asm("wfi"); // to save some power switch off idle cpu
    1da0:	wfi
}
    1da2:	add	sp, #32
    1da4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        #if DO_DEBUG>0
          Serial.println("closed");
        #endif
      }
    }
    else if(state>0)
    1da8:	ldrsh.w	r3, [r4]
    1dac:	ldr	r6, [pc, #88]	; (1e08 <loop+0x2a8>)
    1dae:	cmp	r3, #0
    1db0:	ble.n	1d00 <loop+0x1a0>
    { // close file
      // write remaining data to disk and close file
      uint32_t nbuf = (uint32_t)(outptr-diskBuffer);
    1db2:	ldr	r5, [pc, #104]	; (1e1c <loop+0x2bc>)
    1db4:	ldr.w	r9, [pc, #120]	; 1e30 <loop+0x2d0>
    1db8:	ldr	r3, [r5, #0]
    1dba:	rsb	r3, r9, r3
      if(nbuf>0)
    1dbe:	asrs	r2, r3, #1
    1dc0:	bne.w	1f12 <loop+0x3b2>
      { state=uSD.write(diskBuffer,nbuf); // this is blocking
      }
      state=uSD.close();
    1dc4:	ldr	r0, [pc, #92]	; (1e24 <loop+0x2c4>)
    1dc6:	bl	a18 <c_uSD::close()>
      uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1dca:	movs	r2, #8
      // write remaining data to disk and close file
      uint32_t nbuf = (uint32_t)(outptr-diskBuffer);
      if(nbuf>0)
      { state=uSD.write(diskBuffer,nbuf); // this is blocking
      }
      state=uSD.close();
    1dcc:	strh	r0, [r4, #0]
      uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1dce:	ldr	r3, [pc, #100]	; (1e34 <loop+0x2d4>)
    1dd0:	str	r2, [sp, #0]
    1dd2:	ldr	r1, [pc, #56]	; (1e0c <loop+0x2ac>)
    1dd4:	ldr	r0, [pc, #76]	; (1e24 <loop+0x2c4>)
    1dd6:	bl	b20 <c_uSD::storeConfig(unsigned long*, int, long*, int)>
      outptr = diskBuffer;
    1dda:	str.w	r9, [r5]
    1dde:	b.n	1d00 <loop+0x1a0>
      
      // number of free samples on diskbuffer
      int32_t nout = diskBuffer+BUFFERSIZE - outptr;

      tmp = tempBuffer;
      if (nout>ndat)
    1de0:	ldr	r3, [pc, #128]	; (1e64 <loop+0x304>)
    1de2:	subs	r2, r6, #2
    1de4:	add.w	r0, r3, #512	; 0x200
      { // sufficient space for all data
        for(int ii=0;ii<ndat;ii++) *ptr++ = *tmp++;
    1de8:	ldrsh.w	r1, [r3], #2
    1dec:	strh.w	r1, [r2, #2]!
    1df0:	cmp	r3, r0
    1df2:	bne.n	1de8 <loop+0x288>
    1df4:	add.w	r2, r6, #512	; 0x200
    1df8:	b.n	1cdc <loop+0x17c>
  public:
    c_uSD(): state(-1), closing(0) {;}
    void init();
    int16_t write(int16_t * data, int32_t ndat);
    uint16_t getNbuf(void) {return nbuf;}
    void setClosing(void) {closing=1;}
    1dfa:	ldr	r3, [pc, #40]	; (1e24 <loop+0x2c4>)
    1dfc:	movs	r2, #1
    1dfe:	strh.w	r2, [r3, #1288]	; 0x508
    1e02:	b.n	1bca <loop+0x6a>
    1e04:	.word	0x20014880
    1e08:	.word	0x200195d0
    1e0c:	.word	0x20013764
    1e10:	.word	0x20019560
    1e14:	.word	0x20019354
    1e18:	.word	0x20013760
    1e1c:	.word	0x20013734
    1e20:	.word	0x200192a8
    1e24:	.word	0x20014364
    1e28:	.word	0x20014878
    1e2c:	.word	0x2001487c
    1e30:	.word	0x200152a8
    1e34:	.word	0x20013740
    1e38:	.word	0x00013564
    1e3c:	.word	0x200138e4
    1e40:	.word	0x200195d4
    1e44:	.word	0x200195cc
    1e48:	.word	0x20019ccc
    1e4c:	.word	0x0001356c
    1e50:	.word	0x20019550
    1e54:	.word	0x0001358c
    1e58:	.word	0x20019d4c
    1e5c:	.word	0x200195c8
    1e60:	.word	0x200192f4
    1e64:	.word	0x20019350
    1e68:	.word	0x20019bc4
    1e6c:	.word	0x000186a0
    if(mustStore)
    {
      if(state==0)
      { // generate header before file is opened
        #ifdef GEN_WAV_FILE // is declared in audio_logger_if.h
          uint32_t *header=(uint32_t *) wavHeader(0); // call initially with zero filesize
    1e70:	bl	810 <wavHeader(unsigned long)>
          //
          int ndat=outptr-diskBuffer;
    1e74:	ldr	r7, [r5, #0]
    1e76:	ldr	r2, [pc, #172]	; (1f24 <loop+0x3c4>)
    1e78:	subs	r6, r7, r2
    1e7a:	asrs	r6, r6, #1
          if(ndat>0)
    1e7c:	cmp	r6, #0
    1e7e:	ble.n	1e9a <loop+0x33a>
    1e80:	add.w	r6, r6, #2147483648	; 0x80000000
    1e84:	subs	r6, #1
    1e86:	add.w	r6, r2, r6, lsl #1
    1e8a:	subs	r3, r2, #2
    1e8c:	adds	r2, #42	; 0x2a
          { // shift exisiting data after header, which is always at beginnig of file
            for(int ii=0; ii<ndat; ii++) diskBuffer[22+ii]=diskBuffer[ii]; 
    1e8e:	ldrsh.w	r1, [r3, #2]!
    1e92:	strh.w	r1, [r2, #2]!
    1e96:	cmp	r3, r6
    1e98:	bne.n	1e8e <loop+0x32e>
    1e9a:	ldr	r2, [pc, #136]	; (1f24 <loop+0x3c4>)
    1e9c:	subs	r3, r0, #4
    1e9e:	adds	r0, #40	; 0x28
          }
          // copy header to disk buffer
          uint32_t *ptr=(uint32_t *) diskBuffer;
          for(int ii=0;ii<11;ii++) ptr[ii] = header[ii];
    1ea0:	ldr.w	r1, [r3, #4]!
    1ea4:	str.w	r1, [r2], #4
    1ea8:	cmp	r0, r3
    1eaa:	bne.n	1ea0 <loop+0x340>
          outptr+=22; //(44 bytes)
    1eac:	add.w	r6, r7, #44	; 0x2c
          uint32_t *ptr=(uint32_t *) diskBuffer;
          // copy to disk buffer
          for(int ii=0;ii<128;ii++) ptr[ii] = header[ii];
          outptr+=256; //(512 bytes)
        #endif
        state=1;
    1eb0:	movs	r3, #1
            for(int ii=0; ii<ndat; ii++) diskBuffer[22+ii]=diskBuffer[ii]; 
          }
          // copy header to disk buffer
          uint32_t *ptr=(uint32_t *) diskBuffer;
          for(int ii=0;ii<11;ii++) ptr[ii] = header[ii];
          outptr+=22; //(44 bytes)
    1eb2:	str	r6, [r5, #0]
          uint32_t *ptr=(uint32_t *) diskBuffer;
          // copy to disk buffer
          for(int ii=0;ii<128;ii++) ptr[ii] = header[ii];
          outptr+=256; //(512 bytes)
        #endif
        state=1;
    1eb4:	strh	r3, [r4, #0]
    1eb6:	b.n	1c50 <loop+0xf0>
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
    1eb8:	mla	lr, r5, r2, r6
	if (t == head) return NULL;
	if (++t >= mq) t = 0;
    1ebc:	mov	ip, r3
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
    1ebe:	ldrh.w	r7, [lr, #1038]	; 0x40e
	if (t == head) return NULL;
    1ec2:	ldrh.w	r8, [lr, #1036]	; 0x40c
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
    1ec6:	uxth	r7, r7
	if (t == head) return NULL;
    1ec8:	uxth.w	r8, r8
	if (++t >= mq) t = 0;
    1ecc:	add.w	lr, r7, #1
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
	if (t == head) return NULL;
    1ed0:	cmp	r7, r8
	if (++t >= mq) t = 0;
    1ed2:	uxth.w	lr, lr
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
	if (t == head) return NULL;
    1ed6:	beq.w	1be0 <loop+0x80>
	if (++t >= mq) t = 0;
    1eda:	cmp.w	lr, #249	; 0xf9
	userblock = queue[t];
    1ede:	add.w	r3, r2, r2, lsl #6
    1ee2:	it	ls
    1ee4:	movls	ip, lr
    1ee6:	add.w	r3, r2, r3, lsl #2
    1eea:	add	r3, ip
    1eec:	add.w	r3, r3, #8
	tail = t;
    1ef0:	mla	r7, r5, r2, r6

	if (userblock) return NULL;
	t = tail;
	if (t == head) return NULL;
	if (++t >= mq) t = 0;
	userblock = queue[t];
    1ef4:	ldr.w	r3, [r6, r3, lsl #2]
    1ef8:	str.w	r3, [r1, #1032]	; 0x408
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
	if (t == head) return NULL;
	if (++t >= mq) t = 0;
    1efc:	it	hi
    1efe:	movhi	lr, ip
	userblock = queue[t];
	tail = t;
	return (void *) userblock->data;
    1f00:	adds	r3, #4
	if (userblock) return NULL;
	t = tail;
	if (t == head) return NULL;
	if (++t >= mq) t = 0;
	userblock = queue[t];
	tail = t;
    1f02:	strh.w	lr, [r7, #1038]	; 0x40e
    1f06:	b.n	1be0 <loop+0x80>
        ndat=0;
      }
      else
      { // fill up disk buffer
        int nbuf=nout;
        if(uSD.isClosing()) nbuf=(nbuf/NCH)*NCH; // is last record of file 
    1f08:	add.w	r7, r7, r7, lsr #31
    1f0c:	bic.w	r7, r7, #1
    1f10:	b.n	1c6c <loop+0x10c>
    else if(state>0)
    { // close file
      // write remaining data to disk and close file
      uint32_t nbuf = (uint32_t)(outptr-diskBuffer);
      if(nbuf>0)
      { state=uSD.write(diskBuffer,nbuf); // this is blocking
    1f12:	mov	r1, r9
    1f14:	ldr	r0, [pc, #16]	; (1f28 <loop+0x3c8>)
    1f16:	bl	1a54 <c_uSD::write(short*, long)>
    1f1a:	strh	r0, [r6, #0]
    1f1c:	b.n	1dc4 <loop+0x264>
      int32_t ndat = AUDIO_BLOCK_SAMPLES*NCH;
      
      // number of free samples on diskbuffer
      int32_t nout = diskBuffer+BUFFERSIZE - outptr;

      tmp = tempBuffer;
    1f1e:	ldr	r6, [pc, #12]	; (1f2c <loop+0x3cc>)
    1f20:	b.n	1c8e <loop+0x12e>
    1f22:	nop
    1f24:	.word	0x200152a8
    1f28:	.word	0x20014364
    1f2c:	.word	0x20019350

00001f30 <_GLOBAL__sub_I_acqParameters>:
  }

#endif

  asm("wfi"); // to save some power switch off idle cpu
}
    1f30:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    1f34:	ldr	r7, [pc, #436]	; (20ec <_GLOBAL__sub_I_acqParameters+0x1bc>)
#define AUDIO_HEADPHONE_LINEIN 1

class AudioControlSGTL5000 : public AudioControl
{
public:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
    1f36:	ldr	r1, [pc, #440]	; (20f0 <_GLOBAL__sub_I_acqParameters+0x1c0>)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    1f38:	ldr	r5, [pc, #440]	; (20f4 <_GLOBAL__sub_I_acqParameters+0x1c4>)
    1f3a:	ldr	r3, [pc, #444]	; (20f8 <_GLOBAL__sub_I_acqParameters+0x1c8>)
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    1f3c:	ldr	r2, [r7, #0]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    1f3e:	ldr.w	r8, [pc, #480]	; 2120 <_GLOBAL__sub_I_acqParameters+0x1f0>
    1f42:	str	r3, [r1, #0]
    1f44:	movs	r0, #10
    1f46:	movs	r3, #0
    1f48:	strb	r0, [r1, #8]
    1f4a:	str.w	r8, [r5]
    1f4e:	strb	r3, [r5, #9]
    1f50:	str	r3, [r5, #16]
			active = false;
    1f52:	strb	r3, [r5, #8]
			destination_list = NULL;
    1f54:	str	r3, [r5, #12]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    1f56:	cbnz	r2, 1f5c <_GLOBAL__sub_I_acqParameters+0x2c>
    1f58:	b.n	20e6 <_GLOBAL__sub_I_acqParameters+0x1b6>
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    1f5a:	mov	r2, r3
    1f5c:	ldr	r3, [r2, #20]
    1f5e:	cmp	r3, #0
    1f60:	bne.n	1f5a <_GLOBAL__sub_I_acqParameters+0x2a>
				p->next_update = this;
    1f62:	str	r5, [r2, #20]
			}
			next_update = NULL;
    1f64:	movs	r4, #0
#include <DMAChannel.h>

class AudioInputI2S : public AudioStream
{
public:
	AudioInputI2S(void) : AudioStream(0, NULL) { begin(); }
    1f66:	ldr	r3, [pc, #404]	; (20fc <_GLOBAL__sub_I_acqParameters+0x1cc>)
    1f68:	ldr	r0, [pc, #392]	; (20f4 <_GLOBAL__sub_I_acqParameters+0x1c4>)
    1f6a:	str	r4, [r5, #20]
			cpu_cycles = 0;
    1f6c:	strh	r4, [r5, #4]
			cpu_cycles_max = 0;
    1f6e:	strh	r4, [r5, #6]
			numConnections = 0;
    1f70:	strb	r4, [r5, #10]
    1f72:	str	r3, [r5, #0]
    1f74:	bl	291c <AudioInputI2S::begin()>
    1f78:	ldr	r2, [pc, #388]	; (2100 <_GLOBAL__sub_I_acqParameters+0x1d0>)
    1f7a:	ldr.w	r9, [pc, #424]	; 2124 <_GLOBAL__sub_I_acqParameters+0x1f4>
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    1f7e:	ldr.w	sl, [pc, #364]	; 20ec <_GLOBAL__sub_I_acqParameters+0x1bc>
class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
    1f82:	mov	r1, r4
    1f84:	addw	ip, r2, #2088	; 0x828

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    1f88:	mov.w	lr, #1
    1f8c:	str.w	r8, [r2, #-28]
    1f90:	strb.w	lr, [r2, #-19]
    1f94:	str.w	r2, [r2, #-12]
			active = false;
    1f98:	strb.w	r1, [r2, #-20]
			destination_list = NULL;
    1f9c:	str.w	r1, [r2, #-16]
    1fa0:	sub.w	r6, r2, #28
    1fa4:	mov	r0, r2
    1fa6:	movs	r3, #0
    1fa8:	b.n	1fae <_GLOBAL__sub_I_acqParameters+0x7e>
    1faa:	ldr.w	r0, [r2, #-12]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    1fae:	str.w	r1, [r0, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    1fb2:	ldrb.w	r0, [r2, #-19]
    1fb6:	adds	r3, #1
    1fb8:	cmp	r0, r3
    1fba:	bgt.n	1faa <_GLOBAL__sub_I_acqParameters+0x7a>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    1fbc:	ldr	r0, [r7, #0]
    1fbe:	cbnz	r0, 1fc4 <_GLOBAL__sub_I_acqParameters+0x94>
    1fc0:	b.n	20e0 <_GLOBAL__sub_I_acqParameters+0x1b0>
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    1fc2:	mov	r0, r3
    1fc4:	ldr	r3, [r0, #20]
    1fc6:	cmp	r3, #0
    1fc8:	bne.n	1fc2 <_GLOBAL__sub_I_acqParameters+0x92>
				p->next_update = this;
    1fca:	str	r6, [r0, #20]
template <int mq>
class mRecordQueue : public AudioStream
{
public:
	mRecordQueue(void) : AudioStream(1, inputQueueArray),
		userblock(NULL), head(0), tail(0), enabled(0) { }
    1fcc:	str.w	r1, [r2, #1004]	; 0x3ec
			}
			next_update = NULL;
    1fd0:	str.w	r1, [r2, #-8]
			cpu_cycles = 0;
    1fd4:	strh.w	r1, [r2, #-24]
			cpu_cycles_max = 0;
    1fd8:	strh.w	r1, [r2, #-22]
			numConnections = 0;
    1fdc:	strb.w	r1, [r2, #-18]
    1fe0:	str.w	r9, [r2, #-28]
    1fe4:	addw	r2, r2, #1044	; 0x414
  AudioInputI2S         acq;

  #define NCH 2
  #define MQ (MAX_Q/NCH)
  #include "m_queue.h"
  mRecordQueue<MQ> queue[NCH];
    1fe8:	cmp	r2, ip
    1fea:	strh.w	r1, [r6, #1036]	; 0x40c
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
    1fee:	mov.w	r4, #0
    1ff2:	strh.w	r1, [r6, #1038]	; 0x40e
    1ff6:	strh.w	r1, [r6, #1040]	; 0x410
    1ffa:	bne.n	1f8c <_GLOBAL__sub_I_acqParameters+0x5c>
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    1ffc:	ldr.w	r8, [pc, #296]	; 2128 <_GLOBAL__sub_I_acqParameters+0x1f8>
    2000:	ldr	r7, [pc, #256]	; (2104 <_GLOBAL__sub_I_acqParameters+0x1d4>)
    2002:	ldr.w	r9, [pc, #296]	; 212c <_GLOBAL__sub_I_acqParameters+0x1fc>
    2006:	str.w	r5, [r8]
		{ isConnected = false;
		  connect(); }
    200a:	mov	r0, r8
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    200c:	strb.w	r4, [r8, #8]
    2010:	strb.w	r4, [r8, #9]
    2014:	str.w	r4, [r8, #12]
		{ isConnected = false;
    2018:	strb.w	r4, [r8, #16]
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    201c:	str.w	r9, [r8, #4]
		{ isConnected = false;
		  connect(); }
    2020:	bl	abf0 <AudioConnection::connect()>
    #include "m_delay.h" 
    mDelay<NCH,(MDEL+2)>  delay1(2); // have two buffers more in queue only to be safe 
  #endif 

  #if MDEL<0
    AudioConnection     patchCord3(acq,0, queue[0],0);
    2024:	ldr	r2, [pc, #224]	; (2108 <_GLOBAL__sub_I_acqParameters+0x1d8>)
    2026:	ldr	r1, [pc, #228]	; (210c <_GLOBAL__sub_I_acqParameters+0x1dc>)
    2028:	mov	r0, r8
    202a:	bl	af34 <__aeabi_atexit>
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    202e:	mov.w	sl, #1
    2032:	addw	r3, r9, #1044	; 0x414
		{ isConnected = false;
		  connect(); }
    2036:	mov	r0, r7
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    2038:	str	r3, [r7, #4]
    203a:	str	r5, [r7, #0]
    203c:	strb	r4, [r7, #9]
    203e:	str	r4, [r7, #12]
		{ isConnected = false;
    2040:	strb	r4, [r7, #16]
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    2042:	strb.w	sl, [r7, #8]
		{ isConnected = false;
		  connect(); }
    2046:	bl	abf0 <AudioConnection::connect()>
    AudioConnection     patchCord4(acq,1, queue[1],0);
    204a:	mov	r0, r7
    204c:	ldr	r2, [pc, #184]	; (2108 <_GLOBAL__sub_I_acqParameters+0x1d8>)
    204e:	ldr	r1, [pc, #188]	; (210c <_GLOBAL__sub_I_acqParameters+0x1dc>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    2050:	ldr.w	r8, [pc, #220]	; 2130 <_GLOBAL__sub_I_acqParameters+0x200>
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2054:	ldr.w	r9, [pc, #220]	; 2134 <_GLOBAL__sub_I_acqParameters+0x204>
    2058:	bl	af34 <__aeabi_atexit>
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    205c:	ldr	r3, [pc, #176]	; (2110 <_GLOBAL__sub_I_acqParameters+0x1e0>)
// rename in SdFat-beta/src the file SdFat.h to SdFat-beta.h
// to avoid confict with stock SD library needed for Audio library
//
#include "SdFat.h" 

FsFile logFile;
    205e:	ldr	r2, [pc, #168]	; (2108 <_GLOBAL__sub_I_acqParameters+0x1d8>)
    2060:	strb	r4, [r3, #4]
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    2062:	mov.w	r5, #1000	; 0x3e8
    2066:	strb	r4, [r3, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    2068:	str	r4, [r3, #72]	; 0x48
    206a:	str	r4, [r3, #76]	; 0x4c
    206c:	str	r5, [r3, #8]
    206e:	ldr	r1, [pc, #164]	; (2114 <_GLOBAL__sub_I_acqParameters+0x1e4>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    2070:	str.w	r8, [r3]
    2074:	mov	r0, r3
    2076:	bl	af34 <__aeabi_atexit>
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    207a:	ldr	r3, [pc, #156]	; (2118 <_GLOBAL__sub_I_acqParameters+0x1e8>)
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    207c:	ldr.w	lr, [pc, #184]	; 2138 <_GLOBAL__sub_I_acqParameters+0x208>
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    2080:	ldr.w	ip, [pc, #184]	; 213c <_GLOBAL__sub_I_acqParameters+0x20c>
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2084:	strb.w	r4, [r3, #1176]	; 0x498
    2088:	movs	r7, #41	; 0x29
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    208a:	strb.w	r4, [r3, #1177]	; 0x499
    208e:	strb.w	r4, [r3, #1202]	; 0x4b2
    2092:	strb.w	r4, [r3, #1208]	; 0x4b8
    2096:	str.w	r5, [r3, #1212]	; 0x4bc
    209a:	strb.w	r4, [r3, #1216]	; 0x4c0
  private:
    SdFs sd;
    FsFile file;
    
  public:
    c_uSD(): state(-1), closing(0) {;}
    209e:	movw	r5, #65535	; 0xffff
    20a2:	strb.w	r7, [r3, #1199]	; 0x4af
    20a6:	strb.w	sl, [r3, #1197]	; 0x4ad
    20aa:	str.w	r4, [r3, #1152]	; 0x480
    20ae:	str.w	r4, [r3, #1156]	; 0x484
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    20b2:	str.w	r4, [r3, #1276]	; 0x4fc
    20b6:	str.w	r4, [r3, #1280]	; 0x500
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    20ba:	str.w	r8, [r3, #1204]	; 0x4b4
    20be:	strh.w	r4, [r3, #1288]	; 0x508
    20c2:	str.w	r9, [r3, #1168]	; 0x490
    20c6:	str.w	lr, [r3, #1188]	; 0x4a4
    20ca:	strh.w	r5, [r3, #1284]	; 0x504
  public:
  void loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2);
  void storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2);
  void writeTemperature(float temperature, float pressure, float humidity, uint16_t lux);
};
c_uSD uSD;
    20ce:	mov	r0, r3
    20d0:	ldr	r2, [pc, #52]	; (2108 <_GLOBAL__sub_I_acqParameters+0x1d8>)
    20d2:	ldr	r1, [pc, #72]	; (211c <_GLOBAL__sub_I_acqParameters+0x1ec>)
    20d4:	str.w	ip, [r3, #1180]	; 0x49c
  }

#endif

  asm("wfi"); // to save some power switch off idle cpu
}
    20d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    20dc:	b.w	af34 <__aeabi_atexit>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
				first_update = this;
    20e0:	str.w	r6, [sl]
    20e4:	b.n	1fcc <_GLOBAL__sub_I_acqParameters+0x9c>
    20e6:	str	r5, [r7, #0]
    20e8:	b.n	1f64 <_GLOBAL__sub_I_acqParameters+0x34>
    20ea:	nop
    20ec:	.word	0x20019cc8
    20f0:	.word	0x200195a0
    20f4:	.word	0x200195b0
    20f8:	.word	0x000135cc
    20fc:	.word	0x000135c0
    2100:	.word	0x2001489c
    2104:	.word	0x2001933c
    2108:	.word	0x20013730
    210c:	.word	0x00000569
    2110:	.word	0x20019550
    2114:	.word	0x00000531
    2118:	.word	0x20014364
    211c:	.word	0x00000549
    2120:	.word	0x000130ac
    2124:	.word	0x000130b8
    2128:	.word	0x20019328
    212c:	.word	0x20014880
    2130:	.word	0x000130e8
    2134:	.word	0x00013814
    2138:	.word	0x38011001
    213c:	.word	0x000137bc

00002140 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>:
			}
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    2140:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2144:	ldr	r4, [r0, #0]
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2146:	ldr	r5, [r4, #12]
    2148:	tst.w	r5, #16777216	; 0x1000000
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    214c:	ldr	r5, [pc, #484]	; (2334 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1f4>)
    214e:	str	r5, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2150:	bne.n	21f8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xb8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2152:	lsls	r7, r3, #31
    2154:	bpl.w	22be <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17e>
		    if (p_write) {
    2158:	cmp	r1, #0
    215a:	beq.w	2324 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1e4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    215e:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    2160:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2162:	it	ne
    2164:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2168:	str	r5, [r4, #52]	; 0x34
    216a:	adds	r1, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    216c:	ldrb.w	r8, [r0, #44]	; 0x2c
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    2170:	add.w	ip, r3, #4294967295
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    2174:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    2178:	cmp.w	ip, #0
    217c:	beq.w	22d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
			// Push out the next byte; 
		    if (p_write) {
    2180:	cbz	r1, 218c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x4c>
		    	w = (*p_write++) << 8;
				w |= *p_write++;
    2182:	ldrb	r5, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    2184:	ldrb.w	r8, [r1], #2
				w |= *p_write++;
    2188:	orr.w	r8, r5, r8, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    218c:	ldr	r5, [r0, #4]
    218e:	ldrb	r6, [r5, #8]
			if (count == 2)
    2190:	cmp.w	ip, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2194:	add.w	r6, r6, #4294967295
    2198:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    219c:	ite	eq
    219e:	orreq.w	r5, r8, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    21a2:	orrne.w	r5, r8, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    21a6:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    21a8:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    21aa:	sub.w	ip, ip, #2
    21ae:	b.n	21c2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x82>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    21b0:	cbz	r2, 21b6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x76>
							*p_read++ = w;  // Read any pending RX bytes in
    21b2:	strb	r4, [r2, #0]
    21b4:	adds	r2, #1
						} 
						count_read--;
    21b6:	subs	r3, #1
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    21b8:	and.w	r5, r5, #61440	; 0xf000
    21bc:	cmp	r5, r6
    21be:	bls.n	21ee <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xae>
    21c0:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    21c2:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    21c4:	tst.w	r5, #240	; 0xf0
    21c8:	beq.n	21b8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x78>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    21ca:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    21cc:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
    21d0:	mov	r7, r2
    21d2:	mov.w	lr, r4, asr #8
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    21d6:	bne.n	21b0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x70>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    21d8:	cbz	r2, 21e2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xa2>
							*p_read++ = w >> 8;
    21da:	strb.w	lr, [r7], #2
							*p_read++ = (w & 0xff);
    21de:	strb	r4, [r2, #1]
    21e0:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    21e2:	and.w	r5, r5, #61440	; 0xf000
    21e6:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
    21e8:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    21ec:	bhi.n	21c0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x80>
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
    21ee:	cmp.w	ip, #0
    21f2:	beq.n	22d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    21f4:	ldr	r4, [r0, #0]
    21f6:	b.n	2180 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    21f8:	lsls	r5, r3, #31
    21fa:	bpl.n	2296 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x156>
		    if (p_write) {
    21fc:	cmp	r1, #0
    21fe:	beq.w	2314 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2202:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    2204:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2206:	it	ne
    2208:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    220c:	str	r5, [r4, #52]	; 0x34
    220e:	adds	r1, #1
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    2210:	add.w	lr, r3, #4294967295
		}

	    uint16_t w = _transferWriteFill;
    2214:	ldrb.w	ip, [r0, #44]	; 0x2c

		while (count > 0) {
    2218:	cmp.w	lr, #0
    221c:	beq.n	22a2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
			// Push out the next byte; 
		    if (p_write) {
    221e:	cbz	r1, 222c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xec>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    2220:	ldrb.w	ip, [r1, #1]
    2224:	ldrb	r5, [r1, #0]
    2226:	adds	r1, #2
    2228:	orr.w	ip, r5, ip, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    222c:	ldr	r5, [r0, #4]
    222e:	ldrb	r6, [r5, #8]
			if (count == 2)
    2230:	cmp.w	lr, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2234:	add.w	r6, r6, #4294967295
    2238:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    223c:	ite	eq
    223e:	orreq.w	r5, ip, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2242:	orrne.w	r5, ip, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2246:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2248:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    224a:	sub.w	lr, lr, #2
    224e:	b.n	2262 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x122>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    2250:	cbz	r2, 2256 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x116>
							*p_read++ = w;  // Read any pending RX bytes in
    2252:	strb	r4, [r2, #0]
    2254:	adds	r2, #1
						} 
						count_read--;
    2256:	subs	r3, #1
							*p_read++ = w >> 8;
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2258:	and.w	r5, r5, #61440	; 0xf000
    225c:	cmp	r5, r6
    225e:	bls.n	228c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x14c>
    2260:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2262:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    2264:	tst.w	r5, #240	; 0xf0
    2268:	beq.n	2258 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x118>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    226a:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
    226e:	mov	r7, r2
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2270:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    2272:	bne.n	2250 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x110>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    2274:	cbz	r2, 2280 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x140>
							*p_read++ = (w & 0xff);
    2276:	strb.w	r4, [r7], #2
							*p_read++ = w >> 8;
    227a:	asrs	r4, r4, #8
    227c:	strb	r4, [r2, #1]
    227e:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2280:	and.w	r5, r5, #61440	; 0xf000
    2284:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
							*p_read++ = w >> 8;
						}
						count_read -= 2;
    2286:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    228a:	bhi.n	2260 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x120>
			count--;
		}

	    uint16_t w = _transferWriteFill;

		while (count > 0) {
    228c:	cmp.w	lr, #0
    2290:	beq.n	22a2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
    2292:	ldr	r4, [r0, #0]
    2294:	b.n	221e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2296:	mov	lr, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    2298:	ldrb.w	ip, [r0, #44]	; 0x2c

		while (count > 0) {
    229c:	cmp.w	lr, #0
    22a0:	bne.n	221e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    22a2:	cbz	r3, 22ec <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    22a4:	ldr	r4, [r0, #0]
			sr = port().SR;
    22a6:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    22a8:	tst.w	r1, #240	; 0xf0
    22ac:	beq.n	22a6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x166>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    22ae:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    22b0:	lsls	r4, r3, #31
    22b2:	bpl.n	22f0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1b0>
					if (p_read)
    22b4:	cbz	r2, 22ba <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17a>
						*p_read++ = w;  // Read any pending RX bytes in
    22b6:	strb	r1, [r2, #0]
    22b8:	adds	r2, #1
					count_read--;
    22ba:	subs	r3, #1
    22bc:	b.n	22a2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    22be:	ldrb.w	r8, [r0, #44]	; 0x2c
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    22c2:	mov	ip, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    22c4:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    22c8:	cmp.w	ip, #0
    22cc:	bne.w	2180 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    22d0:	cbz	r3, 22ec <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
    22d2:	ldr	r4, [r0, #0]
			sr = port().SR;
    22d4:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    22d6:	tst.w	r1, #240	; 0xf0
    22da:	beq.n	22d4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x194>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    22dc:	lsls	r6, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    22de:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    22e0:	bpl.n	2302 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1c2>
					if (p_read)
    22e2:	cbz	r2, 22e8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1a8>
						*p_read++ = w;  // Read any pending RX bytes in
    22e4:	strb	r1, [r2, #0]
    22e6:	adds	r2, #1
					count_read--;
    22e8:	subs	r3, #1
    22ea:	b.n	22d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    22ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    22f0:	cbz	r2, 22fe <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1be>
						*p_read++ = (w & 0xff);
    22f2:	mov	r4, r2
						*p_read++ = w >> 8;
    22f4:	asrs	r5, r1, #8
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
						*p_read++ = (w & 0xff);
    22f6:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    22fa:	strb	r5, [r2, #1]
    22fc:	mov	r2, r4
					}
					count_read -= 2;
    22fe:	subs	r3, #2
    2300:	b.n	22a2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    2302:	cbz	r2, 2310 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d0>
						*p_read++ = w >> 8;
    2304:	mov	r4, r2
    2306:	asrs	r5, r1, #8
    2308:	strb.w	r5, [r4], #2
						*p_read++ = (w & 0xff);
    230c:	strb	r1, [r2, #1]
    230e:	mov	r2, r4
					}
					count_read -= 2;
    2310:	subs	r3, #2
    2312:	b.n	22d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2314:	ldrb.w	r5, [r0, #44]	; 0x2c
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    2318:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    231a:	it	ne
    231c:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2320:	str	r5, [r4, #52]	; 0x34
    2322:	b.n	2210 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xd0>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2324:	ldrb.w	r5, [r0, #44]	; 0x2c
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    2328:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    232a:	it	ne
    232c:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2330:	str	r5, [r4, #52]	; 0x34
    2332:	b.n	216c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x2c>
    2334:	.word	0x801f0400

00002338 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    2338:	cbz	r3, 233e <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    233a:	b.w	2140 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>
    233e:	bx	lr

00002340 <breakTime(long, tmElements_t&)>:
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    2340:	ldr	r2, [pc, #400]	; (24d4 <breakTime(long, tmElements_t&)+0x194>)
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    2342:	ldr	r3, [pc, #404]	; (24d8 <breakTime(long, tmElements_t&)+0x198>)
// leap year calculator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
    2344:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    2348:	ldr	r6, [pc, #400]	; (24dc <breakTime(long, tmElements_t&)+0x19c>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    234a:	ldr.w	sl, [pc, #416]	; 24ec <breakTime(long, tmElements_t&)+0x1ac>
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    234e:	ldr	r4, [pc, #400]	; (24e0 <breakTime(long, tmElements_t&)+0x1a0>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    2350:	ldr.w	r9, [pc, #400]	; 24e4 <breakTime(long, tmElements_t&)+0x1a4>
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    2354:	umull	r5, r2, r2, r0
    2358:	mov.w	ip, r2, lsr #16
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    235c:	add.w	r7, ip, #4
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    2360:	umull	r2, r5, r3, r0
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    2364:	umull	r6, r2, r6, r0
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    2368:	umull	sl, fp, r7, sl
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    236c:	lsrs	r5, r5, #5
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    236e:	lsrs	r2, r2, #11
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    2370:	umull	r6, r3, r3, r5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    2374:	umull	r6, r4, r4, r2
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    2378:	rsb	r6, fp, r7
    237c:	add.w	r6, fp, r6, lsr #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    2380:	lsrs	r3, r3, #5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    2382:	lsrs	r6, r6, #2
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    2384:	lsrs	r4, r4, #4
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    2386:	rsb	r6, r6, r6, lsl #3
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    238a:	rsb	r3, r3, r3, lsl #4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    238e:	add.w	r4, r4, r4, lsl #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    2392:	sub.w	r3, r5, r3, lsl #2
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    2396:	subs	r6, r7, r6
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    2398:	rsb	r5, r5, r5, lsl #4
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    239c:	sub.w	r2, r2, r4, lsl #3
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    23a0:	sub.w	r0, r0, r5, lsl #2
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    23a4:	adds	r6, #1
    23a6:	movs	r4, #0
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    23a8:	strb	r2, [r1, #2]
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    23aa:	strb	r0, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    23ac:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    23ae:	strb	r6, [r1, #3]
  
  year = 0;  
  days = 0;
    23b0:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    23b2:	movw	fp, #365	; 0x16d
    23b6:	mov.w	r8, #100	; 0x64
    23ba:	mov.w	sl, #400	; 0x190
    23be:	b.n	23de <breakTime(long, tmElements_t&)+0x9e>
    23c0:	rsb	r5, r6, r5, asr #7
    23c4:	mls	r5, sl, r5, r3
    23c8:	cbnz	r0, 2428 <breakTime(long, tmElements_t&)+0xe8>
    23ca:	cmp	r5, #0
    23cc:	ite	ne
    23ce:	movne	r0, fp
    23d0:	moveq.w	r0, #366	; 0x16e
    23d4:	add	r2, r0
    23d6:	cmp	ip, r2
    23d8:	add.w	r4, r4, #1
    23dc:	bcc.n	2406 <breakTime(long, tmElements_t&)+0xc6>
    23de:	uxtb	r7, r4
    23e0:	addw	r3, r7, #1970	; 0x7b2
    23e4:	smull	r0, r5, r9, r3
    23e8:	asrs	r6, r3, #31
    23ea:	rsb	r0, r6, r5, asr #5
    23ee:	ands.w	lr, r3, #3
    23f2:	mls	r0, r8, r0, r3
    23f6:	beq.n	23c0 <breakTime(long, tmElements_t&)+0x80>
    23f8:	movw	r0, #365	; 0x16d
    23fc:	add	r2, r0
    23fe:	cmp	ip, r2
    2400:	add.w	r4, r4, #1
    2404:	bcs.n	23de <breakTime(long, tmElements_t&)+0x9e>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    2406:	strb	r7, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    2408:	cmp.w	lr, #0
    240c:	bne.n	242e <breakTime(long, tmElements_t&)+0xee>
    240e:	ldr	r0, [pc, #212]	; (24e4 <breakTime(long, tmElements_t&)+0x1a4>)
    2410:	asrs	r6, r3, #31
    2412:	smull	r4, r0, r0, r3
    2416:	rsb	r4, r6, r0, asr #5
    241a:	movs	r5, #100	; 0x64
    241c:	mls	r4, r5, r4, r3
    2420:	cbz	r4, 2492 <breakTime(long, tmElements_t&)+0x152>
    2422:	mov.w	r4, #366	; 0x16e
    2426:	b.n	2434 <breakTime(long, tmElements_t&)+0xf4>
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    2428:	mov.w	r0, #366	; 0x16e
    242c:	b.n	23d4 <breakTime(long, tmElements_t&)+0x94>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    242e:	movw	r4, #365	; 0x16d
    2432:	asrs	r6, r3, #31
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    2434:	ldr	r0, [pc, #172]	; (24e4 <breakTime(long, tmElements_t&)+0x1a4>)
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    2436:	ldr	r5, [pc, #176]	; (24e8 <breakTime(long, tmElements_t&)+0x1a8>)
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    2438:	smull	r7, r0, r0, r3
    243c:	rsb	r8, r6, r0, asr #5
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    2440:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    2442:	rsb	r6, r6, r0, asr #7
    2446:	movs	r4, #100	; 0x64
    2448:	mov.w	r0, #400	; 0x190
    244c:	mls	r6, r0, r6, r3
    2450:	mls	r8, r4, r8, r3
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    2454:	rsb	r2, r2, ip
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    2458:	movs	r0, #1
    245a:	movs	r3, #0
    245c:	b.n	2464 <breakTime(long, tmElements_t&)+0x124>
    245e:	adds	r0, #1
    2460:	uxtb	r0, r0
    2462:	adds	r3, #1
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    2464:	cmp	r3, #1
    2466:	uxtb	r7, r3
    2468:	beq.n	24ac <breakTime(long, tmElements_t&)+0x16c>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    246a:	ldrb	r4, [r3, r5]
    246c:	cmp	r4, r2
    246e:	bhi.n	2484 <breakTime(long, tmElements_t&)+0x144>
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    2470:	cmp	r0, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    2472:	sub.w	r2, r2, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    2476:	bne.n	245e <breakTime(long, tmElements_t&)+0x11e>
    2478:	movs	r7, #13
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    247a:	adds	r2, #1
    247c:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    247e:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    2480:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2484:	adds	r7, #1
    2486:	uxtb	r7, r7
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    2488:	adds	r2, #1
    248a:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    248c:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    248e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    2492:	mov.w	r4, #400	; 0x190
    2496:	rsb	r0, r6, r0, asr #7
    249a:	mls	r0, r4, r0, r3
    249e:	cmp	r0, #0
    24a0:	movw	r4, #365	; 0x16d
    24a4:	it	eq
    24a6:	moveq.w	r4, #366	; 0x16e
    24aa:	b.n	2434 <breakTime(long, tmElements_t&)+0xf4>
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    24ac:	cmp.w	lr, #0
    24b0:	bne.n	24c8 <breakTime(long, tmElements_t&)+0x188>
    24b2:	cmp.w	r8, #0
    24b6:	bne.n	24d0 <breakTime(long, tmElements_t&)+0x190>
    24b8:	cmp	r6, #0
    24ba:	ite	ne
    24bc:	movne	r4, #28
    24be:	moveq	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    24c0:	cmp	r2, r4
    24c2:	bcc.n	24cc <breakTime(long, tmElements_t&)+0x18c>
      time -= monthLength;
    24c4:	subs	r2, r2, r4
    24c6:	b.n	245e <breakTime(long, tmElements_t&)+0x11e>
    24c8:	movs	r4, #28
    24ca:	b.n	24c0 <breakTime(long, tmElements_t&)+0x180>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    24cc:	movs	r7, #2
    24ce:	b.n	247a <breakTime(long, tmElements_t&)+0x13a>
    24d0:	movs	r4, #29
    24d2:	b.n	24c0 <breakTime(long, tmElements_t&)+0x180>
    24d4:	.word	0xc22e4507
    24d8:	.word	0x88888889
    24dc:	.word	0x91a2b3c5
    24e0:	.word	0xaaaaaaab
    24e4:	.word	0x51eb851f
    24e8:	.word	0x000135ac
    24ec:	.word	0x24924925

000024f0 <refreshCache(long) [clone .part.0]>:

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    24f0:	push	{r4, lr}
  if (t != cacheTime) {
    breakTime(t, tm); 
    24f2:	ldr	r1, [pc, #12]	; (2500 <refreshCache(long) [clone .part.0]+0x10>)

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    24f4:	mov	r4, r0
  if (t != cacheTime) {
    breakTime(t, tm); 
    24f6:	bl	2340 <breakTime(long, tmElements_t&)>
    cacheTime = t; 
    24fa:	ldr	r3, [pc, #8]	; (2504 <refreshCache(long) [clone .part.0]+0x14>)
    24fc:	str	r4, [r3, #0]
    24fe:	pop	{r4, pc}
    2500:	.word	0x200195dc
    2504:	.word	0x200195d8

00002508 <makeTime(tmElements_t const&)>:
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
}

time_t makeTime(const tmElements_t &tm){   
    2508:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    250c:	ldr	r1, [pc, #228]	; (25f4 <makeTime(tmElements_t const&)+0xec>)
    250e:	ldrb	r6, [r0, #6]
    2510:	mul.w	r1, r1, r6
  for (i = 0; i < tm.Year; i++) {
    2514:	cbz	r6, 2558 <makeTime(tmElements_t const&)+0x50>
    2516:	addw	ip, r6, #1970	; 0x7b2
    251a:	movw	r3, #1971	; 0x7b3
    if (LEAP_YEAR(i)) {
    251e:	ldr.w	lr, [pc, #216]	; 25f8 <makeTime(tmElements_t const&)+0xf0>
    2522:	movs	r7, #100	; 0x64
    2524:	mov.w	r8, #400	; 0x190
    2528:	b.n	2546 <makeTime(tmElements_t const&)+0x3e>
    252a:	tst.w	r3, #3
    252e:	bne.n	2544 <makeTime(tmElements_t const&)+0x3c>
    2530:	rsb	r2, r2, r5, asr #7
    2534:	mls	r2, r8, r2, r3
    2538:	cbnz	r4, 253c <makeTime(tmElements_t const&)+0x34>
    253a:	cbnz	r2, 2544 <makeTime(tmElements_t const&)+0x3c>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    253c:	add.w	r1, r1, #86016	; 0x15000
    2540:	add.w	r1, r1, #384	; 0x180
    2544:	adds	r3, #1
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    2546:	smull	r2, r5, lr, r3
    254a:	asrs	r2, r3, #31
    254c:	rsb	r4, r2, r5, asr #5
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    2550:	cmp	r3, ip
    if (LEAP_YEAR(i)) {
    2552:	mls	r4, r7, r4, r3
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    2556:	bne.n	252a <makeTime(tmElements_t const&)+0x22>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    2558:	ldrb	r7, [r0, #5]
    255a:	cmp	r7, #1
    255c:	ble.n	25be <makeTime(tmElements_t const&)+0xb6>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    255e:	ldr	r4, [pc, #152]	; (25f8 <makeTime(tmElements_t const&)+0xf0>)
    2560:	ldr	r2, [pc, #152]	; (25fc <makeTime(tmElements_t const&)+0xf4>)
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    2562:	ldr.w	lr, [pc, #156]	; 2600 <makeTime(tmElements_t const&)+0xf8>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    2566:	addw	r3, r6, #1970	; 0x7b2
    256a:	smull	r4, r6, r4, r3
    256e:	asrs	r4, r3, #31
    2570:	rsb	ip, r4, r6, asr #5
    2574:	movs	r5, #100	; 0x64
    2576:	rsb	r6, r4, r6, asr #7
    257a:	mov.w	r4, #400	; 0x190
    257e:	mls	ip, r5, ip, r3
    2582:	mls	r6, r4, r6, r3
    2586:	and.w	r5, r3, #3
    258a:	movs	r3, #1
    258c:	b.n	259e <makeTime(tmElements_t const&)+0x96>
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    258e:	ldrb	r4, [r2, #0]
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    2590:	adds	r3, #1
    2592:	cmp	r3, r7
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    2594:	mla	r1, lr, r4, r1
    2598:	add.w	r2, r2, #1
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    259c:	beq.n	25be <makeTime(tmElements_t const&)+0xb6>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    259e:	cmp	r3, #2
    25a0:	bne.n	258e <makeTime(tmElements_t const&)+0x86>
    25a2:	cmp	r5, #0
    25a4:	bne.n	258e <makeTime(tmElements_t const&)+0x86>
    25a6:	cmp.w	ip, #0
    25aa:	beq.n	25e4 <makeTime(tmElements_t const&)+0xdc>
      seconds += SECS_PER_DAY * 29;
    25ac:	add.w	r1, r1, #2490368	; 0x260000
    25b0:	add.w	r1, r1, #15232	; 0x3b80
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    25b4:	adds	r3, #1
    25b6:	cmp	r3, r7
    25b8:	add.w	r2, r2, #1
    25bc:	bne.n	259e <makeTime(tmElements_t const&)+0x96>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return (time_t)seconds; 
    25be:	ldrb	r3, [r0, #1]
    25c0:	ldrb	r5, [r0, #2]
    25c2:	ldrb	r4, [r0, #0]
    25c4:	ldrb	r2, [r0, #4]
    25c6:	ldr	r0, [pc, #56]	; (2600 <makeTime(tmElements_t const&)+0xf8>)
    25c8:	rsb	r3, r3, r3, lsl #4
    25cc:	mov.w	r6, #3600	; 0xe10
    25d0:	lsls	r3, r3, #2
    25d2:	mla	r3, r6, r5, r3
    25d6:	add	r3, r4
    25d8:	subs	r2, #1
    25da:	mla	r0, r0, r2, r3
}
    25de:	add	r0, r1
    25e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    25e4:	cmp	r6, #0
    25e6:	bne.n	258e <makeTime(tmElements_t const&)+0x86>
      seconds += SECS_PER_DAY * 29;
    25e8:	add.w	r1, r1, #2490368	; 0x260000
    25ec:	add.w	r1, r1, #15232	; 0x3b80
    25f0:	b.n	25b4 <makeTime(tmElements_t const&)+0xac>
    25f2:	nop
    25f4:	.word	0x01e13380
    25f8:	.word	0x51eb851f
    25fc:	.word	0x000135ac
    2600:	.word	0x00015180

00002604 <now()>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    2604:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2606:	ldr	r4, [pc, #128]	; (2688 <now()+0x84>)
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    2608:	ldr	r6, [pc, #128]	; (268c <now()+0x88>)
    260a:	ldr	r3, [r4, #0]
    260c:	ldr	r2, [r6, #0]
    260e:	ldr	r5, [pc, #128]	; (2690 <now()+0x8c>)
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    2610:	sub	sp, #12
    2612:	ldr	r0, [r5, #0]
    2614:	str	r3, [sp, #0]
	return ret;
    2616:	ldr	r3, [sp, #0]
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    2618:	subs	r3, r3, r2
    261a:	cmp.w	r3, #1000	; 0x3e8
    261e:	bcc.n	2640 <now()+0x3c>
    2620:	adds	r0, #1
    2622:	b.n	2626 <now()+0x22>
    2624:	mov	r0, r1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2626:	ldr	r3, [r4, #0]
    2628:	str	r3, [sp, #0]
	return ret;
    262a:	ldr	r3, [sp, #0]
		// millis() and prevMillis are both unsigned ints thus the subtraction will always be the absolute value of the difference
    sysTime++;
    prevMillis += 1000;	
    262c:	add.w	r2, r2, #1000	; 0x3e8
#endif


time_t now() {
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    2630:	subs	r3, r3, r2
    2632:	cmp.w	r3, #1000	; 0x3e8
    2636:	add.w	r1, r0, #1
    263a:	bcs.n	2624 <now()+0x20>
    263c:	str	r0, [r5, #0]
    263e:	str	r2, [r6, #0]
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif
  }
  if (nextSyncTime <= sysTime) {
    2640:	ldr	r7, [pc, #80]	; (2694 <now()+0x90>)
    2642:	ldr	r3, [r7, #0]
    2644:	cmp	r0, r3
    2646:	bcc.n	2668 <now()+0x64>
    if (getTimePtr != 0) {
    2648:	ldr	r3, [pc, #76]	; (2698 <now()+0x94>)
    264a:	ldr	r3, [r3, #0]
    264c:	cbz	r3, 2668 <now()+0x64>
      time_t t = getTimePtr();
    264e:	blx	r3
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    2650:	ldr	r3, [pc, #72]	; (269c <now()+0x98>)
#endif
  }
  if (nextSyncTime <= sysTime) {
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
    2652:	cbnz	r0, 266c <now()+0x68>
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    2654:	ldr	r1, [pc, #72]	; (26a0 <now()+0x9c>)
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    2656:	ldr	r2, [r3, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    2658:	ldrb	r3, [r1, #0]
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    265a:	ldr	r0, [r5, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    265c:	adds	r3, #0
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    265e:	add	r2, r0
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    2660:	it	ne
    2662:	movne	r3, #1
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    2664:	str	r2, [r7, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    2666:	strb	r3, [r1, #0]
      }
    }
  }  
  return (time_t)sysTime;
}
    2668:	add	sp, #12
    266a:	pop	{r4, r5, r6, r7, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    266c:	ldr	r2, [r4, #0]
    266e:	str	r2, [sp, #4]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    2670:	ldr	r3, [r3, #0]
  Status = timeSet;
    2672:	ldr	r2, [pc, #44]	; (26a0 <now()+0x9c>)
	return ret;
    2674:	ldr	r4, [sp, #4]
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    2676:	str	r0, [r5, #0]
  nextSyncTime = (uint32_t)t + syncInterval;
    2678:	add	r3, r0
  Status = timeSet;
    267a:	movs	r1, #2
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    267c:	str	r4, [r6, #0]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    267e:	str	r3, [r7, #0]
  Status = timeSet;
    2680:	strb	r1, [r2, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
      }
    }
  }  
  return (time_t)sysTime;
}
    2682:	add	sp, #12
    2684:	pop	{r4, r5, r6, r7, pc}
    2686:	nop
    2688:	.word	0x20019bc4
    268c:	.word	0x200195f0
    2690:	.word	0x200195e4
    2694:	.word	0x200195f4
    2698:	.word	0x200195ec
    269c:	.word	0x2001378c
    26a0:	.word	0x200195e8

000026a4 <hour()>:
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour() { // the hour now 
    26a4:	push	{r3, lr}
  return hour(now()); 
    26a6:	bl	2604 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    26aa:	ldr	r3, [pc, #16]	; (26bc <hour()+0x18>)
    26ac:	ldr	r3, [r3, #0]
    26ae:	cmp	r0, r3
    26b0:	beq.n	26b6 <hour()+0x12>
    26b2:	bl	24f0 <refreshCache(long) [clone .part.0]>
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
  return tm.Hour;  
    26b6:	ldr	r3, [pc, #8]	; (26c0 <hour()+0x1c>)
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    26b8:	ldrb	r0, [r3, #2]
    26ba:	pop	{r3, pc}
    26bc:	.word	0x200195d8
    26c0:	.word	0x200195dc

000026c4 <minute()>:

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
    26c4:	push	{r3, lr}
  return minute(now()); 
    26c6:	bl	2604 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    26ca:	ldr	r3, [pc, #16]	; (26dc <minute()+0x18>)
    26cc:	ldr	r3, [r3, #0]
    26ce:	cmp	r0, r3
    26d0:	beq.n	26d6 <minute()+0x12>
    26d2:	bl	24f0 <refreshCache(long) [clone .part.0]>
  return minute(now()); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
    26d6:	ldr	r3, [pc, #8]	; (26e0 <minute()+0x1c>)
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    26d8:	ldrb	r0, [r3, #1]
    26da:	pop	{r3, pc}
    26dc:	.word	0x200195d8
    26e0:	.word	0x200195dc

000026e4 <second()>:
int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second() {
    26e4:	push	{r3, lr}
  return second(now()); 
    26e6:	bl	2604 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    26ea:	ldr	r3, [pc, #16]	; (26fc <second()+0x18>)
    26ec:	ldr	r3, [r3, #0]
    26ee:	cmp	r0, r3
    26f0:	beq.n	26f6 <second()+0x12>
    26f2:	bl	24f0 <refreshCache(long) [clone .part.0]>
  return second(now()); 
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
    26f6:	ldr	r3, [pc, #8]	; (2700 <second()+0x1c>)
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    26f8:	ldrb	r0, [r3, #0]
    26fa:	pop	{r3, pc}
    26fc:	.word	0x200195d8
    2700:	.word	0x200195dc

00002704 <day()>:
int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(){
    2704:	push	{r3, lr}
  return(day(now())); 
    2706:	bl	2604 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    270a:	ldr	r3, [pc, #16]	; (271c <day()+0x18>)
    270c:	ldr	r3, [r3, #0]
    270e:	cmp	r0, r3
    2710:	beq.n	2716 <day()+0x12>
    2712:	bl	24f0 <refreshCache(long) [clone .part.0]>
  return(day(now())); 
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
  return tm.Day;
    2716:	ldr	r3, [pc, #8]	; (2720 <day()+0x1c>)
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    2718:	ldrb	r0, [r3, #4]
    271a:	pop	{r3, pc}
    271c:	.word	0x200195d8
    2720:	.word	0x200195dc

00002724 <month()>:
int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
    2724:	push	{r3, lr}
  return month(now()); 
    2726:	bl	2604 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    272a:	ldr	r3, [pc, #16]	; (273c <month()+0x18>)
    272c:	ldr	r3, [r3, #0]
    272e:	cmp	r0, r3
    2730:	beq.n	2736 <month()+0x12>
    2732:	bl	24f0 <refreshCache(long) [clone .part.0]>
  return month(now()); 
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
    2736:	ldr	r3, [pc, #8]	; (2740 <month()+0x1c>)
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    2738:	ldrb	r0, [r3, #5]
    273a:	pop	{r3, pc}
    273c:	.word	0x200195d8
    2740:	.word	0x200195dc

00002744 <year()>:
int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
    2744:	push	{r3, lr}
  return year(now()); 
    2746:	bl	2604 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    274a:	ldr	r3, [pc, #20]	; (2760 <year()+0x1c>)
    274c:	ldr	r3, [r3, #0]
    274e:	cmp	r0, r3
    2750:	beq.n	2756 <year()+0x12>
    2752:	bl	24f0 <refreshCache(long) [clone .part.0]>
  return year(now()); 
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
  return tmYearToCalendar(tm.Year);
    2756:	ldr	r3, [pc, #12]	; (2764 <year()+0x20>)
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    2758:	ldrb	r0, [r3, #6]
}
    275a:	addw	r0, r0, #1970	; 0x7b2
    275e:	pop	{r3, pc}
    2760:	.word	0x200195d8
    2764:	.word	0x200195dc

00002768 <setTime(long)>:
    }
  }  
  return (time_t)sysTime;
}

void setTime(time_t t) { 
    2768:	push	{r4, r5, r6}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    276a:	ldr	r3, [pc, #40]	; (2794 <setTime(long)+0x2c>)
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    276c:	ldr	r2, [pc, #40]	; (2798 <setTime(long)+0x30>)
    276e:	ldr	r3, [r3, #0]
    2770:	ldr	r2, [r2, #0]
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    2772:	ldr	r6, [pc, #40]	; (279c <setTime(long)+0x34>)
  nextSyncTime = (uint32_t)t + syncInterval;
    2774:	ldr	r5, [pc, #40]	; (27a0 <setTime(long)+0x38>)
  Status = timeSet;
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    2776:	ldr	r1, [pc, #44]	; (27a4 <setTime(long)+0x3c>)
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    2778:	str	r0, [r6, #0]
    }
  }  
  return (time_t)sysTime;
}

void setTime(time_t t) { 
    277a:	sub	sp, #12
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    277c:	add	r0, r2
    277e:	str	r3, [sp, #4]
	return ret;
    2780:	ldr	r4, [sp, #4]
  Status = timeSet;
    2782:	ldr	r3, [pc, #36]	; (27a8 <setTime(long)+0x40>)
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    2784:	str	r0, [r5, #0]
  Status = timeSet;
    2786:	movs	r2, #2
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    2788:	str	r4, [r1, #0]
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
  Status = timeSet;
    278a:	strb	r2, [r3, #0]
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
} 
    278c:	add	sp, #12
    278e:	pop	{r4, r5, r6}
    2790:	bx	lr
    2792:	nop
    2794:	.word	0x20019bc4
    2798:	.word	0x2001378c
    279c:	.word	0x200195e4
    27a0:	.word	0x200195f4
    27a4:	.word	0x200195f0
    27a8:	.word	0x200195e8

000027ac <setSyncProvider(long (*)())>:
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
  nextSyncTime = sysTime;
    27ac:	ldr	r1, [pc, #12]	; (27bc <setSyncProvider(long (*)())+0x10>)
    27ae:	ldr	r2, [pc, #16]	; (27c0 <setSyncProvider(long (*)())+0x14>)
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    27b0:	ldr	r3, [pc, #16]	; (27c4 <setSyncProvider(long (*)())+0x18>)
  nextSyncTime = sysTime;
    27b2:	ldr	r1, [r1, #0]
    27b4:	str	r1, [r2, #0]
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    27b6:	str	r0, [r3, #0]
  nextSyncTime = sysTime;
  now(); // this will sync the clock
    27b8:	b.w	2604 <now()>
    27bc:	.word	0x200195e4
    27c0:	.word	0x200195f4
    27c4:	.word	0x200195ec

000027c8 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
    27c8:	push	{r4, lr}
    27ca:	mov	r4, r0
		release();
    27cc:	bl	a87c <DMAChannel::release()>
	}
    27d0:	mov	r0, r4
    27d2:	pop	{r4, pc}

000027d4 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE>:
audio_block_t * AudioOutputPWM::block_2nd = NULL;
uint32_t  AudioOutputPWM::block_offset = 0;
uint8_t AudioOutputPWM::interrupt_count = 0;

DMAMEM uint32_t pwm_dma_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputPWM::dma(false);
    27d4:	ldr	r2, [pc, #8]	; (27e0 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0xc>)
    27d6:	ldr	r1, [pc, #12]	; (27e4 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x10>)
    27d8:	ldr	r0, [pc, #12]	; (27e8 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x14>)
    27da:	b.w	af34 <__aeabi_atexit>
    27de:	nop
    27e0:	.word	0x20013730
    27e4:	.word	0x000027c9
    27e8:	.word	0x200195f8

000027ec <AudioInputI2S::isr()>:
	const int16_t *src, *end;
	int16_t *dest_left, *dest_right;
	audio_block_t *left, *right;

#if defined(KINETISK) || defined(__IMXRT1062__)
	daddr = (uint32_t)(dma.TCD->DADDR);
    27ec:	ldr	r2, [pc, #104]	; (2858 <AudioInputI2S::isr()+0x6c>)
	dma.clearInterrupt();
	//Serial.println("isr");

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
    27ee:	ldr	r3, [pc, #108]	; (285c <AudioInputI2S::isr()+0x70>)
	const int16_t *src, *end;
	int16_t *dest_left, *dest_right;
	audio_block_t *left, *right;

#if defined(KINETISK) || defined(__IMXRT1062__)
	daddr = (uint32_t)(dma.TCD->DADDR);
    27f0:	ldr	r1, [r2, #0]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    27f2:	ldr	r0, [pc, #108]	; (2860 <AudioInputI2S::isr()+0x74>)
    27f4:	ldr	r1, [r1, #16]
	dma.enable();
	dma.attachInterrupt(isr);
}

void AudioInputI2S::isr(void)
{
    27f6:	push	{r4, r5, r6}
#if defined(KINETISK) || defined(__IMXRT1062__)
	daddr = (uint32_t)(dma.TCD->DADDR);
	dma.clearInterrupt();
	//Serial.println("isr");

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
    27f8:	cmp	r1, r3
    27fa:	ldrb	r2, [r2, #4]
    27fc:	strb	r2, [r0, #0]
    27fe:	bcs.n	2812 <AudioInputI2S::isr()+0x26>
		// DMA is receiving to the first half of the buffer
		// need to remove data from the second half
		src = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
		if (AudioInputI2S::update_responsibility) AudioStream::update_all();
    2800:	ldr	r2, [pc, #96]	; (2864 <AudioInputI2S::isr()+0x78>)
    2802:	ldrb	r2, [r2, #0]
    2804:	cbz	r2, 2852 <AudioInputI2S::isr()+0x66>
	void transmit(audio_block_t *block, unsigned char index = 0);
	audio_block_t * receiveReadOnly(unsigned int index = 0);
	audio_block_t * receiveWritable(unsigned int index = 0);
	static bool update_setup(void);
	static void update_stop(void);
	static void update_all(void) { NVIC_SET_PENDING(IRQ_SOFTWARE); }
    2806:	ldr	r2, [pc, #96]	; (2868 <AudioInputI2S::isr()+0x7c>)
    2808:	movs	r1, #1
    280a:	str	r1, [r2, #0]

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
		// DMA is receiving to the first half of the buffer
		// need to remove data from the second half
		src = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
    280c:	add.w	r4, r3, #256	; 0x100
    2810:	b.n	2818 <AudioInputI2S::isr()+0x2c>
		if (AudioInputI2S::update_responsibility) AudioStream::update_all();
	} else {
		// DMA is receiving to the second half of the buffer
		// need to remove data from the first half
		src = (int16_t *)&i2s_rx_buffer[0];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
    2812:	mov	r4, r3
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
		if (AudioInputI2S::update_responsibility) AudioStream::update_all();
	} else {
		// DMA is receiving to the second half of the buffer
		// need to remove data from the first half
		src = (int16_t *)&i2s_rx_buffer[0];
    2814:	sub.w	r3, r3, #256	; 0x100
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
	}
	left = AudioInputI2S::block_left;
    2818:	ldr	r2, [pc, #80]	; (286c <AudioInputI2S::isr()+0x80>)
	right = AudioInputI2S::block_right;
    281a:	ldr	r1, [pc, #84]	; (2870 <AudioInputI2S::isr()+0x84>)
		// DMA is receiving to the second half of the buffer
		// need to remove data from the first half
		src = (int16_t *)&i2s_rx_buffer[0];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
	}
	left = AudioInputI2S::block_left;
    281c:	ldr	r2, [r2, #0]
	right = AudioInputI2S::block_right;
    281e:	ldr	r5, [r1, #0]
	if (left != NULL && right != NULL) {
    2820:	cbz	r2, 284e <AudioInputI2S::isr()+0x62>
    2822:	cbz	r5, 284e <AudioInputI2S::isr()+0x62>
		offset = AudioInputI2S::block_offset;
    2824:	ldr	r6, [pc, #76]	; (2874 <AudioInputI2S::isr()+0x88>)
    2826:	ldrh	r0, [r6, #0]
		if (offset <= AUDIO_BLOCK_SAMPLES/2) {
    2828:	cmp	r0, #64	; 0x40
    282a:	bhi.n	284e <AudioInputI2S::isr()+0x62>
			dest_left = &(left->data[offset]);
    282c:	lsls	r1, r0, #1
    282e:	add	r2, r1
			dest_right = &(right->data[offset]);
			AudioInputI2S::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
    2830:	adds	r0, #64	; 0x40
	right = AudioInputI2S::block_right;
	if (left != NULL && right != NULL) {
		offset = AudioInputI2S::block_offset;
		if (offset <= AUDIO_BLOCK_SAMPLES/2) {
			dest_left = &(left->data[offset]);
			dest_right = &(right->data[offset]);
    2832:	add	r1, r5
    2834:	adds	r2, #2
    2836:	adds	r1, #2
			AudioInputI2S::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
    2838:	strh	r0, [r6, #0]
			arm_dcache_delete((void*)src, sizeof(i2s_rx_buffer) / 2);
			do {
				*dest_left++ = *src++;
    283a:	ldrsh.w	r0, [r3], #4
    283e:	strh.w	r0, [r2, #2]!
				*dest_right++ = *src++;
			} while (src < end);
    2842:	cmp	r4, r3
			dest_right = &(right->data[offset]);
			AudioInputI2S::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
			arm_dcache_delete((void*)src, sizeof(i2s_rx_buffer) / 2);
			do {
				*dest_left++ = *src++;
				*dest_right++ = *src++;
    2844:	ldrsh.w	r0, [r3, #-2]
    2848:	strh.w	r0, [r1, #2]!
			} while (src < end);
    284c:	bhi.n	283a <AudioInputI2S::isr()+0x4e>
		}
	}
#endif
}
    284e:	pop	{r4, r5, r6}
    2850:	bx	lr

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
		// DMA is receiving to the first half of the buffer
		// need to remove data from the second half
		src = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
    2852:	add.w	r4, r3, #256	; 0x100
    2856:	b.n	2818 <AudioInputI2S::isr()+0x2c>
    2858:	.word	0x20019608
    285c:	.word	0x200130a0
    2860:	.word	0x4000801f
    2864:	.word	0x20019602
    2868:	.word	0xe000e208
    286c:	.word	0x20019610
    2870:	.word	0x20019604
    2874:	.word	0x20019600

00002878 <AudioInputI2S::update()>:
}



void AudioInputI2S::update(void)
{
    2878:	push	{r3, r4, r5, r6, r7, lr}
    287a:	mov	r6, r0
	audio_block_t *new_left=NULL, *new_right=NULL, *out_left=NULL, *out_right=NULL;

	// allocate 2 new blocks, but if one fails, allocate neither
	new_left = allocate();
    287c:	bl	aaa8 <AudioStream::allocate()>
	if (new_left != NULL) {
    2880:	mov	r4, r0
    2882:	cbz	r0, 28c0 <AudioInputI2S::update()+0x48>
		new_right = allocate();
    2884:	bl	aaa8 <AudioStream::allocate()>
		if (new_right == NULL) {
    2888:	mov	r5, r0
    288a:	cmp	r0, #0
    288c:	beq.n	2904 <AudioInputI2S::update()+0x8c>
			release(new_left);
			new_left = NULL;
		}
	}
	__disable_irq();
    288e:	cpsid	i
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
    2890:	ldr	r3, [pc, #124]	; (2910 <AudioInputI2S::update()+0x98>)
    2892:	ldrh	r2, [r3, #0]
    2894:	cmp	r2, #127	; 0x7f
    2896:	bhi.n	28cc <AudioInputI2S::update()+0x54>
		transmit(out_left, 0);
		release(out_left);
		transmit(out_right, 1);
		release(out_right);
		//Serial.print(".");
	} else if (new_left != NULL) {
    2898:	cmp	r4, #0
    289a:	beq.n	2900 <AudioInputI2S::update()+0x88>
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
    289c:	ldr	r1, [pc, #116]	; (2914 <AudioInputI2S::update()+0x9c>)
    289e:	ldr	r2, [r1, #0]
    28a0:	cbz	r2, 28b4 <AudioInputI2S::update()+0x3c>
			block_right = new_right;
			block_offset = 0;
			__enable_irq();
		} else {
			// the DMA already has blocks, doesn't need these
			__enable_irq();
    28a2:	cpsie	i
			release(new_left);
    28a4:	mov	r0, r4
    28a6:	bl	ab50 <AudioStream::release(audio_block_struct*)>
			release(new_right);
    28aa:	mov	r0, r5
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
    28ac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			__enable_irq();
		} else {
			// the DMA already has blocks, doesn't need these
			__enable_irq();
			release(new_left);
			release(new_right);
    28b0:	b.w	ab50 <AudioStream::release(audio_block_struct*)>
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
			// the DMA doesn't have any blocks to fill, so
			// give it the ones we just allocated
			block_left = new_left;
			block_right = new_right;
    28b4:	ldr	r0, [pc, #96]	; (2918 <AudioInputI2S::update()+0xa0>)
	} else if (new_left != NULL) {
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
			// the DMA doesn't have any blocks to fill, so
			// give it the ones we just allocated
			block_left = new_left;
    28b6:	str	r4, [r1, #0]
			block_right = new_right;
			block_offset = 0;
    28b8:	strh	r2, [r3, #0]
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
			// the DMA doesn't have any blocks to fill, so
			// give it the ones we just allocated
			block_left = new_left;
			block_right = new_right;
    28ba:	str	r5, [r0, #0]
			block_offset = 0;
			__enable_irq();
    28bc:	cpsie	i
    28be:	pop	{r3, r4, r5, r6, r7, pc}



void AudioInputI2S::update(void)
{
	audio_block_t *new_left=NULL, *new_right=NULL, *out_left=NULL, *out_right=NULL;
    28c0:	mov	r5, r0
		if (new_right == NULL) {
			release(new_left);
			new_left = NULL;
		}
	}
	__disable_irq();
    28c2:	cpsid	i
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
    28c4:	ldr	r3, [pc, #72]	; (2910 <AudioInputI2S::update()+0x98>)
    28c6:	ldrh	r2, [r3, #0]
    28c8:	cmp	r2, #127	; 0x7f
    28ca:	bls.n	2898 <AudioInputI2S::update()+0x20>
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
    28cc:	ldr	r2, [pc, #68]	; (2914 <AudioInputI2S::update()+0x9c>)
		block_left = new_left;
		out_right = block_right;
    28ce:	ldr	r1, [pc, #72]	; (2918 <AudioInputI2S::update()+0xa0>)
	}
	__disable_irq();
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
    28d0:	ldr	r7, [r2, #0]
		block_left = new_left;
    28d2:	str	r4, [r2, #0]
		out_right = block_right;
		block_right = new_right;
		block_offset = 0;
    28d4:	movs	r2, #0
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
		block_left = new_left;
		out_right = block_right;
    28d6:	ldr	r4, [r1, #0]
		block_right = new_right;
		block_offset = 0;
    28d8:	strh	r2, [r3, #0]
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
		block_left = new_left;
		out_right = block_right;
		block_right = new_right;
    28da:	str	r5, [r1, #0]
		block_offset = 0;
		__enable_irq();
    28dc:	cpsie	i
		// then transmit the DMA's former blocks
		transmit(out_left, 0);
    28de:	mov	r1, r7
    28e0:	mov	r0, r6
    28e2:	bl	aba4 <AudioStream::transmit(audio_block_struct*, unsigned char)>
		release(out_left);
    28e6:	mov	r0, r7
    28e8:	bl	ab50 <AudioStream::release(audio_block_struct*)>
		transmit(out_right, 1);
    28ec:	mov	r0, r6
    28ee:	mov	r1, r4
    28f0:	movs	r2, #1
    28f2:	bl	aba4 <AudioStream::transmit(audio_block_struct*, unsigned char)>
		release(out_right);
    28f6:	mov	r0, r4
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
    28f8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		__enable_irq();
		// then transmit the DMA's former blocks
		transmit(out_left, 0);
		release(out_left);
		transmit(out_right, 1);
		release(out_right);
    28fc:	b.w	ab50 <AudioStream::release(audio_block_struct*)>
		}
	} else {
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
    2900:	cpsie	i
    2902:	pop	{r3, r4, r5, r6, r7, pc}
	// allocate 2 new blocks, but if one fails, allocate neither
	new_left = allocate();
	if (new_left != NULL) {
		new_right = allocate();
		if (new_right == NULL) {
			release(new_left);
    2904:	mov	r0, r4
    2906:	bl	ab50 <AudioStream::release(audio_block_struct*)>
			new_left = NULL;
    290a:	mov	r4, r5
    290c:	b.n	288e <AudioInputI2S::update()+0x16>
    290e:	nop
    2910:	.word	0x20019600
    2914:	.word	0x20019610
    2918:	.word	0x20019604

0000291c <AudioInputI2S::begin()>:
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);


void AudioInputI2S::begin(void)
{
    291c:	push	{r3, r4, r5, r6, r7, lr}
	dma.begin(true); // Allocate the DMA channel first
    291e:	ldr	r4, [pc, #160]	; (29c0 <AudioInputI2S::begin()+0xa4>)
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
    2920:	ldr	r6, [pc, #160]	; (29c4 <AudioInputI2S::begin()+0xa8>)
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
    2922:	ldr	r7, [pc, #164]	; (29c8 <AudioInputI2S::begin()+0xac>)
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);

	I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
    2924:	ldr	r5, [pc, #164]	; (29cc <AudioInputI2S::begin()+0xb0>)
DMAChannel AudioInputI2S::dma(false);


void AudioInputI2S::begin(void)
{
	dma.begin(true); // Allocate the DMA channel first
    2926:	movs	r1, #1
    2928:	mov	r0, r4
    292a:	bl	a7b0 <DMAChannel::begin(bool)>

	//block_left_1st = NULL;
	//block_right_1st = NULL;

	// TODO: should we set & clear the I2S_RCSR_SR bit here?
	AudioOutputI2S::config_i2s();
    292e:	movs	r0, #0
    2930:	bl	3518 <AudioOutputI2S::config_i2s(bool)>

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
    2934:	ldr	r3, [pc, #152]	; (29d0 <AudioInputI2S::begin()+0xb4>)
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
    2936:	ldr	r2, [pc, #156]	; (29d4 <AudioInputI2S::begin()+0xb8>)
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);

	I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
	I2S0_TCSR |= I2S_TCSR_TE | I2S_TCSR_BCE; // TX clock enable, because sync'd to TX
    2938:	ldr	r0, [pc, #156]	; (29d8 <AudioInputI2S::begin()+0xbc>)

	// TODO: should we set & clear the I2S_RCSR_SR bit here?
	AudioOutputI2S::config_i2s();

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
    293a:	mov.w	r1, #1024	; 0x400
    293e:	str	r1, [r3, #0]
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
    2940:	ldr	r3, [r4, #0]
	dma.TCD->SOFF = 0;
    2942:	movs	r1, #0
	// TODO: should we set & clear the I2S_RCSR_SR bit here?
	AudioOutputI2S::config_i2s();

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
    2944:	str	r2, [r3, #0]
	dma.TCD->SOFF = 0;
    2946:	strh	r1, [r3, #4]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    2948:	ldrb	r2, [r4, #4]
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
    294a:	str	r6, [r3, #16]
    294c:	add.w	r2, r2, #1073741824	; 0x40000000

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
    2950:	movw	r6, #257	; 0x101
    2954:	strh	r6, [r3, #6]
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
    2956:	str	r7, [r3, #24]
    2958:	add.w	r2, r2, #135168	; 0x21000
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
    295c:	mov.w	r6, #256	; 0x100
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    2960:	movs	r7, #6
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
    2962:	strh	r6, [r3, #22]
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
    2964:	strh	r6, [r3, #30]
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    2966:	strh	r7, [r3, #28]
#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
    2968:	movs	r6, #2
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    296a:	movs	r7, #140	; 0x8c
	dma.TCD->SLAST = 0;
    296c:	str	r1, [r3, #12]
#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
    296e:	str	r6, [r3, #8]
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
    2970:	strh	r6, [r3, #20]

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    2972:	strb	r1, [r2, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    2974:	strb	r7, [r2, #0]
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);

	I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
    2976:	ldr	r3, [r5, #0]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    2978:	ldr	r6, [pc, #96]	; (29dc <AudioInputI2S::begin()+0xc0>)
    297a:	orr.w	r3, r3, #2449473536	; 0x92000000
    297e:	orr.w	r3, r3, #1
    2982:	str	r3, [r5, #0]
	I2S0_TCSR |= I2S_TCSR_TE | I2S_TCSR_BCE; // TX clock enable, because sync'd to TX
    2984:	ldr	r3, [r0, #0]

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    2986:	ldr	r5, [pc, #88]	; (29e0 <AudioInputI2S::begin()+0xc4>)
    2988:	orr.w	r3, r3, #2415919104	; 0x90000000
    298c:	str	r3, [r0, #0]
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_SAI1_RX);

	I2S1_RCSR = I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
#endif
	update_responsibility = update_setup();
    298e:	bl	acd4 <AudioStream::update_setup()>
    2992:	ldrb	r2, [r4, #4]
    2994:	ldr	r3, [pc, #76]	; (29e4 <AudioInputI2S::begin()+0xc8>)
    2996:	ldr	r4, [pc, #80]	; (29e8 <AudioInputI2S::begin()+0xcc>)
    2998:	strb	r0, [r3, #0]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    299a:	asrs	r3, r2, #5
    299c:	lsls	r3, r3, #2
    299e:	add.w	r3, r3, #3758096384	; 0xe0000000
    29a2:	mov	r7, r2

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    29a4:	add.w	r0, r2, #16
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    29a8:	add.w	r3, r3, #57600	; 0xe100
    29ac:	and.w	r2, r2, #31
    29b0:	movs	r1, #1
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    29b2:	strb	r7, [r6, #0]
	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    29b4:	lsl.w	r2, r1, r2

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    29b8:	str.w	r4, [r5, r0, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    29bc:	str	r2, [r3, #0]
    29be:	pop	{r3, r4, r5, r6, r7, pc}
    29c0:	.word	0x20019608
    29c4:	.word	0x20012fa0
    29c8:	.word	0xfffffe00
    29cc:	.word	0x4002f080
    29d0:	.word	0x4004b014
    29d4:	.word	0x4002f0a2
    29d8:	.word	0x4002f000
    29dc:	.word	0x4000801b
    29e0:	.word	0x20013200
    29e4:	.word	0x20019602
    29e8:	.word	0x000027ed

000029ec <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
    29ec:	ldr	r2, [pc, #8]	; (29f8 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
    29ee:	ldr	r1, [pc, #12]	; (29fc <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
    29f0:	ldr	r0, [pc, #12]	; (2a00 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
    29f2:	b.w	af34 <__aeabi_atexit>
    29f6:	nop
    29f8:	.word	0x20013730
    29fc:	.word	0x000027c9
    2a00:	.word	0x20019608

00002a04 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
    2a04:	ldr	r2, [pc, #8]	; (2a10 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
    2a06:	ldr	r1, [pc, #12]	; (2a14 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
    2a08:	ldr	r0, [pc, #12]	; (2a18 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
    2a0a:	b.w	af34 <__aeabi_atexit>
    2a0e:	nop
    2a10:	.word	0x20013730
    2a14:	.word	0x000027c9
    2a18:	.word	0x20019614

00002a1c <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE>:
bool AudioOutputADAT::update_responsibility = false;
//uint32_t  AudioOutputADAT::vucp = VUCP_VALID;

DMAMEM __attribute__((aligned(32))) static uint32_t ADAT_tx_buffer[AUDIO_BLOCK_SAMPLES * 8]; //4 KB, AUDIO_BLOCK_SAMPLES is usually 128

DMAChannel AudioOutputADAT::dma(false);
    2a1c:	ldr	r2, [pc, #8]	; (2a28 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0xc>)
    2a1e:	ldr	r1, [pc, #12]	; (2a2c <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x10>)
    2a20:	ldr	r0, [pc, #12]	; (2a30 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x14>)
    2a22:	b.w	af34 <__aeabi_atexit>
    2a26:	nop
    2a28:	.word	0x20013730
    2a2c:	.word	0x000027c9
    2a30:	.word	0x2001961c

00002a34 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE>:
uint16_t AudioInputAnalog::block_offset = 0;
int32_t AudioInputAnalog::hpf_y1 = 0;
int32_t AudioInputAnalog::hpf_x1 = 0;

bool AudioInputAnalog::update_responsibility = false;
DMAChannel AudioInputAnalog::dma(false);
    2a34:	ldr	r2, [pc, #8]	; (2a40 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0xc>)
    2a36:	ldr	r1, [pc, #12]	; (2a44 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x10>)
    2a38:	ldr	r0, [pc, #12]	; (2a48 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x14>)
    2a3a:	b.w	af34 <__aeabi_atexit>
    2a3e:	nop
    2a40:	.word	0x20013730
    2a44:	.word	0x000027c9
    2a48:	.word	0x20019624

00002a4c <AudioControlSGTL5000::disable()>:
	void setAddress(uint8_t level);
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
    2a4c:	movs	r0, #0
    2a4e:	bx	lr

00002a50 <AudioControlSGTL5000::inputLevel(float)>:
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
	bool inputLevel(float n) {return false;}
    2a50:	movs	r0, #0
    2a52:	bx	lr

00002a54 <AudioControlSGTL5000::read(unsigned int)>:
	return true;
}


unsigned int AudioControlSGTL5000::read(unsigned int reg)
{
    2a54:	push	{r3, r4, r5, r6, r7, lr}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2a56:	ldr	r4, [pc, #124]	; (2ad4 <AudioControlSGTL5000::read(unsigned int)+0x80>)
    2a58:	ldrb	r2, [r0, #8]
    2a5a:	mov	r6, r1
    2a5c:	lsls	r2, r2, #1
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    2a5e:	ubfx	r1, r1, #8, #8
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    2a62:	movs	r5, #1
    2a64:	mov	r7, r0
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    2a66:	mov	r0, r4
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2a68:	strb.w	r2, [r4, #59]	; 0x3b
		transmitting = 1;
    2a6c:	strb.w	r5, [r4, #94]	; 0x5e
		txBufferLength = 1;
    2a70:	strb.w	r5, [r4, #93]	; 0x5d
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    2a74:	bl	36e0 <TwoWire::write(unsigned char)>
    2a78:	uxtb	r1, r6
    2a7a:	mov	r0, r4
    2a7c:	bl	36e0 <TwoWire::write(unsigned char)>
	unsigned int val;
	Wire.beginTransmission(i2c_addr);
	Wire.write(reg >> 8);
	Wire.write(reg);
	if (Wire.endTransmission(false) != 0) return 0;
    2a80:	mov	r0, r4
    2a82:	movs	r1, #0
    2a84:	bl	39b8 <TwoWire::endTransmission(unsigned char)>
    2a88:	cbz	r0, 2a8e <AudioControlSGTL5000::read(unsigned int)+0x3a>
    2a8a:	movs	r0, #0
    2a8c:	pop	{r3, r4, r5, r6, r7, pc}
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
    2a8e:	mov	r3, r5
    2a90:	ldrb	r1, [r7, #8]
    2a92:	movs	r2, #2
    2a94:	mov	r0, r4
    2a96:	bl	3acc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
	if (Wire.requestFrom((int)i2c_addr, 2) < 2) return 0;
    2a9a:	cmp	r0, #1
    2a9c:	bls.n	2a8a <AudioControlSGTL5000::read(unsigned int)+0x36>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2a9e:	ldrb.w	r1, [r4, #56]	; 0x38
    2aa2:	ldrb.w	r5, [r4, #57]	; 0x39
    2aa6:	cmp	r1, r5
    2aa8:	bcs.n	2acc <AudioControlSGTL5000::read(unsigned int)+0x78>
		return rxBuffer[rxBufferIndex++];
    2aaa:	adds	r3, r4, r1
    2aac:	adds	r2, r1, #1
    2aae:	uxtb	r2, r2
	val = Wire.read() << 8;
    2ab0:	ldrb	r0, [r3, #24]
    2ab2:	strb.w	r2, [r4, #56]	; 0x38
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2ab6:	cmp	r5, r2
    2ab8:	mov.w	r3, r0, lsl #8
    2abc:	bls.n	2acc <AudioControlSGTL5000::read(unsigned int)+0x78>
		return rxBuffer[rxBufferIndex++];
    2abe:	add	r2, r4
    2ac0:	adds	r1, #2
    2ac2:	ldrb	r0, [r2, #24]
    2ac4:	strb.w	r1, [r4, #56]	; 0x38
    2ac8:	orrs	r0, r3
    2aca:	pop	{r3, r4, r5, r6, r7, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2acc:	mov.w	r0, #4294967295
	val |= Wire.read();
	return val;
}
    2ad0:	pop	{r3, r4, r5, r6, r7, pc}
    2ad2:	nop
    2ad4:	.word	0x200137fc

00002ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>:

bool AudioControlSGTL5000::write(unsigned int reg, unsigned int val)
{
    2ad8:	push	{r3, r4, r5, r6, r7, lr}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2ada:	ldr	r4, [pc, #80]	; (2b2c <AudioControlSGTL5000::write(unsigned int, unsigned int)+0x54>)
    2adc:	ldrb	r3, [r0, #8]
	if (reg == CHIP_ANA_CTRL) ana_ctrl = val;
    2ade:	cmp	r1, #36	; 0x24
    2ae0:	it	eq
    2ae2:	strheq	r2, [r0, #6]
    2ae4:	lsls	r3, r3, #1
		transmitting = 1;
    2ae6:	movs	r5, #1
	val |= Wire.read();
	return val;
}

bool AudioControlSGTL5000::write(unsigned int reg, unsigned int val)
{
    2ae8:	mov	r6, r1
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    2aea:	mov	r0, r4
    2aec:	ubfx	r1, r1, #8, #8
    2af0:	mov	r7, r2
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2af2:	strb.w	r3, [r4, #59]	; 0x3b
		transmitting = 1;
    2af6:	strb.w	r5, [r4, #94]	; 0x5e
		txBufferLength = 1;
    2afa:	strb.w	r5, [r4, #93]	; 0x5d
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
    2afe:	bl	36e0 <TwoWire::write(unsigned char)>
    2b02:	uxtb	r1, r6
    2b04:	mov	r0, r4
    2b06:	bl	36e0 <TwoWire::write(unsigned char)>
    2b0a:	ubfx	r1, r7, #8, #8
    2b0e:	mov	r0, r4
    2b10:	bl	36e0 <TwoWire::write(unsigned char)>
    2b14:	uxtb	r1, r7
    2b16:	mov	r0, r4
    2b18:	bl	36e0 <TwoWire::write(unsigned char)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    2b1c:	mov	r1, r5
    2b1e:	mov	r0, r4
    2b20:	bl	39b8 <TwoWire::endTransmission(unsigned char)>
	Wire.write(reg);
	Wire.write(val >> 8);
	Wire.write(val);
	if (Wire.endTransmission() == 0) return true;
	return false;
}
    2b24:	clz	r0, r0
    2b28:	lsrs	r0, r0, #5
    2b2a:	pop	{r3, r4, r5, r6, r7, pc}
    2b2c:	.word	0x200137fc

00002b30 <AudioControlSGTL5000::enable(unsigned int, unsigned long)>:
	return enable(0);
#endif	
}

bool AudioControlSGTL5000::enable(const unsigned extMCLK, const uint32_t pllFreq)
{
    2b30:	push	{r3, r4, r5, r6, r7, lr}
    2b32:	mov	r4, r0

	Wire.begin();
    2b34:	ldr	r0, [pc, #492]	; (2d24 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1f4>)
	return enable(0);
#endif	
}

bool AudioControlSGTL5000::enable(const unsigned extMCLK, const uint32_t pllFreq)
{
    2b36:	mov	r5, r1
    2b38:	mov	r6, r2

	Wire.begin();
    2b3a:	bl	3708 <TwoWire::begin()>
	delay(5);
    2b3e:	movs	r0, #5
    2b40:	bl	9988 <delay>
	
	//Check if we are in Master Mode and if the Teensy had a reset:
	unsigned int n = read(CHIP_I2S_CTRL);
    2b44:	mov	r0, r4
    2b46:	movs	r1, #6
    2b48:	bl	2a54 <AudioControlSGTL5000::read(unsigned int)>
	if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
    2b4c:	cmp	r5, #0
    2b4e:	beq.w	2c7c <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x14c>
    2b52:	cmp	r0, #176	; 0xb0
    2b54:	beq.w	2d18 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1e8>
	//Serial.print("chip ID = ");
	//delay(5);
	//unsigned int n = read(CHIP_ID);
	//Serial.println(n, HEX);

        muted = true;
    2b58:	movs	r7, #1
    2b5a:	strb	r7, [r4, #4]

	int r = write(CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    2b5c:	movw	r2, #16480	; 0x4060
    2b60:	movs	r1, #48	; 0x30
    2b62:	mov	r0, r4
    2b64:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	if (!r) return false;
    2b68:	cbnz	r0, 2b6e <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x3e>
    2b6a:	movs	r0, #0
    2b6c:	pop	{r3, r4, r5, r6, r7, pc}
	write(CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    2b6e:	movs	r2, #108	; 0x6c
    2b70:	movs	r1, #38	; 0x26
    2b72:	mov	r0, r4
    2b74:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    2b78:	mov.w	r2, #498	; 0x1f2
    2b7c:	movs	r1, #40	; 0x28
    2b7e:	mov	r0, r4
    2b80:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    2b84:	movw	r2, #3874	; 0xf22
    2b88:	movs	r1, #44	; 0x2c
    2b8a:	mov	r0, r4
    2b8c:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    2b90:	movw	r2, #17478	; 0x4446
    2b94:	movs	r1, #60	; 0x3c
    2b96:	mov	r0, r4
    2b98:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    2b9c:	movw	r2, #311	; 0x137
    2ba0:	movs	r1, #36	; 0x24
    2ba2:	mov	r0, r4
    2ba4:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		
	if (extMCLK > 0) {
		//SGTL is I2S Master
		//Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
		if (extMCLK > 17000000) {
    2ba8:	ldr	r3, [pc, #380]	; (2d28 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1f8>)
    2baa:	cmp	r5, r3
    2bac:	bhi.w	2d0c <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1dc>
			write(CHIP_CLK_TOP_CTRL, 1);
		} else {
			write(CHIP_CLK_TOP_CTRL, 0);
    2bb0:	movs	r2, #0
    2bb2:	movs	r1, #52	; 0x34
    2bb4:	mov	r0, r4
    2bb6:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		}

		uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    2bba:	udiv	r2, r6, r5
		uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
		
		write(CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    2bbe:	vmov	s15, r6
    2bc2:	vcvt.f32.u32	s13, s15
    2bc6:	vmov	s15, r5
    2bca:	vcvt.f32.u32	s15, s15
			write(CHIP_CLK_TOP_CTRL, 1);
		} else {
			write(CHIP_CLK_TOP_CTRL, 0);
		}

		uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    2bce:	and.w	r2, r2, #31
		uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
		
		write(CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    2bd2:	vdiv.f32	s14, s13, s15
    2bd6:	movs	r1, #50	; 0x32
    2bd8:	mov	r0, r4
    2bda:	vmov	s15, r2
    2bde:	vcvt.f32.s32	s15, s15
    2be2:	vldr	s13, [pc, #328]	; 2d2c <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x1fc>
    2be6:	vsub.f32	s15, s14, s15
    2bea:	vmul.f32	s15, s15, s13
    2bee:	vcvt.u32.f32	s15, s15
    2bf2:	vmov	r3, s15
    2bf6:	ubfx	r3, r3, #0, #11
    2bfa:	orr.w	r2, r3, r2, lsl #11
    2bfe:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
    2c02:	movw	r2, #17919	; 0x45ff
    2c06:	movs	r1, #48	; 0x30
    2c08:	mov	r0, r4
    2c0a:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	} else {
		//SGTL is I2S Slave
		write(CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
	}

	write(CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    2c0e:	movs	r2, #115	; 0x73
    2c10:	movs	r1, #2
    2c12:	mov	r0, r4
    2c14:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	delay(400);
    2c18:	mov.w	r0, #400	; 0x190
    2c1c:	bl	9988 <delay>
	write(CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    2c20:	movw	r2, #7453	; 0x1d1d
    2c24:	movs	r1, #46	; 0x2e
    2c26:	mov	r0, r4
    2c28:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	
	if (extMCLK > 0) { 
		//SGTL is I2S Master
		write(CHIP_CLK_CTRL, 0x0004 | 0x03);  // 44.1 kHz, 256*Fs, use PLL
    2c2c:	movs	r2, #7
    2c2e:	movs	r1, #4
    2c30:	mov	r0, r4
    2c32:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_I2S_CTRL, 0x0030 | (1<<7)); // SCLK=64*Fs, 16bit, I2S format
    2c36:	movs	r2, #176	; 0xb0
    2c38:	movs	r1, #6
    2c3a:	mov	r0, r4
    2c3c:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
		write(CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
	}

	// default signal routing is ok?
	write(CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
    2c40:	movs	r2, #16
    2c42:	movs	r1, #10
    2c44:	mov	r0, r4
    2c46:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
    2c4a:	movs	r2, #0
    2c4c:	movs	r1, #14
    2c4e:	mov	r0, r4
    2c50:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
    2c54:	movw	r2, #15420	; 0x3c3c
    2c58:	movs	r1, #16
    2c5a:	mov	r0, r4
    2c5c:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
    2c60:	movw	r2, #32639	; 0x7f7f
    2c64:	movs	r1, #34	; 0x22
    2c66:	mov	r0, r4
    2c68:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
    2c6c:	movs	r2, #54	; 0x36
    2c6e:	movs	r1, #36	; 0x24
    2c70:	mov	r0, r4
    2c72:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>

	semi_automated = true;
    2c76:	movs	r0, #1
    2c78:	strb	r0, [r4, #9]
    2c7a:	pop	{r3, r4, r5, r6, r7, pc}
	//Serial.print("chip ID = ");
	//delay(5);
	//unsigned int n = read(CHIP_ID);
	//Serial.println(n, HEX);

        muted = true;
    2c7c:	movs	r3, #1
    2c7e:	strb	r3, [r4, #4]

	int r = write(CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    2c80:	movw	r2, #16480	; 0x4060
    2c84:	movs	r1, #48	; 0x30
    2c86:	mov	r0, r4
    2c88:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	if (!r) return false;
    2c8c:	cmp	r0, #0
    2c8e:	beq.w	2b6a <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x3a>
	write(CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    2c92:	movs	r2, #108	; 0x6c
    2c94:	movs	r1, #38	; 0x26
    2c96:	mov	r0, r4
    2c98:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    2c9c:	mov.w	r2, #498	; 0x1f2
    2ca0:	movs	r1, #40	; 0x28
    2ca2:	mov	r0, r4
    2ca4:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    2ca8:	movw	r2, #3874	; 0xf22
    2cac:	movs	r1, #44	; 0x2c
    2cae:	mov	r0, r4
    2cb0:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    2cb4:	movw	r2, #17478	; 0x4446
    2cb8:	movs	r1, #60	; 0x3c
    2cba:	mov	r0, r4
    2cbc:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    2cc0:	movw	r2, #311	; 0x137
    2cc4:	movs	r1, #36	; 0x24
    2cc6:	mov	r0, r4
    2cc8:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		
		write(CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
		write(CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
	} else {
		//SGTL is I2S Slave
		write(CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
    2ccc:	movw	r2, #16639	; 0x40ff
    2cd0:	movs	r1, #48	; 0x30
    2cd2:	mov	r0, r4
    2cd4:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	}

	write(CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    2cd8:	movs	r2, #115	; 0x73
    2cda:	movs	r1, #2
    2cdc:	mov	r0, r4
    2cde:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	delay(400);
    2ce2:	mov.w	r0, #400	; 0x190
    2ce6:	bl	9988 <delay>
	write(CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    2cea:	movw	r2, #7453	; 0x1d1d
    2cee:	movs	r1, #46	; 0x2e
    2cf0:	mov	r0, r4
    2cf2:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		//SGTL is I2S Master
		write(CHIP_CLK_CTRL, 0x0004 | 0x03);  // 44.1 kHz, 256*Fs, use PLL
		write(CHIP_I2S_CTRL, 0x0030 | (1<<7)); // SCLK=64*Fs, 16bit, I2S format
	} else {
		//SGTL is I2S Slave
		write(CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
    2cf6:	movs	r2, #4
    2cf8:	mov	r1, r2
    2cfa:	mov	r0, r4
    2cfc:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		write(CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
    2d00:	movs	r2, #48	; 0x30
    2d02:	movs	r1, #6
    2d04:	mov	r0, r4
    2d06:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    2d0a:	b.n	2c40 <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x110>
		
	if (extMCLK > 0) {
		//SGTL is I2S Master
		//Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
		if (extMCLK > 17000000) {
			write(CHIP_CLK_TOP_CTRL, 1);
    2d0c:	mov	r2, r7
    2d0e:	movs	r1, #52	; 0x34
    2d10:	mov	r0, r4
    2d12:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    2d16:	b.n	2bba <AudioControlSGTL5000::enable(unsigned int, unsigned long)+0x8a>
	
	//Check if we are in Master Mode and if the Teensy had a reset:
	unsigned int n = read(CHIP_I2S_CTRL);
	if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
		//Yes. Do not initialize.
		muted = false;
    2d18:	movs	r3, #0
		semi_automated = true;
    2d1a:	movs	r0, #1
	
	//Check if we are in Master Mode and if the Teensy had a reset:
	unsigned int n = read(CHIP_I2S_CTRL);
	if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
		//Yes. Do not initialize.
		muted = false;
    2d1c:	strb	r3, [r4, #4]
		semi_automated = true;
    2d1e:	strb	r0, [r4, #9]
		return true;
    2d20:	pop	{r3, r4, r5, r6, r7, pc}
    2d22:	nop
    2d24:	.word	0x200137fc
    2d28:	.word	0x01036640
    2d2c:	.word	0x45000000

00002d30 <AudioControlSGTL5000::enable()>:

bool AudioControlSGTL5000::enable(void) {
#if defined(KINETISL)
	return enable(16000000); // SGTL as Master with 16MHz MCLK from Teensy LC
#else	
	return enable(0);
    2d30:	ldr	r2, [pc, #4]	; (2d38 <AudioControlSGTL5000::enable()+0x8>)
    2d32:	movs	r1, #0
    2d34:	b.w	2b30 <AudioControlSGTL5000::enable(unsigned int, unsigned long)>
    2d38:	.word	0x0ac55a60

00002d3c <AudioControlSGTL5000::inputSelect(int)>:
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
    2d3c:	push	{r4, lr}
    2d3e:	mov	r4, r0
		if (n == AUDIO_INPUT_LINEIN) {
    2d40:	cbz	r1, 2d4a <AudioControlSGTL5000::inputSelect(int)+0xe>
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
    2d42:	cmp	r1, #1
    2d44:	beq.n	2d6a <AudioControlSGTL5000::inputSelect(int)+0x2e>
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
		} else {
			return false;
		}
	}
    2d46:	movs	r0, #0
    2d48:	pop	{r4, pc}
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
    2d4a:	movs	r2, #85	; 0x55
    2d4c:	movs	r1, #32
    2d4e:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
    2d52:	cmp	r0, #0
    2d54:	beq.n	2d46 <AudioControlSGTL5000::inputSelect(int)+0xa>
    2d56:	ldrh	r2, [r4, #6]
    2d58:	orr.w	r2, r2, #4
    2d5c:	mov	r0, r4
    2d5e:	uxth	r2, r2
    2d60:	movs	r1, #36	; 0x24
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
		} else {
			return false;
		}
	}
    2d62:	ldmia.w	sp!, {r4, lr}
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
    2d66:	b.w	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
    2d6a:	movw	r2, #371	; 0x173
    2d6e:	movs	r1, #42	; 0x2a
    2d70:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    2d74:	cmp	r0, #0
    2d76:	beq.n	2d46 <AudioControlSGTL5000::inputSelect(int)+0xa>
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
    2d78:	movs	r2, #136	; 0x88
    2d7a:	movs	r1, #32
    2d7c:	mov	r0, r4
    2d7e:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    2d82:	cmp	r0, #0
    2d84:	beq.n	2d46 <AudioControlSGTL5000::inputSelect(int)+0xa>
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    2d86:	ldrh	r2, [r4, #6]
    2d88:	mov	r0, r4
    2d8a:	bic.w	r2, r2, #4
    2d8e:	movs	r1, #36	; 0x24
		} else {
			return false;
		}
	}
    2d90:	ldmia.w	sp!, {r4, lr}
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
    2d94:	b.w	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>

00002d98 <AudioControlSGTL5000::volumeInteger(unsigned int)>:
	if(!write(reg,val1)) return 0;
	return val1;
}

bool AudioControlSGTL5000::volumeInteger(unsigned int n)
{
    2d98:	push	{r3, r4, r5, lr}
    2d9a:	mov	r5, r0
	if (n == 0) {
    2d9c:	cbz	r1, 2ddc <AudioControlSGTL5000::volumeInteger(unsigned int)+0x44>
		muted = true;
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
		return muteHeadphone();
	} else if (n > 0x80) {
    2d9e:	cmp	r1, #128	; 0x80
		n = 0;
	} else {
		n = 0x80 - n;
	}
	if (muted) {
    2da0:	ldrb	r3, [r0, #4]
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
		return muteHeadphone();
	} else if (n > 0x80) {
		n = 0;
	} else {
		n = 0x80 - n;
    2da2:	itte	ls
    2da4:	rsbls	r4, r1, #128	; 0x80
    2da8:	orrls.w	r4, r4, r4, lsl #8
    2dac:	movhi	r4, #0
	}
	if (muted) {
    2dae:	cbnz	r3, 2dbe <AudioControlSGTL5000::volumeInteger(unsigned int)+0x26>
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    2db0:	mov	r2, r4
    2db2:	mov	r0, r5
    2db4:	movs	r1, #34	; 0x22
}
    2db6:	ldmia.w	sp!, {r3, r4, r5, lr}
	if (muted) {
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    2dba:	b.w	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
	bool inputLevel(float n) {return false;}
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
    2dbe:	ldrh	r2, [r0, #6]
		n = 0;
	} else {
		n = 0x80 - n;
	}
	if (muted) {
		muted = false;
    2dc0:	movs	r3, #0
    2dc2:	bic.w	r2, r2, #16
    2dc6:	strb	r3, [r0, #4]
    2dc8:	movs	r1, #36	; 0x24
    2dca:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    2dce:	mov	r2, r4
    2dd0:	mov	r0, r5
    2dd2:	movs	r1, #34	; 0x22
}
    2dd4:	ldmia.w	sp!, {r3, r4, r5, lr}
	if (muted) {
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
    2dd8:	b.w	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
}

bool AudioControlSGTL5000::volumeInteger(unsigned int n)
{
	if (n == 0) {
		muted = true;
    2ddc:	movs	r3, #1
    2dde:	strb	r3, [r0, #4]
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
    2de0:	movw	r2, #32639	; 0x7f7f
    2de4:	movs	r1, #34	; 0x22
    2de6:	bl	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
	bool inputLevel(float n) {return false;}
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
    2dea:	ldrh	r2, [r5, #6]
    2dec:	orr.w	r2, r2, #16
    2df0:	mov	r0, r5
    2df2:	uxth	r2, r2
    2df4:	movs	r1, #36	; 0x24
		muted = false;
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
}
    2df6:	ldmia.w	sp!, {r3, r4, r5, lr}
    2dfa:	b.w	2ad8 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
    2dfe:	nop

00002e00 <AudioControlSGTL5000::volume(float)>:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
	void setAddress(uint8_t level);
	bool enable(void);//For Teensy LC the SGTL acts as master, for all other Teensys as slave.
	bool enable(const unsigned extMCLK, const uint32_t pllFreq = (4096.0l * AUDIO_SAMPLE_RATE_EXACT) ); //With extMCLK > 0, the SGTL acts as Master
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499f); }
    2e00:	vldr	s14, [pc, #20]	; 2e18 <AudioControlSGTL5000::volume(float)+0x18>
    2e04:	vldr	s15, [pc, #20]	; 2e1c <AudioControlSGTL5000::volume(float)+0x1c>
    2e08:	vfma.f32	s15, s0, s14
    2e0c:	vcvt.u32.f32	s15, s15
    2e10:	vmov	r1, s15
    2e14:	b.w	2d98 <AudioControlSGTL5000::volumeInteger(unsigned int)>
    2e18:	.word	0x43010000
    2e1c:	.word	0x3eff7cee

00002e20 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE>:

DMAMEM __attribute__((aligned(32))) static uint16_t dac_buffer[AUDIO_BLOCK_SAMPLES*2];
audio_block_t * AudioOutputAnalog::block_left_1st = NULL;
audio_block_t * AudioOutputAnalog::block_left_2nd = NULL;
bool AudioOutputAnalog::update_responsibility = false;
DMAChannel AudioOutputAnalog::dma(false);
    2e20:	ldr	r2, [pc, #8]	; (2e2c <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0xc>)
    2e22:	ldr	r1, [pc, #12]	; (2e30 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x10>)
    2e24:	ldr	r0, [pc, #12]	; (2e34 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x14>)
    2e26:	b.w	af34 <__aeabi_atexit>
    2e2a:	nop
    2e2c:	.word	0x20013730
    2e30:	.word	0x000027c9
    2e34:	.word	0x2001962c

00002e38 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE>:
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    2e38:	push	{r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_left = 0;
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
    2e3a:	ldr	r5, [pc, #28]	; (2e58 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x20>)
    2e3c:	ldr	r4, [pc, #28]	; (2e5c <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x24>)
    2e3e:	ldr	r0, [pc, #32]	; (2e60 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x28>)
    2e40:	mov	r2, r5
    2e42:	mov	r1, r4
    2e44:	bl	af34 <__aeabi_atexit>
DMAChannel AudioInputAnalogStereo::dma1(false);
    2e48:	mov	r2, r5
    2e4a:	mov	r1, r4
    2e4c:	ldr	r0, [pc, #20]	; (2e64 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x2c>)
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    2e4e:	ldmia.w	sp!, {r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
DMAChannel AudioInputAnalogStereo::dma1(false);
    2e52:	b.w	af34 <__aeabi_atexit>
    2e56:	nop
    2e58:	.word	0x20013730
    2e5c:	.word	0x000027c9
    2e60:	.word	0x20019634
    2e64:	.word	0x2001963c

00002e68 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
    2e68:	ldr	r2, [pc, #8]	; (2e74 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
    2e6a:	ldr	r1, [pc, #12]	; (2e78 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
    2e6c:	ldr	r0, [pc, #12]	; (2e7c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
    2e6e:	b.w	af34 <__aeabi_atexit>
    2e72:	nop
    2e74:	.word	0x20013730
    2e78:	.word	0x000027c9
    2e7c:	.word	0x20019644

00002e80 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE>:
audio_block_t * AudioOutputAnalogStereo::block_left_2nd = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_1st = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_2nd = NULL;
audio_block_t AudioOutputAnalogStereo::block_silent;
bool AudioOutputAnalogStereo::update_responsibility = false;
DMAChannel AudioOutputAnalogStereo::dma(false);
    2e80:	ldr	r2, [pc, #8]	; (2e8c <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0xc>)
    2e82:	ldr	r1, [pc, #12]	; (2e90 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x10>)
    2e84:	ldr	r0, [pc, #12]	; (2e94 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x14>)
    2e86:	b.w	af34 <__aeabi_atexit>
    2e8a:	nop
    2e8c:	.word	0x20013730
    2e90:	.word	0x000027c9
    2e94:	.word	0x2001964c

00002e98 <File::read(void*, unsigned int)>:
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    2e98:	ldr	r0, [r0, #16]
    2e9a:	cbz	r0, 2ea2 <File::read(void*, unsigned int)+0xa>
    2e9c:	ldr	r3, [r0, #0]
    2e9e:	ldr	r3, [r3, #40]	; 0x28
    2ea0:	bx	r3
	}
    2ea2:	bx	lr

00002ea4 <File::write(void const*, unsigned int)>:
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    2ea4:	ldr	r0, [r0, #16]
    2ea6:	cbz	r0, 2eae <File::write(void const*, unsigned int)+0xa>
    2ea8:	ldr	r3, [r0, #0]
    2eaa:	ldr	r3, [r3, #44]	; 0x2c
    2eac:	bx	r3
	}
    2eae:	bx	lr

00002eb0 <File::available()>:
	virtual int available() {
		return (f) ? f->available() : 0;
    2eb0:	ldr	r0, [r0, #16]
    2eb2:	cbz	r0, 2eba <File::available()+0xa>
    2eb4:	ldr	r3, [r0, #0]
    2eb6:	ldr	r3, [r3, #16]
    2eb8:	bx	r3
	}
    2eba:	bx	lr

00002ebc <File::peek()>:
	virtual int peek() {
		return (f) ? f->peek() : -1;
    2ebc:	ldr	r0, [r0, #16]
    2ebe:	cbz	r0, 2ec6 <File::peek()+0xa>
    2ec0:	ldr	r3, [r0, #0]
    2ec2:	ldr	r3, [r3, #24]
    2ec4:	bx	r3
	}
    2ec6:	mov.w	r0, #4294967295
    2eca:	bx	lr

00002ecc <File::flush()>:
	virtual void flush() {
		if (f) f->flush();
    2ecc:	ldr	r0, [r0, #16]
    2ece:	cbz	r0, 2ed6 <File::flush()+0xa>
    2ed0:	ldr	r3, [r0, #0]
    2ed2:	ldr	r3, [r3, #12]
    2ed4:	bx	r3
    2ed6:	bx	lr

00002ed8 <File::truncate(unsigned long long)>:
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
    2ed8:	ldr	r0, [r0, #16]
    2eda:	cbz	r0, 2ee2 <File::truncate(unsigned long long)+0xa>
    2edc:	ldr	r1, [r0, #0]
    2ede:	ldr	r1, [r1, #48]	; 0x30
    2ee0:	bx	r1
	}
    2ee2:	bx	lr

00002ee4 <File::seek(unsigned long long, int)>:
	virtual bool seek(uint64_t pos, int mode) {
    2ee4:	push	{r4}
		return (f) ? f->seek(pos, mode) : false;
    2ee6:	ldr	r0, [r0, #16]
    2ee8:	cbz	r0, 2ef4 <File::seek(unsigned long long, int)+0x10>
    2eea:	ldr	r4, [r0, #0]
    2eec:	ldr	r1, [r4, #52]	; 0x34
	}
    2eee:	ldr.w	r4, [sp], #4
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    2ef2:	bx	r1
	}
    2ef4:	ldr.w	r4, [sp], #4
    2ef8:	bx	lr
    2efa:	nop

00002efc <File::position()>:
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
    2efc:	ldr	r0, [r0, #16]
    2efe:	cbz	r0, 2f06 <File::position()+0xa>
    2f00:	ldr	r3, [r0, #0]
    2f02:	ldr	r3, [r3, #56]	; 0x38
    2f04:	bx	r3
	}
    2f06:	movs	r0, #0
    2f08:	movs	r1, #0
    2f0a:	bx	lr

00002f0c <File::size()>:
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2f0c:	ldr	r0, [r0, #16]
    2f0e:	cbz	r0, 2f16 <File::size()+0xa>
    2f10:	ldr	r3, [r0, #0]
    2f12:	ldr	r3, [r3, #60]	; 0x3c
    2f14:	bx	r3
	}
    2f16:	movs	r0, #0
    2f18:	movs	r1, #0
    2f1a:	bx	lr

00002f1c <File::close()>:
	virtual void close() {
		if (f) f->close();
    2f1c:	ldr	r0, [r0, #16]
    2f1e:	cbz	r0, 2f26 <File::close()+0xa>
    2f20:	ldr	r3, [r0, #0]
    2f22:	ldr	r3, [r3, #64]	; 0x40
    2f24:	bx	r3
    2f26:	bx	lr

00002f28 <File::operator bool()>:
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2f28:	ldr	r0, [r0, #16]
    2f2a:	cbz	r0, 2f32 <File::operator bool()+0xa>
    2f2c:	ldr	r3, [r0, #0]
    2f2e:	ldr	r3, [r3, #68]	; 0x44
    2f30:	bx	r3
	}
    2f32:	bx	lr

00002f34 <File::name()>:
	virtual const char* name() {
		return (f) ? f->name() : "";
    2f34:	ldr	r0, [r0, #16]
    2f36:	cbz	r0, 2f3e <File::name()+0xa>
    2f38:	ldr	r3, [r0, #0]
    2f3a:	ldr	r3, [r3, #72]	; 0x48
    2f3c:	bx	r3
	}
    2f3e:	ldr	r0, [pc, #4]	; (2f44 <File::name()+0x10>)
    2f40:	bx	lr
    2f42:	nop
    2f44:	.word	0x000131e4

00002f48 <File::isDirectory()>:
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    2f48:	ldr	r0, [r0, #16]
    2f4a:	cbz	r0, 2f52 <File::isDirectory()+0xa>
    2f4c:	ldr	r3, [r0, #0]
    2f4e:	ldr	r3, [r3, #76]	; 0x4c
    2f50:	bx	r3
	}
    2f52:	bx	lr

00002f54 <File::openNextFile(unsigned char)>:
	virtual File openNextFile(uint8_t mode=0) {
    2f54:	push	{r3, r4, r5, lr}
		return (f) ? f->openNextFile(mode) : *this;
    2f56:	ldr	r3, [r1, #16]
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
    2f58:	mov	r4, r0
		return (f) ? f->openNextFile(mode) : *this;
    2f5a:	cbz	r3, 2f68 <File::openNextFile(unsigned char)+0x14>
    2f5c:	ldr	r5, [r3, #0]
    2f5e:	mov	r1, r3
    2f60:	ldr	r3, [r5, #80]	; 0x50
    2f62:	blx	r3
	}
    2f64:	mov	r0, r4
    2f66:	pop	{r3, r4, r5, pc}
    2f68:	mov.w	r0, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    2f6c:	ldr	r2, [pc, #24]	; (2f88 <File::openNextFile(unsigned char)+0x34>)
    2f6e:	strb	r3, [r4, #4]
    2f70:	strb	r3, [r4, #12]
    2f72:	str	r0, [r4, #8]
    2f74:	str	r2, [r4, #0]
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    2f76:	ldr	r3, [r1, #16]
    2f78:	str	r3, [r4, #16]
		if (f) f->refcount++;
    2f7a:	cmp	r3, #0
    2f7c:	beq.n	2f64 <File::openNextFile(unsigned char)+0x10>
    2f7e:	ldr	r2, [r3, #16]
    2f80:	adds	r2, #1
    2f82:	str	r2, [r3, #16]
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
	}
    2f84:	mov	r0, r4
    2f86:	pop	{r3, r4, r5, pc}
    2f88:	.word	0x0001360c

00002f8c <File::rewindDirectory()>:
	virtual void rewindDirectory(void) {
		if (f) f->rewindDirectory();
    2f8c:	ldr	r0, [r0, #16]
    2f8e:	cbz	r0, 2f96 <File::rewindDirectory()+0xa>
    2f90:	ldr	r3, [r0, #0]
    2f92:	ldr	r3, [r3, #84]	; 0x54
    2f94:	bx	r3
    2f96:	bx	lr

00002f98 <File::read()>:
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
    2f98:	ldr	r0, [r0, #16]
    2f9a:	cbz	r0, 2fbe <File::read()+0x26>
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
    2f9c:	push	{lr}
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
    2f9e:	ldr	r3, [r0, #0]
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
    2fa0:	sub	sp, #12
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
    2fa2:	ldr	r3, [r3, #40]	; 0x28
    2fa4:	movs	r2, #1
    2fa6:	add.w	r1, sp, #7
    2faa:	blx	r3
    2fac:	cbz	r0, 2fb8 <File::read()+0x20>
		return b;
    2fae:	ldrb.w	r0, [sp, #7]
	}
    2fb2:	add	sp, #12
    2fb4:	ldr.w	pc, [sp], #4
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
    2fb8:	mov.w	r0, #4294967295
    2fbc:	b.n	2fb2 <File::read()+0x1a>
    2fbe:	mov.w	r0, #4294967295
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
    2fc2:	bx	lr

00002fc4 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
    2fc4:	push	{r4, lr}
    2fc6:	sub	sp, #8
    2fc8:	add	r3, sp, #8
		return write(&b, 1);
    2fca:	ldr	r2, [r0, #0]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
    2fcc:	strb.w	r1, [r3, #-1]!
		return write(&b, 1);
    2fd0:	ldr	r4, [r2, #44]	; 0x2c
    2fd2:	mov	r1, r3
    2fd4:	movs	r2, #1
    2fd6:	blx	r4
	}
    2fd8:	add	sp, #8
    2fda:	pop	{r4, pc}

00002fdc <SDFile::operator bool()>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    2fdc:	ldr	r3, [r0, #92]	; 0x5c
    2fde:	cbz	r3, 2fe4 <SDFile::operator bool()+0x8>
    2fe0:	movs	r0, #1
		}
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
    2fe2:	bx	lr
    2fe4:	ldr	r0, [r0, #96]	; 0x60
    2fe6:	adds	r0, #0
    2fe8:	it	ne
    2fea:	movne	r0, #1
    2fec:	bx	lr
    2fee:	nop

00002ff0 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
    2ff0:	push	{r4, lr}
    2ff2:	mov	r4, r0
		if (filename) {
    2ff4:	ldr	r0, [r0, #100]	; 0x64
    2ff6:	cbz	r0, 3000 <SDFile::close()+0x10>
			free(filename);
    2ff8:	bl	bd20 <free>
			filename = nullptr;
    2ffc:	movs	r3, #0
    2ffe:	str	r3, [r4, #100]	; 0x64
		}
		sdfatfile.close();
    3000:	add.w	r0, r4, #36	; 0x24
	}
    3004:	ldmia.w	sp!, {r4, lr}
	virtual void close() {
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		sdfatfile.close();
    3008:	b.w	7660 <FsBaseFile::close()>

0000300c <File::whoami()>:
	}
	virtual ~File() {
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
    300c:	push	{r4, lr}
    300e:	mov	r4, r0
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
    3010:	mov	r2, r0
    3012:	ldr	r3, [r0, #16]
    3014:	ldr	r1, [pc, #20]	; (302c <File::whoami()+0x20>)
    3016:	ldr	r0, [pc, #24]	; (3030 <File::whoami()+0x24>)
    3018:	bl	a990 <Print::printf(char const*, ...)>
		if (f) f->whoami();
    301c:	ldr	r0, [r4, #16]
    301e:	cbz	r0, 302a <File::whoami()+0x1e>
    3020:	ldr	r3, [r0, #0]
	}
    3022:	ldmia.w	sp!, {r4, lr}
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
		if (f) f->whoami();
    3026:	ldr	r3, [r3, #36]	; 0x24
    3028:	bx	r3
    302a:	pop	{r4, pc}
    302c:	.word	0x000136c4
    3030:	.word	0x200138e4

00003034 <SDFile::whoami()>:
		if (filename) free(filename);
	}
#ifdef FILE_WHOAMI
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
    3034:	mov	r2, r0
    3036:	ldr	r3, [r0, #16]
    3038:	ldr	r1, [pc, #4]	; (3040 <SDFile::whoami()+0xc>)
    303a:	ldr	r0, [pc, #8]	; (3044 <SDFile::whoami()+0x10>)
    303c:	b.w	a990 <Print::printf(char const*, ...)>
    3040:	.word	0x000136e0
    3044:	.word	0x200138e4

00003048 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
    3048:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    304c:	movs	r3, #0
    304e:	sub	sp, #80	; 0x50
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
    3050:	mov	r2, r3
    3052:	mov	r5, r0
    3054:	adds	r1, #36	; 0x24
    3056:	add	r0, sp, #16
    3058:	mov.w	r4, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    305c:	ldr	r7, [pc, #148]	; (30f4 <SDFile::openNextFile(unsigned char)+0xac>)
    305e:	strb.w	r3, [sp, #4]
    3062:	strb.w	r3, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    3066:	str	r3, [sp, #72]	; 0x48
    3068:	str	r3, [sp, #76]	; 0x4c
    306a:	str	r4, [sp, #8]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    306c:	str	r7, [sp, #0]
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
    306e:	bl	7708 <FsBaseFile::openNext(FsBaseFile*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    3072:	ldr	r3, [sp, #72]	; 0x48
    3074:	cmp	r3, #0
    3076:	beq.n	30de <SDFile::openNextFile(unsigned char)+0x96>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
    3078:	movs	r0, #104	; 0x68
    307a:	bl	ae58 <operator new(unsigned int)>
    307e:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    3080:	ldrb.w	r6, [sp, #4]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    3084:	ldr	r2, [sp, #8]
    3086:	ldrb.w	r3, [sp, #12]
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
    308a:	ldr	r0, [pc, #108]	; (30f8 <SDFile::openNextFile(unsigned char)+0xb0>)
    308c:	ldr	r1, [pc, #108]	; (30fc <SDFile::openNextFile(unsigned char)+0xb4>)
    308e:	strb	r6, [r4, #24]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    3090:	mov.w	r8, #1000	; 0x3e8
{
  public:
	constexpr Print() : write_error(0) {}
    3094:	movs	r6, #0
    3096:	str	r0, [r4, #0]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    3098:	str	r1, [r4, #20]
    309a:	str	r2, [r4, #28]
    309c:	strb.w	r3, [r4, #32]
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
    30a0:	add.w	r0, r4, #36	; 0x24
    30a4:	add	r1, sp, #16
    30a6:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    30a8:	strb	r6, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    30aa:	str	r6, [r4, #16]
    30ac:	str.w	r8, [r4, #8]
    30b0:	bl	75e8 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    30b4:	ldr	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    30b6:	ldr	r2, [pc, #72]	; (3100 <SDFile::openNextFile(unsigned char)+0xb8>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    30b8:	str	r7, [r4, #20]
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    30ba:	adds	r3, #1
    30bc:	str	r6, [r4, #100]	; 0x64
    30be:	strb	r6, [r5, #4]
    30c0:	str.w	r8, [r5, #8]
    30c4:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
    30c6:	str	r4, [r5, #16]
		if (f) f->refcount++;
    30c8:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    30ca:	str	r2, [r5, #0]
    30cc:	ldr	r3, [pc, #52]	; (3104 <SDFile::openNextFile(unsigned char)+0xbc>)
    30ce:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    30d0:	add	r0, sp, #16
    30d2:	bl	7660 <FsBaseFile::close()>
	}
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
    30d6:	mov	r0, r5
    30d8:	add	sp, #80	; 0x50
    30da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    30de:	ldr	r3, [sp, #76]	; 0x4c
    30e0:	cmp	r3, #0
    30e2:	bne.n	3078 <SDFile::openNextFile(unsigned char)+0x30>

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    30e4:	ldr	r2, [pc, #24]	; (3100 <SDFile::openNextFile(unsigned char)+0xb8>)
    30e6:	strb	r3, [r5, #4]
    30e8:	str	r4, [r5, #8]
    30ea:	strb	r3, [r5, #12]
    30ec:	str	r3, [r5, #16]
    30ee:	str	r2, [r5, #0]
    30f0:	b.n	30cc <SDFile::openNextFile(unsigned char)+0x84>
    30f2:	nop
    30f4:	.word	0x000130e8
    30f8:	.word	0x0001366c
    30fc:	.word	0x000135e8
    3100:	.word	0x0001360c
    3104:	.word	0x000130c4

00003108 <SDFile::peek()>:
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
    3108:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
    310a:	cbz	r3, 3112 <SDFile::peek()+0xa>
    310c:	mov	r0, r3
    310e:	b.w	6100 <FatFile::peek()>
    3112:	ldr	r0, [r0, #96]	; 0x60
    3114:	cbz	r0, 311a <SDFile::peek()+0x12>
    3116:	b.w	44b4 <ExFatFile::peek()>
		return sdfatfile.peek();
	}
    311a:	mov.w	r0, #4294967295
    311e:	bx	lr

00003120 <SDFile::flush()>:
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
    3120:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
    3122:	cbz	r3, 312a <SDFile::flush()+0xa>
    3124:	mov	r0, r3
    3126:	b.w	65a4 <FatFile::sync()>
    312a:	ldr	r0, [r0, #96]	; 0x60
    312c:	cbz	r0, 3132 <SDFile::flush()+0x12>
    312e:	b.w	5350 <ExFatFile::sync()>
    3132:	bx	lr

00003134 <SDFile::name()>:
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
    3134:	push	{r3, r4, r5, lr}
		if (!filename) {
    3136:	ldr	r4, [r0, #100]	; 0x64
    3138:	cbz	r4, 313e <SDFile::name()+0xa>
				static char zeroterm = 0;
				filename = &zeroterm;
			}
		}
		return filename;
	}
    313a:	mov	r0, r4
    313c:	pop	{r3, r4, r5, pc}
    313e:	mov	r5, r0
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
		if (!filename) {
			filename = (char *)malloc(MAX_FILENAME_LEN);
    3140:	mov.w	r0, #256	; 0x100
    3144:	bl	bd10 <malloc>
    3148:	mov	r1, r0
    314a:	str	r0, [r5, #100]	; 0x64
			if (filename) {
    314c:	cbz	r0, 3170 <SDFile::name()+0x3c>
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    return m_fFile ? m_fFile->getName(name, len) :
    314e:	ldr	r0, [r5, #92]	; 0x5c
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    3150:	strb	r4, [r1, #0]
    return m_fFile ? m_fFile->getName(name, len) :
           m_xFile ? m_xFile->getName(name, len) : 0;
    3152:	cbz	r0, 3160 <SDFile::name()+0x2c>
    3154:	mov.w	r2, #256	; 0x100
    3158:	bl	6cc8 <FatFile::getName(char*, unsigned int)>
    315c:	ldr	r4, [r5, #100]	; 0x64
    315e:	b.n	313a <SDFile::name()+0x6>
    3160:	ldr	r0, [r5, #96]	; 0x60
    3162:	cbz	r0, 3176 <SDFile::name()+0x42>
    3164:	mov.w	r2, #256	; 0x100
    3168:	bl	4170 <ExFatFile::getName(char*, unsigned int)>
    316c:	ldr	r4, [r5, #100]	; 0x64
    316e:	b.n	313a <SDFile::name()+0x6>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
    3170:	ldr	r4, [pc, #8]	; (317c <SDFile::name()+0x48>)
    3172:	str	r4, [r5, #100]	; 0x64
    3174:	b.n	313a <SDFile::name()+0x6>
    3176:	mov	r4, r1
    3178:	b.n	313a <SDFile::name()+0x6>
    317a:	nop
    317c:	.word	0x20019654

00003180 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
    3180:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
    3182:	cbz	r3, 31ac <SDFile::rewindDirectory()+0x2c>
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
    3184:	ldrb	r2, [r3, #0]
    3186:	tst.w	r2, #112	; 0x70
    318a:	bne.n	318e <SDFile::rewindDirectory()+0xe>
    318c:	bx	lr
    318e:	push	{r4, lr}
    3190:	mov	r4, r0
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    3192:	movs	r1, #0
    3194:	mov	r0, r3
    3196:	bl	639c <FatFile::seekSet(unsigned long)>
    319a:	ldr	r0, [r4, #96]	; 0x60
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
    if (m_xFile) m_xFile->rewind();
    319c:	cbz	r0, 31aa <SDFile::rewindDirectory()+0x2a>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    319e:	movs	r2, #0
    31a0:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
    31a2:	ldmia.w	sp!, {r4, lr}
    31a6:	b.w	44e4 <ExFatFile::seekSet(unsigned long long)>
    31aa:	pop	{r4, pc}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
    31ac:	ldr	r0, [r0, #96]	; 0x60
    31ae:	cmp	r0, #0
    31b0:	beq.n	318c <SDFile::rewindDirectory()+0xc>
    31b2:	ldrb.w	r3, [r0, #49]	; 0x31
    31b6:	tst.w	r3, #80	; 0x50
    31ba:	beq.n	318c <SDFile::rewindDirectory()+0xc>
    31bc:	movs	r2, #0
    31be:	movs	r3, #0
    31c0:	b.w	44e4 <ExFatFile::seekSet(unsigned long long)>

000031c4 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
    31c4:	push	{r4, r6, r7, lr}
    31c6:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
           m_xFile ? m_xFile->truncate(length) : false;
    31c8:	cbz	r4, 31ee <SDFile::truncate(unsigned long long)+0x2a>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
    31ca:	cmp	r3, #1
    31cc:	it	eq
    31ce:	cmpeq	r2, #0
    31d0:	bcc.n	31d6 <SDFile::truncate(unsigned long long)+0x12>
    31d2:	movs	r0, #0
		return sdfatfile.truncate(size);
	}
    31d4:	pop	{r4, r6, r7, pc}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
    31d6:	mov	r1, r2
    31d8:	mov	r0, r4
    31da:	bl	639c <FatFile::seekSet(unsigned long)>
    31de:	cmp	r0, #0
    31e0:	beq.n	31d2 <SDFile::truncate(unsigned long long)+0xe>
    31e2:	mov	r0, r4
    31e4:	bl	65b0 <FatFile::truncate()>
    31e8:	cmp	r0, #0
    31ea:	beq.n	31d2 <SDFile::truncate(unsigned long long)+0xe>
    31ec:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
    31ee:	ldr	r4, [r0, #96]	; 0x60
    31f0:	cmp	r4, #0
    31f2:	beq.n	31d2 <SDFile::truncate(unsigned long long)+0xe>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    31f4:	mov	r0, r4
    31f6:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
    31fa:	cmp	r0, #0
    31fc:	beq.n	31d2 <SDFile::truncate(unsigned long long)+0xe>
    31fe:	mov	r0, r4
    3200:	ldmia.w	sp!, {r4, r6, r7, lr}
    3204:	b.w	5704 <ExFatFile::truncate()>

00003208 <SDFile::size()>:
		return false;
	}
	virtual uint64_t position() {
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
    3208:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
    320a:	cbz	r3, 3212 <SDFile::size()+0xa>
    320c:	ldr	r0, [r3, #28]
    320e:	movs	r1, #0
    3210:	bx	lr
    3212:	ldr	r3, [r0, #96]	; 0x60
    3214:	cbz	r3, 321c <SDFile::size()+0x14>
    3216:	ldr	r0, [r3, #16]
    3218:	ldr	r1, [r3, #20]
    321a:	bx	lr
    321c:	mov	r0, r3
    321e:	mov	r1, r3
		return sdfatfile.size();
	}
    3220:	bx	lr
    3222:	nop

00003224 <SDFile::position()>:
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
		return false;
	}
	virtual uint64_t position() {
    3224:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
    3226:	cbz	r3, 322e <SDFile::position()+0xa>
    3228:	ldr	r0, [r3, #20]
    322a:	movs	r1, #0
    322c:	bx	lr
    322e:	ldr	r3, [r0, #96]	; 0x60
    3230:	cbz	r3, 3238 <SDFile::position()+0x14>
    3232:	ldmia.w	r3, {r0, r1}
    3236:	bx	lr
    3238:	mov	r0, r3
    323a:	mov	r1, r3
		return sdfatfile.curPosition();
	}
    323c:	bx	lr
    323e:	nop

00003240 <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
    3240:	ldr	r3, [r0, #92]	; 0x5c
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
    3242:	cbz	r3, 324a <SDFile::read(void*, unsigned int)+0xa>
    3244:	mov	r0, r3
    3246:	b.w	5f60 <FatFile::read(void*, unsigned int)>
    324a:	ldr	r0, [r0, #96]	; 0x60
    324c:	cbz	r0, 3252 <SDFile::read(void*, unsigned int)+0x12>
    324e:	b.w	430c <ExFatFile::read(void*, unsigned int)>
		return sdfatfile.read(buf, nbyte);
	}
    3252:	mov.w	r0, #4294967295
    3256:	bx	lr

00003258 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
    3258:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
    325a:	cbz	r3, 326a <SDFile::isDirectory()+0x12>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
    325c:	ldrb	r3, [r3, #0]
    325e:	tst.w	r3, #112	; 0x70
    3262:	ite	ne
    3264:	movne	r0, #1
    3266:	moveq	r0, #0
    3268:	bx	lr
    326a:	ldr	r0, [r0, #96]	; 0x60
    326c:	cbz	r0, 327c <SDFile::isDirectory()+0x24>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
    326e:	ldrb.w	r3, [r0, #49]	; 0x31
    3272:	tst.w	r3, #80	; 0x50
    3276:	ite	ne
    3278:	movne	r0, #1
    327a:	moveq	r0, #0
		return sdfatfile.isDirectory();
	}
    327c:	bx	lr
    327e:	nop

00003280 <SDFile::write(void const*, unsigned int)>:
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
    3280:	ldr	r3, [r0, #92]	; 0x5c
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
    3282:	cbz	r3, 328a <SDFile::write(void const*, unsigned int)+0xa>
    3284:	mov	r0, r3
    3286:	b.w	6628 <FatFile::write(void const*, unsigned int)>
    328a:	ldr	r0, [r0, #96]	; 0x60
    328c:	cbz	r0, 3292 <SDFile::write(void const*, unsigned int)+0x12>
    328e:	b.w	57e8 <ExFatFile::write(void const*, unsigned int)>
		return sdfatfile.write(buf, size);
	}
    3292:	bx	lr

00003294 <SDFile::available()>:
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
    3294:	ldr	r2, [r0, #92]	; 0x5c
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
    3296:	cbz	r2, 32b2 <SDFile::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
    3298:	ldrb	r3, [r2, #0]
    329a:	and.w	r3, r3, #8
    329e:	and.w	r0, r3, #255	; 0xff
    32a2:	cbz	r3, 32e6 <SDFile::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
    32a4:	ldr	r3, [r2, #28]
    32a6:	ldr	r0, [r2, #20]
    32a8:	subs	r0, r3, r0
    32aa:	it	mi
    32ac:	mvnmi.w	r0, #2147483648	; 0x80000000
    32b0:	bx	lr
    32b2:	ldr	r1, [r0, #96]	; 0x60
    32b4:	cbz	r1, 32e8 <SDFile::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
    32b6:	ldrb.w	r3, [r1, #49]	; 0x31
    32ba:	and.w	r3, r3, #8
    32be:	and.w	r0, r3, #255	; 0xff
    32c2:	cbz	r3, 32e6 <SDFile::available()+0x52>
    32c4:	ldrd	r2, r3, [r1, #16]
    32c8:	ldrd	r0, r1, [r1]
    32cc:	subs	r0, r2, r0
    32ce:	push	{r4, r5}
    32d0:	sbc.w	r1, r3, r1
    32d4:	movs	r5, #0
    32d6:	mvn.w	r4, #2147483648	; 0x80000000
    32da:	cmp	r5, r1
    32dc:	it	eq
    32de:	cmpeq	r4, r0
    32e0:	bcs.n	32e4 <SDFile::available()+0x50>
    32e2:	mov	r0, r4
		return sdfatfile.available();
	}
    32e4:	pop	{r4, r5}
    32e6:	bx	lr
    32e8:	mov	r0, r1
    32ea:	bx	lr

000032ec <SDFile::seek(unsigned long long, int)>:
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
    32ec:	push	{r4, r6, r7}
    32ee:	ldr	r4, [sp, #12]
    32f0:	mov	r6, r2
    32f2:	mov	r7, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
    32f4:	cbz	r4, 3304 <SDFile::seek(unsigned long long, int)+0x18>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
    32f6:	cmp	r4, #1
    32f8:	beq.n	3338 <SDFile::seek(unsigned long long, int)+0x4c>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
    32fa:	cmp	r4, #2
    32fc:	beq.n	331a <SDFile::seek(unsigned long long, int)+0x2e>
		return false;
	}
    32fe:	movs	r0, #0
    3300:	pop	{r4, r6, r7}
    3302:	bx	lr
    3304:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    3306:	cbz	r4, 3340 <SDFile::seek(unsigned long long, int)+0x54>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
    3308:	cmp	r3, #1
    330a:	it	eq
    330c:	cmpeq	r2, #0
    330e:	bcs.n	32fe <SDFile::seek(unsigned long long, int)+0x12>
    3310:	mov	r0, r4
    3312:	mov	r1, r2
    3314:	pop	{r4, r6, r7}
    3316:	b.w	639c <FatFile::seekSet(unsigned long)>
    331a:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
    331c:	cbz	r3, 334c <SDFile::seek(unsigned long long, int)+0x60>
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
    331e:	ldr	r2, [r3, #28]
    3320:	adds	r6, r6, r2
    3322:	adc.w	r7, r7, #0
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
    3326:	cmp	r7, #1
    3328:	it	eq
    332a:	cmpeq	r6, #0
    332c:	bcs.n	32fe <SDFile::seek(unsigned long long, int)+0x12>
    332e:	mov	r1, r6
    3330:	mov	r0, r3
    3332:	pop	{r4, r6, r7}
    3334:	b.w	639c <FatFile::seekSet(unsigned long)>
    3338:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
    333a:	cbz	r3, 3360 <SDFile::seek(unsigned long long, int)+0x74>
  /** Set the files position to current position + \a pos. See seekSet().
   * \param[in] offset The new position in bytes from the current position.
   * \return true for success or false for failure.
   */
  bool seekCur(int64_t offset) {
    return seekSet(curPosition() + offset);
    333c:	ldr	r2, [r3, #20]
    333e:	b.n	3320 <SDFile::seek(unsigned long long, int)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    3340:	ldr	r0, [r0, #96]	; 0x60
    3342:	cmp	r0, #0
    3344:	beq.n	32fe <SDFile::seek(unsigned long long, int)+0x12>
    3346:	pop	{r4, r6, r7}
    3348:	b.w	44e4 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
    334c:	ldr	r0, [r0, #96]	; 0x60
    334e:	cmp	r0, #0
    3350:	beq.n	32fe <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    3352:	ldrd	r2, r3, [r0, #16]
    3356:	adds	r2, r2, r6
    3358:	adcs	r3, r7
    335a:	pop	{r4, r6, r7}
    335c:	b.w	44e4 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
    3360:	ldr	r0, [r0, #96]	; 0x60
    3362:	cmp	r0, #0
    3364:	beq.n	32fe <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    3366:	ldrd	r2, r3, [r0]
    336a:	adds	r2, r2, r6
    336c:	adcs	r3, r7
    336e:	b.n	3346 <SDFile::seek(unsigned long long, int)+0x5a>

00003370 <File::~File()>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3370:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3372:	ldr	r3, [pc, #32]	; (3394 <File::~File()+0x24>)
    3374:	push	{r4, lr}
    3376:	mov	r4, r0
    3378:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    337a:	cbz	r2, 338e <File::~File()+0x1e>
    337c:	ldr	r3, [r2, #16]
    337e:	subs	r3, #1
    3380:	str	r3, [r2, #16]
    3382:	cbnz	r3, 338e <File::~File()+0x1e>
    3384:	ldr	r0, [r0, #16]
    3386:	cbz	r0, 338e <File::~File()+0x1e>
    3388:	ldr	r3, [r0, #0]
    338a:	ldr	r3, [r3, #32]
    338c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    338e:	mov	r0, r4
    3390:	pop	{r4, pc}
    3392:	nop
    3394:	.word	0x0001360c

00003398 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
    3398:	push	{r3, r4, r5, lr}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    339a:	ldr	r3, [r0, #92]	; 0x5c
    339c:	ldr	r2, [pc, #80]	; (33f0 <SDFile::~SDFile()+0x58>)
    339e:	str	r2, [r0, #0]
    33a0:	mov	r4, r0
		if (sdfatfile) sdfatfile.close();
    33a2:	add.w	r5, r0, #36	; 0x24
    33a6:	cbz	r3, 33e6 <SDFile::~SDFile()+0x4e>
    33a8:	mov	r0, r5
    33aa:	bl	7660 <FsBaseFile::close()>
		if (filename) free(filename);
    33ae:	ldr	r0, [r4, #100]	; 0x64
    33b0:	cbz	r0, 33b6 <SDFile::~SDFile()+0x1e>
    33b2:	bl	bd20 <free>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
    33b6:	ldr	r3, [pc, #60]	; (33f4 <SDFile::~SDFile()+0x5c>)
    33b8:	str	r3, [r4, #20]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    33ba:	mov	r0, r5
    33bc:	bl	7660 <FsBaseFile::close()>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    33c0:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    33c2:	ldr	r3, [pc, #52]	; (33f8 <SDFile::~SDFile()+0x60>)
    33c4:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    33c6:	cbz	r2, 33da <SDFile::~SDFile()+0x42>
    33c8:	ldr	r3, [r2, #16]
    33ca:	subs	r3, #1
    33cc:	str	r3, [r2, #16]
    33ce:	cbnz	r3, 33da <SDFile::~SDFile()+0x42>
    33d0:	ldr	r0, [r4, #16]
    33d2:	cbz	r0, 33da <SDFile::~SDFile()+0x42>
    33d4:	ldr	r3, [r0, #0]
    33d6:	ldr	r3, [r3, #32]
    33d8:	blx	r3
	}
    33da:	mov	r0, r4
    33dc:	movs	r1, #104	; 0x68
    33de:	bl	ae5c <operator delete(void*, unsigned int)>
    33e2:	mov	r0, r4
    33e4:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    33e6:	ldr	r3, [r0, #96]	; 0x60
    33e8:	cmp	r3, #0
    33ea:	bne.n	33a8 <SDFile::~SDFile()+0x10>
    33ec:	b.n	33ae <SDFile::~SDFile()+0x16>
    33ee:	nop
    33f0:	.word	0x0001366c
    33f4:	.word	0x000130c4
    33f8:	.word	0x0001360c

000033fc <File::~File()>:
    33fc:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    33fe:	ldr	r3, [pc, #40]	; (3428 <File::~File()+0x2c>)
    3400:	push	{r4, lr}
    3402:	mov	r4, r0
    3404:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3406:	cbz	r2, 341a <File::~File()+0x1e>
    3408:	ldr	r3, [r2, #16]
    340a:	subs	r3, #1
    340c:	str	r3, [r2, #16]
    340e:	cbnz	r3, 341a <File::~File()+0x1e>
    3410:	ldr	r0, [r0, #16]
    3412:	cbz	r0, 341a <File::~File()+0x1e>
    3414:	ldr	r3, [r0, #0]
    3416:	ldr	r3, [r3, #32]
    3418:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    341a:	mov	r0, r4
    341c:	movs	r1, #20
    341e:	bl	ae5c <operator delete(void*, unsigned int)>
    3422:	mov	r0, r4
    3424:	pop	{r4, pc}
    3426:	nop
    3428:	.word	0x0001360c

0000342c <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
    342c:	push	{r3, r4, r5, lr}
    342e:	ldr	r3, [r0, #92]	; 0x5c
    3430:	ldr	r2, [pc, #72]	; (347c <SDFile::~SDFile()+0x50>)
    3432:	str	r2, [r0, #0]
    3434:	mov	r4, r0
		if (sdfatfile) sdfatfile.close();
    3436:	add.w	r5, r0, #36	; 0x24
    343a:	cbz	r3, 3472 <SDFile::~SDFile()+0x46>
    343c:	mov	r0, r5
    343e:	bl	7660 <FsBaseFile::close()>
		if (filename) free(filename);
    3442:	ldr	r0, [r4, #100]	; 0x64
    3444:	cbz	r0, 344a <SDFile::~SDFile()+0x1e>
    3446:	bl	bd20 <free>
    344a:	ldr	r3, [pc, #52]	; (3480 <SDFile::~SDFile()+0x54>)
    344c:	str	r3, [r4, #20]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    344e:	mov	r0, r5
    3450:	bl	7660 <FsBaseFile::close()>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3454:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3456:	ldr	r3, [pc, #44]	; (3484 <SDFile::~SDFile()+0x58>)
    3458:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    345a:	cbz	r2, 346e <SDFile::~SDFile()+0x42>
    345c:	ldr	r3, [r2, #16]
    345e:	subs	r3, #1
    3460:	str	r3, [r2, #16]
    3462:	cbnz	r3, 346e <SDFile::~SDFile()+0x42>
    3464:	ldr	r0, [r4, #16]
    3466:	cbz	r0, 346e <SDFile::~SDFile()+0x42>
    3468:	ldr	r3, [r0, #0]
    346a:	ldr	r3, [r3, #32]
    346c:	blx	r3
	}
    346e:	mov	r0, r4
    3470:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    3472:	ldr	r3, [r0, #96]	; 0x60
    3474:	cmp	r3, #0
    3476:	bne.n	343c <SDFile::~SDFile()+0x10>
    3478:	b.n	3442 <SDFile::~SDFile()+0x16>
    347a:	nop
    347c:	.word	0x0001366c
    3480:	.word	0x000130c4
    3484:	.word	0x0001360c

00003488 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
    3488:	ldr	r2, [pc, #8]	; (3494 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
    348a:	ldr	r1, [pc, #12]	; (3498 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
    348c:	ldr	r0, [pc, #12]	; (349c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
    348e:	b.w	af34 <__aeabi_atexit>
    3492:	nop
    3494:	.word	0x20013730
    3498:	.word	0x000027c9
    349c:	.word	0x20019658

000034a0 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
    34a0:	ldr	r2, [pc, #8]	; (34ac <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0xc>)
    34a2:	ldr	r1, [pc, #12]	; (34b0 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x10>)
    34a4:	ldr	r0, [pc, #12]	; (34b4 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x14>)
    34a6:	b.w	af34 <__aeabi_atexit>
    34aa:	nop
    34ac:	.word	0x20013730
    34b0:	.word	0x000027c9
    34b4:	.word	0x20019660

000034b8 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
    34b8:	ldr	r2, [pc, #8]	; (34c4 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
    34ba:	ldr	r1, [pc, #12]	; (34c8 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
    34bc:	ldr	r0, [pc, #12]	; (34cc <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
    34be:	b.w	af34 <__aeabi_atexit>
    34c2:	nop
    34c4:	.word	0x20013730
    34c8:	.word	0x000027c9
    34cc:	.word	0x20019668

000034d0 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
    34d0:	ldr	r2, [pc, #8]	; (34dc <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
    34d2:	ldr	r1, [pc, #12]	; (34e0 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
    34d4:	ldr	r0, [pc, #12]	; (34e4 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
    34d6:	b.w	af34 <__aeabi_atexit>
    34da:	nop
    34dc:	.word	0x20013730
    34e0:	.word	0x000027c9
    34e4:	.word	0x20019670

000034e8 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
    34e8:	ldr	r2, [pc, #8]	; (34f4 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0xc>)
    34ea:	ldr	r1, [pc, #12]	; (34f8 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x10>)
    34ec:	ldr	r0, [pc, #12]	; (34fc <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x14>)
    34ee:	b.w	af34 <__aeabi_atexit>
    34f2:	nop
    34f4:	.word	0x20013730
    34f8:	.word	0x000027c9
    34fc:	.word	0x20019678

00003500 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE>:

DMAMEM __attribute__((aligned(32))) static uint32_t pdm_buffer[AUDIO_BLOCK_SAMPLES*4];
static uint32_t leftover[14];
audio_block_t * AudioInputPDM::block_left = NULL;
bool AudioInputPDM::update_responsibility = false;
DMAChannel AudioInputPDM::dma(false);
    3500:	ldr	r2, [pc, #8]	; (350c <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0xc>)
    3502:	ldr	r1, [pc, #12]	; (3510 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x10>)
    3504:	ldr	r0, [pc, #12]	; (3514 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x14>)
    3506:	b.w	af34 <__aeabi_atexit>
    350a:	nop
    350c:	.word	0x20013730
    3510:	.word	0x000027c9
    3514:	.word	0x20019680

00003518 <AudioOutputI2S::config_i2s(bool)>:


void AudioOutputI2S::config_i2s(bool only_bclk)
{
#if defined(KINETISK)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
    3518:	ldr	r3, [pc, #184]	; (35d4 <AudioOutputI2S::config_i2s(bool)+0xbc>)
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    351a:	ldr	r1, [pc, #188]	; (35d8 <AudioOutputI2S::config_i2s(bool)+0xc0>)


void AudioOutputI2S::config_i2s(bool only_bclk)
{
#if defined(KINETISK)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
    351c:	ldr	r2, [r3, #0]
    351e:	orr.w	r2, r2, #32768	; 0x8000
#endif
#endif


void AudioOutputI2S::config_i2s(bool only_bclk)
{
    3522:	push	{r4, r5, r6, r7, lr}
#if defined(KINETISK)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
    3524:	str	r2, [r3, #0]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    3526:	ldr	r2, [r1, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;

	// if either transmitter or receiver is enabled, do nothing
	if ((I2S0_TCSR & I2S_TCSR_TE) != 0 || (I2S0_RCSR & I2S_RCSR_RE) != 0)
    3528:	ldr	r4, [pc, #176]	; (35dc <AudioOutputI2S::config_i2s(bool)+0xc4>)

void AudioOutputI2S::config_i2s(bool only_bclk)
{
#if defined(KINETISK)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    352a:	orr.w	r2, r2, #2
    352e:	str	r2, [r1, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    3530:	ldr	r2, [r3, #0]
    3532:	orr.w	r2, r2, #2
    3536:	str	r2, [r3, #0]

	// if either transmitter or receiver is enabled, do nothing
	if ((I2S0_TCSR & I2S_TCSR_TE) != 0 || (I2S0_RCSR & I2S_RCSR_RE) != 0)
    3538:	ldr	r3, [r4, #0]
    353a:	cmp	r3, #0
    353c:	blt.n	35c2 <AudioOutputI2S::config_i2s(bool)+0xaa>
    353e:	ldr	r3, [pc, #160]	; (35e0 <AudioOutputI2S::config_i2s(bool)+0xc8>)
    3540:	ldr	r3, [r3, #0]
    3542:	cmp	r3, #0
    3544:	blt.n	35c2 <AudioOutputI2S::config_i2s(bool)+0xaa>
	  }
	  return ;
	}

	// enable MCLK output
	I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
    3546:	ldr	r2, [pc, #156]	; (35e4 <AudioOutputI2S::config_i2s(bool)+0xcc>)
    3548:	mov.w	r3, #1124073472	; 0x43000000
    354c:	str	r3, [r2, #0]
	while (I2S0_MCR & I2S_MCR_DUF) ;
    354e:	ldr	r3, [r2, #0]
    3550:	cmp	r3, #0
    3552:	blt.n	354e <AudioOutputI2S::config_i2s(bool)+0x36>
	I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    3554:	ldr	r5, [pc, #144]	; (35e8 <AudioOutputI2S::config_i2s(bool)+0xd0>)

	// configure transmitter
	I2S0_TMR = 0;
    3556:	ldr	r4, [pc, #148]	; (35ec <AudioOutputI2S::config_i2s(bool)+0xd4>)
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
    3558:	ldr.w	lr, [pc, #196]	; 3620 <AudioOutputI2S::config_i2s(bool)+0x108>
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(1);
    355c:	ldr	r1, [pc, #144]	; (35f0 <AudioOutputI2S::config_i2s(bool)+0xd8>)
	I2S0_TCR3 = I2S_TCR3_TCE;
    355e:	ldr	r2, [pc, #148]	; (35f4 <AudioOutputI2S::config_i2s(bool)+0xdc>)
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
    3560:	ldr	r3, [pc, #148]	; (35f8 <AudioOutputI2S::config_i2s(bool)+0xe0>)
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
    3562:	ldr	r7, [pc, #152]	; (35fc <AudioOutputI2S::config_i2s(bool)+0xe4>)

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
    3564:	ldr	r6, [pc, #152]	; (3600 <AudioOutputI2S::config_i2s(bool)+0xe8>)
	}

	// enable MCLK output
	I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
	while (I2S0_MCR & I2S_MCR_DUF) ;
	I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    3566:	movw	ip, #4112	; 0x1010
    356a:	str.w	ip, [r5]

	// configure transmitter
	I2S0_TMR = 0;
    356e:	movs	r5, #0
    3570:	str	r5, [r4, #0]
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
    3572:	movs	r4, #1
    3574:	str.w	r4, [lr]
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(1);
    3578:	ldr.w	lr, [pc, #168]	; 3624 <AudioOutputI2S::config_i2s(bool)+0x10c>
    357c:	str.w	lr, [r1]
	I2S0_TCR3 = I2S_TCR3_TCE;
    3580:	mov.w	r1, #65536	; 0x10000
    3584:	str	r1, [r2, #0]
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
    3586:	ldr.w	lr, [pc, #160]	; 3628 <AudioOutputI2S::config_i2s(bool)+0x110>
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(1);
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
    358a:	ldr	r2, [pc, #120]	; (3604 <AudioOutputI2S::config_i2s(bool)+0xec>)
    358c:	str	r2, [r3, #0]
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
    358e:	ldr	r3, [pc, #120]	; (3608 <AudioOutputI2S::config_i2s(bool)+0xf0>)
    3590:	str	r3, [r7, #0]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
    3592:	str	r5, [r6, #0]
	I2S0_RCR1 = I2S_RCR1_RFW(1);
    3594:	str.w	r4, [lr]
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
    3598:	add.w	r4, r4, #1191182336	; 0x47000000
    359c:	str	r4, [r7, #116]	; 0x74
	I2S0_RCR3 = I2S_RCR3_RCE;
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
    359e:	ldr	r5, [pc, #108]	; (360c <AudioOutputI2S::config_i2s(bool)+0xf4>)
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    35a0:	ldr	r4, [pc, #108]	; (3610 <AudioOutputI2S::config_i2s(bool)+0xf8>)
	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
	I2S0_RCR3 = I2S_RCR3_RCE;
    35a2:	str.w	r1, [r6, #-84]
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
    35a6:	str	r2, [r5, #0]
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    35a8:	str	r3, [r4, #0]

	// configure pin mux for 3 clock signals
	if (!only_bclk)
    35aa:	cbnz	r0, 35b8 <AudioOutputI2S::config_i2s(bool)+0xa0>
	{
	  CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    35ac:	ldr	r1, [pc, #100]	; (3614 <AudioOutputI2S::config_i2s(bool)+0xfc>)
	  CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    35ae:	ldr	r2, [pc, #104]	; (3618 <AudioOutputI2S::config_i2s(bool)+0x100>)
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

	// configure pin mux for 3 clock signals
	if (!only_bclk)
	{
	  CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    35b0:	mov.w	r3, #1536	; 0x600
    35b4:	str	r3, [r1, #0]
	  CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    35b6:	str	r3, [r2, #0]
	}
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
    35b8:	ldr	r3, [pc, #96]	; (361c <AudioOutputI2S::config_i2s(bool)+0x104>)
    35ba:	mov.w	r2, #1536	; 0x600
    35be:	str	r2, [r3, #0]
    35c0:	pop	{r4, r5, r6, r7, pc}
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;

	// if either transmitter or receiver is enabled, do nothing
	if ((I2S0_TCSR & I2S_TCSR_TE) != 0 || (I2S0_RCSR & I2S_RCSR_RE) != 0)
	{
	  if (!only_bclk) // if previous transmitter/receiver only activated BCLK, activate the other clock pins now
    35c2:	cbnz	r0, 35d2 <AudioOutputI2S::config_i2s(bool)+0xba>
	  {
	    CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    35c4:	ldr	r1, [pc, #76]	; (3614 <AudioOutputI2S::config_i2s(bool)+0xfc>)
	    CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    35c6:	ldr	r2, [pc, #80]	; (3618 <AudioOutputI2S::config_i2s(bool)+0x100>)
	// if either transmitter or receiver is enabled, do nothing
	if ((I2S0_TCSR & I2S_TCSR_TE) != 0 || (I2S0_RCSR & I2S_RCSR_RE) != 0)
	{
	  if (!only_bclk) // if previous transmitter/receiver only activated BCLK, activate the other clock pins now
	  {
	    CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    35c8:	mov.w	r3, #1536	; 0x600
    35cc:	str	r3, [r1, #0]
	    CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    35ce:	str	r3, [r2, #0]
    35d0:	pop	{r4, r5, r6, r7, pc}
    35d2:	pop	{r4, r5, r6, r7, pc}
    35d4:	.word	0x4004803c
    35d8:	.word	0x40048040
    35dc:	.word	0x4002f000
    35e0:	.word	0x4002f080
    35e4:	.word	0x4002f100
    35e8:	.word	0x4002f104
    35ec:	.word	0x4002f060
    35f0:	.word	0x4002f008
    35f4:	.word	0x4002f00c
    35f8:	.word	0x4002f010
    35fc:	.word	0x4002f014
    3600:	.word	0x4002f0e0
    3604:	.word	0x00011f1b
    3608:	.word	0x1f1f1f00
    360c:	.word	0x4002f090
    3610:	.word	0x4002f094
    3614:	.word	0x4004b008
    3618:	.word	0x4004b018
    361c:	.word	0x4004b00c
    3620:	.word	0x4002f004
    3624:	.word	0x07000001
    3628:	.word	0x4002f084

0000362c <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
    362c:	ldr	r2, [pc, #8]	; (3638 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
    362e:	ldr	r1, [pc, #12]	; (363c <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
    3630:	ldr	r0, [pc, #12]	; (3640 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
    3632:	b.w	af34 <__aeabi_atexit>
    3636:	nop
    3638:	.word	0x20013730
    363c:	.word	0x000027c9
    3640:	.word	0x20019688

00003644 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
    3644:	ldr	r2, [pc, #8]	; (3650 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
    3646:	ldr	r1, [pc, #12]	; (3654 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
    3648:	ldr	r0, [pc, #12]	; (3658 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
    364a:	b.w	af34 <__aeabi_atexit>
    364e:	nop
    3650:	.word	0x20013730
    3654:	.word	0x000027c9
    3658:	.word	0x20019690

0000365c <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    365c:	ldrb.w	r2, [r0, #57]	; 0x39
    3660:	ldrb.w	r0, [r0, #56]	; 0x38
	}
    3664:	subs	r0, r2, r0
    3666:	bx	lr

00003668 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3668:	ldrb.w	r3, [r0, #56]	; 0x38
    366c:	ldrb.w	r2, [r0, #57]	; 0x39
    3670:	cmp	r2, r3
    3672:	bls.n	3680 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    3674:	adds	r2, r3, #1
    3676:	add	r3, r0
    3678:	strb.w	r2, [r0, #56]	; 0x38
    367c:	ldrb	r0, [r3, #24]
    367e:	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3680:	mov.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    3684:	bx	lr
    3686:	nop

00003688 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3688:	ldrb.w	r3, [r0, #56]	; 0x38
    368c:	ldrb.w	r2, [r0, #57]	; 0x39
    3690:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    3692:	itte	hi
    3694:	addhi	r3, r3, r0
    3696:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3698:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    369c:	bx	lr
    369e:	nop

000036a0 <TwoWire::flush()>:
	virtual void flush(void) {
    36a0:	bx	lr
    36a2:	nop

000036a4 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    36a4:	push	{r3, r4, r5, lr}
    36a6:	mov	r5, r0
	if (transmitting || slave_mode) {
    36a8:	ldrh.w	r0, [r0, #94]	; 0x5e
    36ac:	cbz	r0, 36d4 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    36ae:	ldrb.w	r3, [r5, #93]	; 0x5d
    36b2:	mov	r4, r2
    36b4:	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    36b8:	cmp	r4, r2
    36ba:	bhi.n	36d6 <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    36bc:	add.w	r0, r5, #59	; 0x3b
    36c0:	add	r0, r3
    36c2:	mov	r2, r4
    36c4:	bl	9220 <memcpy>
		txBufferLength += quantity;
    36c8:	ldrb.w	r3, [r5, #93]	; 0x5d
    36cc:	add	r3, r4
    36ce:	strb.w	r3, [r5, #93]	; 0x5d
    36d2:	mov	r0, r4
		return quantity;
	}
	return 0;
}
    36d4:	pop	{r3, r4, r5, pc}
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    36d6:	movs	r0, #1
    36d8:	mov	r4, r2
    36da:	strb	r0, [r5, #4]
    36dc:	b.n	36bc <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    36de:	nop

000036e0 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    36e0:	ldrh.w	r3, [r0, #94]	; 0x5e
    36e4:	cbz	r3, 3702 <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    36e6:	ldrb.w	r3, [r0, #93]	; 0x5d
    36ea:	cmp	r3, #32
    36ec:	bhi.n	36fe <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    36ee:	adds	r2, r0, r3
    36f0:	adds	r3, #1
    36f2:	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    36f6:	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    36f8:	strb.w	r1, [r2, #59]	; 0x3b
    36fc:	bx	lr
    36fe:	movs	r3, #1
    3700:	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    3702:	movs	r0, #0
    3704:	bx	lr
    3706:	nop

00003708 <TwoWire::begin()>:
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    3708:	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    370a:	ldr	r2, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    370c:	strb.w	r3, [r0, #56]	; 0x38
	rxBufferLength = 0;
    3710:	strb.w	r3, [r0, #57]	; 0x39
	txBufferIndex = 0;
    3714:	strb.w	r3, [r0, #92]	; 0x5c
	txBufferLength = 0;
    3718:	strb.w	r3, [r0, #93]	; 0x5d
	transmitting = 0;
    371c:	strb.w	r3, [r0, #94]	; 0x5e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    3720:	strb.w	r3, [r0, #95]	; 0x5f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    3724:	ldmia	r2, {r1, r2}

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    3726:	push	{r4, r5}
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    3728:	ldr	r5, [r1, #0]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    372a:	ldr	r4, [r0, #16]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    372c:	str	r3, [r0, #100]	; 0x64
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    372e:	orrs	r2, r5
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    3730:	str	r3, [r0, #104]	; 0x68
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    3732:	str	r2, [r1, #0]
	port().C1 = 0;
    3734:	strb	r3, [r4, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    3736:	ldr	r2, [r0, #20]
    3738:	ldrb.w	r3, [r0, #97]	; 0x61
    373c:	ldr	r1, [pc, #88]	; (3798 <TwoWire::begin()+0x90>)
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    373e:	ldr	r4, [r2, #0]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    3740:	add	r3, r2
    3742:	ldrb	r5, [r3, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3744:	ldrb	r3, [r3, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    3746:	add.w	r5, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    374a:	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    374c:	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    374e:	and.w	r3, r3, #1792	; 0x700
    3752:	orr.w	r3, r3, #100	; 0x64
    3756:	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    3758:	ldrb.w	r3, [r0, #98]	; 0x62
    375c:	add	r3, r2
    375e:	ldrb	r5, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3760:	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    3762:	add.w	r1, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3766:	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    3768:	ldr	r1, [r1, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    376a:	and.w	r3, r3, #1792	; 0x700
    376e:	orr.w	r3, r3, #100	; 0x64
    3772:	str	r3, [r1, #0]
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    3774:	ldr	r1, [r4, #0]
    3776:	ldr	r3, [r2, #4]
    3778:	tst	r1, r3
    377a:	beq.n	3788 <TwoWire::begin()+0x80>
    377c:	ldr	r3, [r0, #16]
		port().F = I2C_F_DIV56; // 0.96 MHz
	}
	port().FLT = 4;
#elif F_BUS == 48000000
	if (frequency < 400000) {
		port().F = 0x27;	// 100 kHz
    377e:	movs	r2, #39	; 0x27
    3780:	strb	r2, [r3, #1]
    3782:	ldr	r3, [r0, #16]
	} else if (frequency < 1000000) {
		port().F = 0x1A; // 400 kHz
	} else {
		port().F = 0x0D; // 1 MHz
	}
	port().FLT = 4;
    3784:	movs	r2, #4
    3786:	strb	r2, [r3, #6]
    3788:	ldr	r3, [r0, #16]
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
	port().C2 = I2C_C2_HDRS;
    378a:	movs	r2, #32
    378c:	strb	r2, [r3, #5]
    378e:	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    3790:	movs	r2, #128	; 0x80
    3792:	strb	r2, [r3, #2]
	//pinMode(3, OUTPUT);
	//pinMode(4, OUTPUT);
}
    3794:	pop	{r4, r5}
    3796:	bx	lr
    3798:	.word	0x00013864

0000379c <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    379c:	push	{r3, r4, r5, lr}
    379e:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    37a0:	ldrb	r4, [r2, #3]
    37a2:	uxtb	r4, r4
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    37a4:	lsls	r1, r4, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    37a6:	mov	r5, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    37a8:	bpl.n	37f4 <TwoWire::isr()+0x58>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    37aa:	movs	r3, #16
    37ac:	strb	r3, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    37ae:	lsls	r3, r4, #25
    37b0:	bpl.n	37f2 <TwoWire::isr()+0x56>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    37b2:	and.w	r4, r4, #4
    37b6:	and.w	r3, r4, #255	; 0xff
    37ba:	cmp	r4, #0
    37bc:	beq.n	3874 <TwoWire::isr()+0xd8>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    37be:	ldr	r1, [pc, #264]	; (38c8 <TwoWire::isr()+0x12c>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    37c0:	ldr	r2, [r5, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    37c2:	movs	r3, #0
    37c4:	strb	r3, [r1, #0]
			txBufferLength = 0;
    37c6:	strb.w	r3, [r5, #93]	; 0x5d
			if (user_onRequest != NULL) {
    37ca:	cmp	r2, #0
    37cc:	beq.n	389c <TwoWire::isr()+0x100>
				user_onRequest();
    37ce:	blx	r2
			}
			if (txBufferLength == 0) {
    37d0:	ldrb.w	r3, [r5, #93]	; 0x5d
    37d4:	cmp	r3, #0
    37d6:	beq.n	389c <TwoWire::isr()+0x100>
    37d8:	ldr	r3, [r5, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    37da:	movs	r2, #208	; 0xd0
    37dc:	strb	r2, [r3, #2]
    37de:	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
    37e0:	ldrb.w	r2, [r5, #59]	; 0x3b
    37e4:	strb	r2, [r3, #4]
    37e6:	ldr	r3, [r5, #16]
			txBufferIndex = 1;
    37e8:	movs	r2, #1
    37ea:	strb.w	r2, [r5, #92]	; 0x5c
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    37ee:	movs	r2, #2
    37f0:	strb	r2, [r3, #3]
    37f2:	pop	{r3, r4, r5, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    37f4:	and.w	r3, r4, #64	; 0x40
    37f8:	and.w	r0, r3, #255	; 0xff
    37fc:	cmp	r3, #0
    37fe:	bne.n	37b2 <TwoWire::isr()+0x16>
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    3800:	ldrb	r3, [r2, #6]
    3802:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    3804:	and.w	r1, r3, #96	; 0x60
    3808:	cmp	r1, #96	; 0x60
    380a:	beq.n	38aa <TwoWire::isr()+0x10e>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    380c:	ldrb	r3, [r2, #2]
	if (c1 & I2C_C1_TX) {
    380e:	and.w	r3, r3, #16
    3812:	and.w	r1, r3, #255	; 0xff
    3816:	cbz	r3, 3846 <TwoWire::isr()+0xaa>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    3818:	ands.w	r4, r4, #1
    381c:	bne.n	388e <TwoWire::isr()+0xf2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    381e:	ldrb.w	r3, [r5, #92]	; 0x5c
    3822:	ldrb.w	r1, [r5, #93]	; 0x5d
    3826:	cmp	r1, r3
    3828:	bls.n	38c2 <TwoWire::isr()+0x126>
				port().D = txBuffer[txBufferIndex++];
    382a:	adds	r1, r3, #1
    382c:	add	r3, r5
    382e:	strb.w	r1, [r5, #92]	; 0x5c
    3832:	ldrb.w	r3, [r3, #59]	; 0x3b
    3836:	strb	r3, [r2, #4]
    3838:	ldr	r3, [r5, #16]
			} else {
				port().D = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    383a:	movs	r2, #208	; 0xd0
    383c:	strb	r2, [r3, #2]
    383e:	ldr	r3, [r5, #16]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    3840:	movs	r2, #2
    3842:	strb	r2, [r3, #3]
    3844:	b.n	37f2 <TwoWire::isr()+0x56>
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    3846:	strb.w	r1, [r5, #96]	; 0x60
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    384a:	ldrb	r3, [r2, #6]
    384c:	orr.w	r3, r3, #32
    3850:	strb	r3, [r2, #6]
    3852:	ldr	r3, [r5, #16]
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    3854:	ldrb.w	r1, [r5, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    3858:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    385a:	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    385c:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    385e:	bhi.n	37ee <TwoWire::isr()+0x52>
    3860:	ldr	r0, [pc, #100]	; (38c8 <TwoWire::isr()+0x12c>)
    3862:	ldrb	r0, [r0, #0]
    3864:	cmp	r0, #0
    3866:	beq.n	37ee <TwoWire::isr()+0x52>
			rxBuffer[rxBufferLength++] = data;
    3868:	adds	r0, r5, r1
    386a:	adds	r1, #1
    386c:	strb.w	r1, [r5, #57]	; 0x39
    3870:	strb	r2, [r0, #24]
    3872:	b.n	37ee <TwoWire::isr()+0x52>
    3874:	ldr	r2, [r5, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    3876:	strb.w	r3, [r5, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    387a:	movs	r3, #192	; 0xc0
    387c:	strb	r3, [r2, #2]
    387e:	ldr	r3, [r5, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    3880:	ldr	r2, [pc, #68]	; (38c8 <TwoWire::isr()+0x12c>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    3882:	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    3884:	movs	r1, #1
    3886:	strb	r1, [r2, #0]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    3888:	movs	r2, #2
    388a:	strb	r2, [r3, #3]
    388c:	b.n	37f2 <TwoWire::isr()+0x56>
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    388e:	movs	r3, #192	; 0xc0
    3890:	strb	r3, [r2, #2]
    3892:	ldr	r3, [r5, #16]
			data = port().D;
    3894:	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    3896:	movs	r2, #2
    3898:	strb	r2, [r3, #3]
    389a:	b.n	37f2 <TwoWire::isr()+0x56>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    389c:	movs	r2, #1
				txBuffer[0] = 0;
    389e:	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    38a0:	strb.w	r2, [r5, #93]	; 0x5d
				txBuffer[0] = 0;
    38a4:	strb.w	r3, [r5, #59]	; 0x3b
    38a8:	b.n	37d8 <TwoWire::isr()+0x3c>
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    38aa:	and.w	r3, r3, #223	; 0xdf
    38ae:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    38b0:	ldr	r3, [r5, #104]	; 0x68
    38b2:	cbz	r3, 38be <TwoWire::isr()+0x122>
			rxBufferIndex = 0;
    38b4:	strb.w	r0, [r5, #56]	; 0x38
			user_onReceive(rxBufferLength);
    38b8:	ldrb.w	r0, [r5, #57]	; 0x39
    38bc:	blx	r3
    38be:	ldr	r2, [r5, #16]
    38c0:	b.n	380c <TwoWire::isr()+0x70>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
				port().D = txBuffer[txBufferIndex++];
			} else {
				port().D = 0;
    38c2:	strb	r4, [r2, #4]
    38c4:	b.n	3838 <TwoWire::isr()+0x9c>
    38c6:	nop
    38c8:	.word	0x20019698

000038cc <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    38cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    38d0:	ldr	r7, [pc, #220]	; (39b0 <L_1438_delayMicroseconds+0x1a>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    38d2:	ldr.w	r9, [pc, #224]	; 39b4 <L_1438_delayMicroseconds+0x1e>
    38d6:	ldr	r3, [r7, #0]
    38d8:	ldr	r2, [r0, #16]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    38da:	sub	sp, #8
    38dc:	mov	r6, r0
    38de:	str	r3, [sp, #0]
	return ret;
    38e0:	ldr.w	r8, [sp]
	bool reset=false;
    38e4:	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    38e6:	movs	r5, #160	; 0xa0
	uint8_t i2c_status(void) {
		return port().S;
    38e8:	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    38ea:	lsls	r3, r3, #26
    38ec:	bpl.n	39a6 <L_1438_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    38ee:	ldr	r3, [r7, #0]
    38f0:	str	r3, [sp, #4]
	return ret;
    38f2:	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    38f4:	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    38f8:	cmp	r3, #15
    38fa:	bls.n	38e8 <TwoWire::wait_idle()+0x1c>
    38fc:	cbz	r1, 3912 <TwoWire::wait_idle()+0x46>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    38fe:	cmp	r3, #16
    3900:	beq.n	38e8 <TwoWire::wait_idle()+0x1c>
			// bus stuck busy too long
			port().C1 = 0;
    3902:	movs	r0, #0
    3904:	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    3906:	ldr	r3, [r6, #16]
			port().C1 = I2C_C1_IICEN;
    3908:	movs	r2, #128	; 0x80
    390a:	strb	r2, [r3, #2]
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
}
    390c:	add	sp, #8
    390e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    3912:	ldr	r2, [r6, #20]
    3914:	ldrb.w	r3, [r6, #97]	; 0x61
    3918:	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    391a:	movs	r1, #5
    391c:	ldrb	r0, [r3, #8]
    391e:	bl	9938 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    3922:	ldr	r2, [r6, #20]
    3924:	ldrb.w	r3, [r6, #97]	; 0x61
    3928:	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    392a:	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    392c:	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    3930:	mov	r0, sl
    3932:	bl	9938 <pinMode>
    3936:	movs	r4, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    3938:	movs	r1, #0
    393a:	mov	r0, sl
    393c:	bl	9910 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    3940:	mov	r3, r5

00003942 <L_1373_delayMicroseconds>:
    3942:	subs	r3, #1
    3944:	bne.n	3942 <L_1373_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    3946:	movs	r1, #1
    3948:	mov	r0, sl
    394a:	bl	9910 <digitalWrite>
    394e:	mov	r3, r5

00003950 <L_1387_delayMicroseconds>:
    3950:	subs	r3, #1
    3952:	bne.n	3950 <L_1387_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    3954:	subs	r4, #1
    3956:	bne.n	3938 <TwoWire::wait_idle()+0x6c>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    3958:	ldr	r0, [r6, #20]
    395a:	ldrb.w	r1, [r6, #97]	; 0x61
    395e:	add	r1, r0
    3960:	mov.w	r2, #320	; 0x140
    3964:	ldrb	r4, [r1, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3966:	ldrb	r3, [r1, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    3968:	add.w	r1, r9, r4, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    396c:	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    396e:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3970:	and.w	r3, r3, #1792	; 0x700
    3974:	orr.w	r3, r3, #100	; 0x64
    3978:	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    397a:	ldrb.w	r3, [r6, #98]	; 0x62
    397e:	add	r3, r0
    3980:	ldrb	r1, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3982:	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    3984:	add.w	r1, r9, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    3988:	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    398a:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    398c:	and.w	r3, r3, #1792	; 0x700
    3990:	orr.w	r3, r3, #100	; 0x64
    3994:	str	r3, [r1, #0]

00003996 <L_1438_delayMicroseconds>:
    3996:	subs	r2, #1
    3998:	bne.n	3996 <L_1438_delayMicroseconds>
    399a:	ldr	r2, [r6, #16]
	uint8_t i2c_status(void) {
		return port().S;
    399c:	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    399e:	lsls	r3, r3, #26
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    39a0:	mov.w	r1, #1
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    39a4:	bmi.n	38ee <TwoWire::wait_idle()+0x22>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
    39a6:	movs	r0, #1
}
    39a8:	add	sp, #8
    39aa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    39ae:	nop
    39b0:	.word	0x20019bc4
    39b4:	.word	0x00013864

000039b8 <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    39b8:	push	{r4, r5, r6, r7, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    39ba:	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    39bc:	movs	r2, #18
    39be:	strb	r2, [r3, #3]
    39c0:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    39c2:	ldrb	r3, [r2, #2]
    39c4:	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    39c8:	sub	sp, #20
    39ca:	mov	r4, r0
    39cc:	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    39ce:	cmp	r3, #0
    39d0:	beq.n	3a90 <TwoWire::endTransmission(unsigned char)+0xd8>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    39d2:	movs	r3, #180	; 0xb4
    39d4:	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    39d6:	ldr	r1, [pc, #240]	; (3ac8 <TwoWire::endTransmission(unsigned char)+0x110>)
    39d8:	ldr	r2, [r4, #16]
    39da:	ldr	r3, [r1, #0]
    39dc:	str	r3, [sp, #0]
	return ret;
    39de:	ldr	r6, [sp, #0]
    39e0:	b.n	39ee <TwoWire::endTransmission(unsigned char)+0x36>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    39e2:	ldr	r3, [r1, #0]
    39e4:	str	r3, [sp, #4]
	return ret;
    39e6:	ldr	r3, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    39e8:	subs	r3, r3, r6
    39ea:	cmp	r3, #4
    39ec:	bhi.n	3a74 <TwoWire::endTransmission(unsigned char)+0xbc>
	uint8_t i2c_status(void) {
		return port().S;
    39ee:	ldrb	r3, [r2, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    39f0:	and.w	r3, r3, #32
    39f4:	and.w	r0, r3, #255	; 0xff
    39f8:	cmp	r3, #0
    39fa:	beq.n	39e2 <TwoWire::endTransmission(unsigned char)+0x2a>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    39fc:	ldrb.w	r3, [r4, #93]	; 0x5d
    3a00:	cmp	r3, #0
    3a02:	beq.n	3a68 <TwoWire::endTransmission(unsigned char)+0xb0>
    3a04:	mov.w	lr, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    3a08:	mov.w	ip, #2
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
		port().D = txBuffer[i];
    3a0c:	add.w	r3, r4, lr
    3a10:	ldrb.w	r3, [r3, #59]	; 0x3b
    3a14:	strb	r3, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3a16:	ldr	r3, [r1, #0]
    3a18:	str	r3, [sp, #12]
	return ret;
    3a1a:	ldr	r7, [sp, #12]
    3a1c:	ldr	r0, [r4, #16]
    3a1e:	b.n	3a30 <TwoWire::endTransmission(unsigned char)+0x78>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
    3a20:	lsls	r3, r3, #26
    3a22:	bpl.n	3a40 <TwoWire::endTransmission(unsigned char)+0x88>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3a24:	ldr	r3, [r1, #0]
    3a26:	str	r3, [sp, #8]
	return ret;
    3a28:	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
    3a2a:	subs	r3, r3, r7
    3a2c:	cmp	r3, #5
    3a2e:	bhi.n	3a82 <TwoWire::endTransmission(unsigned char)+0xca>
    3a30:	ldrb	r3, [r0, #3]
    3a32:	uxtb	r3, r3
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    3a34:	and.w	r2, r3, #2
    3a38:	and.w	r6, r2, #255	; 0xff
    3a3c:	cmp	r2, #0
    3a3e:	beq.n	3a20 <TwoWire::endTransmission(unsigned char)+0x68>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    3a40:	strb.w	ip, [r0, #3]
    3a44:	ldr	r6, [r4, #16]
    3a46:	ldrb	r3, [r6, #3]
    3a48:	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    3a4a:	lsls	r7, r3, #27
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    3a4c:	mov	r2, r6
    3a4e:	bmi.n	3aac <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    3a50:	lsls	r7, r3, #26
    3a52:	bpl.n	3aac <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
    3a54:	lsls	r3, r3, #31
    3a56:	bmi.n	3abc <TwoWire::endTransmission(unsigned char)+0x104>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    3a58:	add.w	lr, lr, #1
    3a5c:	ldrb.w	r3, [r4, #93]	; 0x5d
    3a60:	uxtb.w	lr, lr
    3a64:	cmp	r3, lr
    3a66:	bhi.n	3a0c <TwoWire::endTransmission(unsigned char)+0x54>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    3a68:	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    3a6a:	cbnz	r5, 3ab4 <TwoWire::endTransmission(unsigned char)+0xfc>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    3a6c:	movs	r3, #0
    3a6e:	strb.w	r3, [r4, #94]	; 0x5e
    3a72:	b.n	3a7e <TwoWire::endTransmission(unsigned char)+0xc6>
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    3a74:	strb	r0, [r2, #2]
    3a76:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    3a78:	movs	r2, #128	; 0x80
    3a7a:	strb	r2, [r3, #2]
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
    3a7c:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    3a7e:	add	sp, #20
    3a80:	pop	{r4, r5, r6, r7, pc}
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    3a82:	strb	r6, [r0, #2]
    3a84:	ldr	r3, [r4, #16]
				port().C1 = I2C_C1_IICEN;
    3a86:	movs	r2, #128	; 0x80
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
    3a88:	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
    3a8a:	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    3a8c:	add	sp, #20
    3a8e:	pop	{r4, r5, r6, r7, pc}
    3a90:	and.w	r6, r3, #255	; 0xff
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    3a94:	bl	38cc <TwoWire::wait_idle()>
    3a98:	cbnz	r0, 3aa0 <TwoWire::endTransmission(unsigned char)+0xe8>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    3a9a:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    3a9c:	add	sp, #20
    3a9e:	pop	{r4, r5, r6, r7, pc}
    3aa0:	ldr	r3, [r4, #16]
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    3aa2:	strb.w	r6, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    3aa6:	movs	r2, #176	; 0xb0
    3aa8:	strb	r2, [r3, #2]
    3aaa:	b.n	39d6 <TwoWire::endTransmission(unsigned char)+0x1e>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    3aac:	movs	r3, #128	; 0x80
    3aae:	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    3ab0:	movs	r0, #4
    3ab2:	b.n	3a6a <TwoWire::endTransmission(unsigned char)+0xb2>
    3ab4:	ldr	r6, [r4, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    3ab6:	movs	r3, #128	; 0x80
    3ab8:	strb	r3, [r6, #2]
    3aba:	b.n	3a6c <TwoWire::endTransmission(unsigned char)+0xb4>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    3abc:	cmp.w	lr, #0
    3ac0:	ite	eq
    3ac2:	moveq	r0, #2
    3ac4:	movne	r0, #3
    3ac6:	b.n	3ab6 <TwoWire::endTransmission(unsigned char)+0xfe>
    3ac8:	.word	0x20019bc4

00003acc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    3acc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ad0:	ldr	r6, [r0, #16]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    3ad2:	movs	r5, #0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    3ad4:	movs	r7, #18
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    3ad6:	strb.w	r5, [r0, #56]	; 0x38
	rxBufferLength = 0;
    3ada:	strb.w	r5, [r0, #57]	; 0x39
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    3ade:	strb	r7, [r6, #3]
    3ae0:	ldr.w	ip, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    3ae4:	ldrb.w	lr, [ip, #2]
    3ae8:	and.w	lr, lr, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    3aec:	sub	sp, #32
    3aee:	mov	r4, r0
    3af0:	mov	r8, r1
    3af2:	mov	r5, r2
    3af4:	mov	r6, r3
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    3af6:	cmp.w	lr, #0
    3afa:	beq.n	3b90 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    3afc:	movs	r3, #180	; 0xb4
    3afe:	strb.w	r3, [ip, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3b02:	ldr	r3, [pc, #480]	; (3ce4 <L_2966_delayMicroseconds+0x1a>)
    3b04:	ldr	r1, [r4, #16]
    3b06:	ldr	r2, [r3, #0]
    3b08:	str	r2, [sp, #0]
	return ret;
    3b0a:	ldr.w	lr, [sp]
    3b0e:	b.n	3b1e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x52>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3b10:	ldr	r2, [r3, #0]
    3b12:	str	r2, [sp, #4]
	return ret;
    3b14:	ldr	r0, [sp, #4]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
    3b16:	rsb	r0, lr, r0
    3b1a:	cmp	r0, #4
    3b1c:	bhi.n	3b80 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb4>
	uint8_t i2c_status(void) {
		return port().S;
    3b1e:	ldrb	r0, [r1, #3]
    3b20:	and.w	r0, r0, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    3b24:	and.w	r7, r0, #255	; 0xff
    3b28:	cmp	r0, #0
    3b2a:	beq.n	3b10 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    3b2c:	mov.w	r2, r8, lsl #1
    3b30:	orr.w	r2, r2, #1
    3b34:	uxtb	r2, r2
    3b36:	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3b38:	ldr	r2, [r3, #0]
    3b3a:	str	r2, [sp, #8]
	return ret;
    3b3c:	ldr.w	lr, [sp, #8]
    3b40:	ldr	r0, [r4, #16]
    3b42:	b.n	3b52 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x86>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3b44:	ldr	r2, [r3, #0]
    3b46:	str	r2, [sp, #12]
	return ret;
    3b48:	ldr	r1, [sp, #12]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    3b4a:	rsb	r1, lr, r1
    3b4e:	cmp	r1, #5
    3b50:	bhi.n	3ba8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    3b52:	ldrb	r1, [r0, #3]
    3b54:	and.w	r1, r1, #2
    3b58:	and.w	r7, r1, #255	; 0xff
    3b5c:	cmp	r1, #0
    3b5e:	beq.n	3b44 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x78>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    3b60:	mov.w	ip, #2
    3b64:	strb.w	ip, [r0, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    3b68:	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    3b6a:	ldrb	r1, [r2, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    3b6c:	ands.w	r7, r1, #17
    3b70:	bne.n	3bb8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xec>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
    3b72:	cbnz	r5, 3bc0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    3b74:	cmp	r6, #0
    3b76:	ite	eq
    3b78:	moveq	r3, #160	; 0xa0
    3b7a:	movne	r3, #128	; 0x80
    3b7c:	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    3b7e:	b.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    3b80:	strb	r7, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    3b82:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    3b84:	movs	r2, #128	; 0x80
    3b86:	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    3b88:	mov	r0, r7
    3b8a:	add	sp, #32
    3b8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3b90:	and.w	r7, lr, #255	; 0xff
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    3b94:	bl	38cc <TwoWire::wait_idle()>
    3b98:	cmp	r0, #0
    3b9a:	beq.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    3b9c:	ldr	r3, [r4, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    3b9e:	strb.w	r7, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    3ba2:	movs	r2, #176	; 0xb0
    3ba4:	strb	r2, [r3, #2]
    3ba6:	b.n	3b02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x36>
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    3ba8:	strb	r7, [r0, #2]
    3baa:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    3bac:	movs	r2, #128	; 0x80
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    3bae:	mov	r0, r7
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    3bb0:	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    3bb2:	add	sp, #32
    3bb4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    3bb8:	movs	r3, #128	; 0x80
    3bba:	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    3bbc:	movs	r7, #0
    3bbe:	b.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
    3bc0:	cmp	r5, #1
    3bc2:	beq.n	3cb0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1e4>
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    3bc4:	movs	r1, #160	; 0xa0
    3bc6:	strb	r1, [r2, #2]
    3bc8:	ldr	r1, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
    3bca:	ldrb	r2, [r1, #4]
    3bcc:	mov	lr, r7
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    3bce:	mov	r7, ip
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    3bd0:	mov.w	ip, #168	; 0xa8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3bd4:	ldr	r2, [r3, #0]
    3bd6:	str	r2, [sp, #16]
	return ret;
    3bd8:	ldr	r0, [sp, #16]
    3bda:	b.n	3be8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3bdc:	ldr	r2, [r3, #0]
    3bde:	str	r2, [sp, #20]
	return ret;
    3be0:	ldr	r2, [sp, #20]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
    3be2:	subs	r2, r2, r0
    3be4:	cmp	r2, #5
    3be6:	bhi.n	3c7e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b2>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    3be8:	ldrb	r2, [r1, #3]
    3bea:	and.w	r2, r2, #2
    3bee:	and.w	r8, r2, #255	; 0xff
    3bf2:	cmp	r2, #0
    3bf4:	beq.n	3bdc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x110>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    3bf6:	strb	r7, [r1, #3]
    3bf8:	ldr	r1, [r4, #16]
		status = port().S;
    3bfa:	ldrb	r2, [r1, #3]
    3bfc:	uxtb	r2, r2
		if ((status & I2C_S_ARBL)) {
    3bfe:	tst.w	r2, #16
    3c02:	mov	r0, r1
    3c04:	bne.n	3cbc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    3c06:	lsls	r2, r2, #26
    3c08:	bpl.n	3cbc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    3c0a:	subs	r5, #1
    3c0c:	uxtb	r5, r5
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    3c0e:	cmp	r5, #1
    3c10:	beq.n	3ca6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1da>
		if (count < BUFFER_LENGTH) {
    3c12:	cmp.w	lr, #31
    3c16:	bls.n	3c90 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1c4>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
    3c18:	ldrb	r2, [r1, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    3c1a:	cmp	r5, #1
    3c1c:	bne.n	3bd4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3c1e:	ldr	r2, [r3, #0]
    3c20:	str	r2, [sp, #24]
	return ret;
    3c22:	ldr	r5, [sp, #24]
    3c24:	b.n	3c32 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x166>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3c26:	ldr	r2, [r3, #0]
    3c28:	str	r2, [sp, #28]
	return ret;
    3c2a:	ldr	r2, [sp, #28]
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    3c2c:	subs	r2, r2, r5
    3c2e:	cmp	r2, #5
    3c30:	bhi.n	3cc0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f4>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    3c32:	ldrb	r2, [r0, #3]
    3c34:	and.w	r2, r2, #2
    3c38:	and.w	r1, r2, #255	; 0xff
    3c3c:	cmp	r2, #0
    3c3e:	beq.n	3c26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15a>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    3c40:	movs	r3, #2
    3c42:	strb	r3, [r0, #3]
    3c44:	ldr	r2, [r4, #16]
	status = port().S;
    3c46:	ldrb	r3, [r2, #3]
    3c48:	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    3c4a:	lsls	r1, r3, #27
    3c4c:	bmi.n	3cc4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f8>
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    3c4e:	lsls	r3, r3, #26
    3c50:	bpl.n	3cbc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    3c52:	movs	r3, #176	; 0xb0
	if (count < BUFFER_LENGTH) {
    3c54:	cmp.w	lr, #31
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    3c58:	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    3c5a:	bhi.n	3cdc <L_2966_delayMicroseconds+0x12>
    3c5c:	ldr	r2, [r4, #16]
		rxBuffer[count++] = port().D;
    3c5e:	add.w	r3, r4, lr
    3c62:	ldrb	r2, [r2, #4]
    3c64:	strb	r2, [r3, #24]
    3c66:	add.w	lr, lr, #1
    3c6a:	uxtb.w	lr, lr
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    3c6e:	cbz	r6, 3c76 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1aa>
    3c70:	ldr	r3, [r4, #16]
    3c72:	movs	r2, #128	; 0x80
    3c74:	strb	r2, [r3, #2]
	rxBufferLength = count;
    3c76:	strb.w	lr, [r4, #57]	; 0x39
	return count;
    3c7a:	mov	r7, lr
    3c7c:	b.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    3c7e:	strb.w	r8, [r1, #2]
    3c82:	ldr	r3, [r4, #16]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    3c84:	movs	r2, #128	; 0x80
    3c86:	strb	r2, [r3, #2]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    3c88:	mov	r7, lr
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
			rxBufferLength = count;
    3c8a:	strb.w	lr, [r4, #57]	; 0x39
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    3c8e:	b.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    3c90:	add.w	r2, r4, lr
    3c94:	ldrb.w	r8, [r1, #4]
    3c98:	strb.w	r8, [r2, #24]
    3c9c:	add.w	lr, lr, #1
    3ca0:	uxtb.w	lr, lr
    3ca4:	b.n	3c1a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x14e>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    3ca6:	strb.w	ip, [r1, #2]
    3caa:	ldr	r1, [r4, #16]
    3cac:	mov	r0, r1
    3cae:	b.n	3c12 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    3cb0:	movs	r1, #168	; 0xa8
    3cb2:	strb	r1, [r2, #2]
    3cb4:	ldr	r0, [r4, #16]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    3cb6:	mov	lr, r7
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
    3cb8:	ldrb	r2, [r0, #4]
    3cba:	b.n	3c1e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
    3cbc:	mov	r7, lr
    3cbe:	b.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    3cc0:	strb	r1, [r0, #2]
    3cc2:	b.n	3c82 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b6>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    3cc4:	movs	r1, #16
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    3cc6:	movs	r3, #160	; 0xa0
    3cc8:	strb	r1, [r2, #3]

00003cca <L_2966_delayMicroseconds>:
    3cca:	subs	r3, #1
    3ccc:	bne.n	3cca <L_2966_delayMicroseconds>
    3cce:	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    3cd0:	ldrb	r3, [r2, #2]
    3cd2:	and.w	r3, r3, #247	; 0xf7
		//Serial.printf("requestFrom err9a\n");
		return count;
    3cd6:	mov	r7, lr
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    3cd8:	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
    3cda:	b.n	3b88 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    3cdc:	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
    3cde:	ldrb	r3, [r3, #4]
    3ce0:	b.n	3c6e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1a2>
    3ce2:	nop
    3ce4:	.word	0x20019bc4

00003ce8 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    3ce8:	ldr	r0, [pc, #4]	; (3cf0 <i2c0_isr+0x8>)
    3cea:	b.w	379c <TwoWire::isr()>
    3cee:	nop
    3cf0:	.word	0x200137fc

00003cf4 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    3cf4:	ldr	r0, [pc, #4]	; (3cfc <i2c1_isr+0x8>)
    3cf6:	b.w	379c <TwoWire::isr()>
    3cfa:	nop
    3cfc:	.word	0x20013868

00003d00 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    3d00:	ldr	r0, [pc, #4]	; (3d08 <i2c2_isr+0x8>)
    3d02:	b.w	379c <TwoWire::isr()>
    3d06:	nop
    3d08:	.word	0x20013790

00003d0c <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    3d0c:	bx	lr
    3d0e:	nop

00003d10 <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    3d10:	push	{r4, lr}
    3d12:	ldr.w	r4, [r0, #1156]	; 0x484
    3d16:	sub	sp, #56	; 0x38
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
    3d18:	cbz	r4, 3d44 <SDClass::remove(char const*)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    3d1a:	mov	r2, r1
    3d1c:	mov	r0, sp
    3d1e:	mov	r1, r4
    3d20:	movs	r3, #1
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    3d22:	movs	r4, #0
    3d24:	strb.w	r4, [sp]
    3d28:	strb.w	r4, [sp, #1]
    3d2c:	strb.w	r4, [sp, #2]
    3d30:	bl	5ef4 <FatFile::open(FatVolume*, char const*, int)>
    3d34:	cbnz	r0, 3d3a <SDClass::remove(char const*)+0x2a>
		return sdfs.remove(filepath);
	}
    3d36:	add	sp, #56	; 0x38
    3d38:	pop	{r4, pc}
    3d3a:	mov	r0, sp
    3d3c:	bl	7000 <FatFile::remove()>
    3d40:	add	sp, #56	; 0x38
    3d42:	pop	{r4, pc}
    3d44:	ldr.w	r0, [r0, #1160]	; 0x488
    3d48:	cmp	r0, #0
    3d4a:	beq.n	3d36 <SDClass::remove(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    3d4c:	mov	r2, r1
    3d4e:	movs	r3, #1
    3d50:	mov	r1, r0
    3d52:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    3d54:	strb.w	r4, [sp, #49]	; 0x31
    3d58:	strb.w	r4, [sp, #50]	; 0x32
    3d5c:	strb.w	r4, [sp, #51]	; 0x33
    3d60:	bl	4ac0 <ExFatFile::open(ExFatVolume*, char const*, int)>
    3d64:	cmp	r0, #0
    3d66:	beq.n	3d36 <SDClass::remove(char const*)+0x26>
    3d68:	mov	r0, sp
    3d6a:	bl	50d8 <ExFatFile::remove()>
    3d6e:	add	sp, #56	; 0x38
    3d70:	pop	{r4, pc}
    3d72:	nop

00003d74 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    3d74:	push	{r4, lr}
    3d76:	ldr.w	r4, [r0, #1156]	; 0x484
    3d7a:	sub	sp, #56	; 0x38
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    3d7c:	cbz	r4, 3d9e <SDClass::mkdir(char const*)+0x2a>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    3d7e:	mov	r2, r1
    3d80:	movs	r3, #1
    3d82:	addw	r1, r4, #1092	; 0x444
    3d86:	mov	r0, sp
    3d88:	movs	r4, #0
    3d8a:	strb.w	r4, [sp]
    3d8e:	strb.w	r4, [sp, #1]
    3d92:	strb.w	r4, [sp, #2]
    3d96:	bl	5d70 <FatFile::mkdir(FatFile*, char const*, bool)>
		return sdfs.mkdir(filepath);
	}
    3d9a:	add	sp, #56	; 0x38
    3d9c:	pop	{r4, pc}
    3d9e:	ldr.w	r0, [r0, #1160]	; 0x488
    3da2:	cmp	r0, #0
    3da4:	beq.n	3d9a <SDClass::mkdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    3da6:	mov	r2, r1
    3da8:	movs	r3, #1
    3daa:	add.w	r1, r0, #1096	; 0x448
    3dae:	mov	r0, sp
    3db0:	strb.w	r4, [sp, #49]	; 0x31
    3db4:	strb.w	r4, [sp, #50]	; 0x32
    3db8:	strb.w	r4, [sp, #51]	; 0x33
    3dbc:	bl	54f4 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    3dc0:	add	sp, #56	; 0x38
    3dc2:	pop	{r4, pc}

00003dc4 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    3dc4:	push	{r4, r5, lr}
    3dc6:	ldr.w	r4, [r0, #1156]	; 0x484
    3dca:	sub	sp, #60	; 0x3c
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
    3dcc:	cbz	r4, 3dec <SDClass::exists(char const*)+0x28>
    3dce:	movs	r5, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    3dd0:	mov	r2, r1
    3dd2:	mov	r3, r5
    3dd4:	mov	r1, r4
    3dd6:	mov	r0, sp
    3dd8:	strb.w	r5, [sp]
    3ddc:	strb.w	r5, [sp, #1]
    3de0:	strb.w	r5, [sp, #2]
    3de4:	bl	5ef4 <FatFile::open(FatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    3de8:	add	sp, #60	; 0x3c
    3dea:	pop	{r4, r5, pc}
    3dec:	ldr.w	r0, [r0, #1160]	; 0x488
    3df0:	cmp	r0, #0
    3df2:	beq.n	3de8 <SDClass::exists(char const*)+0x24>
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    3df4:	mov	r2, r1
    3df6:	mov	r3, r4
    3df8:	mov	r1, r0
    3dfa:	mov	r0, sp
    3dfc:	strb.w	r4, [sp, #49]	; 0x31
    3e00:	strb.w	r4, [sp, #50]	; 0x32
    3e04:	strb.w	r4, [sp, #51]	; 0x33
    3e08:	bl	4ac0 <ExFatFile::open(ExFatVolume*, char const*, int)>
    3e0c:	add	sp, #60	; 0x3c
    3e0e:	pop	{r4, r5, pc}

00003e10 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    3e10:	push	{r3, r4, r5, lr}
    3e12:	mov	r5, r0
    3e14:	ldr.w	r0, [r0, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    3e18:	cbz	r0, 3e4c <SDClass::usedSize()+0x3c>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    3e1a:	ldr	r4, [r0, #28]
    3e1c:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    3e1e:	bl	6a80 <FatPartition::freeClusterCount()>
    3e22:	ldr.w	r3, [r5, #1156]	; 0x484
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    3e26:	subs	r4, r4, r0
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    3e28:	cbz	r3, 3e3c <SDClass::usedSize()+0x2c>
    3e2a:	ldrb	r0, [r3, #6]
    3e2c:	mov.w	r3, #512	; 0x200
    3e30:	lsl.w	r0, r3, r0
    3e34:	uxth	r0, r0
    3e36:	umull	r0, r1, r0, r4
    3e3a:	pop	{r3, r4, r5, pc}
    3e3c:	ldr.w	r3, [r5, #1160]	; 0x488
    3e40:	cbz	r3, 3e5c <SDClass::usedSize()+0x4c>
    3e42:	ldr.w	r0, [r3, #1084]	; 0x43c
    3e46:	umull	r0, r1, r0, r4
    3e4a:	pop	{r3, r4, r5, pc}
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    3e4c:	ldr.w	r0, [r5, #1160]	; 0x488
    3e50:	cbz	r0, 3e5c <SDClass::usedSize()+0x4c>
    3e52:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    3e56:	bl	4e4c <ExFatPartition::freeClusterCount()>
    3e5a:	b.n	3e22 <SDClass::usedSize()+0x12>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    3e5c:	movs	r0, #0
    3e5e:	movs	r1, #0
		  * (uint64_t)sdfs.bytesPerCluster();
	}
    3e60:	pop	{r3, r4, r5, pc}
    3e62:	nop

00003e64 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    3e64:	push	{r4, r5, lr}
    3e66:	ldr.w	r4, [r0, #1156]	; 0x484
    3e6a:	sub	sp, #60	; 0x3c
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
           m_xVol ? m_xVol->rmdir(path) : false;
    3e6c:	cbz	r4, 3e98 <SDClass::rmdir(char const*)+0x34>
    3e6e:	movs	r5, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    3e70:	mov	r2, r1
    3e72:	mov	r3, r5
    3e74:	mov	r1, r4
    3e76:	mov	r0, sp
    3e78:	strb.w	r5, [sp]
    3e7c:	strb.w	r5, [sp, #1]
    3e80:	strb.w	r5, [sp, #2]
    3e84:	bl	5ef4 <FatFile::open(FatVolume*, char const*, int)>
    3e88:	cbnz	r0, 3e8e <SDClass::rmdir(char const*)+0x2a>
		return sdfs.rmdir(filepath);
	}
    3e8a:	add	sp, #60	; 0x3c
    3e8c:	pop	{r4, r5, pc}
    3e8e:	mov	r0, sp
    3e90:	bl	6340 <FatFile::rmdir()>
    3e94:	add	sp, #60	; 0x3c
    3e96:	pop	{r4, r5, pc}
    3e98:	ldr.w	r0, [r0, #1160]	; 0x488
    3e9c:	cmp	r0, #0
    3e9e:	beq.n	3e8a <SDClass::rmdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const ExChar_t* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    3ea0:	mov	r2, r1
    3ea2:	mov	r3, r4
    3ea4:	mov	r1, r0
    3ea6:	mov	r0, sp
    3ea8:	strb.w	r4, [sp, #49]	; 0x31
    3eac:	strb.w	r4, [sp, #50]	; 0x32
    3eb0:	strb.w	r4, [sp, #51]	; 0x33
    3eb4:	bl	4ac0 <ExFatFile::open(ExFatVolume*, char const*, int)>
    3eb8:	cmp	r0, #0
    3eba:	beq.n	3e8a <SDClass::rmdir(char const*)+0x26>
    3ebc:	mov	r0, sp
    3ebe:	bl	51b0 <ExFatFile::rmdir()>
    3ec2:	add	sp, #60	; 0x3c
    3ec4:	pop	{r4, r5, pc}
    3ec6:	nop

00003ec8 <SDClass::rename(char const*, char const*)>:
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
    3ec8:	push	{r4, r5, r6, lr}
    3eca:	ldr.w	r4, [r0, #1156]	; 0x484
    3ece:	sub	sp, #56	; 0x38
    3ed0:	mov	r6, r2
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    3ed2:	cbz	r4, 3f06 <SDClass::rename(char const*, char const*)+0x3e>
    3ed4:	movs	r5, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    3ed6:	addw	r4, r4, #1092	; 0x444
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3eda:	mov	r2, r1
    3edc:	mov	r3, r5
    3ede:	mov	r1, r4
    3ee0:	mov	r0, sp
    3ee2:	strb.w	r5, [sp]
    3ee6:	strb.w	r5, [sp, #1]
    3eea:	strb.w	r5, [sp, #2]
    3eee:	bl	5e34 <FatFile::open(FatFile*, char const*, int)>
    3ef2:	cbnz	r0, 3ef8 <SDClass::rename(char const*, char const*)+0x30>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    3ef4:	add	sp, #56	; 0x38
    3ef6:	pop	{r4, r5, r6, pc}
    3ef8:	mov	r2, r6
    3efa:	mov	r1, r4
    3efc:	mov	r0, sp
    3efe:	bl	616c <FatFile::rename(FatFile*, char const*)>
    3f02:	add	sp, #56	; 0x38
    3f04:	pop	{r4, r5, r6, pc}
    3f06:	ldr.w	r0, [r0, #1160]	; 0x488
    3f0a:	cmp	r0, #0
    3f0c:	beq.n	3ef4 <SDClass::rename(char const*, char const*)+0x2c>
#endif  //  USE_EXFAT_UNICODE_NAMES

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    3f0e:	add.w	r5, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const ExChar_t* oldPath, const ExChar_t* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3f12:	mov	r2, r1
    3f14:	mov	r3, r4
    3f16:	mov	r1, r5
    3f18:	mov	r0, sp
    3f1a:	strb.w	r4, [sp, #49]	; 0x31
    3f1e:	strb.w	r4, [sp, #50]	; 0x32
    3f22:	strb.w	r4, [sp, #51]	; 0x33
    3f26:	bl	49c0 <ExFatFile::open(ExFatFile*, char const*, int)>
    3f2a:	cmp	r0, #0
    3f2c:	beq.n	3ef4 <SDClass::rename(char const*, char const*)+0x2c>
    3f2e:	mov	r2, r6
    3f30:	mov	r1, r5
    3f32:	mov	r0, sp
    3f34:	bl	5658 <ExFatFile::rename(ExFatFile*, char const*)>
    3f38:	add	sp, #56	; 0x38
    3f3a:	pop	{r4, r5, r6, pc}

00003f3c <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    3f3c:	ldr.w	r2, [r0, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    3f40:	cbz	r2, 3f56 <SDClass::totalSize()+0x1a>
    3f42:	ldrb	r1, [r2, #6]
    3f44:	ldr	r0, [r2, #28]
    3f46:	mov.w	r3, #512	; 0x200
    3f4a:	lsls	r3, r1
    3f4c:	uxth	r3, r3
    3f4e:	subs	r0, #1
    3f50:	umull	r0, r1, r3, r0
    3f54:	bx	lr
    3f56:	ldr.w	r2, [r0, #1160]	; 0x488
    3f5a:	cbz	r2, 3f6a <SDClass::totalSize()+0x2e>
    3f5c:	ldr.w	r3, [r2, #1072]	; 0x430
    3f60:	ldr.w	r0, [r2, #1084]	; 0x43c
    3f64:	umull	r0, r1, r3, r0
    3f68:	bx	lr
    3f6a:	movs	r0, #0
    3f6c:	movs	r1, #0
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
	}
    3f6e:	bx	lr

00003f70 <SDClass::open(char const*, unsigned char)>:
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    3f70:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    3f74:	cmp	r3, #1
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    3f76:	sub	sp, #80	; 0x50
    3f78:	mov	r5, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    3f7a:	beq.n	4000 <SDClass::open(char const*, unsigned char)+0x90>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
    3f7c:	cmp	r3, #2
		SDFAT_FILE file = sdfs.open(filepath, flags);
    3f7e:	add.w	r1, r1, #4
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
    3f82:	movw	r3, #514	; 0x202
		SDFAT_FILE file = sdfs.open(filepath, flags);
    3f86:	mov	r0, sp
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
    3f88:	it	ne
    3f8a:	movne	r3, #0
		SDFAT_FILE file = sdfs.open(filepath, flags);
    3f8c:	bl	7830 <FsVolume::open(char const*, int)>
    3f90:	ldr	r3, [sp, #72]	; 0x48
    3f92:	cmp	r3, #0
    3f94:	beq.n	4012 <SDClass::open(char const*, unsigned char)+0xa2>
		if (file) return File(new SDFile(file));
    3f96:	movs	r0, #104	; 0x68
    3f98:	bl	ae58 <operator new(unsigned int)>
    3f9c:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    3f9e:	ldrb.w	r6, [sp, #4]
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
    3fa2:	ldr	r0, [pc, #136]	; (402c <SDClass::open(char const*, unsigned char)+0xbc>)
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    3fa4:	ldr	r1, [pc, #136]	; (4030 <SDClass::open(char const*, unsigned char)+0xc0>)
    3fa6:	ldr	r2, [sp, #8]
    3fa8:	ldrb.w	r3, [sp, #12]
    3fac:	str	r0, [r4, #0]
    3fae:	add	r7, sp, #16
    3fb0:	strb	r6, [r4, #24]
    3fb2:	str	r1, [r4, #20]
{
  public:
	constexpr Print() : write_error(0) {}
    3fb4:	movs	r6, #0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    3fb6:	mov.w	r8, #1000	; 0x3e8
    3fba:	mov	r1, r7
    3fbc:	add.w	r0, r4, #36	; 0x24
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    3fc0:	str	r2, [r4, #28]
    3fc2:	strb.w	r3, [r4, #32]
    3fc6:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    3fc8:	strb	r6, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    3fca:	str	r6, [r4, #16]
    3fcc:	str.w	r8, [r4, #8]
    3fd0:	bl	75e8 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    3fd4:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    3fd6:	ldr	r1, [pc, #92]	; (4034 <SDClass::open(char const*, unsigned char)+0xc4>)
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    3fd8:	ldr	r2, [pc, #92]	; (4038 <SDClass::open(char const*, unsigned char)+0xc8>)
    3fda:	str	r6, [r4, #100]	; 0x64
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    3fdc:	adds	r3, #1
    3fde:	strb	r6, [r5, #4]
    3fe0:	str.w	r8, [r5, #8]
    3fe4:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
    3fe6:	str	r4, [r5, #16]
    3fe8:	str	r1, [r4, #20]
		if (f) f->refcount++;
    3fea:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    3fec:	str	r2, [r5, #0]
    3fee:	ldr	r3, [pc, #76]	; (403c <SDClass::open(char const*, unsigned char)+0xcc>)
    3ff0:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    3ff2:	mov	r0, r7
    3ff4:	bl	7660 <FsBaseFile::close()>
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
    3ff8:	mov	r0, r5
    3ffa:	add	sp, #80	; 0x50
    3ffc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    4000:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    4004:	adds	r1, #4
    4006:	mov	r0, sp
    4008:	bl	7830 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    400c:	ldr	r3, [sp, #72]	; 0x48
    400e:	cmp	r3, #0
    4010:	bne.n	3f96 <SDClass::open(char const*, unsigned char)+0x26>
    4012:	ldr	r3, [sp, #76]	; 0x4c
    4014:	cmp	r3, #0
    4016:	bne.n	3f96 <SDClass::open(char const*, unsigned char)+0x26>
    4018:	mov.w	r1, #1000	; 0x3e8

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    401c:	ldr	r2, [pc, #24]	; (4038 <SDClass::open(char const*, unsigned char)+0xc8>)
    401e:	strb	r3, [r5, #4]
    4020:	strb	r3, [r5, #12]
    4022:	str	r3, [r5, #16]
    4024:	str	r1, [r5, #8]
    4026:	str	r2, [r5, #0]
    4028:	add	r7, sp, #16
    402a:	b.n	3fee <SDClass::open(char const*, unsigned char)+0x7e>
    402c:	.word	0x0001366c
    4030:	.word	0x000135e8
    4034:	.word	0x000130e8
    4038:	.word	0x0001360c
    403c:	.word	0x000130c4

00004040 <_GLOBAL__sub_I_SD>:
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    4040:	push	{r4, r5, r6, r7}


class SDClass : public FS
{
public:
	SDClass() { }
    4042:	ldr	r3, [pc, #68]	; (4088 <_GLOBAL__sub_I_SD+0x48>)
    4044:	ldr	r5, [pc, #68]	; (408c <_GLOBAL__sub_I_SD+0x4c>)
    4046:	ldr	r4, [pc, #72]	; (4090 <_GLOBAL__sub_I_SD+0x50>)
    4048:	str	r5, [r3, #0]
    404a:	str.w	r4, [r3, #1184]	; 0x4a0
    404e:	movs	r5, #41	; 0x29
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    4050:	movs	r4, #0
    4052:	ldr	r0, [pc, #64]	; (4094 <_GLOBAL__sub_I_SD+0x54>)
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    4054:	ldr	r7, [pc, #64]	; (4098 <_GLOBAL__sub_I_SD+0x58>)
    4056:	strb.w	r5, [r3, #1203]	; 0x4b3
    405a:	movs	r6, #1
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    405c:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    4060:	strb.w	r4, [r3, #1181]	; 0x49d
    4064:	strb.w	r4, [r3, #1206]	; 0x4b6
    4068:	str.w	r0, [r3, #1172]	; 0x494
    406c:	str.w	r7, [r3, #1192]	; 0x4a8
    4070:	strb.w	r6, [r3, #1201]	; 0x4b1
    4074:	str.w	r4, [r3, #1156]	; 0x484
    4078:	str.w	r4, [r3, #1160]	; 0x488
    407c:	ldr	r2, [pc, #28]	; (409c <_GLOBAL__sub_I_SD+0x5c>)
    407e:	ldr	r1, [pc, #32]	; (40a0 <_GLOBAL__sub_I_SD+0x60>)
    4080:	mov	r0, r3
    4082:	pop	{r4, r5, r6, r7}
    4084:	b.w	af34 <__aeabi_atexit>
    4088:	.word	0x2001969c
    408c:	.word	0x0001378c
    4090:	.word	0x000137bc
    4094:	.word	0x00013814
    4098:	.word	0x38011001
    409c:	.word	0x20013730
    40a0:	.word	0x00003d0d

000040a4 <FsCache::sync() [clone .part.0]>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    40a4:	push	{r3, r4, r5, r6, r7, lr}
    40a6:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    40a8:	add.w	r6, r0, #16
    40ac:	ldr	r0, [r0, #4]
    40ae:	ldr	r1, [r4, #12]
    40b0:	ldr	r3, [r0, #0]
    40b2:	mov	r2, r6
    40b4:	ldr	r3, [r3, #28]
    40b6:	blx	r3
    40b8:	cbz	r0, 40cc <FsCache::sync() [clone .part.0]+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    40ba:	ldrb	r3, [r4, #0]
    40bc:	lsls	r2, r3, #30
    40be:	mov	r5, r0
    40c0:	bmi.n	40d2 <FsCache::sync() [clone .part.0]+0x2e>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    40c2:	bic.w	r3, r3, #1
    40c6:	strb	r3, [r4, #0]
  }
  return true;

 fail:
  return false;
}
    40c8:	mov	r0, r5
    40ca:	pop	{r3, r4, r5, r6, r7, pc}
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    40cc:	movs	r5, #0
}
    40ce:	mov	r0, r5
    40d0:	pop	{r3, r4, r5, r6, r7, pc}
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    40d2:	ldr	r0, [r4, #4]
    40d4:	ldr	r1, [r4, #12]
    40d6:	ldr	r2, [r0, #0]
    40d8:	ldr	r3, [r4, #8]
    40da:	ldr	r7, [r2, #28]
    40dc:	add	r1, r3
    40de:	mov	r2, r6
    40e0:	blx	r7
    40e2:	cmp	r0, #0
    40e4:	beq.n	40cc <FsCache::sync() [clone .part.0]+0x28>
    40e6:	ldrb	r3, [r4, #0]
    40e8:	b.n	40c2 <FsCache::sync() [clone .part.0]+0x1e>
    40ea:	nop

000040ec <FsCache::get(unsigned long, unsigned char)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    40ec:	push	{r3, r4, r5, r6, r7, lr}
  if (!m_blockDev) {
    40ee:	ldr	r5, [r0, #4]
    40f0:	cbz	r5, 4132 <FsCache::get(unsigned long, unsigned char)+0x46>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    40f2:	ldr	r3, [r0, #12]
    40f4:	cmp	r3, r1
    40f6:	mov	r4, r0
    40f8:	mov	r7, r2
    40fa:	mov	r6, r1
    40fc:	beq.n	411c <FsCache::get(unsigned long, unsigned char)+0x30>
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    40fe:	ldrb	r3, [r0, #0]
    4100:	lsls	r2, r3, #31
    4102:	bmi.n	412a <FsCache::get(unsigned long, unsigned char)+0x3e>
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    4104:	lsls	r3, r7, #29
    4106:	bpl.n	4136 <FsCache::get(unsigned long, unsigned char)+0x4a>
    4108:	add.w	r5, r4, #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    410c:	and.w	r2, r7, #3
    4110:	movs	r3, #0
    4112:	orrs	r3, r2
    4114:	strb	r3, [r4, #0]
    4116:	mov	r0, r5
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    m_sector = sector;
    4118:	str	r6, [r4, #12]
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
}
    411a:	pop	{r3, r4, r5, r6, r7, pc}
    411c:	ldrsb.w	r3, [r0], #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    4120:	and.w	r2, r7, #3
    4124:	orrs	r3, r2
    4126:	strb	r3, [r4, #0]
  return m_buffer;

 fail:
  return nullptr;
}
    4128:	pop	{r3, r4, r5, r6, r7, pc}
    412a:	bl	40a4 <FsCache::sync() [clone .part.0]>
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    if (!sync()) {
    412e:	cmp	r0, #0
    4130:	bne.n	4104 <FsCache::get(unsigned long, unsigned char)+0x18>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    4132:	movs	r0, #0
    4134:	pop	{r3, r4, r5, r6, r7, pc}
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    4136:	ldr	r0, [r4, #4]
    4138:	ldr	r3, [r0, #0]
    413a:	add.w	r5, r4, #16
    413e:	ldr	r3, [r3, #12]
    4140:	mov	r2, r5
    4142:	mov	r1, r6
    4144:	blx	r3
    4146:	cmp	r0, #0
    4148:	bne.n	410c <FsCache::get(unsigned long, unsigned char)+0x20>
    414a:	b.n	4132 <FsCache::get(unsigned long, unsigned char)+0x46>

0000414c <FsCache::sync()>:
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    414c:	ldrb	r3, [r0, #0]
    414e:	lsls	r3, r3, #31
    4150:	bmi.n	4156 <FsCache::sync()+0xa>
  }
  return true;

 fail:
  return false;
}
    4152:	movs	r0, #1
    4154:	bx	lr
    4156:	b.w	40a4 <FsCache::sync() [clone .part.0]>
    415a:	nop

0000415c <ExFatFile::close()>:
#include "../common/DebugMacros.h"
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    415c:	push	{r4, lr}
    415e:	mov	r4, r0
  bool rtn = sync();
    4160:	bl	5350 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    4164:	movs	r3, #0
    4166:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    416a:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    416e:	pop	{r4, pc}

00004170 <ExFatFile::getName(char*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    4170:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    4174:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    4178:	mov	r9, r0
    417a:	mov	r7, r1
    417c:	mov	r5, r2
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    417e:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    4182:	sub	sp, #20
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  if (!isOpen()) {
    4184:	ldrb.w	r3, [r9, #49]	; 0x31
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    4188:	add	r6, sp, #4
    418a:	stmia.w	r6, {r0, r1, r2}
  size_t n = 0;
  if (!isOpen()) {
    418e:	cmp	r3, #0
    4190:	beq.n	4210 <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    4192:	ldrb.w	r3, [r9, #48]	; 0x30
    4196:	cmp	r3, #1
    4198:	bls.n	421a <ExFatFile::getName(char*, unsigned int)+0xaa>
    419a:	mov.w	r8, #1
    419e:	movs	r4, #0
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
    41a0:	cmp.w	r8, #1
    41a4:	ite	ne
    41a6:	movne	r2, #32
    41a8:	moveq	r2, #64	; 0x40
    41aa:	mov	r1, r6
    41ac:	ldr.w	r0, [r9, #32]
    41b0:	bl	4d3c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    41b4:	cmp	r0, #1
    41b6:	bne.n	4210 <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    41b8:	movs	r2, #0
    41ba:	mov	r1, r6
    41bc:	ldr.w	r0, [r9, #32]
    41c0:	bl	4d08 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    41c4:	cbz	r0, 4210 <ExFatFile::getName(char*, unsigned int)+0xa0>
    41c6:	ldrb	r3, [r0, #0]
    41c8:	cmp	r3, #193	; 0xc1
    41ca:	bne.n	4210 <ExFatFile::getName(char*, unsigned int)+0xa0>
    41cc:	adds	r1, r7, r4
    41ce:	add.w	lr, r4, #15
    41d2:	b.n	41d6 <ExFatFile::getName(char*, unsigned int)+0x66>
    41d4:	mov	r4, r2
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    41d6:	ldrh.w	r3, [r0, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
    41da:	adds	r2, r4, #1
    41dc:	cbz	r3, 4204 <ExFatFile::getName(char*, unsigned int)+0x94>
    41de:	cmp	r2, r5
    41e0:	bcs.n	4204 <ExFatFile::getName(char*, unsigned int)+0x94>
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    41e2:	cmp	r3, #126	; 0x7e
    41e4:	ite	ls
    41e6:	uxtbls	r3, r3
    41e8:	movhi	r3, #63	; 0x3f
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    41ea:	cmp	r2, lr
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    41ec:	strb.w	r3, [r1], #1
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    41f0:	bne.n	41d4 <ExFatFile::getName(char*, unsigned int)+0x64>
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    41f2:	add.w	r8, r8, #1
    41f6:	ldrb.w	r3, [r9, #48]	; 0x30
    41fa:	uxtb.w	r8, r8
    41fe:	cmp	r3, r8
    4200:	mov	r4, r2
    4202:	bhi.n	41a0 <ExFatFile::getName(char*, unsigned int)+0x30>
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    4204:	movs	r3, #0
  return n;
    4206:	mov	r0, r4
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    4208:	strb	r3, [r7, r4]
  return n;

 fail:
  *name = 0;
  return 0;
}
    420a:	add	sp, #20
    420c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 done:
  name[n] = 0;
  return n;

 fail:
  *name = 0;
    4210:	movs	r0, #0
    4212:	strb	r0, [r7, #0]
  return 0;
}
    4214:	add	sp, #20
    4216:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    421a:	movs	r4, #0
    421c:	b.n	4204 <ExFatFile::getName(char*, unsigned int)+0x94>
    421e:	nop

00004220 <ExFatFile::openRoot(ExFatVolume*)>:
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    4220:	ldrb.w	r2, [r0, #49]	; 0x31
    4224:	cbz	r2, 422a <ExFatFile::openRoot(ExFatVolume*)+0xa>
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    4226:	movs	r0, #0
    4228:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    422a:	push	{r3, r4, r5, lr}
    422c:	mov	r4, r0
    422e:	mov	r5, r1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    4230:	mov	r1, r2
    4232:	movs	r2, #56	; 0x38
    4234:	bl	c49c <memset>
  m_attributes = FILE_ATTR_ROOT;
    4238:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    423a:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    423c:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4240:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    4244:	str	r5, [r4, #32]
    4246:	pop	{r3, r4, r5, pc}

00004248 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const ExChar_t* path,
                            ExName_t* fname, const ExChar_t** ptr) {
    4248:	push	{r4, r5, r6, r7, lr}
  ExChar_t c;
  int end;
  int len = 0;

  // Skip leading spaces.
  while (*path == ' ') {
    424a:	ldrb	r0, [r1, #0]
    424c:	cmp	r0, #32
    424e:	bne.n	4258 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    4250:	ldrb.w	r0, [r1, #1]!
    4254:	cmp	r0, #32
    4256:	beq.n	4250 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x8>
    path++;
  }
  fname->lfn = path;
    4258:	str	r1, [r2, #4]

  for (len = 0; ; len++) {
    c = path[len];
    425a:	ldrb	r0, [r1, #0]
    if (c == 0 || isDirSeparator(c)) {
    425c:	cmp	r0, #0
    425e:	beq.n	4304 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xbc>
    4260:	cmp	r0, #47	; 0x2f
    4262:	beq.n	42bc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x74>
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    4264:	cmp	r0, #92	; 0x5c
    4266:	beq.n	42aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    4268:	sub.w	r4, r0, #34	; 0x22
    426c:	uxtb	r4, r4
    426e:	cmp	r4, #29
    4270:	bls.n	42ae <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
    4272:	ldr.w	lr, [pc, #148]	; 4308 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>
    4276:	adds	r6, r1, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    4278:	movs	r4, #0
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    427a:	cmp	r0, #124	; 0x7c
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    427c:	sub.w	r5, r0, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    4280:	mov	r7, r6
    4282:	beq.n	42aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    4284:	cmp	r5, #94	; 0x5e
    4286:	bhi.n	42aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    4288:	ldrb.w	r0, [r6], #1
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    428c:	sub.w	r5, r0, #34	; 0x22
    4290:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    4292:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    4294:	cbz	r0, 42f6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xae>
    4296:	cmp	r0, #47	; 0x2f
    4298:	beq.n	42be <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x76>
    429a:	cmp	r0, #92	; 0x5c
    429c:	lsr.w	r7, lr, r5
    42a0:	beq.n	42aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    42a2:	cmp	r5, #29
    42a4:	bhi.n	427a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
    42a6:	lsls	r5, r7, #31
    42a8:	bpl.n	427a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    42aa:	movs	r0, #0
    42ac:	pop	{r4, r5, r6, r7, pc}
    42ae:	ldr	r5, [pc, #88]	; (4308 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>)
    42b0:	lsr.w	r4, r5, r4
    42b4:	lsls	r6, r4, #31
    42b6:	bpl.n	4272 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2a>
    42b8:	movs	r0, #0
    42ba:	pop	{r4, r5, r6, r7, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    42bc:	movs	r4, #0
    42be:	adds	r7, r1, r4
    42c0:	mov	r6, r7
    42c2:	mov	r5, r4
    42c4:	movs	r0, #47	; 0x2f
    42c6:	b.n	42ce <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x86>
    42c8:	ldrb.w	r0, [r6, #1]!
    if (!lfnLegalChar(c)) {
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    42cc:	adds	r5, #1
    42ce:	cmp	r0, #32
    42d0:	beq.n	42c8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
    42d2:	cmp	r0, #47	; 0x2f
    42d4:	beq.n	42c8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
  *ptr = &path[end];
    42d6:	add	r1, r5
    42d8:	str	r1, [r3, #0]

  // Back over spaces and dots.
  while (len) {
    42da:	cbz	r4, 42ee <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    42dc:	mov	r1, r7
    c = path[len - 1];
    42de:	ldrb.w	r3, [r1, #-1]!
    if (c != '.' && c != ' ') {
    42e2:	cmp	r3, #46	; 0x2e
    42e4:	beq.n	42ea <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa2>
    42e6:	cmp	r3, #32
    42e8:	bne.n	42fc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xb4>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    42ea:	subs	r4, #1
    42ec:	bne.n	42de <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x96>
    42ee:	mov	r0, r4
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    return false;
  }
  fname->len = len;
    42f0:	str	r0, [r2, #0]
  return true;
    42f2:	movs	r0, #1
    42f4:	pop	{r4, r5, r6, r7, pc}
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    42f6:	str	r7, [r3, #0]
    42f8:	adds	r7, r1, r4
    42fa:	b.n	42dc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x94>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    42fc:	cmp	r4, #255	; 0xff
    42fe:	ble.n	42ee <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    4300:	movs	r0, #0
    4302:	pop	{r4, r5, r6, r7, pc}
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    4304:	str	r1, [r3, #0]
    4306:	b.n	42f0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa8>
    4308:	.word	0x35000101

0000430c <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    430c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4310:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    4314:	lsls	r6, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    4316:	sub	sp, #12
    4318:	mov	r4, r0
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    431a:	bpl.n	43d2 <ExFatFile::read(void*, unsigned int)+0xc6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    431c:	lsls	r5, r3, #25
    431e:	mov	r6, r1
    4320:	mov	fp, r2
    4322:	bpl.w	4496 <ExFatFile::read(void*, unsigned int)+0x18a>
    if ((m_curPosition + count) > m_validLength) {
    4326:	ldrd	r0, r1, [r4]
    432a:	ldrd	r2, r3, [r4, #16]
    432e:	adds.w	r8, r0, fp
    4332:	adc.w	r9, r1, #0
    4336:	cmp	r3, r9
    4338:	it	eq
    433a:	cmpeq	r2, r8
    433c:	bcc.w	44a2 <ExFatFile::read(void*, unsigned int)+0x196>
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    4340:	cmp.w	fp, #0
    4344:	beq.n	4424 <ExFatFile::read(void*, unsigned int)+0x118>
    4346:	mov	r9, r4
    4348:	ldrd	r0, r1, [r9], #24
    434c:	mov	r5, fp
    clusterOffset = m_curPosition & m_vol->clusterMask();
    434e:	ldr	r7, [r4, #32]
    4350:	ldr.w	r3, [r7, #1080]	; 0x438
    4354:	ands	r3, r0
    sectorOffset = clusterOffset & m_vol->sectorMask();
    4356:	ubfx	sl, r3, #0, #9
    if (clusterOffset == 0) {
    435a:	cmp	r3, #0
    435c:	bne.n	4430 <ExFatFile::read(void*, unsigned int)+0x124>
      if (m_curPosition == 0) {
    435e:	orrs.w	r2, r0, r1
    4362:	bne.n	4450 <ExFatFile::read(void*, unsigned int)+0x144>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    4364:	ldrb.w	r2, [r4, #49]	; 0x31
    4368:	lsls	r1, r2, #25
    436a:	ite	mi
    436c:	ldrmi.w	r2, [r7, #1076]	; 0x434
    4370:	ldrpl	r2, [r4, #28]
      } else if (isContiguous()) {
        m_curCluster++;
    4372:	str	r2, [r4, #24]
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    4374:	ldr.w	r0, [r7, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4378:	ldrb.w	lr, [r7, #1093]	; 0x445
    437c:	lsrs	r3, r3, #9
    437e:	subs	r2, #2
    4380:	adds	r1, r3, r0
    4382:	lsl.w	r2, r2, lr
    4386:	add	r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    4388:	cmp.w	sl, #0
    438c:	bne.n	43e8 <ExFatFile::read(void*, unsigned int)+0xdc>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    438e:	cmp.w	r5, #512	; 0x200
    4392:	bcc.n	43e8 <ExFatFile::read(void*, unsigned int)+0xdc>
    4394:	ldr.w	r2, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    4398:	cmp	r1, r2
    439a:	beq.n	43e8 <ExFatFile::read(void*, unsigned int)+0xdc>
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    439c:	cmp.w	r5, #1024	; 0x400
    43a0:	bcc.n	445e <ExFatFile::read(void*, unsigned int)+0x152>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    43a2:	mov.w	r8, #1
    43a6:	lsl.w	r8, r8, lr
    43aa:	rsb	r3, r3, r8
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    43ae:	mov.w	r8, r5, lsr #9
    43b2:	cmp	r8, r3
    43b4:	it	cs
    43b6:	movcs	r8, r3
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    43b8:	cmp	r1, r2
    43ba:	bhi.n	4434 <ExFatFile::read(void*, unsigned int)+0x128>
    43bc:	add.w	r3, r8, r1
    43c0:	cmp	r2, r3
    43c2:	bcs.n	4434 <ExFatFile::read(void*, unsigned int)+0x128>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    43c4:	add.w	r0, r7, #528	; 0x210
    43c8:	str	r1, [sp, #4]
    43ca:	bl	414c <FsCache::sync()>
    43ce:	ldr	r1, [sp, #4]
    43d0:	cbnz	r0, 4434 <ExFatFile::read(void*, unsigned int)+0x128>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    43d2:	ldrb.w	r3, [r4, #50]	; 0x32
  return -1;
    43d6:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    43da:	orr.w	r3, r3, #2
    43de:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
}
    43e2:	add	sp, #12
    43e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    43e8:	add.w	r0, r7, #528	; 0x210
    43ec:	movs	r2, #0
    43ee:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    43f2:	cmp	r0, #0
    43f4:	beq.n	43d2 <ExFatFile::read(void*, unsigned int)+0xc6>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    43f6:	rsb	r8, sl, #512	; 0x200
    43fa:	cmp	r8, r5
    43fc:	it	cs
    43fe:	movcs	r8, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    4400:	add.w	r1, r0, sl
    4404:	mov	r2, r8
    4406:	mov	r0, r6
    4408:	bl	9220 <memcpy>
    440c:	mov	r2, r8
    440e:	movs	r3, #0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    4410:	ldrd	r0, r1, [r4]
    4414:	adds	r0, r0, r2
    4416:	adcs	r1, r3
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    4418:	subs.w	r5, r5, r8
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    441c:	add	r6, r8
    m_curPosition += n;
    441e:	strd	r0, r1, [r4]
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    4422:	bne.n	434e <ExFatFile::read(void*, unsigned int)+0x42>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    4424:	movs	r5, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    4426:	rsb	r0, r5, fp

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    442a:	add	sp, #12
    442c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4430:	ldr	r2, [r4, #24]
    4432:	b.n	4374 <ExFatFile::read(void*, unsigned int)+0x68>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    4434:	ldr.w	r0, [r7, #532]	; 0x214
    4438:	ldr	r3, [r0, #0]
    443a:	mov	r2, r6
    443c:	ldr	r7, [r3, #16]
    443e:	mov	r3, r8
    4440:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    4442:	cmp	r0, #0
    4444:	beq.n	43d2 <ExFatFile::read(void*, unsigned int)+0xc6>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    4446:	mov.w	r8, r8, lsl #9
    444a:	mov	r2, r8
    444c:	movs	r3, #0
    444e:	b.n	4410 <ExFatFile::read(void*, unsigned int)+0x104>
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      if (m_curPosition == 0) {
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
    4450:	ldrb.w	r2, [r4, #51]	; 0x33
    4454:	lsls	r2, r2, #25
    4456:	bpl.n	447a <ExFatFile::read(void*, unsigned int)+0x16e>
        m_curCluster++;
    4458:	ldr	r2, [r4, #24]
    445a:	adds	r2, #1
    445c:	b.n	4372 <ExFatFile::read(void*, unsigned int)+0x66>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    445e:	ldr.w	r0, [r7, #532]	; 0x214
    4462:	ldr	r3, [r0, #0]
    4464:	mov	r2, r6
    4466:	ldr	r3, [r3, #12]
    4468:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    446a:	cmp	r0, #0
    446c:	beq.n	43d2 <ExFatFile::read(void*, unsigned int)+0xc6>
    446e:	mov.w	r2, #512	; 0x200
    4472:	movs	r3, #0
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    4474:	mov.w	r8, #512	; 0x200
    4478:	b.n	4410 <ExFatFile::read(void*, unsigned int)+0x104>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    447a:	mov	r0, r7
    447c:	mov	r2, r9
    447e:	ldr	r1, [r4, #24]
    4480:	str	r3, [sp, #4]
    4482:	bl	4d94 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    4486:	sxtb	r0, r0
        if (fg < 0) {
    4488:	cmp	r0, #0
    448a:	blt.n	43d2 <ExFatFile::read(void*, unsigned int)+0xc6>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    448c:	beq.n	44a8 <ExFatFile::read(void*, unsigned int)+0x19c>
    448e:	ldr	r7, [r4, #32]
    4490:	ldr	r2, [r4, #24]
    4492:	ldr	r3, [sp, #4]
    4494:	b.n	4374 <ExFatFile::read(void*, unsigned int)+0x68>

  if (!isReadable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    4496:	ldrb.w	r3, [r0, #49]	; 0x31
    449a:	lsls	r0, r3, #28
    449c:	bmi.w	4326 <ExFatFile::read(void*, unsigned int)+0x1a>
    44a0:	b.n	4340 <ExFatFile::read(void*, unsigned int)+0x34>
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    44a2:	rsb	fp, r0, r2
    44a6:	b.n	4340 <ExFatFile::read(void*, unsigned int)+0x34>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
          // EOF if directory.
          if (isDir()) {
    44a8:	ldrb.w	r3, [r4, #49]	; 0x31
    44ac:	tst.w	r3, #80	; 0x50
    44b0:	bne.n	4426 <ExFatFile::read(void*, unsigned int)+0x11a>
    44b2:	b.n	43d2 <ExFatFile::read(void*, unsigned int)+0xc6>

000044b4 <ExFatFile::peek()>:
  }
  fname->len = len;
  return true;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    44b4:	push	{r4, r5, r6, r7, lr}
    44b6:	sub	sp, #12
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    44b8:	movs	r2, #1
    44ba:	add.w	r1, sp, #7
    44be:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    44c0:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    44c4:	ldr	r5, [r0, #24]
    44c6:	bl	430c <ExFatFile::read(void*, unsigned int)>
    44ca:	cmp	r0, #1
    44cc:	it	eq
    44ce:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    44d2:	str	r5, [r4, #24]
    44d4:	it	ne
    44d6:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    44da:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    44de:	add	sp, #12
    44e0:	pop	{r4, r5, r6, r7, pc}
    44e2:	nop

000044e4 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    44e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    44e8:	ldrb.w	lr, [r0, #49]	; 0x31
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    44ec:	ldr	r5, [r0, #24]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    44ee:	sub	sp, #12
    44f0:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    44f2:	cmp.w	lr, #0
    44f6:	beq.n	4530 <ExFatFile::seekSet(unsigned long long)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    44f8:	ldrd	r0, r1, [r0]
    44fc:	cmp	r1, r3
    44fe:	it	eq
    4500:	cmpeq	r0, r2
    4502:	mov	r6, r2
    4504:	mov	r7, r3
    4506:	beq.n	4580 <ExFatFile::seekSet(unsigned long long)+0x9c>
    return true;
  }
  if (pos == 0) {
    4508:	orrs.w	r3, r6, r7
    450c:	bne.n	451e <ExFatFile::seekSet(unsigned long long)+0x3a>
    // set position to start of file
    m_curCluster = 0;
    450e:	movs	r3, #0
    4510:	str	r3, [r4, #24]
    }
  }

 done:
  m_curPosition = pos;
  return true;
    4512:	movs	r0, #1
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    4514:	strd	r6, r7, [r4]
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    4518:	add	sp, #12
    451a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    451e:	tst.w	lr, #8
    4522:	beq.n	453a <ExFatFile::seekSet(unsigned long long)+0x56>
    if (pos > m_validLength) {
    4524:	ldrd	r2, r3, [r4, #16]
    4528:	cmp	r3, r7
    452a:	it	eq
    452c:	cmpeq	r2, r6
    452e:	bcs.n	453a <ExFatFile::seekSet(unsigned long long)+0x56>
 done:
  m_curPosition = pos;
  return true;

 fail:
  m_curCluster = tmp;
    4530:	str	r5, [r4, #24]
  return false;
    4532:	movs	r0, #0
}
    4534:	add	sp, #12
    4536:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    453a:	ldr	r3, [r4, #32]
    453c:	str	r3, [sp, #4]
    453e:	ldrb.w	ip, [r3, #1093]	; 0x445
  if (isContiguous()) {
    4542:	ldrb.w	sl, [r4, #51]	; 0x33
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    4546:	add.w	ip, ip, #9
    454a:	uxtb.w	ip, ip
    454e:	adds.w	r2, r6, #4294967295
    4552:	adc.w	r3, r7, #4294967295
    4556:	rsb	r8, ip, #32
    455a:	lsl.w	fp, r3, r8
    455e:	lsr.w	r2, r2, ip
    4562:	orr.w	r2, r2, fp
    4566:	sub.w	fp, ip, #32
    456a:	lsr.w	r3, r3, fp
  if (isContiguous()) {
    456e:	tst.w	sl, #64	; 0x40
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    4572:	orr.w	r2, r2, r3
  if (isContiguous()) {
    4576:	beq.n	4584 <ExFatFile::seekSet(unsigned long long)+0xa0>
    m_curCluster = m_firstCluster + nNew;
    4578:	ldr	r3, [r4, #28]
    457a:	add	r2, r3
    457c:	str	r2, [r4, #24]
    goto done;
    457e:	b.n	4512 <ExFatFile::seekSet(unsigned long long)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    4580:	movs	r0, #1
    4582:	b.n	4534 <ExFatFile::seekSet(unsigned long long)+0x50>
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    4584:	adds.w	r9, r0, #4294967295
    4588:	adc.w	sl, r1, #4294967295
    458c:	lsr.w	ip, r9, ip
    4590:	lsl.w	r8, sl, r8
    4594:	orr.w	ip, ip, r8
    4598:	lsr.w	fp, sl, fp
    459c:	orr.w	ip, ip, fp
  if (nNew < nCur || m_curPosition == 0) {
    45a0:	cmp	r2, ip
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    45a2:	mov	r3, sl
  if (nNew < nCur || m_curPosition == 0) {
    45a4:	bcs.n	45d6 <ExFatFile::seekSet(unsigned long long)+0xf2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    45a6:	tst.w	lr, #64	; 0x40
    45aa:	itet	ne
    45ac:	ldrne	r3, [sp, #4]
    45ae:	ldreq	r3, [r4, #28]
    45b0:	ldrne.w	r3, [r3, #1076]	; 0x434
    45b4:	str	r3, [r4, #24]
    45b6:	mov	r8, r2
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    45b8:	add.w	r9, r4, #24
    45bc:	mov	r2, r9
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    45be:	cmp.w	r8, #0
    45c2:	beq.n	4512 <ExFatFile::seekSet(unsigned long long)+0x2e>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    45c4:	ldr	r1, [r4, #24]
    45c6:	ldr	r0, [r4, #32]
    45c8:	bl	4d94 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    45cc:	add.w	r8, r8, #4294967295
    45d0:	cmp	r0, #0
    45d2:	bne.n	45bc <ExFatFile::seekSet(unsigned long long)+0xd8>
    45d4:	b.n	4530 <ExFatFile::seekSet(unsigned long long)+0x4c>
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
  if (nNew < nCur || m_curPosition == 0) {
    45d6:	orrs.w	r3, r0, r1
    45da:	beq.n	45a6 <ExFatFile::seekSet(unsigned long long)+0xc2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    45dc:	rsb	r2, ip, r2
    45e0:	b.n	45b6 <ExFatFile::seekSet(unsigned long long)+0xd2>
    45e2:	nop

000045e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    45e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    45e8:	mov	r6, r1
    45ea:	sub	sp, #76	; 0x4c
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    45ec:	ldrb.w	r1, [r0, #49]	; 0x31
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    45f0:	str	r2, [sp, #0]
    45f2:	mov	r5, r0
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    45f4:	cbnz	r1, 4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    45f6:	mov	sl, r3
    45f8:	ldrb.w	r3, [r6, #49]	; 0x31
    45fc:	tst.w	r3, #80	; 0x50
    4600:	bne.n	4612 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2e>
  return sync();
#endif  // READ_ONLY
 fail:

  // close file
  m_attributes = FILE_ATTR_CLOSED;
    4602:	movs	r0, #0
    4604:	strb.w	r0, [r5, #49]	; 0x31
  m_flags = 0;
    4608:	strb.w	r0, [r5, #51]	; 0x33
  return false;
}
    460c:	add	sp, #76	; 0x4c
    460e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    4612:	ldr	r3, [sp, #112]	; 0x70
    4614:	and.w	r3, r3, #3
    4618:	cmp	r3, #1
    461a:	beq.n	462a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x46>
    461c:	cmp	r3, #2
    461e:	beq.w	4834 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x250>
    4622:	cmp	r3, #0
    4624:	bne.n	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    4626:	movs	r3, #1
    4628:	b.n	462c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
    462a:	movs	r3, #2
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    462c:	ldr	r2, [sp, #112]	; 0x70
    462e:	and.w	r2, r2, #8
    4632:	orrs	r3, r2
    4634:	str	r3, [sp, #4]
  if (name) {
    4636:	ldr	r3, [sp, #0]
    4638:	cmp	r3, #0
    463a:	beq.w	4838 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x254>
    nameHash = exFatHashName(name, nameLength, 0);
    463e:	mov	r0, r3
    4640:	movs	r2, #0
    4642:	mov	r1, sl
    4644:	bl	5010 <exFatHashName(char const*, unsigned int, unsigned short)>
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    4648:	ldrb.w	r3, [r6, #49]	; 0x31
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    464c:	str	r0, [sp, #8]
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    464e:	cbz	r3, 4664 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    4650:	ldrd	r2, r3, [r6]
    4654:	orrs	r3, r2
    4656:	beq.n	4664 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    4658:	movs	r2, #0
    465a:	movs	r3, #0
    465c:	strd	r2, r3, [r6]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    4660:	movs	r1, #0
    4662:	str	r1, [r6, #24]
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    4664:	ldr	r2, [pc, #736]	; (4948 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x364>)
    4666:	add.w	r3, sl, #14
    466a:	smull	r1, r2, r2, r3
    466e:	add	r2, r3
    4670:	asrs	r3, r3, #31
    4672:	rsb	r3, r3, r2, asr #3
    4676:	uxtb	r3, r3
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;
    4678:	mov.w	r9, #0
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    467c:	str	r3, [sp, #12]
    467e:	adds	r3, #2
    4680:	uxtb.w	fp, r3

  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
    4684:	mov	r4, r9
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
    4686:	mov	r7, r9
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    4688:	movs	r2, #32
    468a:	add	r1, sp, #40	; 0x28
    468c:	mov	r0, r6
    468e:	bl	430c <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4692:	cmp	r0, #0
    4694:	beq.n	4712 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      goto create;
    }
    if (n != 32) {
    4696:	cmp	r0, #32
    4698:	bne.n	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    469a:	ldrb.w	r3, [sp, #40]	; 0x28
    469e:	lsls	r2, r3, #24
    46a0:	bmi.n	4770 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x18c>
      if (freeCount == 0) {
    46a2:	cmp	r4, #0
    46a4:	bne.n	476a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x186>
        freePos.position = dir->curPosition() - 32;
    46a6:	ldr	r2, [r6, #0]
        freePos.cluster = dir->curCluster();
    46a8:	ldr	r1, [r6, #24]
    46aa:	str	r1, [sp, #28]
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
    46ac:	subs	r2, #32
    46ae:	str	r2, [sp, #32]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
        freeCount++;
    46b0:	adds	r4, #1
    46b2:	uxtb	r4, r4
      }
      if (!buf[0]) {
    46b4:	cbz	r3, 4712 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    }
    switch (buf[0]) {
    46b6:	cmp	r3, #192	; 0xc0
    46b8:	beq.w	47e2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fe>
    46bc:	cmp	r3, #193	; 0xc1
    46be:	beq.n	4786 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1a2>
    46c0:	cmp	r3, #133	; 0x85
    46c2:	bne.n	4688 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
    46c4:	movs	r2, #56	; 0x38
    46c6:	movs	r1, #0
    46c8:	mov	r0, r5
    46ca:	bl	c49c <memset>
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    46ce:	ldrb.w	r3, [sp, #44]	; 0x2c
    }
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
    46d2:	ldrb.w	r2, [sp, #41]	; 0x29
    46d6:	strb.w	r2, [r5, #48]	; 0x30
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    46da:	lsls	r0, r3, #27
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    46dc:	and.w	r2, r3, #55	; 0x37
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
    46e0:	it	pl
    46e2:	orrpl.w	r2, r2, #8
    46e6:	strb.w	r2, [r5, #49]	; 0x31
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    46ea:	ldr	r3, [r6, #0]
    46ec:	ldr	r1, [r6, #32]
    46ee:	ldr	r2, [r6, #24]
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
    46f0:	str	r2, [r5, #36]	; 0x24
        m_dirPos.position = dir->curPosition() - 32;
    46f2:	subs	r3, #32
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();
    46f4:	str	r1, [r5, #32]

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    46f6:	str	r3, [r5, #40]	; 0x28
        m_dirPos.isContiguous = dir->isContiguous();
    46f8:	ldrb.w	r3, [r6, #51]	; 0x33
    46fc:	ubfx	r3, r3, #6, #1
    4700:	strb.w	r3, [r5, #44]	; 0x2c
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    4704:	movs	r2, #32
    4706:	add	r1, sp, #40	; 0x28
    4708:	mov	r0, r6
    470a:	bl	430c <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    470e:	cmp	r0, #0
    4710:	bne.n	4696 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xb2>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    4712:	ldr	r3, [sp, #112]	; 0x70
    4714:	lsls	r1, r3, #22
    4716:	bpl.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    471a:	ldr	r3, [sp, #4]
    471c:	lsls	r2, r3, #30
    471e:	bpl.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    4722:	ldr	r3, [sp, #0]
    4724:	cmp	r3, #0
    4726:	beq.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    472a:	cmp	r4, fp
    472c:	bcc.n	4748 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x164>
    472e:	b.n	483e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
        goto fail;
      }
      dir->m_curCluster = curCluster;
      continue;
    }
    if (n != 32) {
    4730:	cmp	r0, #32
    4732:	bne.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    4736:	cbnz	r4, 4742 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x15e>
      freePos.position = dir->curPosition() - 32;
    4738:	ldr	r2, [r6, #0]
      freePos.cluster = dir->curCluster();
    473a:	ldr	r1, [r6, #24]
    473c:	str	r1, [sp, #28]
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
    473e:	subs	r2, #32
    4740:	str	r2, [sp, #32]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    4742:	uxtb	r4, r3
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    4744:	cmp	fp, r4
    4746:	bls.n	483e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
    n = dir->read(buf, 32);
    4748:	movs	r2, #32
    474a:	add	r1, sp, #40	; 0x28
    474c:	mov	r0, r6
    474e:	bl	430c <ExFatFile::read(void*, unsigned int)>
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    4752:	adds	r3, r4, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
    4754:	cmp	r0, #0
    4756:	bne.n	4730 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x14c>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    4758:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    475a:	ldr	r7, [r6, #24]
      if (!dir->addDirCluster()) {
    475c:	bl	53b0 <ExFatFile::addDirCluster()>
    4760:	cmp	r0, #0
    4762:	beq.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    4766:	str	r7, [r6, #24]
      continue;
    4768:	b.n	4744 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x160>
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    476a:	cmp	r4, fp
    476c:	bcs.n	46b4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd0>
    476e:	b.n	46b0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xcc>
        freeCount++;
      }
      if (!buf[0]) {
        goto create;
      }
    } else if (!inSet) {
    4770:	cmp.w	r9, #0
    4774:	bne.n	46b6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd2>
      if (freeCount < freeNeed) {
        freeCount = 0;
    4776:	cmp	r4, fp
    4778:	it	cc
    477a:	movcc	r4, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    477c:	cmp	r3, #133	; 0x85
    477e:	bne.n	4688 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        continue;
      }
      inSet = true;
    4780:	mov.w	r9, #1
    4784:	b.n	46c4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xe0>
        }
        break;

      case EXFAT_TYPE_NAME:
        dirName = reinterpret_cast<DirName_t*>(buf);
        nCmp = nameLength - nameOffset;
    4786:	rsb	r8, r7, sl
    478a:	uxtb.w	r8, r8
    478e:	cmp.w	r8, #15
    4792:	it	cs
    4794:	movcs.w	r8, #15
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
    4798:	mov	r3, r8
    479a:	mov	r2, r7
    479c:	ldr	r1, [sp, #0]
    479e:	add	r0, sp, #40	; 0x28
    47a0:	bl	4fb8 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>
    47a4:	cmp	r0, #0
    47a6:	beq.n	4822 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x23e>
          inSet = false;
          break;
        }
        nameOffset += nCmp;
    47a8:	add	r7, r8
    47aa:	uxtb	r7, r7

        if (nameOffset == nameLength) {
    47ac:	cmp	sl, r7
    47ae:	bne.w	4688 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    47b2:	ldr	r3, [sp, #112]	; 0x70
    47b4:	lsls	r3, r3, #20
    47b6:	bmi.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    47ba:	ldr	r3, [sp, #112]	; 0x70
    47bc:	tst.w	r3, #17408	; 0x4400
    47c0:	bne.w	4904 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
    47c4:	ldrb.w	r3, [r5, #51]	; 0x33
    47c8:	lsls	r7, r3, #30
    47ca:	bmi.w	4904 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    47ce:	ldr	r3, [sp, #112]	; 0x70
    47d0:	lsls	r3, r3, #21
    47d2:	bmi.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    47d6:	ldr	r3, [sp, #112]	; 0x70
    47d8:	lsls	r0, r3, #17
    47da:	bmi.w	494c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x368>
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // READ_ONLY
  return true;
    47de:	movs	r0, #1
    47e0:	b.n	460c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    47e2:	ldrb.w	r3, [sp, #41]	; 0x29
        m_dirPos.isContiguous = dir->isContiguous();
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
    47e6:	ldr	r2, [sp, #4]
    47e8:	strb.w	r2, [r5, #51]	; 0x33
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    47ec:	lsls	r1, r3, #30
    47ee:	bpl.n	47f8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x214>
          m_flags |= FILE_FLAG_CONTIGUOUS;
    47f0:	orr.w	r3, r2, #64	; 0x40
    47f4:	strb.w	r3, [r5, #51]	; 0x33
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    47f8:	ldrd	r2, r3, [sp, #48]	; 0x30
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    47fc:	ldrd	r0, r1, [sp, #64]	; 0x40
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    4800:	strd	r2, r3, [r5, #16]
        m_firstCluster = getLe32(dirStream->firstCluster);
    4804:	ldr	r3, [sp, #60]	; 0x3c
    4806:	str	r3, [r5, #28]
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
    4808:	ldr	r3, [sp, #0]
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    480a:	strd	r0, r1, [r5, #8]
        if (!name) {
    480e:	cmp	r3, #0
    4810:	beq.n	47b2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1ce>
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    4812:	ldrb.w	r3, [sp, #43]	; 0x2b
    4816:	cmp	r3, sl
    4818:	beq.n	4826 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x242>
            nameHash != getLe16(dirStream->nameHash)) {
          inSet = false;
    481a:	mov.w	r9, #0
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    481e:	mov	r7, r9
    4820:	b.n	4688 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        nCmp = nameLength - nameOffset;
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
          inSet = false;
    4822:	mov	r9, r0
    4824:	b.n	4688 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    4826:	ldrh.w	r3, [sp, #44]	; 0x2c
    482a:	ldr	r2, [sp, #8]
    482c:	cmp	r3, r2
    482e:	bne.n	481a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x236>
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    4830:	movs	r7, #0
    4832:	b.n	4688 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    4834:	movs	r3, #3
    4836:	b.n	462c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
  uint8_t nCmp;
  uint8_t modeFlags;
  uint16_t nameHash = 0;
    4838:	ldr	r3, [sp, #0]
    483a:	str	r3, [sp, #8]
    483c:	b.n	4664 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    483e:	ldrb.w	r3, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    4842:	movs	r2, #56	; 0x38
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    4844:	ubfx	r3, r3, #6, #1
  memset(this, 0, sizeof(ExFatFile));
    4848:	movs	r1, #0
    484a:	mov	r0, r5
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    484c:	add.w	r8, sp, #28
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    4850:	strb.w	r3, [sp, #36]	; 0x24
  memset(this, 0, sizeof(ExFatFile));
    4854:	bl	c49c <memset>
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4858:	ldr	r4, [sp, #12]
    485a:	ldr	r3, [r6, #32]
    485c:	str.w	sl, [sp, #12]

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    4860:	ldmia.w	r8, {r0, r1, r2}
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4864:	add.w	r9, r4, #1
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
    4868:	movs	r4, #8
    486a:	strb.w	r4, [r5, #49]	; 0x31
    486e:	add.w	r7, sl, #30
  m_dirPos = freePos;
    4872:	add.w	r4, r5, #36	; 0x24
    4876:	ldr.w	sl, [sp]
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
    487a:	str	r3, [r5, #32]
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    487c:	uxtb.w	r9, r9

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    4880:	stmia.w	r4, {r0, r1, r2}
    4884:	uxtb	r7, r7
  for (uint8_t i = 0; i < freeNeed; i++) {
    4886:	movs	r6, #0
    4888:	mov	r0, r3
      if (1 != m_vol->dirSeek(&freePos, 32)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    cache = m_vol->dirCache(&freePos, FsCache::CACHE_FOR_WRITE);
    488a:	movs	r2, #1
    488c:	mov	r1, r8
    488e:	bl	4d08 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    4892:	mov	r4, r0
    4894:	cmp	r0, #0
    4896:	beq.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    489a:	ldrsb.w	r3, [r0]
    489e:	cmp	r3, #0
    48a0:	blt.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    48a4:	movs	r2, #32
    48a6:	movs	r1, #0
    48a8:	bl	c49c <memset>
    if (i == 0) {
    48ac:	cmp	r6, #0
    48ae:	beq.n	497e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x39a>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    48b0:	cmp	r6, #1
    48b2:	beq.n	495e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x37a>
    48b4:	rsb	r3, r6, r6, lsl #4
    48b8:	cmp	r7, #15
    48ba:	sub.w	r3, r3, #30

      dirStream->nameLength = nameLength;
      setLe16(dirStream->nameHash, nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    48be:	mov.w	r2, #193	; 0xc1
    48c2:	mov	r1, r7
    48c4:	it	cs
    48c6:	movcs	r1, #15
    48c8:	uxtb	r3, r3
    48ca:	strb	r2, [r4, #0]
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    48cc:	cbz	r1, 48e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    48ce:	adds	r4, #2
    48d0:	sxth	r1, r1
    48d2:	add.w	r1, r4, r1, lsl #1
    48d6:	add	r3, sl
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
    48d8:	ldrb.w	r2, [r3], #1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    48dc:	strh.w	r2, [r4], #2
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    48e0:	cmp	r1, r4
    48e2:	bne.n	48d8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2f4>
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  for (uint8_t i = 0; i < freeNeed; i++) {
    48e4:	adds	r6, #1
    48e6:	uxtb	r6, r6
    48e8:	cmp	fp, r6
    48ea:	bls.n	4940 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x35c>
    if (i) {
      if (1 != m_vol->dirSeek(&freePos, 32)) {
    48ec:	movs	r2, #32
    48ee:	mov	r1, r8
    48f0:	ldr	r0, [r5, #32]
    48f2:	bl	4d3c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    48f6:	cmp	r0, #1
    48f8:	bne.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    48fc:	subs	r7, #15
    48fe:	uxtb	r7, r7
    4900:	ldr	r0, [r5, #32]
    4902:	b.n	488a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2a6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    4904:	ldrb.w	r3, [r5, #49]	; 0x31
    4908:	tst.w	r3, #17
    490c:	bne.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    4910:	ldr	r3, [sp, #112]	; 0x70
    4912:	lsls	r6, r3, #21
    4914:	bpl.w	47d6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1f2>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    4918:	ldrb.w	r3, [r5, #51]	; 0x33
    491c:	lsls	r4, r3, #30
    491e:	bpl.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    4922:	movs	r2, #0
    4924:	movs	r3, #0
    4926:	mov	r0, r5
    4928:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
    492c:	cmp	r0, #0
    492e:	beq.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    4932:	mov	r0, r5
    4934:	bl	5704 <ExFatFile::truncate()>
    4938:	cmp	r0, #0
    493a:	beq.w	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    493e:	b.n	47de <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
      for (size_t k = 0; k < nCmp; k++) {
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
      }
    }
  }
  return sync();
    4940:	mov	r0, r5
    4942:	bl	5350 <ExFatFile::sync()>
    4946:	b.n	460c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
    4948:	.word	0x88888889
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    494c:	ldrd	r2, r3, [r5, #16]
    4950:	mov	r0, r5
    4952:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
    4956:	cmp	r0, #0
    4958:	bne.w	47de <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
    495c:	b.n	4602 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    495e:	movs	r3, #192	; 0xc0
    4960:	strb	r3, [r4, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    4962:	ldr	r3, [sp, #4]
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    4964:	movs	r2, #3
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    4966:	orn	r3, r3, #63	; 0x3f
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    496a:	strb	r2, [r4, #1]
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    496c:	strb.w	r3, [r5, #51]	; 0x33

      dirStream->nameLength = nameLength;
    4970:	ldrb.w	r3, [sp, #12]
    4974:	strb	r3, [r4, #3]
    4976:	ldrh.w	r3, [sp, #8]
    497a:	strh	r3, [r4, #4]
    497c:	b.n	48e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
      goto fail;
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    497e:	movs	r3, #133	; 0x85
    4980:	strb	r3, [r4, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    4982:	ldr	r3, [pc, #56]	; (49bc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3d8>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4984:	strb.w	r9, [r5, #48]	; 0x30
      dirFile->setCount = m_setCount;
    4988:	strb.w	r9, [r4, #1]

      if (FsDateTime::callback) {
    498c:	ldr	r3, [r3, #0]
    498e:	cbz	r3, 49b0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3cc>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    4990:	add.w	r2, sp, #23
    4994:	add.w	r1, sp, #26
    4998:	add	r0, sp, #24
    499a:	blx	r3
    499c:	ldrh.w	r1, [sp, #24]
    49a0:	ldrh.w	r2, [sp, #26]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    49a4:	ldrb.w	r3, [sp, #23]
    49a8:	strh	r1, [r4, #10]
    49aa:	strh	r2, [r4, #8]
    49ac:	strb	r3, [r4, #20]
    49ae:	b.n	48e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    49b0:	movw	r3, #21025	; 0x5221
    49b4:	strh	r3, [r4, #10]
    49b6:	strh	r3, [r4, #14]
    49b8:	strh	r3, [r4, #18]
    49ba:	b.n	48e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    49bc:	.word	0x20019b54

000049c0 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    49c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    49c4:	mov	r6, r0
    49c6:	sub	sp, #84	; 0x54
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    49c8:	ldrb.w	r4, [r6, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    49cc:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    49ce:	movs	r0, #0
    49d0:	strb.w	r0, [sp, #73]	; 0x49
    49d4:	strb.w	r0, [sp, #74]	; 0x4a
    49d8:	strb.w	r0, [sp, #75]	; 0x4b
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    49dc:	cbnz	r4, 49ec <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
    49de:	mov	r9, r3
    49e0:	ldrb.w	r3, [r1, #49]	; 0x31
    49e4:	tst.w	r3, #80	; 0x50
    49e8:	mov	r5, r1
    49ea:	bne.n	49f4 <ExFatFile::open(ExFatFile*, char const*, int)+0x34>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    49ec:	movs	r0, #0
}
    49ee:	add	sp, #84	; 0x54
    49f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    49f4:	ldrb	r3, [r2, #0]
    49f6:	cmp	r3, #47	; 0x2f
    49f8:	mov	r4, r2
    49fa:	beq.n	4a62 <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    49fc:	mov.w	r8, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    4a00:	mov	r1, r4
    4a02:	add	r3, sp, #12
    4a04:	add	r2, sp, #16
    4a06:	mov	r0, r6
    4a08:	bl	4248 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    4a0c:	cmp	r0, #0
    4a0e:	beq.n	49ec <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    4a10:	ldr	r3, [sp, #12]
    4a12:	ldrb	r3, [r3, #0]
    4a14:	cmp	r3, #0
    4a16:	beq.n	4a8c <ExFatFile::open(ExFatFile*, char const*, int)+0xcc>
    4a18:	ldrb.w	r3, [sp, #16]
    4a1c:	ldr	r2, [sp, #20]
    4a1e:	str.w	r8, [sp]
    4a22:	mov	r1, r5
    4a24:	mov	r0, r6
    4a26:	bl	45e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    4a2a:	cmp	r0, #0
    4a2c:	beq.n	49ec <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    4a2e:	mov	r4, r6
    4a30:	add	r7, sp, #24
    4a32:	add.w	lr, r6, #48	; 0x30
    4a36:	ldr	r0, [r4, #0]
    4a38:	ldr	r1, [r4, #4]
    4a3a:	ldr	r2, [r4, #8]
    4a3c:	ldr	r3, [r4, #12]
    4a3e:	mov	r5, r7
    4a40:	stmia	r5!, {r0, r1, r2, r3}
    4a42:	adds	r4, #16
    4a44:	cmp	r4, lr
    4a46:	mov	r7, r5
    4a48:	bne.n	4a36 <ExFatFile::open(ExFatFile*, char const*, int)+0x76>
    4a4a:	ldr	r0, [r4, #0]
    4a4c:	str	r0, [r5, #0]
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
    4a4e:	mov	r0, r6
    4a50:	bl	5350 <ExFatFile::sync()>
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    4a54:	add	r5, sp, #24
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    4a56:	strb.w	r8, [r6, #49]	; 0x31
  m_flags = 0;
    4a5a:	strb.w	r8, [r6, #51]	; 0x33
    4a5e:	ldr	r4, [sp, #12]
    4a60:	b.n	4a00 <ExFatFile::open(ExFatFile*, char const*, int)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    4a62:	adds	r4, #1
    4a64:	str	r4, [sp, #12]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    4a66:	ldrb	r1, [r4, #0]
    4a68:	cmp	r1, #47	; 0x2f
    4a6a:	beq.n	4a62 <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
      path++;
    }
    if (*path == 0) {
    4a6c:	cbz	r1, 4aa4 <ExFatFile::open(ExFatFile*, char const*, int)+0xe4>
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    4a6e:	movs	r2, #56	; 0x38
    4a70:	add	r0, sp, #24
    4a72:	movs	r1, #0
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    4a74:	ldr	r7, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    4a76:	bl	c49c <memset>
  m_attributes = FILE_ATTR_ROOT;
    4a7a:	movs	r2, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4a7c:	movs	r3, #1
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    4a7e:	add	r5, sp, #24
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    4a80:	str	r7, [sp, #56]	; 0x38
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    4a82:	strb.w	r2, [sp, #73]	; 0x49
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4a86:	strb.w	r3, [sp, #75]	; 0x4b
    4a8a:	b.n	49fc <ExFatFile::open(ExFatFile*, char const*, int)+0x3c>
    4a8c:	ldrb.w	r3, [sp, #16]
    4a90:	ldr	r2, [sp, #20]
    4a92:	str.w	r9, [sp]
    4a96:	mov	r1, r5
    4a98:	mov	r0, r6
    4a9a:	bl	45e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
}
    4a9e:	add	sp, #84	; 0x54
    4aa0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    4aa4:	movs	r2, #56	; 0x38
    4aa6:	mov	r0, r6
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    4aa8:	ldr	r4, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    4aaa:	bl	c49c <memset>
  m_attributes = FILE_ATTR_ROOT;
    4aae:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4ab0:	movs	r0, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    4ab2:	str	r4, [r6, #32]
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    4ab4:	strb.w	r3, [r6, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4ab8:	strb.w	r0, [r6, #51]	; 0x33
    4abc:	b.n	49ee <ExFatFile::open(ExFatFile*, char const*, int)+0x2e>
    4abe:	nop

00004ac0 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const ExChar_t* path, int oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
    4ac0:	cbz	r1, 4aca <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    4ac2:	add.w	r1, r1, #1096	; 0x448
    4ac6:	b.w	49c0 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    4aca:	mov	r0, r1
    4acc:	bx	lr
    4ace:	nop

00004ad0 <ExFatFile::openNext(ExFatFile*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4ad0:	ldrb.w	r3, [r0, #49]	; 0x31
    4ad4:	cbnz	r3, 4aec <ExFatFile::openNext(ExFatFile*, int)+0x1c>
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    4ad6:	push	{r4, r5, lr}
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4ad8:	ldrb.w	r4, [r1, #49]	; 0x31
    4adc:	ands.w	r4, r4, #80	; 0x50
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    4ae0:	sub	sp, #12
    4ae2:	mov	r5, r1
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4ae4:	bne.n	4af0 <ExFatFile::openNext(ExFatFile*, int)+0x20>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    4ae6:	mov	r0, r4
}
    4ae8:	add	sp, #12
    4aea:	pop	{r4, r5, pc}
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    4aec:	movs	r0, #0
}
    4aee:	bx	lr
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4af0:	ldrd	r4, r5, [r5]
    4af4:	movs	r5, #0
    4af6:	and.w	r4, r4, #31
    4afa:	orrs	r4, r5
    4afc:	beq.n	4b04 <ExFatFile::openNext(ExFatFile*, int)+0x34>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    4afe:	mov	r0, r3
}
    4b00:	add	sp, #12
    4b02:	pop	{r4, r5, pc}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);
    4b04:	str	r2, [sp, #0]
    4b06:	mov	r2, r3
    4b08:	bl	45e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>

 fail:
  return false;
}
    4b0c:	add	sp, #12
    4b0e:	pop	{r4, r5, pc}

00004b10 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>:
    }
  }
  return 1;
}
//------------------------------------------------------------------------------
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    4b10:	push	{r3, r4, r5, lr}
    4b12:	mov	r4, r1
    4b14:	ldr.w	r1, [r0, #1060]	; 0x424
    4b18:	mov	r5, r2
    4b1a:	add.w	r1, r1, r4, lsr #7
    4b1e:	add.w	r0, r0, #528	; 0x210
    4b22:	movs	r2, #0
    4b24:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    return -1;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4b28:	cbz	r0, 4b3c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x2c>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4b2a:	lsls	r4, r4, #2
    4b2c:	ubfx	r4, r4, #0, #9
    4b30:	ldr	r3, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    4b32:	adds	r2, r3, #1
    4b34:	beq.n	4b40 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x30>
    return 0;
  }
  *value = next;
    4b36:	str	r3, [r5, #0]
  return 1;
    4b38:	movs	r0, #1
    4b3a:	pop	{r3, r4, r5, pc}
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    return -1;
    4b3c:	movs	r0, #255	; 0xff
    4b3e:	pop	{r3, r4, r5, pc}
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    return 0;
    4b40:	movs	r0, #0
  }
  *value = next;
  return 1;
}
    4b42:	pop	{r3, r4, r5, pc}

00004b44 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4b44:	push	{r3, r4, r5, lr}
    4b46:	mov	r4, r1
    4b48:	ldr.w	r1, [r0, #1060]	; 0x424
    4b4c:	mov	r5, r2
    4b4e:	add.w	r1, r1, r4, lsr #7
    4b52:	add.w	r0, r0, #528	; 0x210
    4b56:	movs	r2, #1
    4b58:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    4b5c:	mov	r3, r0
    4b5e:	cbz	r0, 4b6c <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]+0x28>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4b60:	lsls	r4, r4, #2
    4b62:	ubfx	r4, r4, #0, #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    4b66:	movs	r0, #1
    4b68:	str	r5, [r3, r4]
    4b6a:	pop	{r3, r4, r5, pc}

 fail:
  return false;
}
    4b6c:	pop	{r3, r4, r5, pc}
    4b6e:	nop

00004b70 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    4b70:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4b74:	mov	r8, r0
    4b76:	mov	r9, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    4b78:	mov	fp, r1
    4b7a:	cmp	r1, #0
    4b7c:	beq.n	4c08 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x98>
    4b7e:	subs	r7, r1, #2
  if (start >= m_clusterCount) {
    4b80:	ldr.w	r3, [r8, #1072]	; 0x430
    4b84:	cmp	r7, r3
    4b86:	bcs.n	4c00 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x90>
    4b88:	and.w	r5, r7, #7
    4b8c:	movs	r3, #1
    4b8e:	lsl.w	r5, r3, r5
    4b92:	uxtb	r5, r5
    4b94:	ubfx	sl, r7, #3, #9
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    4b98:	mov	r6, r7
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    4b9a:	mov	r4, r7
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    4b9c:	ldr.w	r1, [r8, #1068]	; 0x42c
    4ba0:	movs	r2, #0
    4ba2:	add.w	r1, r1, r4, lsr #12
    4ba6:	mov	r0, r8
    4ba8:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    4bac:	cbz	r0, 4be0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
    4bae:	ldrb.w	r1, [r0, sl]
    4bb2:	b.n	4bca <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x5a>
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    4bb4:	cmp	r2, r9
    4bb6:	beq.n	4c0e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x9e>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    4bb8:	cmp	r7, r4
    4bba:	beq.n	4bde <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    4bbc:	ldr.w	r2, [r8, #1072]	; 0x430
    4bc0:	cmp	r4, r2
    4bc2:	bcs.n	4bf4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x84>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    4bc4:	ands.w	r5, r3, #255	; 0xff
    4bc8:	beq.n	4be4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x74>
        endAlloc++;
    4bca:	adds	r4, #1
        if (!(mask & cache[i])) {
    4bcc:	tst	r5, r1
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    4bce:	mov.w	r3, r5, lsl #1
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    4bd2:	sub.w	r2, r4, r6
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    4bd6:	beq.n	4bb4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x44>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    4bd8:	cmp	r7, r4
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    4bda:	mov	r6, r4
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    4bdc:	bne.n	4bbc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4c>
          return 1;
    4bde:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    4be0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4be4:	add.w	sl, sl, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4be8:	cmp.w	sl, #512	; 0x200
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    4bec:	mov.w	r5, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4bf0:	bne.n	4bae <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x3e>
    4bf2:	b.n	4bf8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x88>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    4bf4:	movs	r6, #0
    4bf6:	mov	r4, r6
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    4bf8:	mov.w	sl, #0
    4bfc:	movs	r5, #1
    4bfe:	b.n	4b9c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x2c>
    4c00:	movs	r7, #0
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
    4c02:	mov	sl, r7
    4c04:	movs	r5, #1
    4c06:	b.n	4b98 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x28>
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    4c08:	ldr.w	r7, [r0, #1056]	; 0x420
    4c0c:	b.n	4b80 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
            if (cluster == 0 && count == 1) {
    4c0e:	cmp.w	fp, #0
    4c12:	bne.n	4c1e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xae>
    4c14:	cmp.w	r9, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    4c18:	it	eq
    4c1a:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    4c1e:	adds	r0, r6, #2
    4c20:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4c24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t sector;
  uint32_t start = cluster - 2;
    4c28:	subs	r1, #2
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4c2a:	mov	r8, r0
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4c2c:	ldr.w	r0, [r0, #1072]	; 0x430
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4c30:	mov	r5, r2
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4c32:	adds	r2, r1, r2
    4c34:	cmp	r2, r0
    4c36:	bhi.n	4caa <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    4c38:	mov	sl, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    4c3a:	ldr.w	r3, [r8, #1056]	; 0x420
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    4c3e:	cmp.w	sl, #0
    4c42:	bne.n	4cb0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x8c>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    }
  } else {
    if (start < m_bitmapStart) {
    4c44:	cmp	r1, r3
      m_bitmapStart = start;
    4c46:	it	cc
    4c48:	strcc.w	r1, [r8, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    4c4c:	and.w	r4, r1, #7
    4c50:	movs	r2, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4c52:	ldr.w	r3, [r8, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    4c56:	lsl.w	r4, r2, r4
    4c5a:	uxtb	r4, r4
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4c5c:	add.w	r9, r3, r1, lsr #12
  i = (start >> 3) & m_sectorMask;
    4c60:	ubfx	r6, r1, #3, #9
    4c64:	movs	r2, #1
    4c66:	mov	r1, r9
    4c68:	mov	r0, r8
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    4c6a:	add	r9, r2
    4c6c:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4c70:	cbz	r0, 4caa <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    4c72:	adds	r7, r0, r6
    4c74:	add.w	r0, r0, #512	; 0x200
    4c78:	ldrb.w	r2, [r7], #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    4c7c:	tst	r2, r4
    4c7e:	ite	ne
    4c80:	movne	r6, #1
    4c82:	moveq	r6, #0
    4c84:	cmp	r6, sl
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4c86:	eor.w	r2, r2, r4
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    4c8a:	mov.w	r4, r4, lsl #1
        if (value == static_cast<bool>(cache[i] & mask)) {
    4c8e:	beq.n	4caa <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
    4c90:	subs	r5, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4c92:	strb.w	r2, [r7, #-1]
        if (--count == 0) {
    4c96:	beq.n	4cc4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    4c98:	ands.w	r4, r4, #255	; 0xff
    4c9c:	bne.n	4c7c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x58>
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4c9e:	cmp	r0, r7
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    4ca0:	mov	r6, r4
    4ca2:	mov.w	r4, #1
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4ca6:	bne.n	4c78 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    4ca8:	b.n	4c64 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x40>
    }
    i = 0;
  }

 fail:
  return false;
    4caa:	movs	r0, #0
    4cac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    4cb0:	cmp	r1, r3
    4cb2:	bhi.n	4c4c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
    4cb4:	cmp	r2, r3
    4cb6:	bls.n	4c4c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    4cb8:	cmp	r2, r0
    4cba:	it	cs
    4cbc:	movcs	r2, #0
    4cbe:	str.w	r2, [r8, #1056]	; 0x420
    4cc2:	b.n	4c4c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    4cc4:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    4cc6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4cca:	nop

00004ccc <ExFatPartition::chainSize(unsigned long)>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    4ccc:	push	{r4, r5, r6, lr}
    4cce:	sub	sp, #8
    4cd0:	add	r6, sp, #8
    4cd2:	mov	r5, r0
    4cd4:	str.w	r1, [r6, #-4]!
  uint32_t n = 0;
    4cd8:	movs	r4, #0
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4cda:	ldr.w	r3, [r5, #1072]	; 0x430
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    4cde:	ldr	r1, [sp, #4]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4ce0:	adds	r3, #1
    4ce2:	cmp	r1, r3
    4ce4:	bls.n	4cec <ExFatPartition::chainSize(unsigned long)+0x20>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    4ce6:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    4ce8:	add	sp, #8
    4cea:	pop	{r4, r5, r6, pc}
    4cec:	mov	r2, r6
    4cee:	mov	r0, r5
    4cf0:	bl	4b10 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    4cf4:	sxtb	r0, r0
    if (status < 0) return 0;
    4cf6:	cmp	r0, #0
    4cf8:	blt.n	4ce6 <ExFatPartition::chainSize(unsigned long)+0x1a>
    n++;
    4cfa:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    4cfe:	bne.n	4cda <ExFatPartition::chainSize(unsigned long)+0xe>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    4d00:	mov	r0, r4
  } while (status);
  return n;
}
    4d02:	add	sp, #8
    4d04:	pop	{r4, r5, r6, pc}
    4d06:	nop

00004d08 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    4d08:	push	{r3, r4, r5, r6, r7, lr}
    4d0a:	mov	r6, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    4d0c:	ldmia.w	r6, {r3, r5}
    4d10:	ldr.w	r1, [r0, #1080]	; 0x438
    4d14:	ldr.w	r4, [r0, #1068]	; 0x42c
    4d18:	ldrb.w	r7, [r0, #1093]	; 0x445
    4d1c:	ands	r1, r5
    4d1e:	subs	r3, #2
    4d20:	add.w	r1, r4, r1, lsr #9
    4d24:	lsls	r3, r7
    4d26:	add	r1, r3
    4d28:	add.w	r0, r0, #528	; 0x210
    4d2c:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    4d30:	cbz	r0, 4d3a <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x32>
    4d32:	ldr	r3, [r6, #4]
    4d34:	ubfx	r3, r3, #0, #9
    4d38:	add	r0, r3
}
    4d3a:	pop	{r3, r4, r5, r6, r7, pc}

00004d3c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4d3c:	push	{r4, r5, r6, lr}
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4d3e:	ldr	r4, [r1, #4]
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4d40:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
    4d42:	adds	r3, r4, r2
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4d44:	ldr.w	r1, [r0, #1080]	; 0x438
  pos->position += offset;
    4d48:	str	r3, [r5, #4]
  tmp >>= bytesPerClusterShift();
    4d4a:	ldrb.w	r3, [r0, #1093]	; 0x445
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4d4e:	ands	r4, r1
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4d50:	adds	r3, #9
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4d52:	add	r2, r4
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4d54:	uxtb	r3, r3
    4d56:	lsr.w	r4, r2, r3
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4d5a:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    4d5c:	cbz	r4, 4d6e <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x32>
    if (pos->isContiguous) {
    4d5e:	ldrb	r3, [r5, #8]
    4d60:	cbz	r3, 4d72 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x36>
      pos->cluster++;
    4d62:	ldr	r3, [r5, #0]
    4d64:	adds	r3, #1
    4d66:	str	r3, [r5, #0]
    4d68:	subs	r4, #1
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    4d6a:	cmp	r4, #0
    4d6c:	bne.n	4d5e <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x22>
      if (status != 1) {
        return status;
      }
    }
  }
  return 1;
    4d6e:	movs	r0, #1
    4d70:	pop	{r4, r5, r6, pc}
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4d72:	ldr.w	r3, [r6, #1072]	; 0x430
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4d76:	ldr	r1, [r5, #0]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4d78:	adds	r3, #1
    4d7a:	cmp	r1, r3
    4d7c:	bls.n	4d84 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x48>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4d7e:	mov.w	r0, #4294967295
        return status;
      }
    }
  }
  return 1;
}
    4d82:	pop	{r4, r5, r6, pc}
    4d84:	mov	r2, r5
    4d86:	mov	r0, r6
    4d88:	bl	4b10 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4d8c:	sxtb	r0, r0
      if (status != 1) {
    4d8e:	cmp	r0, #1
    4d90:	beq.n	4d68 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    4d92:	pop	{r4, r5, r6, pc}

00004d94 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4d94:	ldr.w	r3, [r0, #1072]	; 0x430
    4d98:	adds	r3, #1
    4d9a:	cmp	r3, r1
    4d9c:	bcs.n	4da2 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0xe>
  if (next == EXFAT_EOC) {
    return 0;
  }
  *value = next;
  return 1;
}
    4d9e:	movs	r0, #255	; 0xff
    4da0:	bx	lr
    4da2:	b.w	4b10 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
    4da6:	nop

00004da8 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4da8:	cmp	r1, #1
    4daa:	bls.n	4dc8 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x20>
    4dac:	ldr.w	r3, [r0, #1072]	; 0x430
    4db0:	adds	r3, #1
    4db2:	cmp	r1, r3
  }
  *value = next;
  return 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4db4:	push	{r4}
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4db6:	bls.n	4dc0 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x18>
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
}
    4db8:	movs	r0, #0
    4dba:	ldr.w	r4, [sp], #4
    4dbe:	bx	lr
    4dc0:	ldr.w	r4, [sp], #4
    4dc4:	b.w	4b44 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    4dc8:	movs	r0, #0
    4dca:	bx	lr

00004dcc <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    4dcc:	push	{r4, r5, r6, r7, lr}
    4dce:	mov	r4, r1
    4dd0:	sub	sp, #12
    4dd2:	mov	r5, r0
  uint32_t next;
  uint32_t start = cluster;
    4dd4:	mov	r6, r1
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4dd6:	ldr.w	r3, [r5, #1072]	; 0x430
    4dda:	adds	r3, #1
    4ddc:	cmp	r4, r3
    4dde:	bls.n	4de6 <ExFatPartition::freeChain(unsigned long)+0x1a>
  } while (status);

  return true;

 fail:
  return false;
    4de0:	movs	r0, #0
}
    4de2:	add	sp, #12
    4de4:	pop	{r4, r5, r6, r7, pc}
    4de6:	add	r2, sp, #4
    4de8:	mov	r1, r4
    4dea:	mov	r0, r5
    4dec:	bl	4b10 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    4df0:	sxtb	r7, r0
    if (status < 0) {
    4df2:	cmp	r7, #0
    4df4:	blt.n	4de0 <ExFatPartition::freeChain(unsigned long)+0x14>
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4df6:	cmp	r4, #1
    4df8:	bls.n	4de0 <ExFatPartition::freeChain(unsigned long)+0x14>
    4dfa:	ldr.w	r3, [r5, #1072]	; 0x430
    4dfe:	adds	r3, #1
    4e00:	cmp	r4, r3
    4e02:	bhi.n	4de0 <ExFatPartition::freeChain(unsigned long)+0x14>
    4e04:	movs	r2, #0
    4e06:	mov	r1, r4
    4e08:	mov	r0, r5
    4e0a:	bl	4b44 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    4e0e:	cmp	r0, #0
    4e10:	beq.n	4de0 <ExFatPartition::freeChain(unsigned long)+0x14>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    4e12:	ldr	r3, [sp, #4]
    4e14:	adds	r4, #1
    4e16:	cmp	r4, r3
    4e18:	bne.n	4e32 <ExFatPartition::freeChain(unsigned long)+0x66>
    4e1a:	cmp	r7, #0
    4e1c:	bne.n	4dd6 <ExFatPartition::freeChain(unsigned long)+0xa>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4e1e:	mov	r3, r7
    4e20:	subs	r2, r4, r6
    4e22:	mov	r1, r6
    4e24:	mov	r0, r5
    4e26:	bl	4c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4e2a:	cmp	r0, #0
    4e2c:	beq.n	4de0 <ExFatPartition::freeChain(unsigned long)+0x14>

  return true;

 fail:
  return false;
}
    4e2e:	add	sp, #12
    4e30:	pop	{r4, r5, r6, r7, pc}
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4e32:	subs	r2, r4, r6
    4e34:	mov	r1, r6
    4e36:	movs	r3, #0
    4e38:	mov	r0, r5
    4e3a:	bl	4c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4e3e:	cmp	r0, #0
    4e40:	beq.n	4de0 <ExFatPartition::freeChain(unsigned long)+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4e42:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    4e44:	cmp	r7, #0
    4e46:	beq.n	4de2 <ExFatPartition::freeChain(unsigned long)+0x16>
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4e48:	mov	r6, r4
    4e4a:	b.n	4dd6 <ExFatPartition::freeChain(unsigned long)+0xa>

00004e4c <ExFatPartition::freeClusterCount()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4e4c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
    4e50:	movs	r4, #0
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    4e52:	ldr.w	r6, [r0, #1068]	; 0x42c

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4e56:	mov	r8, r0
    4e58:	add.w	r7, r0, #528	; 0x210
  uint32_t nc = 0;
    4e5c:	mov	r5, r4
    4e5e:	mov	r1, r6
    4e60:	movs	r2, #0
    4e62:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4e64:	adds	r6, #1
    4e66:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4e6a:	cbz	r0, 4eba <ExFatPartition::freeClusterCount()+0x6e>
    4e6c:	add.w	lr, r0, #4294967295
    4e70:	ldr.w	ip, [r8, #1072]	; 0x430
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    4e74:	ldrb.w	r0, [lr, #1]!
    4e78:	cmp	r0, #255	; 0xff
    4e7a:	add.w	r9, r5, #4096	; 0x1000
    4e7e:	beq.n	4ea8 <ExFatPartition::freeClusterCount()+0x5c>
        usedCount+= 8;
      } else if (cache[i]) {
    4e80:	cbz	r0, 4e96 <ExFatPartition::freeClusterCount()+0x4a>
    4e82:	movs	r2, #8
    4e84:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    4e86:	tst	r0, r3
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4e88:	mov.w	r1, r3, lsl #1
          if ((mask & cache[i])) {
            usedCount++;
    4e8c:	it	ne
    4e8e:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4e90:	subs	r2, #1
    4e92:	uxtb	r3, r1
    4e94:	bne.n	4e86 <ExFatPartition::freeClusterCount()+0x3a>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4e96:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4e98:	cmp	ip, r5
    4e9a:	bls.n	4eb2 <ExFatPartition::freeClusterCount()+0x66>
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4e9c:	cmp	r5, r9
    4e9e:	beq.n	4e5e <ExFatPartition::freeClusterCount()+0x12>
      if (cache[i] == 0XFF) {
    4ea0:	ldrb.w	r0, [lr, #1]!
    4ea4:	cmp	r0, #255	; 0xff
    4ea6:	bne.n	4e80 <ExFatPartition::freeClusterCount()+0x34>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4ea8:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4eaa:	cmp	ip, r5
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
    4eac:	add.w	r4, r4, #8
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    4eb0:	bhi.n	4e9c <ExFatPartition::freeClusterCount()+0x50>
        return m_clusterCount - usedCount;
    4eb2:	rsb	r0, r4, ip
    4eb6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }
}
    4eba:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4ebe:	nop

00004ec0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4ec0:	push	{r3, r4, r5, r6, r7, lr}
    4ec2:	mov	r4, r0
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    4ec4:	movs	r3, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4ec6:	mov.w	r6, #4294967295
    4eca:	add.w	r7, r0, #528	; 0x210
  m_blockDev = dev;
    4ece:	str.w	r1, [r0, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4ed2:	str	r1, [r0, #4]
    4ed4:	str.w	r1, [r0, #532]	; 0x214
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4ed8:	mov	r5, r2
    4eda:	mov	r0, r7
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    4edc:	strb.w	r3, [r4, #1092]	; 0x444
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4ee0:	strb	r3, [r4, #0]
    4ee2:	strb.w	r3, [r4, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    4ee6:	str	r6, [r4, #12]
    4ee8:	str.w	r6, [r4, #540]	; 0x21c
    4eec:	mov	r2, r3
    4eee:	mov	r1, r3
    4ef0:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    4ef4:	cmp	r5, #4
    4ef6:	bhi.n	4f12 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    4ef8:	mov	r6, r0
    4efa:	cbz	r0, 4f12 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    4efc:	cbnz	r5, 4f16 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    4efe:	movs	r2, #5
    4f00:	ldr	r1, [pc, #152]	; (4f9c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xdc>)
    4f02:	adds	r0, r6, #3
    4f04:	bl	cc5c <strncmp>
    4f08:	cbnz	r0, 4f12 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4f0a:	ldrb.w	r3, [r6, #108]	; 0x6c
    4f0e:	cmp	r3, #9
    4f10:	beq.n	4f46 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x86>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    4f12:	movs	r0, #0
    4f14:	pop	{r3, r4, r5, r6, r7, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    4f16:	subs	r3, r5, #1
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
    4f18:	add.w	r3, r0, r3, lsl #4
    4f1c:	ldrb.w	r2, [r3, #446]	; 0x1be
    4f20:	ands.w	r2, r2, #127	; 0x7f
    4f24:	bne.n	4f12 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    4f26:	ldrb.w	r3, [r3, #450]	; 0x1c2
    4f2a:	cmp	r3, #0
    4f2c:	beq.n	4f12 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4f2e:	add.w	r5, r0, r5, lsl #4
    4f32:	mov	r0, r7
    4f34:	ldr.w	r5, [r5, #438]	; 0x1b6
    4f38:	mov	r1, r5
    4f3a:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    volStart = getLe32(mp->relativeSectors);
    cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
    if (!cache) {
    4f3e:	mov	r6, r0
    4f40:	cmp	r0, #0
    4f42:	bne.n	4efe <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x3e>
    4f44:	b.n	4f12 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    4f46:	ldr	r3, [r6, #80]	; 0x50
    4f48:	add	r3, r5
    4f4a:	str.w	r3, [r4, #1060]	; 0x424
    4f4e:	ldr	r3, [r6, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4f50:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4f54:	ldr	r3, [r6, #88]	; 0x58
    4f56:	add	r5, r3
    4f58:	str.w	r5, [r4, #1068]	; 0x42c
    4f5c:	ldr	r3, [r6, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4f5e:	str.w	r3, [r4, #1072]	; 0x430
    4f62:	ldr	r3, [r6, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4f64:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4f68:	ldrb.w	r3, [r6, #109]	; 0x6d
    4f6c:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4f70:	movs	r5, #1
    4f72:	adds	r3, #9
    4f74:	lsl.w	r3, r5, r3
  m_clusterMask = m_bytesPerCluster - 1;
    4f78:	subs	r2, r3, #1
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    4f7a:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    4f7e:	mov	r1, r0
  m_fatLength = getLe32(bpb->fatLength);
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
  m_clusterCount = getLe32(bpb->clusterCount);
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4f80:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4f84:	str.w	r2, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
  bitmapFind(0, 1);
    4f88:	mov	r0, r4
    4f8a:	mov	r2, r5
    4f8c:	bl	4b70 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4f90:	movs	r3, #64	; 0x40
    4f92:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    4f96:	mov	r0, r5

 fail:
  return false;
}
    4f98:	pop	{r3, r4, r5, r6, r7, pc}
    4f9a:	nop
    4f9c:	.word	0x000137ac

00004fa0 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4fa0:	push	{r4, lr}
    4fa2:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    4fa4:	ldr.w	r1, [r0, #1076]	; 0x434
    4fa8:	bl	4ccc <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4fac:	ldrb.w	r3, [r4, #1093]	; 0x445
    4fb0:	adds	r3, #9
    4fb2:	uxtb	r3, r3
}
    4fb4:	lsls	r0, r3
    4fb6:	pop	{r4, pc}

00004fb8 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>:
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    4fb8:	cbz	r3, 500c <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x54>
  }
  return true;
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
    4fba:	push	{r4, r5, r6}
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    4fbc:	ldrh	r4, [r0, #2]
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    4fbe:	cmp	r4, #126	; 0x7e
    4fc0:	bhi.n	5000 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
    4fc2:	add	r3, r2
    4fc4:	adds	r5, r1, r3
    4fc6:	add	r2, r1
    4fc8:	adds	r0, #2
    4fca:	ldrb.w	r3, [r2], #1
    4fce:	uxtb	r4, r4
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    4fd0:	sub.w	r1, r3, #97	; 0x61
    4fd4:	cmp	r1, #25
    4fd6:	sub.w	r1, r4, #97	; 0x61
    4fda:	ite	ls
    4fdc:	movls	r6, #32
    4fde:	movhi	r6, #0
    4fe0:	cmp	r1, #25
    4fe2:	ite	ls
    4fe4:	movls	r1, #32
    4fe6:	movhi	r1, #0
    4fe8:	subs	r3, r3, r6
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    4fea:	subs	r4, r4, r1
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    4fec:	uxtb	r3, r3
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    4fee:	uxtb	r4, r4
    4ff0:	cmp	r4, r3
    4ff2:	bne.n	5000 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    4ff4:	cmp	r2, r5
    4ff6:	beq.n	5006 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x4e>
    4ff8:	ldrh.w	r4, [r0, #2]!
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    4ffc:	cmp	r4, #126	; 0x7e
    4ffe:	bls.n	4fca <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x12>
      return false;
    5000:	movs	r0, #0
    }
  }
  return true;
}
    5002:	pop	{r4, r5, r6}
    5004:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    5006:	movs	r0, #1
}
    5008:	pop	{r4, r5, r6}
    500a:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    500c:	movs	r0, #1
}
    500e:	bx	lr

00005010 <exFatHashName(char const*, unsigned int, unsigned short)>:
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    5010:	cbz	r1, 5046 <exFatHashName(char const*, unsigned int, unsigned short)+0x36>
    hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
    5012:	push	{r4}
    5014:	add	r1, r0
    5016:	lsls	r3, r2, #15
    5018:	orr.w	r3, r3, r2, lsr #1
  for (size_t i = 0; i < n; i++) {
    uint8_t c = name[i];
    501c:	ldrb.w	r2, [r0], #1
    if ('a' <= c && c <= 'z') {
    5020:	sub.w	r4, r2, #97	; 0x61
    5024:	cmp	r4, #25
      c -= 'a' - 'A';
    5026:	itt	ls
    5028:	subls	r2, #32
    502a:	uxtbls	r2, r2
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    502c:	uxtah	r2, r2, r3
    5030:	uxth	r2, r2
    5032:	lsls	r3, r2, #15
    5034:	orr.w	r2, r3, r2, lsr #1
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    5038:	cmp	r1, r0
    503a:	uxth	r2, r2
    503c:	bne.n	5016 <exFatHashName(char const*, unsigned int, unsigned short)+0x6>
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    hash = ((hash << 15) | (hash >> 1));
  }
  return hash;
}
    503e:	mov	r0, r2
    5040:	ldr.w	r4, [sp], #4
    5044:	bx	lr
    5046:	mov	r0, r2
    5048:	bx	lr
    504a:	nop

0000504c <ExFatFile::addCluster()>:
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    504c:	ldr	r1, [r0, #24]
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    504e:	push	{r3, r4, r5, r6, r7, lr}
    5050:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    5052:	ldr	r0, [r0, #32]
    5054:	cbz	r1, 5058 <ExFatFile::addCluster()+0xc>
    5056:	adds	r1, #1
    5058:	movs	r2, #1
    505a:	bl	4b70 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    505e:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    5060:	mov	r6, r0
  if (find < 2) {
    5062:	bls.n	50c4 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    5064:	movs	r3, #1
    5066:	mov	r1, r0
    5068:	mov	r2, r3
    506a:	ldr	r0, [r4, #32]
    506c:	bl	4c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    5070:	mov	r7, r0
    5072:	cbz	r0, 50c4 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    5074:	ldr	r0, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    5076:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    507a:	cbz	r0, 50ca <ExFatFile::addCluster()+0x7e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    goto done;
  }
  if (isContiguous()) {
    507c:	lsls	r2, r3, #25
    507e:	bpl.n	50a8 <ExFatFile::addCluster()+0x5c>
    if (find == (m_curCluster + 1)) {
    5080:	adds	r2, r0, #1
    5082:	cmp	r6, r2
    5084:	beq.n	50d2 <ExFatFile::addCluster()+0x86>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    5086:	bic.w	r2, r3, #64	; 0x40
    508a:	strb.w	r2, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    508e:	ldr	r3, [r4, #28]
    5090:	b.n	509e <ExFatFile::addCluster()+0x52>
      if (!m_vol->fatPut(c, c + 1)) {
    5092:	ldr	r0, [r4, #32]
    5094:	bl	4da8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    5098:	cbz	r0, 50c4 <ExFatFile::addCluster()+0x78>
    509a:	ldr	r0, [r4, #24]
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    509c:	mov	r3, r5
      if (!m_vol->fatPut(c, c + 1)) {
    509e:	adds	r5, r3, #1
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    50a0:	cmp	r3, r0
      if (!m_vol->fatPut(c, c + 1)) {
    50a2:	mov	r1, r3
    50a4:	mov	r2, r5
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    50a6:	bcc.n	5092 <ExFatFile::addCluster()+0x46>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    50a8:	mov.w	r2, #4294967295
    50ac:	mov	r1, r6
    50ae:	ldr	r0, [r4, #32]
    50b0:	bl	4da8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    50b4:	cbz	r0, 50c4 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    50b6:	ldr	r1, [r4, #24]
    50b8:	cbz	r1, 50d2 <ExFatFile::addCluster()+0x86>
    if (!m_vol->fatPut(m_curCluster, find)) {
    50ba:	mov	r2, r6
    50bc:	ldr	r0, [r4, #32]
    50be:	bl	4da8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    50c2:	cbnz	r0, 50d2 <ExFatFile::addCluster()+0x86>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    50c4:	movs	r7, #0
}
    50c6:	mov	r0, r7
    50c8:	pop	{r3, r4, r5, r6, r7, pc}
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    50ca:	orr.w	r3, r3, #64	; 0x40
    50ce:	strb.w	r3, [r4, #51]	; 0x33
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    50d2:	str	r6, [r4, #24]
  return true;

 fail:
  return false;
}
    50d4:	mov	r0, r7
    50d6:	pop	{r3, r4, r5, r6, r7, pc}

000050d8 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    50d8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirPos_t pos = m_dirPos;
    50dc:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    50e0:	mov	r5, r0
  DirPos_t pos = m_dirPos;
    50e2:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    50e6:	sub	sp, #20
    50e8:	ldrb.w	r3, [r5, #51]	; 0x33
  DirPos_t pos = m_dirPos;
    50ec:	add	r6, sp, #4
    50ee:	stmia.w	r6, {r0, r1, r2}
  uint8_t* cache;
  if (!isWritable()) {
    50f2:	lsls	r2, r3, #30
    50f4:	bpl.n	512e <ExFatFile::remove()+0x56>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    50f6:	ldr	r1, [r5, #28]
    50f8:	cbnz	r1, 5136 <ExFatFile::remove()+0x5e>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    50fa:	movs	r4, #0
  for (uint8_t i = 0; i <= m_setCount; i++) {
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    50fc:	movs	r2, #1
    50fe:	mov	r1, r6
    5100:	ldr	r0, [r5, #32]
    5102:	bl	4d08 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    5106:	adds	r4, #1
    5108:	uxtb	r4, r4
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
    510a:	cbz	r0, 512e <ExFatFile::remove()+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    510c:	ldrb	r3, [r0, #0]
    510e:	and.w	r3, r3, #127	; 0x7f
    5112:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    5114:	ldrb.w	r3, [r5, #48]	; 0x30
    5118:	cmp	r3, r4
    511a:	bcc.n	5180 <ExFatFile::remove()+0xa8>
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
    511c:	cmp	r4, #0
    511e:	beq.n	50fc <ExFatFile::remove()+0x24>
    5120:	movs	r2, #32
    5122:	mov	r1, r6
    5124:	ldr	r0, [r5, #32]
    5126:	bl	4d3c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    512a:	cmp	r0, #1
    512c:	beq.n	50fc <ExFatFile::remove()+0x24>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    512e:	movs	r0, #0
}
    5130:	add	sp, #20
    5132:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    5136:	lsls	r3, r3, #25
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    5138:	ldr	r0, [r5, #32]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    513a:	bpl.n	5176 <ExFatFile::remove()+0x9e>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    513c:	ldrd	r2, r3, [r5, #8]
    5140:	ldrb.w	r4, [r0, #1093]	; 0x445
    5144:	adds	r4, #9
    5146:	uxtb	r4, r4
    5148:	adds.w	r8, r2, #4294967295
    514c:	adc.w	r9, r3, #4294967295
    5150:	rsb	r7, r4, #32
    5154:	lsl.w	r7, r9, r7
    5158:	lsr.w	r2, r8, r4
    515c:	sub.w	r3, r4, #32
    5160:	lsr.w	r3, r9, r3
    5164:	orrs	r2, r7
    5166:	orrs	r2, r3
    5168:	adds	r2, #1
    516a:	movs	r3, #0
    516c:	bl	4c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    5170:	cmp	r0, #0
    5172:	bne.n	50fa <ExFatFile::remove()+0x22>
    5174:	b.n	512e <ExFatFile::remove()+0x56>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    5176:	bl	4dcc <ExFatPartition::freeChain(unsigned long)>
    517a:	cmp	r0, #0
    517c:	bne.n	50fa <ExFatFile::remove()+0x22>
    517e:	b.n	512e <ExFatFile::remove()+0x56>
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  return m_vol->cacheSync();
    5180:	ldr	r4, [r5, #32]
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    5182:	movs	r3, #0
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    5184:	mov	r0, r4
    5186:	strb.w	r3, [r5, #49]	; 0x31
  m_flags = 0;
    518a:	strb.w	r3, [r5, #51]	; 0x33
    518e:	bl	414c <FsCache::sync()>
    5192:	cmp	r0, #0
    5194:	beq.n	512e <ExFatFile::remove()+0x56>
    5196:	add.w	r0, r4, #528	; 0x210
    519a:	bl	414c <FsCache::sync()>
    519e:	cmp	r0, #0
    51a0:	beq.n	512e <ExFatFile::remove()+0x56>
    51a2:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    51a6:	ldr	r3, [r0, #0]
    51a8:	ldr	r3, [r3, #24]
    51aa:	blx	r3
    51ac:	b.n	5130 <ExFatFile::remove()+0x58>
    51ae:	nop

000051b0 <ExFatFile::rmdir()>:
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    51b0:	ldrb.w	r3, [r0, #49]	; 0x31
    51b4:	lsls	r1, r3, #27
    51b6:	bmi.n	51bc <ExFatFile::rmdir()+0xc>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    51b8:	movs	r0, #0
}
    51ba:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    51bc:	push	{r4, lr}
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    51be:	movs	r2, #0
    51c0:	sub	sp, #32
    51c2:	movs	r3, #0
    51c4:	mov	r4, r0
    51c6:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
    51ca:	b.n	51da <ExFatFile::rmdir()+0x2a>
  while (1) {
    n = read(dir, 32);
    if (n == 0) {
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    51cc:	cmp	r0, #32
    51ce:	bne.n	5204 <ExFatFile::rmdir()+0x54>
    51d0:	ldrb.w	r3, [sp]
    51d4:	lsls	r2, r3, #24
    51d6:	bmi.n	5204 <ExFatFile::rmdir()+0x54>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    51d8:	cbz	r3, 51e8 <ExFatFile::rmdir()+0x38>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    51da:	movs	r2, #32
    51dc:	mov	r1, sp
    51de:	mov	r0, r4
    51e0:	bl	430c <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    51e4:	cmp	r0, #0
    51e6:	bne.n	51cc <ExFatFile::rmdir()+0x1c>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    51e8:	ldrb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    51ec:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    51ee:	orr.w	r3, r3, #2
    51f2:	strb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    51f6:	strb.w	r2, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    51fa:	mov	r0, r4
    51fc:	bl	50d8 <ExFatFile::remove()>

 fail:
  return false;
}
    5200:	add	sp, #32
    5202:	pop	{r4, pc}
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    5204:	movs	r0, #0
}
    5206:	add	sp, #32
    5208:	pop	{r4, pc}
    520a:	nop

0000520c <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    520c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    5210:	add.w	fp, r0, #36	; 0x24
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    5214:	mov	r6, r0
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    5216:	ldmia.w	fp, {r0, r1, r2}
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    521a:	sub	sp, #28
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    521c:	add.w	r8, sp, #12
    5220:	stmia.w	r8, {r0, r1, r2}
    5224:	movs	r7, #0
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;
    5226:	mov	sl, r7
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    5228:	mov	r4, r7
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;

  for (uint8_t i = 0;; i++) {
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    522a:	movs	r2, #0
    522c:	mov	r1, r8
    522e:	ldr	r0, [r6, #32]
    5230:	bl	4d08 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    5234:	uxtb.w	r9, r7
    if (!cache) {
    5238:	mov	r5, r0
    523a:	cbz	r0, 524a <ExFatFile::syncDir()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    523c:	ldrb	r3, [r0, #0]
    523e:	cmp	r3, #192	; 0xc0
    5240:	beq.n	52e6 <ExFatFile::syncDir()+0xda>
    5242:	cmp	r3, #193	; 0xc1
    5244:	beq.n	52e2 <ExFatFile::syncDir()+0xd6>
    5246:	cmp	r3, #133	; 0x85
    5248:	beq.n	525e <ExFatFile::syncDir()+0x52>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    524a:	ldrb.w	r3, [r6, #50]	; 0x32
    524e:	orr.w	r3, r3, #1
    5252:	strb.w	r3, [r6, #50]	; 0x32
  return false;
    5256:	movs	r0, #0
}
    5258:	add	sp, #28
    525a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    525e:	ldr	r3, [pc, #236]	; (534c <ExFatFile::syncDir()+0x140>)
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5260:	ldrb.w	r2, [r6, #49]	; 0x31
    5264:	ldr	r3, [r3, #0]
      goto fail;
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
    5266:	ldrb.w	sl, [r0, #1]
    526a:	and.w	r2, r2, #55	; 0x37
    526e:	strh	r2, [r0, #4]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    5270:	cbz	r3, 5294 <ExFatFile::syncDir()+0x88>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    5272:	add.w	r2, sp, #7
    5276:	add.w	r1, sp, #10
    527a:	add	r0, sp, #8
    527c:	blx	r3
          df->modifyTimeMs = ms10;
          setLe16(df->modifyTime, time);
    527e:	ldrh.w	r2, [sp, #10]
          setLe16(df->modifyDate, date);
    5282:	ldrh.w	r3, [sp, #8]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    5286:	ldrb.w	r1, [sp, #7]
    528a:	strb	r1, [r5, #21]
    528c:	strh	r2, [r5, #12]
    528e:	strh	r2, [r5, #16]
    5290:	strh	r3, [r5, #14]
    5292:	strh	r3, [r5, #18]
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
        m_vol->dataCacheDirty();
    5294:	ldr	r2, [r6, #32]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    5296:	ldrb.w	r3, [r2, #528]	; 0x210
    529a:	orr.w	r3, r3, #1
    529e:	strb.w	r3, [r2, #528]	; 0x210
    52a2:	ldrb	r0, [r5, #0]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    52a4:	movs	r1, #0
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    52a6:	ldrb	r2, [r5, r1]
    52a8:	lsls	r3, r4, #15
    52aa:	orr.w	r4, r3, r4, lsr #1
    52ae:	uxtah	r4, r2, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    52b2:	cmp	r1, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    52b4:	uxth	r4, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    52b6:	add.w	r1, r1, #1
    52ba:	beq.n	52d8 <ExFatFile::syncDir()+0xcc>
    52bc:	cmp	r1, #31
    52be:	bls.n	52a6 <ExFatFile::syncDir()+0x9a>
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    if (i == setCount) break;
    52c0:	cmp	sl, r9
    52c2:	beq.n	5312 <ExFatFile::syncDir()+0x106>
    if (m_vol->dirSeek(&pos, 32) != 1) {
    52c4:	movs	r2, #32
    52c6:	mov	r1, r8
    52c8:	ldr	r0, [r6, #32]
    52ca:	bl	4d3c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    52ce:	cmp	r0, #1
    52d0:	add.w	r7, r7, #1
    52d4:	beq.n	522a <ExFatFile::syncDir()+0x1e>
    52d6:	b.n	524a <ExFatFile::syncDir()+0x3e>
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    52d8:	cmp	r0, #133	; 0x85
    52da:	ite	eq
    52dc:	moveq	r1, #4
    52de:	movne	r1, #2
    52e0:	b.n	52a6 <ExFatFile::syncDir()+0x9a>
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    52e2:	mov	r0, r3
    52e4:	b.n	52a4 <ExFatFile::syncDir()+0x98>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    52e6:	ldrb.w	r3, [r6, #51]	; 0x33
    52ea:	tst.w	r3, #64	; 0x40
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    52ee:	ldrb	r3, [r0, #1]
    52f0:	ite	ne
    52f2:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    52f6:	biceq.w	r3, r3, #2
    52fa:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    52fc:	ldrd	r2, r3, [r6, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    5300:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
    5304:	ldrd	r2, r3, [r6, #8]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
    5308:	ldr	r1, [r6, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    530a:	str	r1, [r0, #20]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    530c:	strd	r2, r3, [r0, #24]
    5310:	b.n	5294 <ExFatFile::syncDir()+0x88>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    5312:	mov	r1, fp
    5314:	movs	r2, #1
    5316:	ldr	r0, [r6, #32]
    5318:	bl	4d08 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    531c:	cmp	r0, #0
    531e:	beq.n	524a <ExFatFile::syncDir()+0x3e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    5320:	ldr	r5, [r6, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5322:	strh	r4, [r0, #2]
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    5324:	mov	r0, r5
    5326:	bl	414c <FsCache::sync()>
    532a:	cmp	r0, #0
    532c:	beq.n	524a <ExFatFile::syncDir()+0x3e>
    532e:	add.w	r0, r5, #528	; 0x210
    5332:	bl	414c <FsCache::sync()>
    5336:	cmp	r0, #0
    5338:	beq.n	524a <ExFatFile::syncDir()+0x3e>
    533a:	ldr.w	r0, [r5, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    533e:	ldr	r3, [r0, #0]
    5340:	ldr	r3, [r3, #24]
    5342:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    5344:	cmp	r0, #0
    5346:	beq.n	524a <ExFatFile::syncDir()+0x3e>
    5348:	b.n	5258 <ExFatFile::syncDir()+0x4c>
    534a:	nop
    534c:	.word	0x20019b54

00005350 <ExFatFile::sync()>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    5350:	ldrb.w	r2, [r0, #49]	; 0x31
    5354:	cbz	r2, 537c <ExFatFile::sync()+0x2c>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    5356:	push	{r3, r4, r5, lr}
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    5358:	ldrb.w	r2, [r0, #51]	; 0x33
    535c:	lsls	r1, r2, #24
    535e:	bmi.n	5380 <ExFatFile::sync()+0x30>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
  }
  if (!m_vol->cacheSync()) {
    5360:	ldr	r5, [r0, #32]
    5362:	mov	r4, r0
    5364:	mov	r0, r5
    5366:	bl	414c <FsCache::sync()>
    536a:	cbnz	r0, 5390 <ExFatFile::sync()+0x40>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    536c:	ldrb.w	r3, [r4, #50]	; 0x32
    5370:	orr.w	r3, r3, #1
    5374:	strb.w	r3, [r4, #50]	; 0x32
  return false;
    5378:	movs	r0, #0
}
    537a:	pop	{r3, r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    537c:	movs	r0, #1
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    537e:	bx	lr
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    5380:	and.w	r2, r2, #127	; 0x7f
    5384:	strb.w	r2, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    5388:	ldmia.w	sp!, {r3, r4, r5, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    538c:	b.w	520c <ExFatFile::syncDir()>
    5390:	add.w	r0, r5, #528	; 0x210
    5394:	bl	414c <FsCache::sync()>
    5398:	cmp	r0, #0
    539a:	beq.n	536c <ExFatFile::sync()+0x1c>
    539c:	ldr.w	r0, [r5, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    53a0:	ldr	r3, [r0, #0]
    53a2:	ldr	r3, [r3, #24]
    53a4:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    53a6:	cmp	r0, #0
    53a8:	beq.n	536c <ExFatFile::sync()+0x1c>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    53aa:	movs	r0, #1
    53ac:	pop	{r3, r4, r5, pc}
    53ae:	nop

000053b0 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    53b0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    53b4:	ldrb.w	r3, [r0, #49]	; 0x31
    53b8:	lsls	r1, r3, #25

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    53ba:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    53bc:	bmi.n	5480 <ExFatFile::addDirCluster()+0xd0>
    53be:	ldr	r0, [r0, #8]
    53c0:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    53c2:	ldr.w	r3, [r3, #1084]	; 0x43c
    53c6:	add	r0, r3
    53c8:	cmp.w	r0, #67108864	; 0x4000000
    53cc:	bcc.n	53d4 <ExFatFile::addDirCluster()+0x24>
  }
  return sync();

 fail:
  return false;
}
    53ce:	movs	r0, #0
    53d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    53d4:	mov	r0, r4
    53d6:	bl	504c <ExFatFile::addCluster()>
    53da:	cmp	r0, #0
    53dc:	beq.n	53ce <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    53de:	ldr	r6, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    53e0:	ldrb.w	r3, [r6, #528]	; 0x210
    53e4:	lsls	r2, r3, #31
    53e6:	bmi.n	5488 <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    53e8:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    53ec:	movs	r5, #0
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    53ee:	add.w	r8, r6, #544	; 0x220
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    53f2:	str.w	r3, [r6, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    53f6:	strb.w	r5, [r6, #528]	; 0x210
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    53fa:	mov	r1, r5
    53fc:	mov.w	r2, #512	; 0x200
    5400:	mov	r0, r8
    5402:	bl	c49c <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    5406:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5408:	ldr	r3, [r4, #24]
    540a:	ldrb.w	r0, [r2, #1093]	; 0x445
    540e:	ldr.w	r1, [r2, #1068]	; 0x42c
    5412:	subs	r3, #2
    5414:	lsls	r3, r0
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    5416:	movs	r6, #1
    5418:	adds	r7, r3, r1
    541a:	lsls.w	r3, r6, r0
    541e:	beq.n	5442 <ExFatFile::addDirCluster()+0x92>
    5420:	ldr.w	r0, [r2, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5424:	ldr	r3, [r0, #0]
    5426:	adds	r1, r7, r5
    5428:	ldr	r3, [r3, #28]
    542a:	mov	r2, r8
    542c:	blx	r3
    542e:	adds	r5, #1
    if (!m_vol->writeSector(sector + i, cache)) {
    5430:	cmp	r0, #0
    5432:	beq.n	53ce <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    5434:	ldr	r2, [r4, #32]
    5436:	ldrb.w	r3, [r2, #1093]	; 0x445
    543a:	lsl.w	r3, r6, r3
    543e:	cmp	r3, r5
    5440:	bhi.n	5420 <ExFatFile::addDirCluster()+0x70>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    5442:	ldrb.w	r3, [r4, #49]	; 0x31
    5446:	lsls	r3, r3, #25
    5448:	bmi.n	5476 <ExFatFile::addDirCluster()+0xc6>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    544a:	ldrb.w	r3, [r4, #51]	; 0x33
    544e:	orn	r3, r3, #127	; 0x7f
    5452:	strb.w	r3, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    5456:	ldr.w	r6, [r2, #1084]	; 0x43c
    545a:	ldrd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    545e:	ldrd	r0, r1, [r4, #16]
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    5462:	adds	r2, r2, r6
    5464:	mov.w	r7, #0
    5468:	adcs	r3, r7
    m_validLength += m_vol->bytesPerCluster();
    546a:	adds	r0, r0, r6
    546c:	adcs	r1, r7
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    546e:	strd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    5472:	strd	r0, r1, [r4, #16]
  }
  return sync();
    5476:	mov	r0, r4

 fail:
  return false;
}
    5478:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    547c:	b.w	5350 <ExFatFile::sync()>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    5480:	ldr	r0, [r0, #32]
    5482:	bl	4fa0 <ExFatPartition::rootLength()>
    5486:	b.n	53c0 <ExFatFile::addDirCluster()+0x10>
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    5488:	add.w	r0, r6, #528	; 0x210
    548c:	bl	414c <FsCache::sync()>
    5490:	cmp	r0, #0
    5492:	bne.n	53e8 <ExFatFile::addDirCluster()+0x38>
    5494:	b.n	53ce <ExFatFile::addDirCluster()+0x1e>
    5496:	nop

00005498 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
  if (!parent->isDir()) {
    5498:	ldrb.w	r3, [r1, #49]	; 0x31
    549c:	tst.w	r3, #80	; 0x50
    54a0:	bne.n	54a6 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0xe>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    54a2:	movs	r0, #0
    54a4:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    54a6:	push	{r4, r5, lr}
    54a8:	sub	sp, #12
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    54aa:	movw	r5, #2562	; 0xa02
    54ae:	ldrb	r3, [r2, #0]
    54b0:	ldr	r2, [r2, #4]
    54b2:	str	r5, [sp, #0]
    54b4:	mov	r4, r0
    54b6:	bl	45e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    54ba:	cbnz	r0, 54c2 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x2a>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    54bc:	movs	r0, #0
    54be:	add	sp, #12
    54c0:	pop	{r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory

  m_attributes = FILE_ATTR_SUBDIR;
    54c2:	movs	r3, #16
    54c4:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    54c8:	mov	r0, r4
    54ca:	bl	53b0 <ExFatFile::addDirCluster()>
    54ce:	cmp	r0, #0
    54d0:	beq.n	54bc <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    54d2:	ldr	r3, [r4, #24]
    54d4:	str	r3, [r4, #28]
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    54d6:	movs	r2, #0
    54d8:	movs	r3, #0
    54da:	mov	r0, r4
    54dc:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    54e0:	movs	r3, #193	; 0xc1
  return sync();
    54e2:	mov	r0, r4
  }
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    54e4:	strb.w	r3, [r4, #51]	; 0x33
  return sync();

 fail:
  return false;
}
    54e8:	add	sp, #12
    54ea:	ldmia.w	sp!, {r4, r5, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    54ee:	b.w	5350 <ExFatFile::sync()>
    54f2:	nop

000054f4 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    54f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    54f8:	mov	r6, r0
    54fa:	sub	sp, #84	; 0x54
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    54fc:	ldrb.w	r5, [r6, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    5500:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    5502:	movs	r0, #0
    5504:	strb.w	r0, [sp, #73]	; 0x49
    5508:	strb.w	r0, [sp, #74]	; 0x4a
    550c:	strb.w	r0, [sp, #75]	; 0x4b
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5510:	cbnz	r5, 5520 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    5512:	mov	r9, r3
    5514:	ldrb.w	r3, [r1, #49]	; 0x31
    5518:	tst.w	r3, #80	; 0x50
    551c:	mov	r4, r1
    551e:	bne.n	5528 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x34>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    5520:	movs	r0, #0
}
    5522:	add	sp, #84	; 0x54
    5524:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5528:	ldrb	r3, [r2, #0]
    552a:	cmp	r3, #47	; 0x2f
    552c:	mov	r1, r2
    552e:	beq.n	559e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    5530:	mov.w	r8, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5534:	add	r3, sp, #12
    5536:	add	r2, sp, #16
    5538:	mov	r0, r6
    553a:	bl	4248 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    553e:	cmp	r0, #0
    5540:	beq.n	5520 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5542:	ldr	r3, [sp, #12]
    5544:	ldrb	r3, [r3, #0]
    5546:	cmp	r3, #0
    5548:	beq.n	55ba <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xc6>
    554a:	ldrb.w	r3, [sp, #16]
    554e:	ldr	r2, [sp, #20]
    5550:	str.w	r8, [sp]
    5554:	mov	r1, r4
    5556:	mov	r0, r6
    5558:	bl	45e4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    555c:	cbnz	r0, 5572 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
      if (!pFlag || !mkdir(parent, &fname)) {
    555e:	cmp.w	r9, #0
    5562:	beq.n	5520 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    5564:	mov	r1, r4
    5566:	add	r2, sp, #16
    5568:	mov	r0, r6
    556a:	bl	5498 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    556e:	cmp	r0, #0
    5570:	beq.n	5520 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5572:	mov	r4, r6
    5574:	add	r7, sp, #24
    5576:	add.w	lr, r6, #48	; 0x30
    557a:	ldr	r0, [r4, #0]
    557c:	ldr	r1, [r4, #4]
    557e:	ldr	r2, [r4, #8]
    5580:	ldr	r3, [r4, #12]
    5582:	mov	r5, r7
    5584:	stmia	r5!, {r0, r1, r2, r3}
    5586:	adds	r4, #16
    5588:	cmp	r4, lr
    558a:	mov	r7, r5
    558c:	bne.n	557a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x86>
    558e:	ldr	r0, [r4, #0]
    5590:	str	r0, [r5, #0]
    parent = &tmpDir;
    close();
    5592:	mov	r0, r6
    5594:	bl	415c <ExFatFile::close()>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    5598:	add	r4, sp, #24
    559a:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    559c:	b.n	5534 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    559e:	adds	r1, #1
    55a0:	str	r1, [sp, #12]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    55a2:	ldrb	r3, [r1, #0]
    55a4:	cmp	r3, #47	; 0x2f
    55a6:	beq.n	559e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    55a8:	ldr	r1, [r4, #32]
    55aa:	add	r0, sp, #24
    55ac:	bl	4220 <ExFatFile::openRoot(ExFatVolume*)>
    55b0:	cmp	r0, #0
    55b2:	beq.n	5520 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    55b4:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    55b6:	add	r4, sp, #24
    55b8:	b.n	5530 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x3c>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    55ba:	add	r2, sp, #16
    55bc:	mov	r1, r4
    55be:	mov	r0, r6
    55c0:	bl	5498 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>

 fail:
  return false;
}
    55c4:	add	sp, #84	; 0x54
    55c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    55ca:	nop

000055cc <ExFatFile::preAllocate(unsigned long long)>:
}
//------------------------------------------------------------------------------
bool ExFatFile::preAllocate(uint64_t length) {
  uint32_t find;
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    55cc:	orrs.w	r1, r2, r3
    55d0:	beq.n	55da <ExFatFile::preAllocate(unsigned long long)+0xe>
    55d2:	ldrb.w	r1, [r0, #51]	; 0x33
    55d6:	lsls	r1, r1, #30
    55d8:	bmi.n	55de <ExFatFile::preAllocate(unsigned long long)+0x12>
  }
  return true;

 fail:
  return false;
}
    55da:	movs	r0, #0
    55dc:	bx	lr
}
//------------------------------------------------------------------------------
bool ExFatFile::preAllocate(uint64_t length) {
  uint32_t find;
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    55de:	ldr	r1, [r0, #28]
    55e0:	cmp	r1, #0
    55e2:	bne.n	55da <ExFatFile::preAllocate(unsigned long long)+0xe>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::preAllocate(uint64_t length) {
    55e4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    55e8:	mov	r6, r0
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  need = 1 + ((length - 1) >> m_vol->bytesPerClusterShift());
    55ea:	ldr	r0, [r0, #32]
    55ec:	mov	r5, r3
    55ee:	ldrb.w	r3, [r0, #1093]	; 0x445
    55f2:	adds	r3, #9
    55f4:	adds.w	r8, r2, #4294967295
    55f8:	uxtb	r3, r3
    55fa:	adc.w	r9, r5, #4294967295
    55fe:	rsb	r7, r3, #32
    5602:	lsl.w	r7, r9, r7
    5606:	mov	r4, r2
    5608:	lsr.w	r2, r8, r3
    560c:	subs	r3, #32
    560e:	orrs	r2, r7
    5610:	lsr.w	r3, r9, r3
    5614:	orrs	r2, r3
    5616:	adds	r7, r2, #1
  find = m_vol->bitmapFind(0, need);
    5618:	mov	r2, r7
    561a:	bl	4b70 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    561e:	cmp	r0, #1
  if (!length || !isWritable() || m_firstCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  need = 1 + ((length - 1) >> m_vol->bytesPerClusterShift());
  find = m_vol->bitmapFind(0, need);
    5620:	mov	r8, r0
  if (find < 2) {
    5622:	bls.n	5632 <ExFatFile::preAllocate(unsigned long long)+0x66>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, need, 1)) {
    5624:	mov	r1, r0
    5626:	mov	r2, r7
    5628:	movs	r3, #1
    562a:	ldr	r0, [r6, #32]
    562c:	bl	4c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    5630:	cbnz	r0, 5638 <ExFatFile::preAllocate(unsigned long long)+0x6c>
  }
  return true;

 fail:
  return false;
}
    5632:	movs	r0, #0
    5634:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_dataLength = length;
  m_firstCluster = find;
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
    5638:	ldrb.w	r3, [r6, #51]	; 0x33
  if (!m_vol->bitmapModify(find, need, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_dataLength = length;
  m_firstCluster = find;
    563c:	str.w	r8, [r6, #28]
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
    5640:	orn	r3, r3, #63	; 0x3f
    5644:	strb.w	r3, [r6, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, need, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_dataLength = length;
    5648:	strd	r4, r5, [r6, #8]
  m_firstCluster = find;
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
  if (!sync()) {
    564c:	mov	r0, r6
  }
  return true;

 fail:
  return false;
}
    564e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    goto fail;
  }
  m_dataLength = length;
  m_firstCluster = find;
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
  if (!sync()) {
    5652:	b.w	5350 <ExFatFile::sync()>
    5656:	nop

00005658 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    5658:	push	{r4, r5, r6, r7, lr}
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    565a:	ldrb.w	r4, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    565e:	sub	sp, #116	; 0x74
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    5660:	movs	r3, #0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5662:	tst.w	r4, #24
    5666:	strb.w	r3, [sp, #49]	; 0x31
    566a:	strb.w	r3, [sp, #50]	; 0x32
    566e:	strb.w	r3, [sp, #51]	; 0x33
    5672:	strb.w	r3, [sp, #105]	; 0x69
    5676:	strb.w	r3, [sp, #106]	; 0x6a
    567a:	strb.w	r3, [sp, #107]	; 0x6b
    567e:	beq.n	5688 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    5680:	ldr	r3, [r1, #32]
    5682:	ldr	r4, [r0, #32]
    5684:	cmp	r4, r3
    5686:	beq.n	568e <ExFatFile::rename(ExFatFile*, char const*)+0x36>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    5688:	movs	r0, #0
}
    568a:	add	sp, #116	; 0x74
    568c:	pop	{r4, r5, r6, r7, pc}
    568e:	mov	r4, r0
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    5690:	movw	r3, #2561	; 0xa01
    5694:	mov	r0, sp
    5696:	bl	49c0 <ExFatFile::open(ExFatFile*, char const*, int)>
    569a:	cmp	r0, #0
    569c:	beq.n	5688 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    569e:	add	r7, sp, #56	; 0x38
    56a0:	mov	r5, r4
    56a2:	add.w	lr, r4, #48	; 0x30
    56a6:	ldr	r0, [r5, #0]
    56a8:	ldr	r1, [r5, #4]
    56aa:	ldr	r2, [r5, #8]
    56ac:	ldr	r3, [r5, #12]
    56ae:	mov	r6, r7
    56b0:	stmia	r6!, {r0, r1, r2, r3}
    56b2:	adds	r5, #16
    56b4:	cmp	r5, lr
    56b6:	mov	r7, r6
    56b8:	bne.n	56a6 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    56ba:	ldr	r0, [r5, #0]
    56bc:	str	r0, [r6, #0]
  m_dirPos = file.m_dirPos;
    56be:	add	r3, sp, #36	; 0x24
    56c0:	ldmia.w	r3, {r0, r1, r2}
    56c4:	add.w	r3, r4, #36	; 0x24
    56c8:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    56cc:	ldrb.w	r3, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
  m_dirPos = file.m_dirPos;
  m_setCount = file.m_setCount;
    56d0:	ldrb.w	r2, [sp, #48]	; 0x30
    56d4:	strb.w	r2, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    56d8:	orn	r3, r3, #127	; 0x7f
    56dc:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    56e0:	mov	r0, r4
    56e2:	bl	5350 <ExFatFile::sync()>
    56e6:	cmp	r0, #0
    56e8:	beq.n	5688 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    56ea:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    56ec:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    56ee:	movs	r3, #8
  return oldFile.remove();
    56f0:	add	r0, sp, #56	; 0x38
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    56f2:	str	r1, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    56f4:	strb.w	r2, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
    56f8:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    56fc:	bl	50d8 <ExFatFile::remove()>
    5700:	b.n	568a <ExFatFile::rename(ExFatFile*, char const*)+0x32>
    5702:	nop

00005704 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    5704:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5708:	lsls	r2, r3, #30
    570a:	bpl.n	573e <ExFatFile::truncate()+0x3a>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    570c:	push	{r4, r5, r6, r7, lr}
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    570e:	ldr	r5, [r0, #28]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    5710:	sub	sp, #12
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    5712:	cbz	r5, 5738 <ExFatFile::truncate()+0x34>
      return true;
  }
  if (isContiguous()) {
    5714:	and.w	r3, r3, #64	; 0x40
    5718:	mov	r4, r0
    571a:	and.w	r0, r3, #255	; 0xff
    571e:	cbnz	r3, 5742 <ExFatFile::truncate()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    5720:	ldr	r1, [r4, #24]
    5722:	cmp	r1, #0
    5724:	bne.n	57aa <ExFatFile::truncate()+0xa6>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    5726:	str	r5, [sp, #4]
      m_firstCluster = 0;
    5728:	str	r1, [r4, #28]
    }
    if (toFree) {
      if (!m_vol->freeChain(toFree)) {
    572a:	mov	r1, r5
    572c:	ldr	r0, [r4, #32]
    572e:	bl	4dcc <ExFatPartition::freeChain(unsigned long)>
    5732:	cbnz	r0, 5782 <ExFatFile::truncate()+0x7e>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    5734:	movs	r0, #0
    5736:	b.n	573a <ExFatFile::truncate()+0x36>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    5738:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    573a:	add	sp, #12
    573c:	pop	{r4, r5, r6, r7, pc}
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    573e:	movs	r0, #0
}
    5740:	bx	lr
    5742:	ldr	r0, [r4, #32]
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
    5744:	ldr	r1, [r4, #24]
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    5746:	ldrb.w	r3, [r0, #1093]	; 0x445
    574a:	ldrd	r6, r7, [r4, #8]
    574e:	adds	r3, #9
    5750:	uxtb	r3, r3
    5752:	adds.w	r6, r6, #4294967295
    5756:	rsb	lr, r3, #32
    575a:	adc.w	r7, r7, #4294967295
    575e:	lsr.w	r2, r6, r3
    5762:	lsl.w	lr, r7, lr
    5766:	subs	r3, #32
    5768:	orr.w	r2, r2, lr
    576c:	lsr.w	r3, r7, r3
    5770:	orrs	r2, r3
    5772:	adds	r2, #1
    if (m_curCluster) {
    5774:	cbz	r1, 57a4 <ExFatFile::truncate()+0xa0>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    5776:	subs	r5, #1
    5778:	subs	r5, r5, r1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    577a:	adds	r1, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    577c:	add	r2, r5
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    577e:	str	r1, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    5780:	cbnz	r2, 57c6 <ExFatFile::truncate()+0xc2>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    5782:	ldrd	r0, r1, [r4]
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5786:	ldrb.w	r3, [r4, #51]	; 0x33
    578a:	orn	r3, r3, #127	; 0x7f
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    578e:	strd	r0, r1, [r4, #8]
  m_validLength = m_curPosition;
    5792:	strd	r0, r1, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5796:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    579a:	mov	r0, r4
    579c:	bl	5350 <ExFatFile::sync()>

 fail:
  return false;
}
    57a0:	add	sp, #12
    57a2:	pop	{r4, r5, r6, r7, pc}
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
    57a4:	str	r5, [sp, #4]
      m_firstCluster = 0;
    57a6:	str	r1, [r4, #28]
    57a8:	b.n	5780 <ExFatFile::truncate()+0x7c>
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    57aa:	add	r2, sp, #8
    57ac:	str.w	r0, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    57b0:	ldr	r0, [r4, #32]
    57b2:	bl	4d94 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    57b6:	sxtb	r0, r0
      if (fg < 0) {
    57b8:	cmp	r0, #0
    57ba:	blt.n	5734 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    57bc:	bne.n	57d4 <ExFatFile::truncate()+0xd0>
      }
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (toFree) {
    57be:	ldr	r5, [sp, #4]
    57c0:	cmp	r5, #0
    57c2:	beq.n	5782 <ExFatFile::truncate()+0x7e>
    57c4:	b.n	572a <ExFatFile::truncate()+0x26>
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    57c6:	movs	r3, #0
    57c8:	ldr	r1, [sp, #4]
    57ca:	bl	4c24 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    57ce:	cmp	r0, #0
    57d0:	bne.n	5782 <ExFatFile::truncate()+0x7e>
    57d2:	b.n	5734 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    57d4:	mov.w	r2, #4294967295
    57d8:	ldr	r1, [r4, #24]
    57da:	ldr	r0, [r4, #32]
    57dc:	bl	4da8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    57e0:	cmp	r0, #0
    57e2:	bne.n	57be <ExFatFile::truncate()+0xba>
    57e4:	b.n	5734 <ExFatFile::truncate()+0x30>
    57e6:	nop

000057e8 <ExFatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    57e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    57ec:	ldrb.w	r3, [r0, #51]	; 0x33
    57f0:	sub	sp, #12

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    57f2:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    57f4:	mov	r4, r0
    57f6:	str	r2, [sp, #0]

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    57f8:	bmi.n	5810 <ExFatFile::write(void const*, unsigned int)+0x28>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    57fa:	ldrb.w	r3, [r4, #50]	; 0x32
    57fe:	orr.w	r3, r3, #1
    5802:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    5806:	mov.w	r0, #4294967295
}
    580a:	add	sp, #12
    580c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    5810:	lsls	r2, r3, #28
    5812:	mov	r9, r1
    5814:	bmi.w	5a1a <ExFatFile::write(void const*, unsigned int)+0x232>
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    5818:	ldr	r3, [sp, #0]
    581a:	cmp	r3, #0
    581c:	beq.w	5a42 <ExFatFile::write(void const*, unsigned int)+0x25a>
    5820:	mov	r1, r4
    5822:	ldrd	r2, r3, [r1], #24
    5826:	ldr.w	r8, [sp]
    582a:	str	r1, [sp, #4]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    582c:	mov.w	fp, #1
    5830:	mov	sl, r9
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    5832:	ldr	r0, [r4, #32]
    5834:	ldr.w	r5, [r0, #1080]	; 0x438
    5838:	ands	r5, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    583a:	ubfx	r9, r5, #0, #9
    if (clusterOffset == 0) {
    583e:	cbnz	r5, 5892 <ExFatFile::write(void const*, unsigned int)+0xaa>
      // start of new cluster
      if (m_curCluster != 0) {
    5840:	ldr	r1, [r4, #24]
    5842:	cmp	r1, #0
    5844:	beq.w	59a4 <ExFatFile::write(void const*, unsigned int)+0x1bc>
        int fg;

        if (isContiguous()) {
    5848:	ldrb.w	r3, [r4, #51]	; 0x33
    584c:	lsls	r3, r3, #25
    584e:	bpl.w	59ec <ExFatFile::write(void const*, unsigned int)+0x204>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    5852:	ldrd	r6, r7, [r4, #8]
    5856:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    585a:	ldr	r3, [r4, #28]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    585c:	adds	r2, #9
    585e:	uxtb	r2, r2
    5860:	adds.w	r6, r6, #4294967295
    5864:	adc.w	r7, r7, #4294967295
    5868:	rsb	lr, r2, #32
    586c:	lsrs	r6, r2
    586e:	lsl.w	lr, r7, lr
    5872:	subs	r2, #32
    5874:	orr.w	r6, r6, lr
    5878:	lsr.w	r2, r7, r2
    587c:	orrs	r6, r2
    587e:	add	r3, r6
    5880:	cmp	r1, r3
    5882:	bcc.w	59d2 <ExFatFile::write(void const*, unsigned int)+0x1ea>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    5886:	mov	r0, r4
    5888:	bl	504c <ExFatFile::addCluster()>
    588c:	cmp	r0, #0
    588e:	beq.n	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
    5890:	ldr	r0, [r4, #32]
    5892:	ldr	r6, [r4, #24]
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    5894:	ldr.w	r7, [r0, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5898:	ldrb.w	lr, [r0, #1093]	; 0x445
    589c:	lsrs	r5, r5, #9
    589e:	subs	r6, #2
    58a0:	adds	r1, r5, r7
    58a2:	lsl.w	r6, r6, lr
    58a6:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    58a8:	cmp.w	r9, #0
    58ac:	bne.n	5996 <ExFatFile::write(void const*, unsigned int)+0x1ae>
    58ae:	cmp.w	r8, #512	; 0x200
    58b2:	bcs.n	5950 <ExFatFile::write(void const*, unsigned int)+0x168>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    58b4:	ldrd	r2, r3, [r4, #16]
    58b8:	ldrd	r6, r7, [r4]
    58bc:	cmp.w	r8, #512	; 0x200
    58c0:	mov	r5, r8
    58c2:	it	cs
    58c4:	movcs.w	r5, #512	; 0x200
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    58c8:	cmp	r7, r3
    58ca:	it	eq
    58cc:	cmpeq	r6, r2
    58ce:	ite	cc
    58d0:	movcc	r2, #1
    58d2:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    58d4:	add.w	r0, r0, #528	; 0x210
    58d8:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    58dc:	cmp	r0, #0
    58de:	beq.n	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    58e0:	add	r0, r9
    58e2:	mov	r2, r5
    58e4:	mov	r1, sl
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    58e6:	add	r9, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    58e8:	bl	9220 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    58ec:	cmp.w	r9, #512	; 0x200
    58f0:	beq.w	5a08 <ExFatFile::write(void const*, unsigned int)+0x220>
    58f4:	mov	r0, r5
    58f6:	movs	r1, #0
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    58f8:	ldrd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    58fc:	ldrd	r6, r7, [r4, #16]
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    5900:	adds	r2, r2, r0
    5902:	adcs	r3, r1
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    5904:	cmp	r7, r3
    5906:	it	eq
    5908:	cmpeq	r6, r2
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    590a:	add	sl, r5
    toWrite -= n;
    590c:	rsb	r8, r5, r8
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    5910:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    5914:	bcs.n	5926 <ExFatFile::write(void const*, unsigned int)+0x13e>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    5916:	ldrb.w	r1, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    591a:	strd	r2, r3, [r4, #16]
    }
    m_curPosition += n;
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
    591e:	orn	r1, r1, #127	; 0x7f
    5922:	strb.w	r1, [r4, #51]	; 0x33
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    5926:	cmp.w	r8, #0
    592a:	bne.n	5832 <ExFatFile::write(void const*, unsigned int)+0x4a>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    592c:	ldrd	r0, r1, [r4, #8]
    5930:	cmp	r1, r3
    5932:	it	eq
    5934:	cmpeq	r0, r2
    5936:	bcc.n	5a2a <ExFatFile::write(void const*, unsigned int)+0x242>
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    5938:	ldr	r3, [pc, #268]	; (5a48 <ExFatFile::write(void const*, unsigned int)+0x260>)
    593a:	ldr	r3, [r3, #0]
    593c:	cmp	r3, #0
    593e:	beq.n	5a3e <ExFatFile::write(void const*, unsigned int)+0x256>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5940:	ldrb.w	r3, [r4, #51]	; 0x33
    5944:	ldr	r0, [sp, #0]
    5946:	orn	r3, r3, #127	; 0x7f
    594a:	strb.w	r3, [r4, #51]	; 0x33
    594e:	b.n	580a <ExFatFile::write(void const*, unsigned int)+0x22>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    5950:	cmp.w	r8, #1024	; 0x400
    5954:	bcc.n	59ac <ExFatFile::write(void const*, unsigned int)+0x1c4>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    5956:	lsl.w	r3, fp, lr
    595a:	subs	r5, r3, r5
    595c:	ldr.w	r2, [r0, #540]	; 0x21c
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    5960:	mov.w	r3, r8, lsr #9
    5964:	cmp	r3, r5
    5966:	it	cs
    5968:	movcs	r3, r5
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    596a:	cmp	r1, r2
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    596c:	mov.w	r5, r3, lsl #9
    5970:	bhi.n	5984 <ExFatFile::write(void const*, unsigned int)+0x19c>
    5972:	adds	r6, r1, r3
    5974:	cmp	r2, r6
    5976:	bcs.n	5984 <ExFatFile::write(void const*, unsigned int)+0x19c>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    5978:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    597c:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    5980:	str.w	r2, [r0, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    5984:	ldr.w	r0, [r0, #532]	; 0x214
    5988:	ldr	r6, [r0, #0]
    598a:	mov	r2, sl
    598c:	ldr	r6, [r6, #32]
    598e:	blx	r6
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    5990:	cmp	r0, #0
    5992:	bne.n	58f4 <ExFatFile::write(void const*, unsigned int)+0x10c>
    5994:	b.n	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    5996:	rsb	r5, r9, #512	; 0x200
    599a:	cmp	r5, r8
    599c:	it	cs
    599e:	movcs	r5, r8
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    59a0:	movs	r2, #1
    59a2:	b.n	58d4 <ExFatFile::write(void const*, unsigned int)+0xec>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    59a4:	ldr	r6, [r4, #28]
    59a6:	cbz	r6, 59d8 <ExFatFile::write(void const*, unsigned int)+0x1f0>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    59a8:	str	r6, [r4, #24]
    59aa:	b.n	5894 <ExFatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    59ac:	ldr.w	r3, [r0, #540]	; 0x21c
    59b0:	cmp	r1, r3
    59b2:	beq.n	59fa <ExFatFile::write(void const*, unsigned int)+0x212>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    59b4:	ldr.w	r0, [r0, #532]	; 0x214
    59b8:	ldr	r3, [r0, #0]
    59ba:	mov	r2, sl
    59bc:	ldr	r3, [r3, #28]
    59be:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    59c0:	cmp	r0, #0
    59c2:	beq.w	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
    59c6:	mov.w	r0, #512	; 0x200
    59ca:	movs	r1, #0
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    59cc:	mov.w	r5, #512	; 0x200
    59d0:	b.n	58f8 <ExFatFile::write(void const*, unsigned int)+0x110>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    59d2:	adds	r6, r1, #1
    59d4:	str	r6, [r4, #24]
    59d6:	b.n	5894 <ExFatFile::write(void const*, unsigned int)+0xac>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    59d8:	mov	r0, r4
    59da:	bl	504c <ExFatFile::addCluster()>
    59de:	cmp	r0, #0
    59e0:	beq.w	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    59e4:	ldr	r6, [r4, #24]
    59e6:	str	r6, [r4, #28]
    59e8:	ldr	r0, [r4, #32]
    59ea:	b.n	5894 <ExFatFile::write(void const*, unsigned int)+0xac>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    59ec:	ldr	r2, [sp, #4]
    59ee:	bl	4d94 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    59f2:	cmp	r0, #0
    59f4:	bne.w	5890 <ExFatFile::write(void const*, unsigned int)+0xa8>
    59f8:	b.n	5886 <ExFatFile::write(void const*, unsigned int)+0x9e>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    59fa:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    59fe:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    5a02:	str.w	r3, [r0, #540]	; 0x21c
    5a06:	b.n	59b4 <ExFatFile::write(void const*, unsigned int)+0x1cc>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    5a08:	ldr	r0, [r4, #32]
    5a0a:	add.w	r0, r0, #528	; 0x210
    5a0e:	bl	414c <FsCache::sync()>
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->dataCacheSync()) {
    5a12:	cmp	r0, #0
    5a14:	bne.w	58f4 <ExFatFile::write(void const*, unsigned int)+0x10c>
    5a18:	b.n	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    5a1a:	ldrd	r2, r3, [r0, #16]
    5a1e:	bl	44e4 <ExFatFile::seekSet(unsigned long long)>
    5a22:	cmp	r0, #0
    5a24:	beq.w	57fa <ExFatFile::write(void const*, unsigned int)+0x12>
    5a28:	b.n	5818 <ExFatFile::write(void const*, unsigned int)+0x30>
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5a2a:	ldrb.w	r1, [r4, #51]	; 0x33
    5a2e:	ldr	r0, [sp, #0]
    5a30:	orn	r1, r1, #127	; 0x7f
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    5a34:	strd	r2, r3, [r4, #8]
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5a38:	strb.w	r1, [r4, #51]	; 0x33
    5a3c:	b.n	580a <ExFatFile::write(void const*, unsigned int)+0x22>
    5a3e:	ldr	r0, [sp, #0]
    5a40:	b.n	580a <ExFatFile::write(void const*, unsigned int)+0x22>
    5a42:	ldrd	r2, r3, [r4]
    5a46:	b.n	592c <ExFatFile::write(void const*, unsigned int)+0x144>
    5a48:	.word	0x20019b54

00005a4c <FatFile::openRoot(FatVolume*) [clone .part.38]>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5a4c:	push	{r3, r4, r5, lr}
    5a4e:	mov	r4, r0
    5a50:	mov	r5, r1
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    5a52:	movs	r2, #36	; 0x24
    5a54:	movs	r1, #0
    5a56:	bl	c49c <memset>

  m_vol = vol;
    5a5a:	str	r5, [r4, #8]
  switch (vol->fatType()) {
    5a5c:	ldrb	r3, [r5, #7]
    5a5e:	cmp	r3, #16
    5a60:	beq.n	5a74 <FatFile::openRoot(FatVolume*) [clone .part.38]+0x28>
    5a62:	cmp	r3, #32
    5a64:	bne.n	5a70 <FatFile::openRoot(FatVolume*) [clone .part.38]+0x24>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5a66:	movs	r3, #64	; 0x40
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5a68:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5a6a:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5a6c:	strb	r0, [r4, #2]
    5a6e:	pop	{r3, r4, r5, pc}
  return true;

 fail:
  return false;
    5a70:	movs	r0, #0
}
    5a72:	pop	{r3, r4, r5, pc}
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5a74:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5a76:	movs	r0, #1
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5a78:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5a7a:	strb	r0, [r4, #2]
    5a7c:	pop	{r3, r4, r5, pc}
    5a7e:	nop

00005a80 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5a80:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5a82:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5a84:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5a88:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    5a8a:	mov	r1, r5
    5a8c:	ldr	r0, [r0, #8]
    5a8e:	bl	6918 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    5a92:	cbz	r0, 5aaa <FatFile::addCluster()+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    5a94:	cbz	r5, 5aac <FatFile::addCluster()+0x2c>
    m_flags |= FILE_FLAG_CONTIGUOUS;
  } else if (m_curCluster != (cc + 1)) {
    5a96:	ldr	r3, [r4, #16]
    5a98:	adds	r5, #1
    5a9a:	cmp	r3, r5
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    5a9c:	ldrb	r3, [r4, #2]
    5a9e:	it	ne
    5aa0:	andne.w	r3, r3, #191	; 0xbf
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5aa4:	orn	r3, r3, #127	; 0x7f
    5aa8:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    5aaa:	pop	{r3, r4, r5, pc}
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    5aac:	ldrb	r3, [r4, #2]
    5aae:	orr.w	r3, r3, #64	; 0x40
    5ab2:	b.n	5aa4 <FatFile::addCluster()+0x24>

00005ab4 <FatFile::addDirCluster()>:
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5ab4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5ab8:	ldrb	r3, [r0, #0]
    5aba:	and.w	r3, r3, #32
    5abe:	cbnz	r3, 5acc <FatFile::addDirCluster()+0x18>
    5ac0:	and.w	r4, r3, #255	; 0xff
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    5ac4:	ldr	r1, [r0, #20]
    5ac6:	ldr	r3, [pc, #128]	; (5b48 <FatFile::addDirCluster()+0x94>)
    5ac8:	cmp	r1, r3
    5aca:	bls.n	5ad4 <FatFile::addDirCluster()+0x20>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    5acc:	movs	r6, #0
}
    5ace:	mov	r0, r6
    5ad0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5ad4:	mov	r5, r0
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    5ad6:	bl	5a80 <FatFile::addCluster()>
    5ada:	mov	r6, r0
    5adc:	cmp	r0, #0
    5ade:	beq.n	5acc <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5ae0:	ldr	r0, [r5, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5ae2:	ldr	r3, [r5, #16]
    5ae4:	ldrb	r7, [r0, #6]
    5ae6:	ldr	r2, [r0, #20]
    5ae8:	subs	r3, #2
    5aea:	lsls	r3, r7
    5aec:	adds	r7, r3, r2
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5aee:	adds	r0, #36	; 0x24
    5af0:	mov	r1, r7
    5af2:	movs	r2, #5
    5af4:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    5af8:	mov	r8, r0
    5afa:	cmp	r0, #0
    5afc:	beq.n	5acc <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    5afe:	mov.w	r2, #512	; 0x200
    5b02:	mov	r1, r4
    5b04:	bl	c49c <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5b08:	ldr	r3, [r5, #8]
    5b0a:	ldrb	r2, [r3, #4]
    5b0c:	cmp	r2, #1
    5b0e:	bls.n	5b32 <FatFile::addDirCluster()+0x7e>
    5b10:	movs	r4, #1
    5b12:	b.n	5b1c <FatFile::addDirCluster()+0x68>
    5b14:	ldr	r3, [r5, #8]
    5b16:	ldrb	r2, [r3, #4]
    5b18:	cmp	r2, r4
    5b1a:	bls.n	5b32 <FatFile::addDirCluster()+0x7e>
    5b1c:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5b1e:	ldr	r3, [r0, #0]
    5b20:	adds	r1, r4, r7
    5b22:	ldr	r3, [r3, #28]
    5b24:	mov	r2, r8
    5b26:	blx	r3
    5b28:	adds	r4, #1
    5b2a:	uxtb	r4, r4
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5b2c:	cmp	r0, #0
    5b2e:	bne.n	5b14 <FatFile::addDirCluster()+0x60>
    5b30:	b.n	5acc <FatFile::addDirCluster()+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    5b32:	ldrb	r3, [r3, #6]
    5b34:	ldr	r1, [r5, #20]
    5b36:	mov.w	r2, #512	; 0x200
    5b3a:	lsl.w	r3, r2, r3
    5b3e:	uxtah	r3, r1, r3
    5b42:	str	r3, [r5, #20]
    5b44:	b.n	5ace <FatFile::addDirCluster()+0x1a>
    5b46:	nop
    5b48:	.word	0x001ffdff

00005b4c <FatFile::cacheDirEntry(unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5b4c:	push	{r4, lr}
    5b4e:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5b50:	ldr	r0, [r0, #8]
    5b52:	mov	r2, r1
    5b54:	adds	r0, #36	; 0x24
    5b56:	ldr	r1, [r4, #24]
    5b58:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    5b5c:	cbz	r0, 5b68 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    5b5e:	ldrh	r3, [r4, #4]
    5b60:	and.w	r3, r3, #15
    5b64:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    5b68:	pop	{r4, pc}
    5b6a:	nop

00005b6c <FatFile::sync() [clone .part.42]>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5b6c:	push	{r4, r5, r6, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    5b6e:	ldrsb.w	r3, [r0, #2]
    5b72:	cmp	r3, #0
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5b74:	sub	sp, #8
    5b76:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    5b78:	blt.n	5bae <FatFile::sync() [clone .part.42]+0x42>
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
  }
  if (m_vol->cacheSync()) {
    5b7a:	ldr	r5, [r4, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5b7c:	add.w	r0, r5, #36	; 0x24
    5b80:	bl	414c <FsCache::sync()>
    5b84:	cbnz	r0, 5b94 <FatFile::sync() [clone .part.42]+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    5b86:	ldrb	r3, [r4, #1]
    5b88:	orr.w	r3, r3, #1
    5b8c:	strb	r3, [r4, #1]
  return false;
    5b8e:	movs	r0, #0
}
    5b90:	add	sp, #8
    5b92:	pop	{r4, r5, r6, pc}
    5b94:	add.w	r0, r5, #564	; 0x234
    5b98:	bl	414c <FsCache::sync()>
    5b9c:	cmp	r0, #0
    5b9e:	beq.n	5b86 <FatFile::sync() [clone .part.42]+0x1a>
    5ba0:	ldr	r0, [r5, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5ba2:	ldr	r3, [r0, #0]
    5ba4:	ldr	r3, [r3, #24]
    5ba6:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5ba8:	cmp	r0, #0
    5baa:	beq.n	5b86 <FatFile::sync() [clone .part.42]+0x1a>
    5bac:	b.n	5b90 <FatFile::sync() [clone .part.42]+0x24>
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5bae:	movs	r1, #1
    5bb0:	bl	5b4c <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5bb4:	mov	r5, r0
    5bb6:	cmp	r0, #0
    5bb8:	beq.n	5b86 <FatFile::sync() [clone .part.42]+0x1a>
    5bba:	ldrb	r3, [r0, #0]
    5bbc:	cmp	r3, #229	; 0xe5
    5bbe:	beq.n	5b86 <FatFile::sync() [clone .part.42]+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    5bc0:	ldrb	r3, [r4, #0]
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    5bc2:	ldr	r2, [pc, #56]	; (5bfc <FatFile::sync() [clone .part.42]+0x90>)
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    5bc4:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    5bc6:	itt	mi
    5bc8:	ldrmi	r3, [r4, #28]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5bca:	strmi	r3, [r0, #28]
    }

    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    5bcc:	ldr	r3, [r4, #32]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    5bce:	ldr	r6, [r2, #0]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5bd0:	strh	r3, [r0, #26]
    5bd2:	lsrs	r3, r3, #16
    5bd4:	strh	r3, [r0, #20]
    5bd6:	cbz	r6, 5bf2 <FatFile::sync() [clone .part.42]+0x86>
      FsDateTime::callback(&date, &time, &ms10);
    5bd8:	add.w	r2, sp, #3
    5bdc:	add.w	r1, sp, #6
    5be0:	add	r0, sp, #4
    5be2:	blx	r6
      setLe16(dir->modifyDate, date);
    5be4:	ldrh.w	r3, [sp, #4]
    5be8:	ldrh.w	r2, [sp, #6]
    5bec:	strh	r3, [r5, #24]
    5bee:	strh	r3, [r5, #18]
    5bf0:	strh	r2, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    5bf2:	ldrb	r3, [r4, #2]
    5bf4:	and.w	r3, r3, #127	; 0x7f
    5bf8:	strb	r3, [r4, #2]
    5bfa:	b.n	5b7a <FatFile::sync() [clone .part.42]+0xe>
    5bfc:	.word	0x20019b54

00005c00 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    5c00:	push	{r4, lr}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5c02:	ldrb	r3, [r0, #0]

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    5c04:	mov	r4, r0
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5c06:	cbnz	r3, 5c12 <FatFile::close()+0x12>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    5c08:	movs	r3, #0
    5c0a:	strb	r3, [r4, #0]
  m_flags = 0;
    5c0c:	strb	r3, [r4, #2]
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    5c0e:	movs	r0, #1
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return rtn;
}
    5c10:	pop	{r4, pc}
    5c12:	bl	5b6c <FatFile::sync() [clone .part.42]>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    5c16:	movs	r3, #0
    5c18:	strb	r3, [r4, #0]
  m_flags = 0;
    5c1a:	strb	r3, [r4, #2]
  return rtn;
}
    5c1c:	pop	{r4, pc}
    5c1e:	nop

00005c20 <FatFile::mkdir(FatFile*, fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    5c20:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5c24:	ldrb	r4, [r1, #0]
    5c26:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    5c2a:	sub	sp, #36	; 0x24
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5c2c:	bne.n	5c36 <FatFile::mkdir(FatFile*, fname_t*)+0x16>
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
}
    5c2e:	movs	r0, #0
    5c30:	add	sp, #36	; 0x24
    5c32:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    5c36:	movw	r3, #2562	; 0xa02
    5c3a:	mov	r5, r0
    5c3c:	mov	r4, r1
    5c3e:	bl	71e0 <FatFile::open(FatFile*, fname_t*, int)>
    5c42:	cmp	r0, #0
    5c44:	beq.n	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5c46:	movs	r2, #1
  m_attributes = FILE_ATTR_SUBDIR;
    5c48:	movs	r3, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5c4a:	strb	r2, [r5, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    5c4c:	strb	r3, [r5, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    5c4e:	mov	r0, r5
    5c50:	bl	5ab4 <FatFile::addDirCluster()>
    5c54:	cmp	r0, #0
    5c56:	beq.n	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    5c58:	ldrb	r3, [r5, #0]
  // allocate and zero first cluster
  if (!addDirCluster()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    5c5a:	ldr	r2, [r5, #16]
    5c5c:	str	r2, [r5, #32]
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    5c5e:	cmp	r3, #0
    5c60:	bne.n	5d4e <FatFile::mkdir(FatFile*, fname_t*)+0x12e>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5c62:	movs	r1, #1
    5c64:	mov	r0, r5
    5c66:	bl	5b4c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5c6a:	mov	r6, r0
    5c6c:	cmp	r0, #0
    5c6e:	beq.n	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    5c70:	movs	r3, #16
    5c72:	strb	r3, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    5c74:	ldr	r2, [r0, #8]
    5c76:	ldr	r1, [r6, #4]
    5c78:	ldr	r3, [r6, #12]
    5c7a:	ldr	r0, [r0, #0]
    5c7c:	ldrh.w	r8, [r6, #20]
    5c80:	ldrh.w	r9, [r6, #26]
    5c84:	mov	r7, sp
    5c86:	stmia	r7!, {r0, r1, r2, r3}
    5c88:	ldr	r1, [r6, #20]
    5c8a:	ldr	r2, [r6, #24]
    5c8c:	ldr	r3, [r6, #28]
    5c8e:	ldr	r0, [r6, #16]
  dot.name[0] = '.';
    5c90:	add	r6, sp, #32
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    5c92:	stmia	r7!, {r0, r1, r2, r3}
  dot.name[0] = '.';
    5c94:	movs	r3, #46	; 0x2e
    5c96:	strb.w	r3, [r6, #-32]!
    5c9a:	add.w	r1, sp, #10
    5c9e:	mov	r3, r6
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    5ca0:	movs	r2, #32
    5ca2:	strb.w	r2, [r3, #1]!
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    5ca6:	cmp	r3, r1
    5ca8:	bne.n	5ca2 <FatFile::mkdir(FatFile*, fname_t*)+0x82>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    5caa:	ldr	r0, [r5, #8]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5cac:	ldr	r3, [r5, #32]
    5cae:	ldrb	r2, [r0, #6]
    5cb0:	ldr	r1, [r0, #20]
    5cb2:	subs	r3, #2
    5cb4:	lsls	r3, r2
    5cb6:	add	r1, r3
    5cb8:	adds	r0, #36	; 0x24
    5cba:	movs	r2, #1
    5cbc:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    5cc0:	mov	lr, r0
    5cc2:	cmp	r0, #0
    5cc4:	beq.n	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    5cc6:	mov	r7, r6
    5cc8:	strh.w	r8, [sp, #20]
    5ccc:	strh.w	r9, [sp, #26]
    5cd0:	ldmia	r7!, {r0, r1, r2, r3}
    5cd2:	str.w	r0, [lr]
    5cd6:	str.w	r1, [lr, #4]
    5cda:	str.w	r2, [lr, #8]
    5cde:	str.w	r3, [lr, #12]
    5ce2:	ldmia	r7!, {r0, r1, r2, r3}
    5ce4:	str.w	r0, [lr, #16]
    5ce8:	str.w	r1, [lr, #20]
    5cec:	str.w	r2, [lr, #24]
    5cf0:	str.w	r3, [lr, #28]
  // make entry for '..'
  dot.name[1] = '.';
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    5cf4:	ldr	r3, [r4, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    5cf6:	strh.w	r3, [sp, #26]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    5cfa:	movs	r2, #46	; 0x2e
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    5cfc:	lsrs	r3, r3, #16
    5cfe:	mov	r4, r6
    5d00:	strh.w	r3, [sp, #20]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    5d04:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    5d08:	ldmia	r4!, {r0, r1, r2, r3}
    5d0a:	add.w	r6, lr, #32
    5d0e:	str.w	r0, [lr, #32]
    5d12:	str	r1, [r6, #4]
    5d14:	str	r2, [r6, #8]
    5d16:	str	r3, [r6, #12]
    5d18:	ldmia	r4!, {r0, r1, r2, r3}
    5d1a:	str	r0, [r6, #16]
    5d1c:	str	r1, [r6, #20]
    5d1e:	str	r2, [r6, #24]
    5d20:	str	r3, [r6, #28]
  // write first sector
  return m_vol->cacheSync();
    5d22:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5d24:	add.w	r0, r4, #36	; 0x24
    5d28:	bl	414c <FsCache::sync()>
    5d2c:	cmp	r0, #0
    5d2e:	beq.w	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    5d32:	add.w	r0, r4, #564	; 0x234
    5d36:	bl	414c <FsCache::sync()>
    5d3a:	cmp	r0, #0
    5d3c:	beq.w	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    5d40:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5d42:	ldr	r3, [r0, #0]
    5d44:	ldr	r3, [r3, #24]

 fail:
  return false;
}
    5d46:	add	sp, #36	; 0x24
    5d48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5d4c:	bx	r3
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    5d4e:	ldr	r3, [r5, #20]
    5d50:	cbz	r3, 5d60 <FatFile::mkdir(FatFile*, fname_t*)+0x140>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5d52:	ldrb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    5d54:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5d56:	bic.w	r3, r3, #32
    5d5a:	strb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    5d5c:	str	r2, [r5, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    5d5e:	str	r2, [r5, #20]
    5d60:	mov	r0, r5
    5d62:	bl	5b6c <FatFile::sync() [clone .part.42]>
  }
  m_firstCluster = m_curCluster;
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    5d66:	cmp	r0, #0
    5d68:	beq.w	5c2e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    5d6c:	b.n	5c62 <FatFile::mkdir(FatFile*, fname_t*)+0x42>
    5d6e:	nop

00005d70 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    5d70:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5d74:	mov	r6, r0
    5d76:	sub	sp, #72	; 0x48
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5d78:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    5d7a:	str	r2, [sp, #4]
    5d7c:	movs	r0, #0
    5d7e:	strb.w	r0, [sp, #36]	; 0x24
    5d82:	strb.w	r0, [sp, #37]	; 0x25
    5d86:	strb.w	r0, [sp, #38]	; 0x26
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5d8a:	cbnz	r5, 5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    5d8c:	mov	r8, r3
    5d8e:	ldrb	r3, [r1, #0]
    5d90:	tst.w	r3, #112	; 0x70
    5d94:	mov	r4, r1
    5d96:	bne.n	5da0 <FatFile::mkdir(FatFile*, char const*, bool)+0x30>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    5d98:	movs	r0, #0
}
    5d9a:	add	sp, #72	; 0x48
    5d9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5da0:	ldrb	r3, [r2, #0]
    5da2:	cmp	r3, #47	; 0x2f
    5da4:	mov	r0, r2
    5da6:	beq.n	5dfe <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    5da8:	movs	r7, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5daa:	add	r2, sp, #4
    5dac:	add	r1, sp, #12
    5dae:	bl	6db4 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    5db2:	add	r2, sp, #12
    5db4:	mov	r1, r4
    5db6:	movs	r3, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5db8:	cmp	r0, #0
    5dba:	beq.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5dbc:	ldr	r5, [sp, #4]
    5dbe:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    5dc0:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5dc2:	cmp	r5, #0
    5dc4:	beq.n	5e22 <FatFile::mkdir(FatFile*, char const*, bool)+0xb2>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    5dc6:	bl	71e0 <FatFile::open(FatFile*, fname_t*, int)>
    5dca:	cbnz	r0, 5de0 <FatFile::mkdir(FatFile*, char const*, bool)+0x70>
      if (!pFlag || !mkdir(parent, &fname)) {
    5dcc:	cmp.w	r8, #0
    5dd0:	beq.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    5dd2:	mov	r1, r4
    5dd4:	add	r2, sp, #12
    5dd6:	mov	r0, r6
    5dd8:	bl	5c20 <FatFile::mkdir(FatFile*, fname_t*)>
    5ddc:	cmp	r0, #0
    5dde:	beq.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5de0:	mov	r5, r6
    5de2:	ldmia	r5!, {r0, r1, r2, r3}
    5de4:	add	r4, sp, #36	; 0x24
    5de6:	stmia	r4!, {r0, r1, r2, r3}
    5de8:	ldmia	r5!, {r0, r1, r2, r3}
    5dea:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5dec:	ldrb	r3, [r6, #0]
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5dee:	ldr	r2, [r5, #0]
    5df0:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5df2:	cbnz	r3, 5e1a <FatFile::mkdir(FatFile*, char const*, bool)+0xaa>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    5df4:	strb	r7, [r6, #0]
  m_flags = 0;
    5df6:	strb	r7, [r6, #2]
    5df8:	ldr	r0, [sp, #4]
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    5dfa:	add	r4, sp, #36	; 0x24
    5dfc:	b.n	5daa <FatFile::mkdir(FatFile*, char const*, bool)+0x3a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    5dfe:	adds	r0, #1
    5e00:	str	r0, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5e02:	ldrb	r3, [r0, #0]
    5e04:	cmp	r3, #47	; 0x2f
    5e06:	beq.n	5dfe <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
    5e08:	ldr	r1, [r4, #8]
    5e0a:	add	r0, sp, #36	; 0x24
    5e0c:	bl	5a4c <FatFile::openRoot(FatVolume*) [clone .part.38]>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    5e10:	cmp	r0, #0
    5e12:	beq.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    5e14:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    5e16:	add	r4, sp, #36	; 0x24
    5e18:	b.n	5da8 <FatFile::mkdir(FatFile*, char const*, bool)+0x38>
    5e1a:	mov	r0, r6
    5e1c:	bl	5b6c <FatFile::sync() [clone .part.42]>
    5e20:	b.n	5df4 <FatFile::mkdir(FatFile*, char const*, bool)+0x84>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    5e22:	add	r2, sp, #12
    5e24:	mov	r1, r4
    5e26:	mov	r0, r6
    5e28:	bl	5c20 <FatFile::mkdir(FatFile*, fname_t*)>

 fail:
  return false;
}
    5e2c:	add	sp, #72	; 0x48
    5e2e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5e32:	nop

00005e34 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5e34:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5e38:	mov	r6, r0
    5e3a:	sub	sp, #72	; 0x48
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5e3c:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5e3e:	str	r2, [sp, #4]
    5e40:	movs	r0, #0
    5e42:	strb.w	r0, [sp, #36]	; 0x24
    5e46:	strb.w	r0, [sp, #37]	; 0x25
    5e4a:	strb.w	r0, [sp, #38]	; 0x26
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5e4e:	cbnz	r5, 5e5c <FatFile::open(FatFile*, char const*, int)+0x28>
    5e50:	mov	r8, r3
    5e52:	ldrb	r3, [r1, #0]
    5e54:	tst.w	r3, #112	; 0x70
    5e58:	mov	r4, r1
    5e5a:	bne.n	5e64 <FatFile::open(FatFile*, char const*, int)+0x30>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    5e5c:	movs	r0, #0
}
    5e5e:	add	sp, #72	; 0x48
    5e60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5e64:	ldrb	r3, [r2, #0]
    5e66:	cmp	r3, #47	; 0x2f
    5e68:	mov	r0, r2
    5e6a:	beq.n	5eb8 <FatFile::open(FatFile*, char const*, int)+0x84>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5e6c:	movs	r7, #0
    5e6e:	b.n	5e78 <FatFile::open(FatFile*, char const*, int)+0x44>
    5e70:	ldr	r0, [sp, #4]
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    5e72:	strb	r7, [r6, #0]
  m_flags = 0;
    5e74:	strb	r7, [r6, #2]
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    5e76:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5e78:	add	r2, sp, #4
    5e7a:	add	r1, sp, #12
    5e7c:	bl	6db4 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5e80:	add	r2, sp, #12
    5e82:	mov	r1, r4
    5e84:	movs	r3, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5e86:	cmp	r0, #0
    5e88:	beq.n	5e5c <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    5e8a:	ldr	r5, [sp, #4]
    5e8c:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5e8e:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    5e90:	cbz	r5, 5ed6 <FatFile::open(FatFile*, char const*, int)+0xa2>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5e92:	bl	71e0 <FatFile::open(FatFile*, fname_t*, int)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    5e96:	mov	r5, r6
    5e98:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5e9a:	cmp	r0, #0
    5e9c:	beq.n	5e5c <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    5e9e:	ldmia	r5!, {r0, r1, r2, r3}
    5ea0:	stmia	r4!, {r0, r1, r2, r3}
    5ea2:	ldmia	r5!, {r0, r1, r2, r3}
    5ea4:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5ea6:	ldrb	r3, [r6, #0]
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    5ea8:	ldr	r2, [r5, #0]
    5eaa:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5eac:	cmp	r3, #0
    5eae:	beq.n	5e70 <FatFile::open(FatFile*, char const*, int)+0x3c>
    5eb0:	mov	r0, r6
    5eb2:	bl	5b6c <FatFile::sync() [clone .part.42]>
    5eb6:	b.n	5e70 <FatFile::open(FatFile*, char const*, int)+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    5eb8:	adds	r0, #1
    5eba:	str	r0, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5ebc:	ldrb	r3, [r0, #0]
    5ebe:	cmp	r3, #47	; 0x2f
    5ec0:	beq.n	5eb8 <FatFile::open(FatFile*, char const*, int)+0x84>
      path++;
    }
    if (*path == 0) {
    5ec2:	cbz	r3, 5ee8 <FatFile::open(FatFile*, char const*, int)+0xb4>
    5ec4:	ldr	r1, [r4, #8]
    5ec6:	add	r0, sp, #36	; 0x24
    5ec8:	bl	5a4c <FatFile::openRoot(FatVolume*) [clone .part.38]>
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    5ecc:	cmp	r0, #0
    5ece:	beq.n	5e5c <FatFile::open(FatFile*, char const*, int)+0x28>
    5ed0:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    5ed2:	add	r4, sp, #36	; 0x24
    5ed4:	b.n	5e6c <FatFile::open(FatFile*, char const*, int)+0x38>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    5ed6:	mov	r3, r8
    5ed8:	add	r2, sp, #12
    5eda:	mov	r1, r4
    5edc:	mov	r0, r6
    5ede:	bl	71e0 <FatFile::open(FatFile*, fname_t*, int)>

 fail:
  return false;
}
    5ee2:	add	sp, #72	; 0x48
    5ee4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5ee8:	ldr	r1, [r4, #8]
    5eea:	mov	r0, r6
    5eec:	bl	5a4c <FatFile::openRoot(FatVolume*) [clone .part.38]>
    5ef0:	b.n	5e5e <FatFile::open(FatFile*, char const*, int)+0x2a>
    5ef2:	nop

00005ef4 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    5ef4:	cbz	r1, 5efe <FatFile::open(FatVolume*, char const*, int)+0xa>
    5ef6:	addw	r1, r1, #1092	; 0x444
    5efa:	b.w	5e34 <FatFile::open(FatFile*, char const*, int)>
}
    5efe:	mov	r0, r1
    5f00:	bx	lr
    5f02:	nop

00005f04 <FatFile::openRoot(FatVolume*)>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
  // error if file is already open
  if (isOpen()) {
    5f04:	ldrb	r3, [r0, #0]
    5f06:	cbz	r3, 5f0c <FatFile::openRoot(FatVolume*)+0x8>
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
}
    5f08:	movs	r0, #0
    5f0a:	bx	lr
    5f0c:	b.w	5a4c <FatFile::openRoot(FatVolume*) [clone .part.38]>

00005f10 <FatFile::preAllocate(unsigned long)>:
//------------------------------------------------------------------------------
bool FatFile::preAllocate(uint32_t length) {
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    5f10:	cbnz	r1, 5f16 <FatFile::preAllocate(unsigned long)+0x6>
  m_flags |= FILE_FLAG_DIR_DIRTY;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  return sync();

 fail:
  return false;
    5f12:	movs	r0, #0
}
    5f14:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::preAllocate(uint32_t length) {
    5f16:	push	{r3, r4, r5, lr}
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    5f18:	ldrb	r3, [r0, #2]
    5f1a:	lsls	r3, r3, #30
    5f1c:	bmi.n	5f22 <FatFile::preAllocate(unsigned long)+0x12>
  m_flags |= FILE_FLAG_DIR_DIRTY;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  return sync();

 fail:
  return false;
    5f1e:	movs	r0, #0
    5f20:	pop	{r3, r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::preAllocate(uint32_t length) {
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    5f22:	ldr	r3, [r0, #32]
    5f24:	cmp	r3, #0
    5f26:	bne.n	5f1e <FatFile::preAllocate(unsigned long)+0xe>
    5f28:	mov	r4, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  need = 1 + ((length - 1) >> m_vol->bytesPerClusterShift());
    5f2a:	ldr	r0, [r0, #8]
  // allocate clusters
  if (!m_vol->allocContiguous(need, &m_firstCluster)) {
    5f2c:	ldrb	r3, [r0, #6]
    5f2e:	adds	r3, #9
    5f30:	mov	r5, r1
    5f32:	uxtb	r3, r3
    5f34:	subs	r1, #1
    5f36:	lsrs	r1, r3
    5f38:	adds	r1, #1
    5f3a:	add.w	r2, r4, #32
    5f3e:	bl	699c <FatPartition::allocContiguous(unsigned long, unsigned long*)>
    5f42:	cmp	r0, #0
    5f44:	beq.n	5f1e <FatFile::preAllocate(unsigned long)+0xe>
  }
  m_fileSize = length;

#if USE_FAT_FILE_FLAG_CONTIGUOUS
  // Mark contiguous and insure sync() will update dir entry
  m_flags |= FILE_FLAG_PREALLOCATE | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    5f46:	ldrb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5f48:	ldrb	r2, [r4, #0]
  // allocate clusters
  if (!m_vol->allocContiguous(need, &m_firstCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fileSize = length;
    5f4a:	str	r5, [r4, #28]

#if USE_FAT_FILE_FLAG_CONTIGUOUS
  // Mark contiguous and insure sync() will update dir entry
  m_flags |= FILE_FLAG_PREALLOCATE | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    5f4c:	orn	r3, r3, #31
    5f50:	strb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5f52:	cbnz	r2, 5f56 <FatFile::preAllocate(unsigned long)+0x46>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  return sync();

 fail:
  return false;
}
    5f54:	pop	{r3, r4, r5, pc}
    5f56:	mov	r0, r4
    5f58:	ldmia.w	sp!, {r3, r4, r5, lr}
    5f5c:	b.w	5b6c <FatFile::sync() [clone .part.42]>

00005f60 <FatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5f60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5f64:	ldrb	r3, [r0, #2]
    5f66:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5f68:	sub	sp, #12
    5f6a:	mov	r5, r0
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5f6c:	bpl.w	6094 <FatFile::read(void*, unsigned int)+0x134>
    5f70:	mov	r7, r1
    5f72:	ldrb	r1, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5f74:	lsls	r6, r1, #28
    5f76:	mov	r9, r2
    5f78:	bmi.w	60a6 <FatFile::read(void*, unsigned int)+0x146>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    5f7c:	lsls	r4, r1, #26
    5f7e:	bpl.n	5f92 <FatFile::read(void*, unsigned int)+0x32>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5f80:	ldr	r2, [r0, #8]
    if (nbyte > tmp16) {
    5f82:	ldr	r3, [r0, #20]
    5f84:	ldrh	r2, [r2, #8]
    5f86:	rsb	r3, r3, r2, lsl #5
    5f8a:	uxth	r3, r3
    5f8c:	cmp	r9, r3
    5f8e:	it	cs
    5f90:	movcs	r9, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5f92:	cmp.w	r9, #0
    5f96:	beq.w	60f2 <FatFile::read(void*, unsigned int)+0x192>
    5f9a:	ldr	r3, [r5, #20]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5f9c:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    5f9e:	lsls	r0, r1, #26
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5fa0:	mov	r6, r9
    5fa2:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5fa6:	add.w	sl, r5, #16
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5faa:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    5fae:	bpl.n	6032 <FatFile::read(void*, unsigned int)+0xd2>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    5fb0:	ldr	r1, [r2, #32]
    5fb2:	add.w	r1, r1, r3, lsr #9
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    5fb6:	cmp.w	fp, #0
    5fba:	bne.n	6068 <FatFile::read(void*, unsigned int)+0x108>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    5fbc:	cmp.w	r6, #512	; 0x200
    5fc0:	bcc.n	6068 <FatFile::read(void*, unsigned int)+0x108>
    5fc2:	ldr	r3, [r2, #48]	; 0x30
        || sector == m_vol->cacheSectorNumber()) {
    5fc4:	cmp	r1, r3
    5fc6:	beq.n	6068 <FatFile::read(void*, unsigned int)+0x108>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    5fc8:	cmp.w	r6, #1024	; 0x400
    5fcc:	bcc.n	60b8 <FatFile::read(void*, unsigned int)+0x158>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    5fce:	ldrb	r0, [r5, #0]
    5fd0:	lsls	r0, r0, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    5fd2:	mov.w	fp, r6, lsr #9
      if (!isRootFixed()) {
    5fd6:	bmi.n	5fe4 <FatFile::read(void*, unsigned int)+0x84>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    5fd8:	ldrb	r0, [r2, #4]
    5fda:	rsb	r0, r8, r0
    5fde:	cmp	fp, r0
    5fe0:	it	cs
    5fe2:	movcs	fp, r0
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5fe4:	cmp	r1, r3
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5fe6:	mov.w	r4, fp, lsl #9
    5fea:	bhi.n	6008 <FatFile::read(void*, unsigned int)+0xa8>
    5fec:	add.w	r0, r1, fp
    5ff0:	cmp	r3, r0
    5ff2:	bcs.n	6008 <FatFile::read(void*, unsigned int)+0xa8>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5ff4:	add.w	r0, r2, #36	; 0x24
    5ff8:	str	r1, [sp, #4]
    5ffa:	str	r2, [sp, #0]
    5ffc:	bl	414c <FsCache::sync()>
    6000:	ldr	r2, [sp, #0]
    6002:	ldr	r1, [sp, #4]
    6004:	cmp	r0, #0
    6006:	beq.n	6094 <FatFile::read(void*, unsigned int)+0x134>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    6008:	ldr	r0, [r2, #40]	; 0x28
    600a:	ldr	r2, [r0, #0]
    600c:	mov	r3, fp
    600e:	ldr.w	fp, [r2, #16]
    6012:	mov	r2, r7
    6014:	blx	fp
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    6016:	cmp	r0, #0
    6018:	beq.n	6094 <FatFile::read(void*, unsigned int)+0x134>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    601a:	ldr	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    601c:	subs	r6, r6, r4
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    601e:	add	r3, r4
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    6020:	add	r7, r4
    m_curPosition += n;
    6022:	str	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    6024:	beq.n	60f2 <FatFile::read(void*, unsigned int)+0x192>
    6026:	ldrb	r1, [r5, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    6028:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    602a:	lsls	r0, r1, #26
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    602c:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    6030:	bmi.n	5fb0 <FatFile::read(void*, unsigned int)+0x50>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    6032:	ldrb.w	r8, [r2, #5]
    6036:	and.w	r8, r8, r3, lsr #9
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    603a:	cmp.w	fp, #0
    603e:	bne.n	60b4 <FatFile::read(void*, unsigned int)+0x154>
    6040:	cmp.w	r8, #0
    6044:	bne.n	60b4 <FatFile::read(void*, unsigned int)+0x154>
        // start of new cluster
        if (m_curPosition == 0) {
    6046:	cmp	r3, #0
    6048:	bne.n	60cc <FatFile::read(void*, unsigned int)+0x16c>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    604a:	lsls	r1, r1, #25
    604c:	ite	mi
    604e:	ldrmi	r4, [r2, #32]
    6050:	ldrpl	r4, [r5, #32]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    6052:	str	r4, [r5, #16]
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    6054:	ldrb	r1, [r2, #6]
    6056:	ldr	r0, [r2, #20]
    6058:	subs	r4, #2
    605a:	lsls	r4, r1
    605c:	add.w	r1, r8, r0
    6060:	add	r1, r4
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    6062:	cmp.w	fp, #0
    6066:	beq.n	5fbc <FatFile::read(void*, unsigned int)+0x5c>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6068:	add.w	r0, r2, #36	; 0x24
    606c:	movs	r2, #0
    606e:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    6072:	cbz	r0, 6094 <FatFile::read(void*, unsigned int)+0x134>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    6074:	rsb	r4, fp, #512	; 0x200
    6078:	cmp	r4, r6
    607a:	it	cs
    607c:	movcs	r4, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    607e:	add.w	r1, r0, fp
    6082:	mov	r2, r4
    6084:	mov	r0, r7
    6086:	bl	9220 <memcpy>
    608a:	b.n	601a <FatFile::read(void*, unsigned int)+0xba>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    608c:	ldrb	r3, [r5, #0]
    608e:	tst.w	r3, #112	; 0x70
    6092:	bne.n	60f4 <FatFile::read(void*, unsigned int)+0x194>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    6094:	ldrb	r3, [r5, #1]
  return -1;
    6096:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    609a:	orr.w	r3, r3, #2
    609e:	strb	r3, [r5, #1]
  return -1;
}
    60a0:	add	sp, #12
    60a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    uint32_t tmp32 = m_fileSize - m_curPosition;
    60a6:	ldr	r3, [r0, #28]
    60a8:	ldr	r2, [r0, #20]
    60aa:	subs	r3, r3, r2
    60ac:	cmp	r9, r3
    60ae:	it	cs
    60b0:	movcs	r9, r3
    60b2:	b.n	5f92 <FatFile::read(void*, unsigned int)+0x32>
    60b4:	ldr	r4, [r5, #16]
    60b6:	b.n	6054 <FatFile::read(void*, unsigned int)+0xf4>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    60b8:	ldr	r0, [r2, #40]	; 0x28
    60ba:	ldr	r3, [r0, #0]
    60bc:	mov	r2, r7
    60be:	ldr	r3, [r3, #12]
    60c0:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    60c2:	cmp	r0, #0
    60c4:	beq.n	6094 <FatFile::read(void*, unsigned int)+0x134>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    60c6:	mov.w	r4, #512	; 0x200
    60ca:	b.n	601a <FatFile::read(void*, unsigned int)+0xba>
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    60cc:	lsls	r3, r1, #28
    60ce:	bpl.n	60dc <FatFile::read(void*, unsigned int)+0x17c>
    60d0:	ldrb	r3, [r5, #2]
    60d2:	lsls	r4, r3, #25
    60d4:	bpl.n	60dc <FatFile::read(void*, unsigned int)+0x17c>
          m_curCluster++;
    60d6:	ldr	r4, [r5, #16]
    60d8:	adds	r4, #1
    60da:	b.n	6052 <FatFile::read(void*, unsigned int)+0xf2>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    60dc:	mov	r0, r2
    60de:	ldr	r1, [r5, #16]
    60e0:	mov	r2, sl
    60e2:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    60e6:	cmp	r0, #0
    60e8:	blt.n	6094 <FatFile::read(void*, unsigned int)+0x134>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    60ea:	beq.n	608c <FatFile::read(void*, unsigned int)+0x12c>
    60ec:	ldr	r2, [r5, #8]
    60ee:	ldr	r4, [r5, #16]
    60f0:	b.n	6054 <FatFile::read(void*, unsigned int)+0xf4>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    60f2:	movs	r6, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    60f4:	rsb	r0, r6, r9

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    60f8:	add	sp, #12
    60fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    60fe:	nop

00006100 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    6100:	push	{r4, r5, r6, lr}
    6102:	sub	sp, #8
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    6104:	movs	r2, #1
    6106:	add.w	r1, sp, #7
    610a:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    610c:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    610e:	ldr	r5, [r0, #16]
    6110:	bl	5f60 <FatFile::read(void*, unsigned int)>
    6114:	cmp	r0, #1
    6116:	it	eq
    6118:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    611c:	str	r6, [r4, #20]
    611e:	it	ne
    6120:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    6124:	str	r5, [r4, #16]
  return c;
}
    6126:	add	sp, #8
    6128:	pop	{r4, r5, r6, pc}
    612a:	nop

0000612c <FatFile::readDirCache(bool)>:
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    612c:	push	{r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
    612e:	ldr	r3, [r0, #20]
    6130:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    6134:	sub	sp, #12
    6136:	mov	r4, r0
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    6138:	cbz	r5, 613c <FatFile::readDirCache(bool)+0x10>
    613a:	cbnz	r1, 6160 <FatFile::readDirCache(bool)+0x34>
    int8_t n = read(&n, 1);
    613c:	movs	r2, #1
    613e:	add.w	r1, sp, #7
    6142:	mov	r0, r4
    6144:	bl	5f60 <FatFile::read(void*, unsigned int)>
    6148:	sxtb	r0, r0
    if  (n != 1) {
    614a:	cmp	r0, #1
    614c:	bne.n	6166 <FatFile::readDirCache(bool)+0x3a>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    614e:	ldr	r3, [r4, #20]
    6150:	adds	r3, #31
    6152:	str	r3, [r4, #20]
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    6154:	ldr	r0, [r4, #8]
    6156:	adds	r0, #52	; 0x34
  } else {
    m_curPosition += 32;
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    6158:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    615c:	add	sp, #12
    615e:	pop	{r4, r5, pc}
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
    6160:	adds	r3, #32
    6162:	str	r3, [r0, #20]
    6164:	b.n	6154 <FatFile::readDirCache(bool)+0x28>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    6166:	movs	r0, #0
}
    6168:	add	sp, #12
    616a:	pop	{r4, r5, pc}

0000616c <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    616c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    6170:	ldrb	r5, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6172:	sub	sp, #104	; 0x68
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    6174:	movs	r4, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    6176:	tst.w	r5, #24
    617a:	strb.w	r4, [sp, #32]
    617e:	strb.w	r4, [sp, #33]	; 0x21
    6182:	strb.w	r4, [sp, #34]	; 0x22
    6186:	strb.w	r4, [sp, #68]	; 0x44
    618a:	strb.w	r4, [sp, #69]	; 0x45
    618e:	strb.w	r4, [sp, #70]	; 0x46
    6192:	beq.n	619e <FatFile::rename(FatFile*, char const*)+0x32>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    6194:	ldr	r6, [r0, #8]
    6196:	ldr	r5, [r1, #8]
    6198:	cmp	r6, r5
    619a:	mov	r3, r0
    619c:	beq.n	61a6 <FatFile::rename(FatFile*, char const*)+0x3a>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    619e:	movs	r0, #0
}
    61a0:	add	sp, #104	; 0x68
    61a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    61a6:	mov	r5, r3
    61a8:	mov	r8, r2
    61aa:	mov	r6, r1
    61ac:	bl	5b6c <FatFile::sync() [clone .part.42]>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    61b0:	mov	lr, r5
    61b2:	ldmia.w	lr!, {r0, r1, r2, r3}
    61b6:	add	r7, sp, #68	; 0x44
    61b8:	stmia	r7!, {r0, r1, r2, r3}
    61ba:	ldmia.w	lr!, {r0, r1, r2, r3}
    61be:	stmia	r7!, {r0, r1, r2, r3}
    61c0:	ldr.w	r3, [lr]
    61c4:	str	r3, [r7, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    61c6:	mov	r1, r4
    61c8:	mov	r0, r5
    61ca:	bl	5b4c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    61ce:	mov	lr, r0
    61d0:	cmp	r0, #0
    61d2:	beq.n	619e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    61d4:	ldr.w	r1, [lr, #4]
    61d8:	ldr.w	r2, [lr, #8]
    61dc:	ldr.w	r3, [lr, #12]
    61e0:	ldr	r0, [r0, #0]
  // make directory entry for new path
  if (isFile()) {
    61e2:	ldrb.w	ip, [r5]
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    61e6:	mov	r7, sp
    61e8:	stmia	r7!, {r0, r1, r2, r3}
    61ea:	ldr.w	r1, [lr, #20]
    61ee:	ldr.w	r2, [lr, #24]
    61f2:	ldr.w	r3, [lr, #28]
    61f6:	ldr.w	r0, [lr, #16]
  // make directory entry for new path
  if (isFile()) {
    61fa:	and.w	lr, ip, #8
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    61fe:	stmia	r7!, {r0, r1, r2, r3}
  // make directory entry for new path
  if (isFile()) {
    6200:	and.w	r3, lr, #255	; 0xff
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    6204:	mov	r2, r8
    6206:	mov	r1, r6
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
  // make directory entry for new path
  if (isFile()) {
    6208:	cmp.w	lr, #0
    620c:	beq.w	6330 <FatFile::rename(FatFile*, char const*)+0x1c4>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    6210:	movw	r3, #2561	; 0xa01
    6214:	add	r0, sp, #32
    6216:	bl	5e34 <FatFile::open(FatFile*, char const*, int)>
    621a:	cmp	r0, #0
    621c:	beq.n	619e <FatFile::rename(FatFile*, char const*)+0x32>
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    621e:	ldr	r0, [sp, #56]	; 0x38
  m_dirIndex = file.m_dirIndex;
    6220:	ldrh.w	r1, [sp, #36]	; 0x24
  m_lfnOrd = file.m_lfnOrd;
    6224:	ldrb.w	r2, [sp, #35]	; 0x23
  m_dirCluster = file.m_dirCluster;
    6228:	ldr	r3, [sp, #44]	; 0x2c
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    622a:	str	r0, [r5, #24]
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    622c:	movs	r6, #0
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
    622e:	strh	r1, [r5, #4]
  m_lfnOrd = file.m_lfnOrd;
    6230:	strb	r2, [r5, #3]
  m_dirCluster = file.m_dirCluster;
    6232:	str	r3, [r5, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6234:	movs	r1, #1
    6236:	mov	r0, r5
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6238:	strb.w	r6, [sp, #32]
  file.m_flags = 0;
    623c:	strb.w	r6, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6240:	bl	5b4c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6244:	cmp	r0, #0
    6246:	beq.n	619e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    6248:	add	r3, sp, #104	; 0x68
  dir->attributes = entry.attributes;
    624a:	ldrb.w	r2, [sp, #11]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    624e:	ldr.w	r7, [r3, #-91]!
    6252:	str.w	r7, [r0, #13]
    6256:	ldr	r7, [r3, #4]
    6258:	str.w	r7, [r0, #17]
    625c:	ldr	r7, [r3, #8]
    625e:	str.w	r7, [r0, #21]
    6262:	ldr	r7, [r3, #12]
    6264:	str.w	r7, [r0, #25]
    6268:	ldrh	r7, [r3, #16]
    626a:	ldrb	r3, [r3, #18]
    626c:	strh.w	r7, [r0, #29]
    6270:	strb	r3, [r0, #31]
  dir->attributes = entry.attributes;
    6272:	strb	r2, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    6274:	cmp	r4, #0
    6276:	beq.n	62ec <FatFile::rename(FatFile*, char const*)+0x180>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    6278:	ldr	r0, [r5, #8]
    627a:	ldrb	r2, [r0, #6]
    627c:	ldr	r1, [r0, #20]
    627e:	subs	r3, r4, #2
    6280:	lsls	r3, r2
    6282:	add	r1, r3
    6284:	mov	r2, r6
    6286:	adds	r0, #36	; 0x24
    6288:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    628c:	cmp	r0, #0
    628e:	beq.n	619e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    6290:	mov	r6, r0
    6292:	mov	r7, sp
    6294:	ldr.w	r0, [r6, #32]!
    6298:	ldr	r1, [r6, #4]
    629a:	ldr	r2, [r6, #8]
    629c:	ldr	r3, [r6, #12]
    629e:	stmia	r7!, {r0, r1, r2, r3}
    62a0:	ldr	r0, [r6, #16]
    62a2:	ldr	r1, [r6, #20]
    62a4:	ldr	r2, [r6, #24]
    62a6:	ldr	r3, [r6, #28]
    62a8:	stmia	r7!, {r0, r1, r2, r3}

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    62aa:	mov	r1, r4
    62ac:	ldr	r0, [r5, #8]
    62ae:	bl	6a44 <FatPartition::freeChain(unsigned long)>
    62b2:	cmp	r0, #0
    62b4:	beq.w	619e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    62b8:	ldr	r0, [r5, #8]
    62ba:	ldr	r3, [r5, #32]
    62bc:	ldrb	r2, [r0, #6]
    62be:	ldr	r1, [r0, #20]
    62c0:	subs	r3, #2
    62c2:	lsls	r3, r2
    62c4:	add	r1, r3
    62c6:	adds	r0, #36	; 0x24
    62c8:	movs	r2, #1
    62ca:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    62ce:	mov	r7, r0
    62d0:	cmp	r0, #0
    62d2:	beq.w	619e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    62d6:	mov	r4, sp
    62d8:	ldmia	r4!, {r0, r1, r2, r3}
    62da:	str	r0, [r7, #32]
    62dc:	str	r1, [r7, #36]	; 0x24
    62de:	str	r2, [r7, #40]	; 0x28
    62e0:	str	r3, [r7, #44]	; 0x2c
    62e2:	ldmia	r4!, {r0, r1, r2, r3}
    62e4:	str	r0, [r7, #48]	; 0x30
    62e6:	str	r1, [r7, #52]	; 0x34
    62e8:	str	r2, [r7, #56]	; 0x38
    62ea:	str	r3, [r7, #60]	; 0x3c
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    62ec:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    62ee:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    62f0:	movs	r3, #8
  if (!oldFile.remove()) {
    62f2:	add	r0, sp, #68	; 0x44
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    62f4:	str	r1, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    62f6:	strb.w	r2, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
    62fa:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    62fe:	bl	7000 <FatFile::remove()>
    6302:	cmp	r0, #0
    6304:	beq.w	619e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    6308:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    630a:	add.w	r0, r4, #36	; 0x24
    630e:	bl	414c <FsCache::sync()>
    6312:	cmp	r0, #0
    6314:	beq.w	619e <FatFile::rename(FatFile*, char const*)+0x32>
    6318:	add.w	r0, r4, #564	; 0x234
    631c:	bl	414c <FsCache::sync()>
    6320:	cmp	r0, #0
    6322:	beq.w	619e <FatFile::rename(FatFile*, char const*)+0x32>
    6326:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    6328:	ldr	r3, [r0, #0]
    632a:	ldr	r3, [r3, #24]
    632c:	blx	r3
    632e:	b.n	61a0 <FatFile::rename(FatFile*, char const*)+0x34>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    6330:	add	r0, sp, #32
    6332:	bl	5d70 <FatFile::mkdir(FatFile*, char const*, bool)>
    6336:	cmp	r0, #0
    6338:	beq.w	619e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    633c:	ldr	r4, [sp, #64]	; 0x40
    633e:	b.n	621e <FatFile::rename(FatFile*, char const*)+0xb2>

00006340 <FatFile::rmdir()>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    6340:	ldrb	r3, [r0, #0]
    6342:	lsls	r2, r3, #27
    6344:	bpl.n	637c <FatFile::rmdir()+0x3c>
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    6346:	ldr	r3, [r0, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    6348:	push	{r4, lr}
    634a:	mov	r4, r0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    634c:	cbz	r3, 635c <FatFile::rmdir()+0x1c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    634e:	ldrb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    6350:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    6352:	bic.w	r3, r3, #32
    6356:	strb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    6358:	str	r2, [r0, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    635a:	str	r2, [r0, #20]
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    635c:	movs	r1, #1
    635e:	mov	r0, r4
    6360:	bl	612c <FatFile::readDirCache(bool)>
    if (!dir) {
    6364:	cbz	r0, 6380 <FatFile::rmdir()+0x40>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    6366:	ldrb	r3, [r0, #0]
    6368:	cbz	r3, 6386 <FatFile::rmdir()+0x46>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    636a:	cmp	r3, #229	; 0xe5
    636c:	beq.n	635c <FatFile::rmdir()+0x1c>
    636e:	cmp	r3, #46	; 0x2e
    6370:	beq.n	635c <FatFile::rmdir()+0x1c>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    6372:	ldrb	r3, [r0, #11]
    6374:	lsls	r3, r3, #28
    6376:	bmi.n	635c <FatFile::rmdir()+0x1c>
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
}
    6378:	movs	r0, #0
    637a:	pop	{r4, pc}
    637c:	movs	r0, #0
    637e:	bx	lr
  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    if (!dir) {
      // EOF if no error.
      if (!getError()) {
    6380:	ldrb	r3, [r4, #1]
    6382:	cmp	r3, #0
    6384:	bne.n	6378 <FatFile::rmdir()+0x38>
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    6386:	ldrb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    6388:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    638a:	orr.w	r3, r3, #2
    638e:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    6390:	strb	r2, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    6392:	mov	r0, r4

 fail:
  return false;
}
    6394:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    6398:	b.w	7000 <FatFile::remove()>

0000639c <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    639c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    63a0:	ldrb	r3, [r0, #0]
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    63a2:	ldr	r7, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    63a4:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    63a6:	cbz	r3, 63d6 <FatFile::seekSet(unsigned long)+0x3a>
    63a8:	mov	r5, r1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    63aa:	ldr	r1, [r0, #20]
    63ac:	cmp	r1, r5
    63ae:	beq.n	6408 <FatFile::seekSet(unsigned long)+0x6c>
    return true;
  }
  if (pos == 0) {
    63b0:	cbnz	r5, 63c4 <FatFile::seekSet(unsigned long)+0x28>
    63b2:	ldrb	r3, [r0, #2]
    // set position to start of file
    m_curCluster = 0;
    63b4:	str	r5, [r0, #16]
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    63b6:	bic.w	r3, r3, #32
    63ba:	strb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    63bc:	str	r5, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;
    63be:	movs	r0, #1
    63c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    63c4:	lsls	r0, r3, #28
    63c6:	bmi.n	63de <FatFile::seekSet(unsigned long)+0x42>
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    63c8:	lsls	r2, r3, #26
    63ca:	bpl.n	63e4 <FatFile::seekSet(unsigned long)+0x48>
    63cc:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    63ce:	ldrh	r3, [r3, #8]
    63d0:	cmp.w	r5, r3, lsl #5
    63d4:	bls.n	6440 <FatFile::seekSet(unsigned long)+0xa4>
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;

 fail:
  m_curCluster = tmp;
    63d6:	str	r7, [r4, #16]
  return false;
    63d8:	movs	r0, #0
    63da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    if (pos > m_fileSize) {
    63de:	ldr	r2, [r4, #28]
    63e0:	cmp	r5, r2
    63e2:	bhi.n	63d6 <FatFile::seekSet(unsigned long)+0x3a>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    63e4:	ldr.w	lr, [r4, #8]
    63e8:	ldrb	r2, [r4, #2]
    63ea:	ldrb.w	r0, [lr, #6]
    63ee:	adds	r0, #9
    63f0:	uxtb	r0, r0
    63f2:	subs	r6, r5, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    63f4:	tst.w	r2, #64	; 0x40
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    63f8:	lsr.w	r6, r6, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    63fc:	beq.n	640e <FatFile::seekSet(unsigned long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    63fe:	ldr	r3, [r4, #32]
    6400:	add	r6, r3
    6402:	str	r6, [r4, #16]
    goto done;
    6404:	mov	r3, r2
    6406:	b.n	63b6 <FatFile::seekSet(unsigned long)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    6408:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    640a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    640e:	subs	r2, r1, #1
    6410:	lsr.w	r0, r2, r0

  if (nNew < nCur || m_curPosition == 0) {
    6414:	cmp	r6, r0
    6416:	bcs.n	6444 <FatFile::seekSet(unsigned long)+0xa8>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    6418:	lsls	r3, r3, #25
    641a:	ite	mi
    641c:	ldrmi.w	r3, [lr, #32]
    6420:	ldrpl	r3, [r4, #32]
    6422:	str	r3, [r4, #16]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    6424:	add.w	r8, r4, #16
    6428:	b.n	643a <FatFile::seekSet(unsigned long)+0x9e>
    642a:	ldr	r1, [r4, #16]
    642c:	ldr	r0, [r4, #8]
    642e:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
    6432:	cmp	r0, #0
    6434:	add.w	r6, r6, #4294967295
    6438:	ble.n	63d6 <FatFile::seekSet(unsigned long)+0x3a>
    643a:	mov	r2, r8
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    643c:	cmp	r6, #0
    643e:	bne.n	642a <FatFile::seekSet(unsigned long)+0x8e>
    6440:	ldrb	r3, [r4, #2]
    6442:	b.n	63b6 <FatFile::seekSet(unsigned long)+0x1a>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());

  if (nNew < nCur || m_curPosition == 0) {
    6444:	cmp	r1, #0
    6446:	beq.n	6418 <FatFile::seekSet(unsigned long)+0x7c>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    6448:	subs	r6, r6, r0
    644a:	b.n	6424 <FatFile::seekSet(unsigned long)+0x88>

0000644c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    644c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6450:	mov	r5, r1
    6452:	mov	r8, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    6454:	movs	r1, #0
    6456:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    6458:	mov	r4, r0
    645a:	mov	r7, r3
    645c:	ldrb.w	r6, [sp, #24]
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    6460:	bl	c49c <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    6464:	ldr	r0, [r5, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    6466:	ldr	r3, [r5, #32]
    6468:	str	r3, [r4, #12]
    646a:	add.w	r2, r0, #52	; 0x34
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    646e:	and.w	r3, r8, #15
    6472:	add.w	r2, r2, r3, lsl #5
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    6476:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
    6478:	strh.w	r8, [r4, #4]
    647c:	ldrb	r1, [r2, #11]
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    647e:	lsls	r5, r1, #28
    6480:	bmi.n	64a8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    6482:	and.w	r1, r1, #23
    6486:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    6488:	ldrb	r3, [r2, #11]
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    648a:	strb	r6, [r4, #3]
  if (!isFileOrSubdir(dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    648c:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
    6490:	it	eq
    6492:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    6496:	and.w	r3, r7, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    649a:	it	eq
    649c:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    649e:	cmp	r3, #1
    64a0:	beq.n	64b2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
    64a2:	cmp	r3, #2
    64a4:	beq.n	64fa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xae>
    64a6:	cbz	r3, 64f0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xa4>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    64a8:	movs	r0, #0
    64aa:	strb	r0, [r4, #0]
  m_flags = 0;
    64ac:	strb	r0, [r4, #2]
  return false;
    64ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    64b2:	movs	r3, #2
    64b4:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    64b6:	ldrb	r1, [r4, #0]
    64b8:	tst.w	r1, #17
    64bc:	bne.n	64a8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    64be:	sxtb	r1, r3
    64c0:	and.w	r5, r7, #1024	; 0x400
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    64c4:	and.w	r3, r7, #8
    64c8:	orrs	r3, r1
    64ca:	uxtb	r3, r3
    64cc:	strb	r3, [r4, #2]

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    64ce:	ldrh.w	lr, [r2, #20]
    64d2:	ldrh	r1, [r2, #26]
    64d4:	ldr	r6, [r0, #48]	; 0x30
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);

  m_dirSector = m_vol->cacheSectorNumber();
    64d6:	str	r6, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    64d8:	orr.w	r1, r1, lr, lsl #16

  if (oflag & O_TRUNC) {
    64dc:	cbz	r5, 6500 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    64de:	cbnz	r1, 6516 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xca>
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    64e0:	orn	r3, r3, #127	; 0x7f
    64e4:	strb	r3, [r4, #2]
  } else {
    m_firstCluster = firstCluster;
    m_fileSize = getLe32(dir->fileSize);
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    64e6:	lsls	r3, r7, #17
    64e8:	bmi.n	6508 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    64ea:	movs	r0, #1
    64ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    64f0:	ands.w	r5, r7, #1024	; 0x400
    64f4:	bne.n	64a8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    64f6:	movs	r1, #1
    64f8:	b.n	64c4 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x78>
      }
      m_flags = FILE_FLAG_READ;
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    64fa:	movs	r3, #3
    64fc:	strb	r3, [r4, #2]
      break;
    64fe:	b.n	64b6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x6a>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    6500:	str	r1, [r4, #32]
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6502:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    6504:	str	r3, [r4, #28]
    6506:	b.n	64e6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9a>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    6508:	ldr	r1, [r4, #28]
    650a:	mov	r0, r4
    650c:	bl	639c <FatFile::seekSet(unsigned long)>
    6510:	cmp	r0, #0
    6512:	bne.n	64ea <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
    6514:	b.n	64a8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);

  if (oflag & O_TRUNC) {
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    6516:	bl	6a44 <FatPartition::freeChain(unsigned long)>
    651a:	cmp	r0, #0
    651c:	beq.n	64a8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    651e:	ldrb	r3, [r4, #2]
    6520:	b.n	64e0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x94>
    6522:	nop

00006524 <FatFile::openNext(FatFile*, int)>:
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6524:	ldrb	r3, [r0, #0]
    6526:	cbnz	r3, 6530 <FatFile::openNext(FatFile*, int)+0xc>
    6528:	ldrb	r3, [r1, #0]
    652a:	tst.w	r3, #112	; 0x70
    652e:	bne.n	6534 <FatFile::openNext(FatFile*, int)+0x10>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    6530:	movs	r0, #0
}
    6532:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    6534:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6538:	ldr	r6, [r1, #20]
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    653a:	ands.w	r7, r6, #31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    653e:	sub	sp, #8
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6540:	bne.n	6586 <FatFile::openNext(FatFile*, int)+0x62>
    6542:	mov	r9, r2
    6544:	mov	r5, r1
    6546:	mov	r8, r0
    6548:	mov	sl, r7
    654a:	b.n	6550 <FatFile::openNext(FatFile*, int)+0x2c>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    654c:	movs	r7, #0
    654e:	ldr	r6, [r5, #20]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    6550:	movs	r1, #0
    6552:	mov	r0, r5
    6554:	bl	612c <FatFile::readDirCache(bool)>
    if (!dir) {
    6558:	cbz	r0, 6586 <FatFile::openNext(FatFile*, int)+0x62>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    655a:	ldrb	r3, [r0, #0]
    655c:	cbz	r3, 6586 <FatFile::openNext(FatFile*, int)+0x62>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    655e:	cmp	r3, #46	; 0x2e
    6560:	beq.n	654c <FatFile::openNext(FatFile*, int)+0x28>
    6562:	cmp	r3, #229	; 0xe5
    6564:	beq.n	654c <FatFile::openNext(FatFile*, int)+0x28>
    6566:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    6568:	lsls	r1, r2, #28
    656a:	bpl.n	658e <FatFile::openNext(FatFile*, int)+0x6a>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    656c:	cmp	r2, #15
    656e:	bne.n	654c <FatFile::openNext(FatFile*, int)+0x28>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    6570:	lsls	r2, r3, #25
    6572:	bpl.n	654e <FatFile::openNext(FatFile*, int)+0x2a>
        lfnOrd = ldir->order & 0X1F;
    6574:	and.w	r7, r3, #31
        checksum = ldir->checksum;
    6578:	ldrb.w	sl, [r0, #13]
    657c:	b.n	654e <FatFile::openNext(FatFile*, int)+0x2a>
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    657e:	bl	6c74 <FatFile::lfnChecksum(unsigned char*)>
    6582:	cmp	r0, sl
    6584:	beq.n	6592 <FatFile::openNext(FatFile*, int)+0x6e>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    6586:	movs	r0, #0
}
    6588:	add	sp, #8
    658a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    658e:	cmp	r7, #0
    6590:	bne.n	657e <FatFile::openNext(FatFile*, int)+0x5a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    6592:	str	r7, [sp, #0]
    6594:	mov	r3, r9
    6596:	ubfx	r2, r6, #5, #16
    659a:	mov	r1, r5
    659c:	mov	r0, r8
    659e:	bl	644c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    65a2:	b.n	6588 <FatFile::openNext(FatFile*, int)+0x64>

000065a4 <FatFile::sync()>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    65a4:	ldrb	r3, [r0, #0]
    65a6:	cbz	r3, 65ac <FatFile::sync()+0x8>
    65a8:	b.w	5b6c <FatFile::sync() [clone .part.42]>
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    65ac:	movs	r0, #1
    65ae:	bx	lr

000065b0 <FatFile::truncate()>:
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    65b0:	ldrb	r3, [r0, #2]
    65b2:	lsls	r3, r3, #30
    65b4:	bpl.n	65ec <FatFile::truncate()+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    65b6:	ldr	r3, [r0, #32]
    65b8:	cbz	r3, 65e8 <FatFile::truncate()+0x38>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    65ba:	push	{r4, lr}
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    65bc:	ldr	r1, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    65be:	sub	sp, #8
    65c0:	mov	r4, r0
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    65c2:	cbnz	r1, 6602 <FatFile::truncate()+0x52>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    65c4:	str	r3, [sp, #4]
    m_firstCluster = 0;
    65c6:	str	r1, [r0, #32]
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    65c8:	mov	r1, r3
    65ca:	ldr	r0, [r4, #8]
    65cc:	bl	6a44 <FatPartition::freeChain(unsigned long)>
    65d0:	cbz	r0, 65fe <FatFile::truncate()+0x4e>
    }
  }
  m_fileSize = m_curPosition;

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    65d2:	ldrb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    65d4:	ldrb	r2, [r4, #0]
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    65d6:	ldr	r1, [r4, #20]
    65d8:	str	r1, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    65da:	orn	r3, r3, #127	; 0x7f
    65de:	strb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    65e0:	cbnz	r2, 661e <FatFile::truncate()+0x6e>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    65e2:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    65e4:	add	sp, #8
    65e6:	pop	{r4, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    65e8:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    65ea:	bx	lr
    goto fail;
  }
  return true;

 fail:
  return false;
    65ec:	movs	r0, #0
}
    65ee:	bx	lr
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    65f0:	mvn.w	r2, #4026531840	; 0xf0000000
    65f4:	ldr	r1, [r4, #16]
    65f6:	ldr	r0, [r4, #8]
    65f8:	bl	68b0 <FatPartition::fatPut(unsigned long, unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    65fc:	cbnz	r0, 6616 <FatFile::truncate()+0x66>
    goto fail;
  }
  return true;

 fail:
  return false;
    65fe:	movs	r0, #0
    6600:	b.n	65e4 <FatFile::truncate()+0x34>
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    toFree = 0;
    6602:	add	r2, sp, #8
    6604:	movs	r3, #0
    6606:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    660a:	ldr	r0, [r0, #8]
    660c:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6610:	cmp	r0, #0
    6612:	blt.n	65fe <FatFile::truncate()+0x4e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    6614:	bne.n	65f0 <FatFile::truncate()+0x40>
    }
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    6616:	ldr	r3, [sp, #4]
    6618:	cmp	r3, #0
    661a:	beq.n	65d2 <FatFile::truncate()+0x22>
    661c:	b.n	65c8 <FatFile::truncate()+0x18>
    661e:	mov	r0, r4
    6620:	bl	5b6c <FatFile::sync() [clone .part.42]>
    6624:	b.n	65e4 <FatFile::truncate()+0x34>
    6626:	nop

00006628 <FatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6628:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    662c:	ldrb	r3, [r0, #2]
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    662e:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6630:	mov	r4, r0
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6632:	bmi.n	6644 <FatFile::write(void const*, unsigned int)+0x1c>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    6634:	ldrb	r3, [r4, #1]
    6636:	orr.w	r3, r3, #1
    663a:	strb	r3, [r4, #1]
  return -1;
    663c:	mov.w	r0, #4294967295
    6640:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6644:	mov	r8, r2
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    6646:	lsls	r2, r3, #28
    6648:	mov	r7, r1
    664a:	bmi.w	67ea <FatFile::write(void const*, unsigned int)+0x1c2>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    664e:	ldr	r2, [r4, #20]
    6650:	mvns	r3, r2
    6652:	cmp	r8, r3
    6654:	bhi.n	6634 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    6656:	cmp.w	r8, #0
    665a:	beq.w	680c <FatFile::write(void const*, unsigned int)+0x1e4>
    665e:	mov	r6, r8
    6660:	b.n	66d8 <FatFile::write(void const*, unsigned int)+0xb0>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6662:	cmp.w	r9, #0
    6666:	bne.n	671a <FatFile::write(void const*, unsigned int)+0xf2>
      // start of new cluster
      if (m_curCluster != 0) {
    6668:	ldr	r1, [r4, #16]
    666a:	cmp	r1, #0
    666c:	beq.w	6796 <FatFile::write(void const*, unsigned int)+0x16e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    6670:	ldrb	r3, [r4, #2]
    6672:	lsls	r3, r3, #25
    6674:	bpl.w	67aa <FatFile::write(void const*, unsigned int)+0x182>
    6678:	ldr	r3, [r4, #28]
    667a:	cmp	r3, r2
    667c:	bls.w	67aa <FatFile::write(void const*, unsigned int)+0x182>
          m_curCluster++;
    6680:	adds	r3, r1, #1
    6682:	str	r3, [r4, #16]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    6684:	ldrb	r2, [r0, #6]
    6686:	ldr	r3, [r0, #20]
    6688:	subs	r1, #1
    668a:	lsls	r1, r2
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    668c:	cmp.w	r6, #512	; 0x200
    6690:	add	r1, r3
    6692:	bcs.n	6736 <FatFile::write(void const*, unsigned int)+0x10e>
    6694:	cmp.w	r6, #512	; 0x200
    6698:	mov	r5, r6
    669a:	it	cs
    669c:	movcs.w	r5, #512	; 0x200
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    66a0:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    66a2:	tst.w	r3, #32
    66a6:	ite	eq
    66a8:	moveq	r2, #1
    66aa:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    66ac:	adds	r0, #36	; 0x24
    66ae:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    66b2:	cmp	r0, #0
    66b4:	beq.n	6634 <FatFile::write(void const*, unsigned int)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    66b6:	add	r0, r9
    66b8:	mov	r2, r5
    66ba:	mov	r1, r7
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    66bc:	add	r9, r5
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    66be:	bl	9220 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    66c2:	cmp.w	r9, #512	; 0x200
    66c6:	beq.w	67da <FatFile::write(void const*, unsigned int)+0x1b2>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    66ca:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    66cc:	subs	r6, r6, r5
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    66ce:	add	r2, r5
    src += n;
    66d0:	add	r7, r5
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    66d2:	str	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    66d4:	beq.w	680c <FatFile::write(void const*, unsigned int)+0x1e4>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    66d8:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    66da:	ldrb	r3, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    66dc:	ands.w	r5, r3, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    66e0:	ubfx	r9, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    66e4:	beq.n	6662 <FatFile::write(void const*, unsigned int)+0x3a>
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;
    66e6:	ldr	r3, [r4, #16]
    66e8:	ldrb	r1, [r0, #6]
    66ea:	ldr	r2, [r0, #20]
    66ec:	subs	r3, #2
    66ee:	lsl.w	r1, r3, r1
    66f2:	add	r1, r2
    66f4:	add	r1, r5

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    66f6:	cmp.w	r9, #0
    66fa:	bne.n	6728 <FatFile::write(void const*, unsigned int)+0x100>
    66fc:	cmp.w	r6, #512	; 0x200
    6700:	bcs.n	6736 <FatFile::write(void const*, unsigned int)+0x10e>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    6702:	ldr	r2, [r4, #20]
    6704:	ldr	r3, [r4, #28]
    6706:	cmp.w	r6, #512	; 0x200
    670a:	mov	r5, r6
    670c:	it	cs
    670e:	movcs.w	r5, #512	; 0x200
    6712:	cmp	r2, r3
    6714:	bcc.n	66a0 <FatFile::write(void const*, unsigned int)+0x78>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6716:	movs	r2, #5
    6718:	b.n	66ac <FatFile::write(void const*, unsigned int)+0x84>
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    671a:	ldr	r3, [r4, #16]
    671c:	ldrb	r1, [r0, #6]
    671e:	ldr	r2, [r0, #20]
    6720:	subs	r3, #2
    6722:	lsl.w	r1, r3, r1
    6726:	add	r1, r2
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    6728:	rsb	r5, r9, #512	; 0x200
    672c:	cmp	r5, r6
    672e:	it	cs
    6730:	movcs	r5, r6
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    6732:	movs	r2, #1
    6734:	b.n	66ac <FatFile::write(void const*, unsigned int)+0x84>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    6736:	cmp.w	r6, #1024	; 0x400
    673a:	bcc.n	677a <FatFile::write(void const*, unsigned int)+0x152>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    673c:	ldrb	r3, [r0, #4]
    673e:	ldr.w	lr, [r0, #48]	; 0x30
    6742:	subs	r3, r3, r5
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    6744:	lsrs	r2, r6, #9
    6746:	cmp	r3, r2
    6748:	it	cs
    674a:	movcs	r3, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    674c:	cmp	lr, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    674e:	mov.w	r5, r3, lsl #9
    6752:	bcc.n	6768 <FatFile::write(void const*, unsigned int)+0x140>
    6754:	adds	r2, r3, r1
    6756:	cmp	lr, r2
    6758:	bcs.n	6768 <FatFile::write(void const*, unsigned int)+0x140>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    675a:	mov.w	lr, #0
    m_sector = 0XFFFFFFFF;
    675e:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6762:	strb.w	lr, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    6766:	str	r2, [r0, #48]	; 0x30
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    6768:	ldr	r0, [r0, #40]	; 0x28
    676a:	ldr	r2, [r0, #0]
    676c:	ldr.w	r9, [r2, #32]
    6770:	mov	r2, r7
    6772:	blx	r9
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    6774:	cmp	r0, #0
    6776:	bne.n	66ca <FatFile::write(void const*, unsigned int)+0xa2>
    6778:	b.n	6634 <FatFile::write(void const*, unsigned int)+0xc>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    677a:	ldr	r3, [r0, #48]	; 0x30
    677c:	cmp	r3, r1
    677e:	beq.n	67cc <FatFile::write(void const*, unsigned int)+0x1a4>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    6780:	ldr	r0, [r0, #40]	; 0x28
    6782:	ldr	r3, [r0, #0]
    6784:	mov	r2, r7
    6786:	ldr	r3, [r3, #28]
    6788:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    678a:	cmp	r0, #0
    678c:	beq.w	6634 <FatFile::write(void const*, unsigned int)+0xc>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    6790:	mov.w	r5, #512	; 0x200
    6794:	b.n	66ca <FatFile::write(void const*, unsigned int)+0xa2>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    6796:	ldr	r3, [r4, #32]
    6798:	cbz	r3, 67f8 <FatFile::write(void const*, unsigned int)+0x1d0>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    679a:	str	r3, [r4, #16]
    679c:	ldrb	r1, [r0, #6]
    679e:	ldr	r2, [r0, #20]
    67a0:	subs	r3, #2
    67a2:	lsl.w	r1, r3, r1
    67a6:	add	r1, r2
    67a8:	b.n	66fc <FatFile::write(void const*, unsigned int)+0xd4>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    67aa:	add.w	r2, r4, #16
    67ae:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    67b2:	cmp	r0, #0
    67b4:	blt.w	6634 <FatFile::write(void const*, unsigned int)+0xc>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    67b8:	bne.n	67c6 <FatFile::write(void const*, unsigned int)+0x19e>
          // add cluster if at end of chain
          if (!addCluster()) {
    67ba:	mov	r0, r4
    67bc:	bl	5a80 <FatFile::addCluster()>
    67c0:	cmp	r0, #0
    67c2:	beq.w	6634 <FatFile::write(void const*, unsigned int)+0xc>
    67c6:	ldr	r3, [r4, #16]
    67c8:	ldr	r0, [r4, #8]
    67ca:	b.n	679c <FatFile::write(void const*, unsigned int)+0x174>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    67cc:	movs	r2, #0
    m_sector = 0XFFFFFFFF;
    67ce:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    67d2:	strb.w	r2, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    67d6:	str	r3, [r0, #48]	; 0x30
    67d8:	b.n	6780 <FatFile::write(void const*, unsigned int)+0x158>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    67da:	ldr	r0, [r4, #8]
    67dc:	adds	r0, #36	; 0x24
    67de:	bl	414c <FsCache::sync()>
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->cacheSyncData()) {
    67e2:	cmp	r0, #0
    67e4:	bne.w	66ca <FatFile::write(void const*, unsigned int)+0xa2>
    67e8:	b.n	6634 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    67ea:	ldr	r1, [r0, #28]
    67ec:	bl	639c <FatFile::seekSet(unsigned long)>
    67f0:	cmp	r0, #0
    67f2:	beq.w	6634 <FatFile::write(void const*, unsigned int)+0xc>
    67f6:	b.n	664e <FatFile::write(void const*, unsigned int)+0x26>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    67f8:	mov	r0, r4
    67fa:	bl	5a80 <FatFile::addCluster()>
    67fe:	cmp	r0, #0
    6800:	beq.w	6634 <FatFile::write(void const*, unsigned int)+0xc>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    6804:	ldr	r3, [r4, #16]
    6806:	str	r3, [r4, #32]
    6808:	ldr	r0, [r4, #8]
    680a:	b.n	679c <FatFile::write(void const*, unsigned int)+0x174>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    680c:	ldr	r3, [r4, #28]
    680e:	cmp	r3, r2
    6810:	bcc.n	6826 <FatFile::write(void const*, unsigned int)+0x1fe>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    6812:	ldr	r3, [pc, #40]	; (683c <FatFile::write(void const*, unsigned int)+0x214>)
    6814:	ldr	r3, [r3, #0]
    6816:	cbz	r3, 6836 <FatFile::write(void const*, unsigned int)+0x20e>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6818:	ldrb	r3, [r4, #2]
    681a:	orn	r3, r3, #127	; 0x7f
    681e:	strb	r3, [r4, #2]
    6820:	mov	r0, r8
    6822:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6826:	ldrb	r3, [r4, #2]
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    6828:	str	r2, [r4, #28]
    m_flags |= FILE_FLAG_DIR_DIRTY;
    682a:	orn	r3, r3, #127	; 0x7f
    682e:	strb	r3, [r4, #2]
    6830:	mov	r0, r8
    6832:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6836:	mov	r0, r8
    6838:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    683c:	.word	0x20019b54

00006840 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6840:	cmp	r1, #1
    6842:	bls.n	68a8 <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
    6844:	ldr	r3, [r0, #28]
    6846:	cmp	r1, r3
    6848:	bhi.n	68a8 <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    684a:	push	{r4, r5, r6, lr}
    684c:	ldrb	r3, [r0, #7]
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    684e:	cmp	r3, #32
    6850:	mov	r6, r2
    6852:	mov	r5, r0
    6854:	mov	r4, r1
    6856:	beq.n	688a <FatPartition::fatGet(unsigned long, unsigned long*)+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    6858:	cmp	r3, #16
    685a:	bne.n	6884 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    685c:	ldr	r3, [r0, #24]
    685e:	ubfx	r1, r1, #8, #8
    6862:	add	r1, r3
    6864:	movs	r2, #2
    6866:	add.w	r0, r0, #564	; 0x234
    686a:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    686e:	cbz	r0, 6884 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6870:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    6872:	ldrh.w	r3, [r0, r1, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    6876:	ldr	r2, [r5, #28]
    6878:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    687a:	itte	ls
    687c:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    687e:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    6880:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    6882:	pop	{r4, r5, r6, pc}
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6884:	mov.w	r0, #4294967295
    6888:	pop	{r4, r5, r6, pc}
    688a:	ldr	r1, [r0, #24]
    688c:	movs	r2, #2
    688e:	add.w	r1, r1, r4, lsr #7
    6892:	add.w	r0, r0, #564	; 0x234
    6896:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    689a:	cmp	r0, #0
    689c:	beq.n	6884 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    689e:	and.w	r1, r4, #127	; 0x7f
    68a2:	ldr.w	r3, [r0, r1, lsl #2]
    68a6:	b.n	6876 <FatPartition::fatGet(unsigned long, unsigned long*)+0x36>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    68a8:	mov.w	r0, #4294967295
}
    68ac:	bx	lr
    68ae:	nop

000068b0 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    68b0:	cmp	r1, #1
    68b2:	bls.n	68f0 <FatPartition::fatPut(unsigned long, unsigned long)+0x40>
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    68b4:	push	{r3, r4, r5, lr}
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    68b6:	ldr	r3, [r0, #28]
    68b8:	cmp	r1, r3
    68ba:	bhi.n	68ca <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
    68bc:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    68be:	cmp	r3, #32
    68c0:	mov	r5, r2
    68c2:	mov	r4, r1
    68c4:	beq.n	68f4 <FatPartition::fatPut(unsigned long, unsigned long)+0x44>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    68c6:	cmp	r3, #16
    68c8:	beq.n	68ce <FatPartition::fatPut(unsigned long, unsigned long)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    68ca:	movs	r0, #0
    68cc:	pop	{r3, r4, r5, pc}
    68ce:	ldr	r3, [r0, #24]
    68d0:	ubfx	r1, r1, #8, #8
    68d4:	add	r1, r3
    68d6:	add.w	r0, r0, #564	; 0x234
    68da:	movs	r2, #3
    68dc:	bl	40ec <FsCache::get(unsigned long, unsigned char)>

  if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    68e0:	mov	r3, r0
    68e2:	cmp	r0, #0
    68e4:	beq.n	68ca <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    68e6:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    68e8:	movs	r0, #1
    68ea:	strh.w	r5, [r3, r1, lsl #1]
    goto fail;
  }

 fail:
  return false;
}
    68ee:	pop	{r3, r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    68f0:	movs	r0, #0
}
    68f2:	bx	lr
    68f4:	ldr	r1, [r0, #24]
    68f6:	movs	r2, #3
    68f8:	add.w	r0, r0, #564	; 0x234
    68fc:	add.w	r1, r1, r4, lsr #7
    6900:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6904:	mov	r3, r0
    6906:	cmp	r0, #0
    6908:	beq.n	68ca <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    690a:	and.w	r1, r4, #127	; 0x7f
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
    690e:	movs	r0, #1
    6910:	str.w	r5, [r3, r1, lsl #2]
    6914:	pop	{r3, r4, r5, pc}
    6916:	nop

00006918 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6918:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    691c:	ldr	r4, [r0, #12]
    691e:	cmp	r4, r1
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6920:	sub	sp, #8
    6922:	mov	r5, r0
    6924:	mov	r7, r1
    6926:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6928:	itte	cc
    692a:	movcc	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    692c:	movcc	r6, #0
  } else {
    find = m_allocSearchStart;
    setStart = true;
    692e:	movcs	r6, #1
    6930:	ldr	r3, [r5, #28]
  }
  while (1) {
    find++;
    6932:	adds	r4, #1
    if (find > m_lastCluster) {
    6934:	cmp	r4, r3
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6936:	add	r2, sp, #4
    6938:	mov	r0, r5
    693a:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    693c:	bls.n	6952 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x3a>
      if (setStart) {
    693e:	cbnz	r6, 6990 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    6940:	ldr	r4, [r5, #12]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6942:	adds	r4, #1
    if (find > m_lastCluster) {
    6944:	cmp	r4, r3
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
      setStart = true;
    6946:	mov.w	r6, #1
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    694a:	add	r2, sp, #4
    694c:	mov	r0, r5
    694e:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    6950:	bhi.n	693e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x26>
      }
      find = m_allocSearchStart;
      setStart = true;
      continue;
    }
    if (find == current) {
    6952:	cmp	r7, r4
    6954:	beq.n	6990 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6956:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    695a:	cmp	r0, #0
    695c:	blt.n	6990 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    695e:	beq.n	6930 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
    6960:	ldr	r3, [sp, #4]
    6962:	cmp	r3, #0
    6964:	bne.n	6930 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
      break;
    }
  }
  if (setStart) {
    6966:	cbz	r6, 696a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
    m_allocSearchStart = find;
    6968:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    696a:	mvn.w	r2, #4026531840	; 0xf0000000
    696e:	mov	r1, r4
    6970:	mov	r0, r5
    6972:	bl	68b0 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    6976:	mov	r6, r0
    6978:	cbz	r0, 6990 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    697a:	cbnz	r7, 6982 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x6a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    697c:	str.w	r4, [r8]
  return true;
    6980:	b.n	6992 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x7a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
    6982:	mov	r1, r7
    6984:	mov	r0, r5
    6986:	mov	r2, r4
    6988:	bl	68b0 <FatPartition::fatPut(unsigned long, unsigned long)>
    698c:	cmp	r0, #0
    698e:	bne.n	697c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    6990:	movs	r6, #0
}
    6992:	mov	r0, r6
    6994:	add	sp, #8
    6996:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    699a:	nop

0000699c <FatPartition::allocContiguous(unsigned long, unsigned long*)>:
//------------------------------------------------------------------------------
// find a contiguous group of clusters
bool FatPartition::allocContiguous(uint32_t count, uint32_t* firstCluster) {
    699c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  // start of group
  uint32_t bgnCluster;
  // end of group
  uint32_t endCluster;
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;
    69a0:	ldr	r4, [r0, #12]

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69a2:	ldr	r3, [r0, #28]
  // start of group
  uint32_t bgnCluster;
  // end of group
  uint32_t endCluster;
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;
    69a4:	adds	r7, r4, #1

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69a6:	cmp	r7, r3
 fail:
  return false;
}
//------------------------------------------------------------------------------
// find a contiguous group of clusters
bool FatPartition::allocContiguous(uint32_t count, uint32_t* firstCluster) {
    69a8:	sub	sp, #8
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69aa:	bhi.n	69fa <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
    69ac:	mov	sl, r2
    69ae:	mov	r9, r1
    69b0:	mov	r6, r0
    69b2:	adds	r4, #2
    69b4:	mov.w	r8, #1
    69b8:	b.n	69ce <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x32>
      if (bgnCluster != endCluster) {
        setStart = false;
      }
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
    69ba:	subs	r2, r4, r7
    69bc:	mov	r3, r4
    int8_t fg = fatGet(endCluster, &f);
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (f || fg == 0) {
    69be:	cbz	r0, 69e4 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x48>
      if (bgnCluster != endCluster) {
        setStart = false;
      }
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
    69c0:	cmp	r2, r9
    69c2:	beq.n	6a04 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x68>
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69c4:	ldr	r2, [r6, #28]
    69c6:	cmp	r3, r2
    69c8:	add.w	r4, r4, #1
    69cc:	bhi.n	69fa <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
    69ce:	subs	r5, r4, #1
      // Can't find space.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(endCluster, &f);
    69d0:	mov	r1, r5
    69d2:	add	r2, sp, #4
    69d4:	mov	r0, r6
    69d6:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    69da:	cmp	r0, #0
    69dc:	blt.n	69fa <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (f || fg == 0) {
    69de:	ldr	r3, [sp, #4]
    69e0:	cmp	r3, #0
    69e2:	beq.n	69ba <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x1e>
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69e4:	ldr	r2, [r6, #28]
      // don't update search start if unallocated clusters before endCluster.
      if (bgnCluster != endCluster) {
        setStart = false;
      }
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    69e6:	mov	r3, r4
      goto fail;
    }
    if (f || fg == 0) {
      // don't update search start if unallocated clusters before endCluster.
      if (bgnCluster != endCluster) {
        setStart = false;
    69e8:	cmp	r7, r5
    69ea:	it	ne
    69ec:	movne.w	r8, #0
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69f0:	cmp	r3, r2
      // don't update search start if unallocated clusters before endCluster.
      if (bgnCluster != endCluster) {
        setStart = false;
      }
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    69f2:	mov	r7, r4
    69f4:	add.w	r4, r4, #1
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    69f8:	bls.n	69ce <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x32>
  // return first cluster number to caller
  *firstCluster = bgnCluster;
  return true;

 fail:
  return false;
    69fa:	movs	r4, #0
}
    69fc:	mov	r0, r4
    69fe:	add	sp, #8
    6a00:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      break;
    }
    endCluster++;
  }
  // Remember possible next free cluster.
  if (setStart) {
    6a04:	cmp.w	r8, #0
    6a08:	beq.n	6a0c <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x70>
    m_allocSearchStart = endCluster;
    6a0a:	str	r5, [r6, #12]
    6a0c:	mvn.w	r2, #4026531840	; 0xf0000000
    6a10:	mov	r1, r5
    6a12:	mov	r0, r6
    6a14:	bl	68b0 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) {
    6a18:	mov	r4, r0
    6a1a:	cmp	r0, #0
    6a1c:	beq.n	69fa <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // link clusters
  while (endCluster > bgnCluster) {
    6a1e:	cmp	r7, r5
    6a20:	bcc.n	6a28 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x8c>
    6a22:	b.n	6a3e <FatPartition::allocContiguous(unsigned long, unsigned long*)+0xa2>
    6a24:	cmp	r5, r7
    6a26:	bls.n	6a3e <FatPartition::allocContiguous(unsigned long, unsigned long*)+0xa2>
    if (!fatPut(endCluster - 1, endCluster)) {
    6a28:	add.w	r8, r5, #4294967295
    6a2c:	mov	r2, r5
    6a2e:	mov	r1, r8
    6a30:	mov	r0, r6
    6a32:	bl	68b0 <FatPartition::fatPut(unsigned long, unsigned long)>
    6a36:	mov	r5, r8
    6a38:	cmp	r0, #0
    6a3a:	bne.n	6a24 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x88>
    6a3c:	b.n	69fa <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
  }
  // Maintain count of free clusters.
  updateFreeClusterCount(-count);

  // return first cluster number to caller
  *firstCluster = bgnCluster;
    6a3e:	str.w	r7, [sl]
  return true;
    6a42:	b.n	69fc <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x60>

00006a44 <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    6a44:	push	{r4, r5, r6, lr}
    6a46:	mov	r5, r0
    6a48:	sub	sp, #8
    6a4a:	mov	r4, r1
    6a4c:	b.n	6a64 <FatPartition::freeChain(unsigned long)+0x20>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6a4e:	bl	68b0 <FatPartition::fatPut(unsigned long, unsigned long)>
    6a52:	cbz	r0, 6a7a <FatPartition::freeChain(unsigned long)+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    6a54:	ldr	r3, [r5, #12]
    6a56:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6a58:	itt	cc
    6a5a:	addcc.w	r4, r4, #4294967295
    6a5e:	strcc	r4, [r5, #12]
    }
    cluster = next;
    6a60:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    6a62:	cbz	r6, 6a7c <FatPartition::freeChain(unsigned long)+0x38>
    fg = fatGet(cluster, &next);
    6a64:	add	r2, sp, #4
    6a66:	mov	r1, r4
    6a68:	mov	r0, r5
    6a6a:	bl	6840 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6a6e:	subs	r6, r0, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6a70:	mov	r1, r4
    6a72:	mov.w	r2, #0
    6a76:	mov	r0, r5
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    if (fg < 0) {
    6a78:	bge.n	6a4e <FatPartition::freeChain(unsigned long)+0xa>
  } while (fg);

  return true;

 fail:
  return false;
    6a7a:	movs	r0, #0
}
    6a7c:	add	sp, #8
    6a7e:	pop	{r4, r5, r6, pc}

00006a80 <FatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6a80:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6a84:	ldrb	r3, [r0, #7]
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    6a86:	ldr	r2, [r0, #28]
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    6a88:	cmp	r3, #16
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    6a8a:	add.w	r8, r2, #1
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    6a8e:	beq.n	6a9c <FatPartition::freeClusterCount()+0x1c>
    6a90:	cmp	r3, #32
    6a92:	beq.n	6a9c <FatPartition::freeClusterCount()+0x1c>
  }
  setFreeClusterCount(free);
  return free;

 fail:
  return -1;
    6a94:	mov.w	r0, #4294967295
    6a98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    6a9c:	ldr	r5, [r0, #24]
    while (todo) {
    6a9e:	cmp.w	r8, #0
    6aa2:	beq.n	6b22 <FatPartition::freeClusterCount()+0xa2>
    6aa4:	mov	r6, r0
    6aa6:	add.w	r7, r0, #564	; 0x234
    6aaa:	movs	r4, #0
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    6aac:	mov	r1, r5
    6aae:	movs	r2, #2
    6ab0:	mov	r0, r7
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
    6ab2:	adds	r5, #1
    6ab4:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      if (!pc) {
    6ab8:	cmp	r0, #0
    6aba:	beq.n	6a94 <FatPartition::freeClusterCount()+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    6abc:	ldrb	r3, [r6, #7]
    6abe:	cmp	r3, #16
    6ac0:	beq.n	6af0 <FatPartition::freeClusterCount()+0x70>
      if (todo < n) {
    6ac2:	cmp.w	r8, #127	; 0x7f
    6ac6:	bhi.n	6b1a <FatPartition::freeClusterCount()+0x9a>
        n = todo;
    6ac8:	uxth.w	r1, r8
    6acc:	mov	lr, r8
    6ace:	subs	r1, #1
    6ad0:	uxth	r1, r1
    6ad2:	add.w	r1, r0, r1, lsl #2
    6ad6:	subs	r3, r0, #4
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat32[i] == 0) {
    6ad8:	ldr.w	r2, [r3, #4]!
    6adc:	cbnz	r2, 6ae0 <FatPartition::freeClusterCount()+0x60>
            free++;
    6ade:	adds	r4, #1
          if (pc->fat16[i] == 0) {
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
    6ae0:	cmp	r3, r1
    6ae2:	bne.n	6ad8 <FatPartition::freeClusterCount()+0x58>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    6ae4:	subs.w	r8, r8, lr
    6ae8:	bne.n	6aac <FatPartition::freeClusterCount()+0x2c>
    6aea:	mov	r0, r4
    6aec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    6af0:	cmp.w	r8, #255	; 0xff
    6af4:	bls.n	6b28 <FatPartition::freeClusterCount()+0xa8>
    6af6:	mov.w	lr, #256	; 0x100
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    6afa:	mov	r3, lr
    6afc:	subs	r1, r3, #1
    6afe:	uxth	r1, r1
    6b00:	add.w	r1, r0, r1, lsl #1
    6b04:	subs	r3, r0, #2
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat16[i] == 0) {
    6b06:	ldrh.w	r2, [r3, #2]!
    6b0a:	cbnz	r2, 6b0e <FatPartition::freeClusterCount()+0x8e>
            free++;
    6b0c:	adds	r4, #1
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
    6b0e:	cmp	r1, r3
    6b10:	bne.n	6b06 <FatPartition::freeClusterCount()+0x86>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    6b12:	subs.w	r8, r8, lr
    6b16:	bne.n	6aac <FatPartition::freeClusterCount()+0x2c>
    6b18:	b.n	6aea <FatPartition::freeClusterCount()+0x6a>
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    6b1a:	mov.w	lr, #128	; 0x80
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    6b1e:	mov	r1, lr
    6b20:	b.n	6ace <FatPartition::freeClusterCount()+0x4e>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    6b22:	mov	r0, r8
    // invalid FAT type
    DBG_FAIL_MACRO;
    goto fail;
  }
  setFreeClusterCount(free);
  return free;
    6b24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
    6b28:	uxth.w	r3, r8
    6b2c:	mov	lr, r8
    6b2e:	b.n	6afc <FatPartition::freeClusterCount()+0x7c>

00006b30 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:

 fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6b30:	push	{r3, r4, r5, r6, r7, lr}
    6b32:	mov	r4, r0
  m_blockDev = dev;
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    6b34:	movs	r3, #0
  m_allocSearchStart = 1;
    6b36:	movs	r5, #1
    6b38:	mov.w	r0, #4294967295
    6b3c:	str	r5, [r4, #12]
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    6b3e:	str	r1, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6b40:	str	r1, [r4, #40]	; 0x28
    6b42:	str.w	r1, [r4, #568]	; 0x238
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    6b46:	strb	r3, [r4, #7]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6b48:	strb.w	r3, [r4, #36]	; 0x24
    6b4c:	strb.w	r3, [r4, #564]	; 0x234
    m_sector = 0XFFFFFFFF;
    6b50:	str	r0, [r4, #48]	; 0x30
    6b52:	str.w	r0, [r4, #576]	; 0x240
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    6b56:	mov	r5, r2
    6b58:	cbz	r2, 6b92 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x62>
    if (part > 4) {
    6b5a:	cmp	r2, #4
    6b5c:	bls.n	6b62 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x32>
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6b5e:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6b60:	pop	{r3, r4, r5, r6, r7, pc}
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6b62:	add.w	r6, r4, #36	; 0x24
    6b66:	mov	r2, r3
    6b68:	mov	r1, r3
    6b6a:	mov	r0, r6
    6b6c:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    mbr = reinterpret_cast<MbrSector_t*>
          (cacheFetchData(0, FsCache::CACHE_FOR_READ));
    MbrPart_t* mp = mbr->part + part - 1;
    6b70:	add.w	r5, r5, #268435456	; 0x10000000
    6b74:	subs	r5, #1
    6b76:	lsls	r5, r5, #4
    6b78:	add.w	r3, r0, #446	; 0x1be
    6b7c:	adds	r2, r3, r5

    if (!mbr || mp->type == 0 || (mp->boot != 0 && mp->boot != 0X80)) {
    6b7e:	cmp	r0, #0
    6b80:	beq.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    6b82:	ldrb	r1, [r2, #4]
    6b84:	cmp	r1, #0
    6b86:	beq.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    6b88:	ldrb	r3, [r3, r5]
    6b8a:	lsls	r3, r3, #25
    6b8c:	bne.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6b8e:	ldr	r5, [r2, #8]
    6b90:	b.n	6b96 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x66>
    6b92:	add.w	r6, r4, #36	; 0x24
    6b96:	mov	r0, r6
    6b98:	movs	r2, #0
    6b9a:	mov	r1, r5
    6b9c:	bl	40ec <FsCache::get(unsigned long, unsigned char)>
    volumeStartSector = getLe32(mp->relativeSectors);
  }
  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    6ba0:	cmp	r0, #0
    6ba2:	beq.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    6ba4:	ldrb	r3, [r0, #16]
    6ba6:	cmp	r3, #2
    6ba8:	bne.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    6baa:	ldrh.w	r3, [r0, #11]
    6bae:	cmp.w	r3, #512	; 0x200
    6bb2:	bne.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6bb4:	ldrb	r6, [r0, #13]
    6bb6:	strb	r6, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6bb8:	subs	r3, r6, #1
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6bba:	movs	r2, #0
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6bbc:	cmp	r6, #1
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6bbe:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6bc0:	strb	r2, [r4, #6]
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6bc2:	beq.n	6be4 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb4>
    6bc4:	movs	r2, #1
    6bc6:	mov	r1, r2
    6bc8:	b.n	6bcc <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x9c>
    6bca:	mov	r2, r3
    6bcc:	lsls	r1, r1, #1
    6bce:	uxtb	r1, r1
    6bd0:	adds	r3, r2, #1
    6bd2:	cmp	r6, r1
    6bd4:	uxtb	r3, r3
    6bd6:	beq.n	6be2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb2>
    if (tmp == 0) {
    6bd8:	cmp	r3, #9
    6bda:	bne.n	6bca <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x9a>
    6bdc:	strb	r2, [r4, #6]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6bde:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6be0:	pop	{r3, r4, r5, r6, r7, pc}
    6be2:	strb	r2, [r4, #6]
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6be4:	ldrh	r6, [r0, #22]
    6be6:	str	r6, [r4, #16]
  if (m_sectorsPerFat == 0) {
    6be8:	cbnz	r6, 6bee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xbe>
    6bea:	ldr	r6, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    6bec:	str	r6, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6bee:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6bf0:	ldrh.w	r3, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6bf4:	strh	r3, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6bf6:	add	r1, r5
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6bf8:	lsls	r3, r3, #5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6bfa:	add.w	r7, r1, r6, lsl #1
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6bfe:	addw	r3, r3, #511	; 0x1ff
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6c02:	str	r1, [r4, #24]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6c04:	ldrh.w	r1, [r0, #19]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6c08:	str	r7, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6c0a:	add.w	r3, r7, r3, asr #9
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6c0e:	str	r3, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6c10:	cbnz	r1, 6c14 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe4>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6c12:	ldr	r1, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6c14:	subs	r5, r5, r3
    6c16:	add	r5, r1

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    6c18:	lsr.w	r2, r5, r2
  m_lastCluster = clusterCount + 1;

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6c1c:	movw	r3, #4084	; 0xff4
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    6c20:	adds	r1, r2, #1

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6c22:	cmp	r2, r3
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    6c24:	str	r1, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6c26:	bls.n	6c44 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x114>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6c28:	movw	r3, #65524	; 0xfff4
    6c2c:	cmp	r2, r3
    6c2e:	ittet	hi
    6c30:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    6c32:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6c34:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6c36:	movhi	r3, #32
    6c38:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    6c3a:	str	r6, [r4, #44]	; 0x2c
    6c3c:	str.w	r6, [r4, #572]	; 0x23c
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    6c40:	movs	r0, #1
    6c42:	pop	{r3, r4, r5, r6, r7, pc}

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    6c44:	movs	r3, #12
    6c46:	strb	r3, [r4, #7]
    6c48:	b.n	6b5e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    6c4a:	nop

00006c4c <lfnGetChar(DirLfn_t*, unsigned char)>:
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    6c4c:	cmp	r1, #4
    6c4e:	bls.n	6c6a <lfnGetChar(DirLfn_t*, unsigned char)+0x1e>
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    6c50:	cmp	r1, #10
    6c52:	bls.n	6c62 <lfnGetChar(DirLfn_t*, unsigned char)+0x16>
    return getLe16(ldir->unicode2 + 2*i - 10);
  } else if (i < 13) {
    6c54:	cmp	r1, #12
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6c56:	itte	ls
    6c58:	addls.w	r1, r0, r1, lsl #1
    6c5c:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  return 0;
    6c5e:	movhi	r0, #0
}
    6c60:	bx	lr
    6c62:	add.w	r1, r0, r1, lsl #1
    6c66:	ldrh	r0, [r1, #4]
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    return getLe16(ldir->unicode2 + 2*i - 10);
    6c68:	bx	lr
    6c6a:	add.w	r1, r0, r1, lsl #1
    6c6e:	ldrh.w	r0, [r1, #1]
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
    6c72:	bx	lr

00006c74 <FatFile::lfnChecksum(unsigned char*)>:
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
    6c74:	push	{r4}
    6c76:	subs	r2, r0, #1
    6c78:	add.w	r4, r0, #10
  uint8_t sum = 0;
    6c7c:	movs	r0, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    6c7e:	ldrb.w	r1, [r2, #1]!
    6c82:	lsrs	r3, r0, #1
    6c84:	orr.w	r0, r3, r0, lsl #7
    6c88:	uxtab	r0, r1, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    6c8c:	cmp	r4, r2
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    6c8e:	uxtb	r0, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    6c90:	bne.n	6c7e <FatFile::lfnChecksum(unsigned char*)+0xa>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
    6c92:	ldr.w	r4, [sp], #4
    6c96:	bx	lr

00006c98 <FatFile::openCluster(FatFile*)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    6c98:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    6c9a:	ldr	r3, [r1, #12]
    6c9c:	cbz	r3, 6cbc <FatFile::openCluster(FatFile*)+0x24>
    6c9e:	mov	r5, r0
    6ca0:	mov	r4, r1
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
    6ca2:	movs	r2, #36	; 0x24
    6ca4:	movs	r1, #0
    6ca6:	bl	c49c <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    6caa:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    6cac:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    6cae:	strb	r3, [r5, #0]
  m_flags = FILE_FLAG_READ;
    6cb0:	strb	r0, [r5, #2]
  m_vol = file->m_vol;
    6cb2:	ldr	r2, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    6cb4:	ldr	r3, [r4, #12]
    6cb6:	str	r3, [r5, #32]
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
    6cb8:	str	r2, [r5, #8]
  m_firstCluster = file->m_dirCluster;
  return true;
}
    6cba:	pop	{r3, r4, r5, pc}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    6cbc:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    6cbe:	ldmia.w	sp!, {r3, r4, r5, lr}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    6cc2:	b.w	5f04 <FatFile::openRoot(FatVolume*)>
    6cc6:	nop

00006cc8 <FatFile::getName(char*, unsigned int)>:
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    6cc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ccc:	sub	sp, #52	; 0x34
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    6cce:	ldrb	r3, [r0, #0]
    6cd0:	movs	r4, #0
    6cd2:	strb.w	r4, [sp, #12]
    6cd6:	strb.w	r4, [sp, #13]
    6cda:	strb.w	r4, [sp, #14]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    6cde:	mov	r8, r1
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    6ce0:	cbz	r3, 6ce8 <FatFile::getName(char*, unsigned int)+0x20>
    6ce2:	cmp	r2, #12
    6ce4:	mov	r9, r2
    6ce6:	bhi.n	6cf4 <FatFile::getName(char*, unsigned int)+0x2c>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
    6ce8:	movs	r0, #0
    6cea:	strb.w	r0, [r8]
  return 0;
}
    6cee:	add	sp, #52	; 0x34
    6cf0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    6cf4:	ldrb	r3, [r0, #3]
    6cf6:	mov	r7, r0
    6cf8:	cmp	r3, #0
    6cfa:	beq.n	6da2 <FatFile::getName(char*, unsigned int)+0xda>
    return getSFN(name);
  }
  if (!dirFile.openCluster(this)) {
    6cfc:	add	r0, sp, #12
    6cfe:	mov	r1, r7
    6d00:	bl	6c98 <FatFile::openCluster(FatFile*)>
    6d04:	cmp	r0, #0
    6d06:	beq.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6d08:	ldrb	r3, [r7, #3]
    6d0a:	cmp	r3, #0
    6d0c:	beq.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    6d0e:	str	r4, [sp, #4]
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6d10:	movs	r6, #1
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    6d12:	add.w	r5, r9, #4294967295
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    6d16:	ldrh	r1, [r7, #4]
    6d18:	subs	r1, r1, r6
    6d1a:	lsls	r1, r1, #5
    6d1c:	add	r0, sp, #12
    6d1e:	bl	639c <FatFile::seekSet(unsigned long)>
    6d22:	cmp	r0, #0
    6d24:	beq.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    6d26:	movs	r1, #0
    6d28:	add	r0, sp, #12
    6d2a:	bl	612c <FatFile::readDirCache(bool)>
    if (!ldir) {
    6d2e:	mov	fp, r0
    6d30:	cmp	r0, #0
    6d32:	beq.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME) {
    6d34:	ldrb	r3, [r0, #11]
    6d36:	cmp	r3, #15
    6d38:	bne.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (order != (ldir->order & 0X1F)) {
    6d3a:	ldrb	r3, [r0, #0]
    6d3c:	and.w	r3, r3, #31
    6d40:	cmp	r6, r3
    6d42:	bne.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
  return 0;
}
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
    6d44:	subs	r3, r6, #1
    6d46:	add.w	r4, r3, r3, lsl #1
    6d4a:	add.w	r4, r3, r4, lsl #2
    6d4e:	mov	r3, r4
    6d50:	add.w	sl, r8, r4
    6d54:	add.w	r2, r4, #13
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    6d58:	subs	r1, r3, r4
    6d5a:	uxtb	r1, r1
    6d5c:	mov	r0, fp
    6d5e:	bl	6c4c <lfnGetChar(DirLfn_t*, unsigned char)>
    if (c == 0 || k >= (n - 1)) {
    6d62:	cbz	r0, 6dac <FatFile::getName(char*, unsigned int)+0xe4>
    6d64:	cmp	r5, r3
    6d66:	bls.n	6dac <FatFile::getName(char*, unsigned int)+0xe4>
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    6d68:	cmp	r0, #126	; 0x7e
    6d6a:	add.w	r3, r3, #1
    6d6e:	ite	ls
    6d70:	uxtbls	r0, r0
    6d72:	movhi	r0, #63	; 0x3f
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    6d74:	cmp	r2, r3
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    6d76:	strb.w	r0, [sl], #1
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    6d7a:	bne.n	6d58 <FatFile::getName(char*, unsigned int)+0x90>
    }
    name[k++] = c >= 0X7F ? '?' : c;
  }
  // Terminate with zero byte.
  if (k >= n) {  // <<----------added
    k = n - 1;   // <<--------- added
    6d7c:	cmp	r9, r2
    6d7e:	it	ls
    6d80:	movls	r2, r5
  }             // <<---------added
  name[k] = '\0';
    6d82:	ldrb.w	r3, [sp, #4]
    6d86:	strb.w	r3, [r8, r2]
    if (order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    n = lfnGetName(ldir, name, size);
    if (n == 0) {
    6d8a:	cmp	r2, #0
    6d8c:	beq.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    6d8e:	ldrb.w	r3, [fp]
    6d92:	lsls	r3, r3, #25
    6d94:	bmi.n	6db0 <FatFile::getName(char*, unsigned int)+0xe8>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6d96:	adds	r6, #1
    6d98:	ldrb	r3, [r7, #3]
    6d9a:	uxtb	r6, r6
    6d9c:	cmp	r3, r6
    6d9e:	bcs.n	6d16 <FatFile::getName(char*, unsigned int)+0x4e>
    6da0:	b.n	6ce8 <FatFile::getName(char*, unsigned int)+0x20>
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    return getSFN(name);
    6da2:	bl	7570 <FatFile::getSFN(char*)>
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
  return 0;
}
    6da6:	add	sp, #52	; 0x34
    6da8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    6dac:	mov	r2, r3
    6dae:	b.n	6d7c <FatFile::getName(char*, unsigned int)+0xb4>
    6db0:	mov	r0, r2
    6db2:	b.n	6cee <FatFile::getName(char*, unsigned int)+0x26>

00006db4 <FatFile::parsePathName(char const*, fname_t*, char const**)>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
    6db4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
    6db8:	ldrb	r3, [r0, #0]
    6dba:	cmp	r3, #32
    6dbc:	bne.n	6dc6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x12>
    6dbe:	ldrb.w	r3, [r0, #1]!
    6dc2:	cmp	r3, #32
    6dc4:	beq.n	6dbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa>
    path++;
  }
  fname->lfn = path;
    6dc6:	str	r0, [r1, #8]

  for (len = 0; ; len++) {
    c = path[len];
    6dc8:	ldrb	r3, [r0, #0]
    if (c == 0 || isDirSeparator(c)) {
    6dca:	cmp	r3, #0
    6dcc:	beq.w	6fde <FatFile::parsePathName(char const*, fname_t*, char const**)+0x22a>
    6dd0:	cmp	r3, #47	; 0x2f
    6dd2:	beq.n	6e34 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x80>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    6dd4:	cmp	r3, #92	; 0x5c
    6dd6:	beq.n	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    6dd8:	sub.w	r4, r3, #34	; 0x22
    6ddc:	uxtb	r4, r4
    6dde:	cmp	r4, #29
    6de0:	bls.n	6e24 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x70>
    6de2:	ldr.w	lr, [pc, #536]	; 6ffc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>
    6de6:	adds	r6, r0, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    6de8:	movs	r4, #0
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    6dea:	cmp	r3, #124	; 0x7c
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    6dec:	sub.w	r5, r3, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    6df0:	mov	r7, r6
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    6df2:	beq.n	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    6df4:	cmp	r5, #94	; 0x5e
    6df6:	bhi.n	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    6df8:	ldrb.w	r3, [r6], #1
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    6dfc:	sub.w	r5, r3, #34	; 0x22
    6e00:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    6e02:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    6e04:	cmp	r3, #0
    6e06:	beq.w	6fb0 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1fc>
    6e0a:	cmp	r3, #47	; 0x2f
    6e0c:	beq.n	6e36 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x82>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    6e0e:	cmp	r3, #92	; 0x5c
    6e10:	lsr.w	r7, lr, r5
    6e14:	beq.n	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    6e16:	cmp	r5, #29
    6e18:	bhi.n	6dea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    6e1a:	lsls	r7, r7, #31
    6e1c:	bpl.n	6dea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    6e1e:	movs	r0, #0
    6e20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    6e24:	ldr	r5, [pc, #468]	; (6ffc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>)
    6e26:	lsr.w	r4, r5, r4
    6e2a:	lsls	r4, r4, #31
    6e2c:	bpl.n	6de2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x2e>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    6e2e:	movs	r0, #0
    6e30:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    6e34:	movs	r4, #0
    6e36:	adds	r7, r0, r4
    6e38:	mov	r6, r7
    6e3a:	mov	r5, r4
    6e3c:	movs	r3, #47	; 0x2f
    6e3e:	b.n	6e46 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x92>
    6e40:	ldrb.w	r3, [r6, #1]!
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    6e44:	adds	r5, #1
    6e46:	cmp	r3, #32
    6e48:	beq.n	6e40 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
    6e4a:	cmp	r3, #47	; 0x2f
    6e4c:	beq.n	6e40 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
  *ptr = &path[end];
    6e4e:	add	r5, r0
    6e50:	str	r5, [r2, #0]

  // Back over spaces and dots.
  while (len) {
    6e52:	cbz	r4, 6e68 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb4>
    6e54:	mov	r2, r7
    c = path[len - 1];
    6e56:	ldrb.w	r3, [r2, #-1]!
    if (c != '.' && c != ' ') {
    6e5a:	cmp	r3, #46	; 0x2e
    6e5c:	beq.n	6e64 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb0>
    6e5e:	cmp	r3, #32
    6e60:	bne.w	6fb6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x202>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    6e64:	subs	r4, #1
    6e66:	bne.n	6e56 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa2>
    6e68:	mov.w	r5, #4294967295
    6e6c:	mov	r3, r4
  // Max length of LFN is 255.
  if (len > 255) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
    6e6e:	str	r3, [r1, #4]
    6e70:	add.w	r6, r1, #23
    6e74:	add.w	r3, r1, #12
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6e78:	movs	r2, #32
    6e7a:	strb.w	r2, [r3, #1]!
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6e7e:	cmp	r3, r6
    6e80:	bne.n	6e7a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xc6>
    6e82:	subs	r6, r0, #1
    6e84:	movs	r2, #0
    6e86:	b.n	6e8a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd6>
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
    6e88:	adds	r2, #1
    6e8a:	ldrb.w	r3, [r6, #1]!
    6e8e:	cmp	r3, #46	; 0x2e
    6e90:	beq.n	6e88 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
    6e92:	cmp	r3, #32
    6e94:	beq.n	6e88 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
  // Not 8.3 if leading dot or space.
  is83 = !si;
    6e96:	clz	ip, r2

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    6e9a:	adds	r6, r5, #1
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
    6e9c:	mov.w	ip, ip, lsr #5

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    6ea0:	beq.n	6ebc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    6ea2:	ldrb	r7, [r0, r5]
    6ea4:	cmp	r7, #46	; 0x2e
    6ea6:	add.w	r6, r0, r5
    6eaa:	bne.n	6eb6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x102>
    6eac:	b.n	6ebc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    6eae:	ldrb.w	r7, [r6, #-1]!
    6eb2:	cmp	r7, #46	; 0x2e
    6eb4:	beq.n	6ebc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    6eb6:	adds.w	r5, r5, #4294967295
    6eba:	bcs.n	6eae <FatFile::parsePathName(char const*, fname_t*, char const**)+0xfa>
  for (; si < len; si++) {
    6ebc:	cmp	r2, r4
    6ebe:	mov.w	r9, #0
    6ec2:	bge.w	6fe8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x234>
    6ec6:	mov	r6, r9
    6ec8:	mov	sl, r9
    6eca:	movs	r7, #7
    6ecc:	mov.w	r8, #8
    6ed0:	b.n	6f1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16a>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    6ed2:	cmp	r3, #46	; 0x2e
    6ed4:	beq.n	6f66 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b2>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    6ed6:	cmp	r3, #34	; 0x22
    6ed8:	beq.n	6ef2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    6eda:	cmp	r3, #124	; 0x7c
    6edc:	beq.n	6ef2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6ede:	sub.w	lr, r3, #42	; 0x2a
    6ee2:	cmp.w	lr, #5
    6ee6:	bls.n	6f7a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1c6>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    6ee8:	sub.w	lr, r3, #58	; 0x3a
    6eec:	cmp.w	lr, #5
    6ef0:	bhi.n	6fa4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1f0>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    6ef2:	cmp	r5, r2
    6ef4:	beq.n	6f6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    6ef6:	cmp	r7, r6
    6ef8:	bcc.n	6f4e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
    6efa:	mov.w	ip, #0
      c = '_';
    6efe:	movs	r3, #95	; 0x5f
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    6f00:	add.w	lr, r6, #1
    6f04:	add.w	fp, r1, r6
    6f08:	uxtb.w	r6, lr
      if (i < 7) {
    6f0c:	cmp	r6, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    6f0e:	strb.w	r3, [fp, #13]
      if (i < 7) {
    6f12:	bhi.n	6f16 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
        fname->seqPos = i;
    6f14:	strb	r6, [r1, #12]
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    6f16:	adds	r2, #1
    6f18:	cmp	r2, r4
    6f1a:	bge.n	6f2c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
    6f1c:	ldrb	r3, [r0, r2]
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    6f1e:	cmp	r3, #32
    6f20:	bne.n	6ed2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x11e>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    6f22:	adds	r2, #1
    6f24:	cmp	r2, r4
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    6f26:	mov.w	ip, #0
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    6f2a:	blt.n	6f1c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x168>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6f2c:	ldrb	r3, [r1, #13]
    6f2e:	cmp	r3, #32
    6f30:	beq.w	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (is83) {
    6f34:	cmp.w	ip, #0
    6f38:	beq.n	6fca <FatFile::parsePathName(char const*, fname_t*, char const**)+0x216>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    6f3a:	tst.w	sl, r9
    6f3e:	it	ne
    6f40:	movne.w	r9, #2
    6f44:	strb.w	r9, [r1]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    6f48:	movs	r0, #1
    6f4a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    6f4e:	cmp	r7, #10
    6f50:	beq.n	6fc2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
    6f52:	cmp	r5, r2
    6f54:	blt.n	6fc2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    6f56:	mov	r2, r5
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    6f58:	movs	r7, #10
      i = 8;    // Place for extension.
    6f5a:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6f5c:	mov.w	r8, #16
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    6f60:	mov.w	ip, #0
    6f64:	b.n	6f16 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    6f66:	cmp	r5, r2
    6f68:	bne.n	6f22 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16e>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    6f6a:	cmp	r7, #10
    6f6c:	beq.n	6fc2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    6f6e:	mov	r2, r5
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    6f70:	movs	r7, #10
      i = 8;    // Place for extension.
    6f72:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6f74:	mov.w	r8, #16
    6f78:	b.n	6f16 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6f7a:	cmp	r3, #45	; 0x2d
    6f7c:	bne.n	6ef2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    6f7e:	sub.w	lr, r3, #33	; 0x21
    6f82:	cmp.w	lr, #93	; 0x5d
    6f86:	bhi.n	6ef2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    6f88:	cmp	r5, r2
    6f8a:	beq.n	6f6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
    6f8c:	cmp	r7, r6
    6f8e:	bcc.n	6f4e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
    6f90:	sub.w	lr, r3, #97	; 0x61
    6f94:	cmp.w	lr, #25
    6f98:	bhi.n	6fec <FatFile::parsePathName(char const*, fname_t*, char const**)+0x238>
        c += 'A' - 'a';
    6f9a:	subs	r3, #32
    6f9c:	uxtb	r3, r3
        lc |= bit;
    6f9e:	orr.w	r9, r8, r9
    6fa2:	b.n	6f00 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    6fa4:	sub.w	lr, r3, #91	; 0x5b
    6fa8:	cmp.w	lr, #2
    6fac:	bls.n	6ef2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    6fae:	b.n	6f7e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1ca>
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    6fb0:	str	r7, [r2, #0]
    6fb2:	adds	r7, r0, r4
    6fb4:	b.n	6e54 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa0>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > 255) {
    6fb6:	cmp	r4, #255	; 0xff
    6fb8:	bgt.w	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    6fbc:	subs	r5, r4, #1
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    c = path[len - 1];
    6fbe:	mov	r3, r4
    6fc0:	b.n	6e6e <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6fc2:	ldrb	r3, [r1, #13]
    6fc4:	cmp	r3, #32
    6fc6:	beq.w	6e1e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    6fca:	ldrb	r3, [r1, #12]
    6fcc:	add	r3, r1
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    6fce:	movs	r0, #1
    fname->sfn[fname->seqPos] = '~';
    6fd0:	movs	r4, #126	; 0x7e
    fname->sfn[fname->seqPos + 1] = '1';
    6fd2:	movs	r2, #49	; 0x31
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    6fd4:	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
    6fd6:	strb	r4, [r3, #13]
    fname->sfn[fname->seqPos + 1] = '1';
    6fd8:	strb	r2, [r3, #14]
    6fda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    6fde:	str	r0, [r2, #0]
    6fe0:	mov	r4, r3
    6fe2:	mov.w	r5, #4294967295
    6fe6:	b.n	6e6e <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    6fe8:	mov	sl, r9
    6fea:	b.n	6f2c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
    6fec:	sub.w	lr, r3, #65	; 0x41
    6ff0:	cmp.w	lr, #25
        uc |= bit;
    6ff4:	it	ls
    6ff6:	orrls.w	sl, r8, sl
    6ffa:	b.n	6f00 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    6ffc:	.word	0x35000101

00007000 <FatFile::remove()>:

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    7000:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    7004:	ldrb	r2, [r0, #2]

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    7006:	sub	sp, #40	; 0x28
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    7008:	movs	r3, #0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    700a:	lsls	r2, r2, #30
    700c:	strb.w	r3, [sp, #4]
    7010:	strb.w	r3, [sp, #5]
    7014:	strb.w	r3, [sp, #6]
    7018:	bpl.n	7060 <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    701a:	ldr	r1, [r0, #32]
    701c:	mov	r5, r0
    701e:	cbnz	r1, 706a <FatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    7020:	movs	r1, #1
    7022:	mov	r0, r5
    7024:	bl	5b4c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    7028:	cbz	r0, 7060 <FatFile::remove()+0x60>
    702a:	subs	r1, r0, #1
    702c:	add.w	r7, r0, #10
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    7030:	movs	r4, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    7032:	lsrs	r2, r4, #1
    7034:	ldrb.w	r6, [r1, #1]!
    7038:	orr.w	r3, r2, r4, lsl #7
    703c:	uxtab	r3, r6, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    7040:	cmp	r7, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    7042:	uxtb	r4, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    7044:	bne.n	7032 <FatFile::remove()+0x32>
    goto fail;
  }
  checksum = lfnChecksum(dir->name);

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    7046:	mov.w	r8, #229	; 0xe5
    704a:	strb.w	r8, [r0]
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    704e:	ldr	r6, [r5, #8]

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    7050:	movs	r3, #0
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    7052:	add.w	r0, r6, #36	; 0x24
    7056:	strb	r3, [r5, #0]
  m_flags = 0;
    7058:	strb	r3, [r5, #2]
    705a:	bl	414c <FsCache::sync()>
    705e:	cbnz	r0, 7076 <FatFile::remove()+0x76>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    7060:	movs	r6, #0
}
    7062:	mov	r0, r6
    7064:	add	sp, #40	; 0x28
    7066:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    706a:	ldr	r0, [r0, #8]
    706c:	bl	6a44 <FatPartition::freeChain(unsigned long)>
    7070:	cmp	r0, #0
    7072:	bne.n	7020 <FatFile::remove()+0x20>
    7074:	b.n	7060 <FatFile::remove()+0x60>
    7076:	add.w	r0, r6, #564	; 0x234
    707a:	bl	414c <FsCache::sync()>
    707e:	cmp	r0, #0
    7080:	beq.n	7060 <FatFile::remove()+0x60>
    7082:	ldr	r0, [r6, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    7084:	ldr	r3, [r0, #0]
    7086:	ldr	r3, [r3, #24]
    7088:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    708a:	mov	r6, r0
    708c:	cmp	r0, #0
    708e:	beq.n	7060 <FatFile::remove()+0x60>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    7090:	ldrb	r3, [r5, #3]
    7092:	cmp	r3, #0
    7094:	beq.n	7062 <FatFile::remove()+0x62>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    7096:	add	r0, sp, #4
    7098:	mov	r1, r5
    709a:	bl	6c98 <FatFile::openCluster(FatFile*)>
    709e:	cmp	r0, #0
    70a0:	beq.n	7060 <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    70a2:	ldrb	r3, [r5, #3]
    70a4:	cmp	r3, #0
    70a6:	beq.n	7060 <FatFile::remove()+0x60>
    70a8:	movs	r7, #1
    70aa:	b.n	70ec <FatFile::remove()+0xec>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    70ac:	add	r0, sp, #4
    70ae:	bl	612c <FatFile::readDirCache(bool)>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    70b2:	adds	r3, r7, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
    70b4:	cmp	r0, #0
    70b6:	beq.n	7060 <FatFile::remove()+0x60>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    70b8:	ldrb	r2, [r0, #11]
    70ba:	cmp	r2, #15
    70bc:	bne.n	7060 <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    70be:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    70c0:	and.w	r1, r2, #31
    70c4:	cmp	r7, r1
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    70c6:	uxtb	r7, r3
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    70c8:	bne.n	7060 <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    70ca:	ldrb	r3, [r0, #13]
    70cc:	cmp	r3, r4
    70ce:	bne.n	7060 <FatFile::remove()+0x60>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    70d0:	strb.w	r8, [r0]
    m_vol->cacheDirty();
    70d4:	ldr	r1, [r5, #8]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    70d6:	ldrb.w	r3, [r1, #36]	; 0x24
    70da:	orr.w	r3, r3, #1
    70de:	strb.w	r3, [r1, #36]	; 0x24
    if (last) {
    70e2:	lsls	r3, r2, #25
    70e4:	bmi.n	7100 <FatFile::remove()+0x100>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    70e6:	ldrb	r3, [r5, #3]
    70e8:	cmp	r3, r7
    70ea:	bcc.n	7060 <FatFile::remove()+0x60>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    70ec:	ldrh	r1, [r5, #4]
    70ee:	subs	r1, r1, r7
    70f0:	lsls	r1, r1, #5
    70f2:	add	r0, sp, #4
    70f4:	bl	639c <FatFile::seekSet(unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    70f8:	movs	r1, #0
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    70fa:	cmp	r0, #0
    70fc:	bne.n	70ac <FatFile::remove()+0xac>
    70fe:	b.n	7060 <FatFile::remove()+0x60>
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    m_vol->cacheDirty();
    if (last) {
      if (!m_vol->cacheSync()) {
    7100:	ldr	r4, [r5, #8]
    7102:	add.w	r0, r4, #36	; 0x24
    7106:	bl	414c <FsCache::sync()>
    710a:	cmp	r0, #0
    710c:	beq.n	7060 <FatFile::remove()+0x60>
    710e:	add.w	r0, r4, #564	; 0x234
    7112:	bl	414c <FsCache::sync()>
    7116:	cmp	r0, #0
    7118:	beq.n	7060 <FatFile::remove()+0x60>
    711a:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    711c:	ldr	r3, [r0, #0]
    711e:	ldr	r3, [r3, #24]
    7120:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    7122:	cmp	r0, #0
    7124:	beq.n	7060 <FatFile::remove()+0x60>
    7126:	b.n	7062 <FatFile::remove()+0x62>

00007128 <FatFile::lfnUniqueSfn(fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    7128:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    712c:	ldrb	r7, [r1, #12]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    712e:	mov	r6, r1
    7130:	mov	r4, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    7132:	add.w	r5, r1, #13
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    7136:	mov.w	r8, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    713a:	mov.w	r9, #126	; 0x7e
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
    713e:	ldr	r0, [r6, #4]
    7140:	ldr	r1, [r6, #8]
    7142:	add.w	r3, r8, r0
    7146:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    7148:	cbz	r0, 715c <FatFile::lfnUniqueSfn(fname_t*)+0x34>
    714a:	add	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    714c:	ldrb.w	r2, [r1], #1
    7150:	add.w	r3, r3, r3, lsl #5
    7154:	eors	r3, r2
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    7156:	cmp	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    7158:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    715a:	bne.n	714c <FatFile::lfnUniqueSfn(fname_t*)+0x24>
    715c:	cmp	r7, #3
    715e:	it	cs
    7160:	movcs	r7, #3
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    7162:	adds	r2, r7, #4
    7164:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
    7166:	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    716a:	adds	r0, r6, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    716c:	subs	r2, #1
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    716e:	cmp	r1, #9
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    7170:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    7172:	ite	ls
    7174:	addls	r1, #48	; 0x30
    7176:	addhi	r1, #55	; 0x37
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    7178:	cmp	r7, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
    717a:	mov.w	r3, r3, lsr #4
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    717e:	strb	r1, [r0, #13]
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    7180:	bcc.n	7166 <FatFile::lfnUniqueSfn(fname_t*)+0x3e>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    7182:	adds	r3, r6, r7
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    7184:	movs	r1, #0
    7186:	strb.w	r9, [r3, #13]
    718a:	mov	r0, r4
    718c:	bl	639c <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    7190:	movs	r1, #1
    7192:	mov	r0, r4
    7194:	bl	612c <FatFile::readDirCache(bool)>
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    7198:	movs	r2, #11
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    719a:	mov	r3, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    719c:	mov	r1, r0
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    719e:	cbz	r0, 71cc <FatFile::lfnUniqueSfn(fname_t*)+0xa4>
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    71a0:	ldrb.w	lr, [r3]
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    71a4:	mov	r0, r5
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    71a6:	cmp.w	lr, #0
    71aa:	beq.n	71d8 <FatFile::lfnUniqueSfn(fname_t*)+0xb0>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    71ac:	ldrb	r3, [r3, #11]
    71ae:	lsls	r3, r3, #28
    71b0:	bmi.n	7190 <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    71b2:	bl	c370 <memcmp>
    71b6:	cmp	r0, #0
    71b8:	bne.n	7190 <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    71ba:	add.w	r8, r8, #1
    71be:	uxth.w	r8, r8
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
    71c2:	cmp.w	r8, #100	; 0x64
    71c6:	bne.n	713e <FatFile::lfnUniqueSfn(fname_t*)+0x16>
 fail:
  return false;

 done:
  return true;
}
    71c8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
        if (!getError()) {
    71cc:	ldrb	r0, [r4, #1]
    71ce:	clz	r0, r0
    71d2:	lsrs	r0, r0, #5
    71d4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

 fail:
  return false;

 done:
  return true;
    71d8:	movs	r0, #1
    71da:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    71de:	nop

000071e0 <FatFile::open(FatFile*, fname_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    71e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    71e4:	ldrb	r4, [r1, #0]
    71e6:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    71ea:	sub	sp, #52	; 0x34
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    71ec:	beq.n	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    71ee:	ldrb	r4, [r0, #0]
    71f0:	cbz	r4, 71fa <FatFile::open(FatFile*, fname_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    71f2:	movs	r0, #0
}
    71f4:	add	sp, #52	; 0x34
    71f6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    71fa:	ldrb	r4, [r2, #0]
  uint16_t curIndex;
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;
    71fc:	ldr.w	sl, [r2, #4]
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    7200:	lsls	r4, r4, #30
    7202:	bne.n	728a <FatFile::open(FatFile*, fname_t*, int)+0xaa>
    7204:	mov.w	r8, #1
    7208:	mov	r6, r1
    720a:	mov	fp, r2
    720c:	str	r0, [sp, #36]	; 0x24
    720e:	movs	r1, #0
    7210:	mov	r0, r6
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint16_t freeIndex = 0;
    7212:	mov	r7, r1
    7214:	str	r3, [sp, #28]
    7216:	bl	639c <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    721a:	add.w	r3, fp, #13
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    721e:	str	r7, [sp, #24]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    7220:	str	r7, [sp, #12]
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    7222:	mov	r4, r7
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    7224:	mov	r9, r7
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    7226:	str	r7, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7228:	str	r3, [sp, #16]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    722a:	movs	r1, #1
    722c:	mov	r0, r6
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    722e:	ldr	r5, [r6, #20]
    dir = dirFile->readDirCache(true);
    7230:	bl	612c <FatFile::readDirCache(bool)>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7234:	ubfx	r5, r5, #5, #16
    dir = dirFile->readDirCache(true);
    if (!dir) {
    7238:	mov	r3, r0
    723a:	cmp	r0, #0
    723c:	beq.w	7358 <FatFile::open(FatFile*, fname_t*, int)+0x178>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    7240:	ldrb	r2, [r0, #0]
    7242:	cmp	r2, #229	; 0xe5
    7244:	beq.n	72bc <FatFile::open(FatFile*, fname_t*, int)+0xdc>
    7246:	cmp	r2, #0
    7248:	beq.n	72bc <FatFile::open(FatFile*, fname_t*, int)+0xdc>
      if (dir->name[0] == FAT_NAME_FREE) {
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    724a:	cmp	r4, r8
    724c:	it	cc
    724e:	movcc	r4, #0
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    7250:	cmp	r2, #46	; 0x2e
    7252:	beq.n	72b6 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    7254:	ldrb	r1, [r3, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    7256:	cmp	r1, #15
    7258:	beq.n	72d8 <FatFile::open(FatFile*, fname_t*, int)+0xf8>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
    725a:	and.w	r1, r1, #8
    725e:	and.w	r2, r1, #255	; 0xff
    7262:	cbnz	r1, 72b6 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (lfnOrd) {
    7264:	cmp.w	r9, #0
    7268:	bne.w	752c <FatFile::open(FatFile*, fname_t*, int)+0x34c>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    726c:	mov	r0, r3
    726e:	movs	r2, #11
    7270:	ldr	r1, [sp, #16]
    7272:	bl	c370 <memcmp>
    7276:	cmp	r0, #0
    7278:	bne.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    727a:	ldrb.w	r3, [fp]
    727e:	lsls	r0, r3, #31
    7280:	bpl.w	7554 <FatFile::open(FatFile*, fname_t*, int)+0x374>
          goto found;
        }
        fnameFound = true;
    7284:	movs	r3, #1
    7286:	str	r3, [sp, #20]
    7288:	b.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    728a:	ldr	r5, [pc, #732]	; (7568 <FatFile::open(FatFile*, fname_t*, int)+0x388>)
    728c:	add.w	r4, sl, #12
    7290:	umull	r4, r8, r5, r4
    7294:	mov.w	r8, r8, lsr #2
    7298:	add.w	r8, r8, #1
    729c:	uxtb.w	r8, r8
    72a0:	b.n	7208 <FatFile::open(FatFile*, fname_t*, int)+0x28>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    72a2:	ldr	r1, [sp, #12]
    72a4:	subs	r1, #1
    72a6:	uxtb	r1, r1
    72a8:	cmp	r2, r1
    72aa:	str	r1, [sp, #12]
    72ac:	bne.n	72b6 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    72ae:	ldrb	r2, [r3, #13]
    72b0:	ldr	r1, [sp, #24]
    72b2:	cmp	r1, r2
    72b4:	beq.n	72ee <FatFile::open(FatFile*, fname_t*, int)+0x10e>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    72b6:	mov.w	r9, #0
    72ba:	b.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    72bc:	cmp	r4, #0
    72be:	it	eq
    72c0:	moveq	r7, r5
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    72c2:	cmp	r4, r8
        freeFound++;
    72c4:	itt	cc
    72c6:	addcc	r4, #1
    72c8:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    72ca:	cmp	r2, #0
    72cc:	beq.n	7360 <FatFile::open(FatFile*, fname_t*, int)+0x180>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    72ce:	cmp	r2, #229	; 0xe5
    72d0:	bne.n	7250 <FatFile::open(FatFile*, fname_t*, int)+0x70>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    72d2:	mov.w	r9, #0
    72d6:	b.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    72d8:	cmp.w	r9, #0
    72dc:	bne.n	72a2 <FatFile::open(FatFile*, fname_t*, int)+0xc2>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
    72de:	lsls	r5, r2, #25
    72e0:	bpl.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    72e2:	and.w	r9, r2, #31
        checksum = ldir->checksum;
    72e6:	ldrb	r2, [r3, #13]
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    72e8:	str.w	r9, [sp, #12]
        checksum = ldir->checksum;
    72ec:	str	r2, [sp, #24]
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    72ee:	ldr	r2, [sp, #12]
    72f0:	subs	r2, #1
    72f2:	add.w	r5, r2, r2, lsl #1
    72f6:	add.w	r5, r2, r5, lsl #2
      if (k >= len) {
    72fa:	cmp	sl, r5
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    72fc:	mov	r2, r5
      if (k >= len) {
    72fe:	bls.n	72b6 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    7300:	add.w	r1, r5, #13
    7304:	str.w	r9, [sp, #32]
    7308:	mov	r9, r1
    730a:	b.n	7334 <FatFile::open(FatFile*, fname_t*, int)+0x154>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    730c:	ldr.w	r0, [fp, #8]
    7310:	ldrb	r2, [r0, r2]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    7312:	cmp.w	ip, #25
    7316:	it	ls
    7318:	addls	r1, #32
    731a:	sub.w	r0, r2, #65	; 0x41
    731e:	it	ls
    7320:	uxtbls	r1, r1
    7322:	cmp	r0, #25
    7324:	itt	ls
    7326:	addls	r2, #32
    7328:	uxtbls	r2, r2
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    732a:	cmp	r1, r2
    732c:	bne.n	72b6 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
    732e:	cmp	lr, r9
    7330:	beq.n	73b8 <FatFile::open(FatFile*, fname_t*, int)+0x1d8>
    7332:	mov	r2, lr
        uint16_t u = lfnGetChar(ldir, i);
    7334:	subs	r1, r2, r5
    7336:	uxtb	r1, r1
    7338:	mov	r0, r3
    733a:	bl	6c4c <lfnGetChar(DirLfn_t*, unsigned char)>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    733e:	uxtb	r1, r0
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    7340:	cmp	sl, r2
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    7342:	sub.w	ip, r1, #65	; 0x41
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    7346:	add.w	lr, r2, #1
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    734a:	beq.w	751e <FatFile::open(FatFile*, fname_t*, int)+0x33e>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    734e:	cmp	r0, #255	; 0xff
    7350:	bls.n	730c <FatFile::open(FatFile*, fname_t*, int)+0x12c>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    7352:	mov.w	r9, #0
    7356:	b.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
    7358:	ldrb	r3, [r6, #1]
    735a:	cmp	r3, #0
    735c:	bne.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    7360:	ldr	r2, [sp, #28]
    7362:	mov	r3, r2
    7364:	lsls	r2, r3, #22
    7366:	bpl.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    736a:	and.w	r3, r3, #3
    736e:	subs	r3, #1
    7370:	cmp	r3, #1
    7372:	bhi.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    7376:	cmp	r4, #0
    7378:	it	eq
    737a:	moveq	r7, r5
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    737c:	cmp	r4, r8
    737e:	bcc.n	7388 <FatFile::open(FatFile*, fname_t*, int)+0x1a8>
    7380:	b.n	73be <FatFile::open(FatFile*, fname_t*, int)+0x1de>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    7382:	uxtb	r4, r3
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    7384:	cmp	r8, r4
    7386:	bls.n	73be <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    dir = dirFile->readDirCache();
    7388:	movs	r1, #0
    738a:	mov	r0, r6
    738c:	bl	612c <FatFile::readDirCache(bool)>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    7390:	adds	r3, r4, #1
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    if (!dir) {
    7392:	cmp	r0, #0
    7394:	bne.n	7382 <FatFile::open(FatFile*, fname_t*, int)+0x1a2>
      if (dirFile->getError()) {
    7396:	ldrb	r3, [r6, #1]
    7398:	cbz	r3, 73a4 <FatFile::open(FatFile*, fname_t*, int)+0x1c4>
    739a:	b.n	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    739c:	ldr	r3, [r6, #8]
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
    739e:	ldrb	r3, [r3, #4]
    73a0:	cmp	r3, #1
    73a2:	bhi.n	73be <FatFile::open(FatFile*, fname_t*, int)+0x1de>
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    73a4:	cmp	r8, r4
    73a6:	bls.n	73be <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    73a8:	mov	r0, r6
    73aa:	bl	5ab4 <FatFile::addDirCluster()>
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
    73ae:	adds	r4, #16
    73b0:	uxtb	r4, r4
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    73b2:	cmp	r0, #0
    73b4:	bne.n	739c <FatFile::open(FatFile*, fname_t*, int)+0x1bc>
    73b6:	b.n	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    73b8:	ldr.w	r9, [sp, #32]
    73bc:	b.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    73be:	ldr	r3, [sp, #20]
    73c0:	cbz	r3, 73d0 <FatFile::open(FatFile*, fname_t*, int)+0x1f0>
    if (!dirFile->lfnUniqueSfn(fname)) {
    73c2:	mov	r1, fp
    73c4:	mov	r0, r6
    73c6:	bl	7128 <FatFile::lfnUniqueSfn(fname_t*)>
    73ca:	cmp	r0, #0
    73cc:	beq.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    73d0:	lsls	r1, r7, #5
    73d2:	mov	r0, r6
    73d4:	bl	639c <FatFile::seekSet(unsigned long)>
    73d8:	cmp	r0, #0
    73da:	beq.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
    73de:	add.w	r8, r8, #4294967295
  for (order = lfnOrd ; order ; order--) {
    73e2:	ands.w	r9, r8, #255	; 0xff
    73e6:	beq.n	749c <FatFile::open(FatFile*, fname_t*, int)+0x2bc>
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    73e8:	orr.w	r4, r9, #64	; 0x40
    73ec:	uxtb	r4, r4
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    73ee:	mov	r5, r9
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    73f0:	movs	r7, #0
    73f2:	movs	r1, #0
    73f4:	mov	r0, r6
    73f6:	bl	612c <FatFile::readDirCache(bool)>
    if (!ldir) {
    73fa:	cmp	r0, #0
    73fc:	beq.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    7400:	ldr	r2, [r6, #8]
    7402:	ldrb.w	r3, [r2, #36]	; 0x24
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    7406:	cmp	r9, r5
    7408:	orr.w	r3, r3, #1
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    740c:	mov.w	ip, #15
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    7410:	ite	ne
    7412:	movne	r1, r5
    7414:	moveq	r1, r4
    7416:	strb.w	r3, [r2, #36]	; 0x24
    741a:	add.w	lr, fp, #12
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    741e:	strb.w	ip, [r0, #11]
    ldir->mustBeZero1 = 0;
    7422:	strb	r7, [r0, #12]
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    7424:	strb	r1, [r0, #0]
    7426:	add.w	ip, fp, #23
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    742a:	movs	r3, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    742c:	ldrb.w	r8, [lr, #1]!
    7430:	lsrs	r2, r3, #1
    7432:	orr.w	r3, r2, r3, lsl #7
    7436:	uxtab	r3, r8, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    743a:	cmp	lr, ip
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    743c:	uxtb	r3, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    743e:	bne.n	742c <FatFile::open(FatFile*, fname_t*, int)+0x24c>
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    7440:	and.w	r1, r1, #31
    7444:	subs	r1, #1
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    7446:	strb	r3, [r0, #13]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    7448:	add.w	r2, r1, r1, lsl #1
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
    744c:	ldr.w	lr, [fp, #8]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    7450:	strh	r7, [r0, #26]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    7452:	add.w	r2, r1, r2, lsl #2
    7456:	adds	r0, #4
  for (uint8_t i = 0; i < 13; i++, k++) {
    7458:	movs	r3, #0
    745a:	b.n	747c <FatFile::open(FatFile*, fname_t*, int)+0x29c>
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    745c:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    745e:	ldrb.w	r1, [lr, r2]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    7462:	bls.n	748e <FatFile::open(FatFile*, fname_t*, int)+0x2ae>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    7464:	cmp	r3, #10
    7466:	ite	ls
    7468:	strhls	r1, [r0, #0]
    746a:	strhhi	r1, [r0, #2]
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    746c:	adds	r3, #1
    746e:	uxtb	r3, r3
    7470:	cmp	r3, #13
    7472:	add.w	r2, r2, #1
    7476:	add.w	r0, r0, #2
    747a:	beq.n	7494 <FatFile::open(FatFile*, fname_t*, int)+0x2b4>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    747c:	cmp	sl, r2
    747e:	bhi.n	745c <FatFile::open(FatFile*, fname_t*, int)+0x27c>
    7480:	ite	ne
    7482:	movne.w	r1, #4294967295
    7486:	moveq	r1, #0
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    7488:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    748a:	uxth	r1, r1
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    748c:	bhi.n	7464 <FatFile::open(FatFile*, fname_t*, int)+0x284>
    748e:	strh.w	r1, [r0, #-3]
    7492:	b.n	746c <FatFile::open(FatFile*, fname_t*, int)+0x28c>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    7494:	subs	r5, #1
    7496:	ands.w	r5, r5, #255	; 0xff
    749a:	bne.n	73f2 <FatFile::open(FatFile*, fname_t*, int)+0x212>
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
    749c:	movs	r1, #0
    749e:	mov	r0, r6
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    74a0:	ldr	r5, [r6, #20]
  dir = dirFile->readDirCache();
    74a2:	bl	612c <FatFile::readDirCache(bool)>
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    74a6:	ubfx	r5, r5, #5, #16
  dir = dirFile->readDirCache();
  if (!dir) {
    74aa:	mov	r4, r0
    74ac:	cmp	r0, #0
    74ae:	beq.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    74b2:	movs	r2, #32
    74b4:	movs	r1, #0
    74b6:	bl	c49c <memset>
  memcpy(dir->name, fname->sfn, 11);
    74ba:	mov	r3, fp

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;

  // Set timestamps.
  if (FsDateTime::callback) {
    74bc:	ldr	r2, [pc, #172]	; (756c <FatFile::open(FatFile*, fname_t*, int)+0x38c>)
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);
    74be:	ldr.w	r1, [r3, #13]!
    74c2:	ldr	r0, [r3, #4]
    74c4:	str	r0, [r4, #4]
    74c6:	str	r1, [r4, #0]
    74c8:	ldrh	r1, [r3, #8]
    74ca:	ldrb	r3, [r3, #10]
    74cc:	strb	r3, [r4, #10]
    74ce:	strh	r1, [r4, #8]

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    74d0:	ldrb.w	r3, [fp]

  // Set timestamps.
  if (FsDateTime::callback) {
    74d4:	ldr	r7, [r2, #0]
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    74d6:	and.w	r3, r3, #24
    74da:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    74dc:	cmp	r7, #0
    74de:	beq.n	755c <FatFile::open(FatFile*, fname_t*, int)+0x37c>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    74e0:	add.w	r2, sp, #43	; 0x2b
    74e4:	add.w	r1, sp, #46	; 0x2e
    74e8:	add	r0, sp, #44	; 0x2c
    74ea:	blx	r7
    74ec:	ldrh.w	r1, [sp, #44]	; 0x2c
    74f0:	ldrh.w	r2, [sp, #46]	; 0x2e
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    74f4:	ldrb.w	r3, [sp, #43]	; 0x2b
    74f8:	strh	r1, [r4, #16]
    74fa:	strh	r2, [r4, #14]
    74fc:	strb	r3, [r4, #13]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    74fe:	ldr	r2, [r6, #8]
    7500:	ldrb.w	r3, [r2, #36]	; 0x24
    7504:	orr.w	r3, r3, #1
    7508:	strb.w	r3, [r2, #36]	; 0x24

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    750c:	str.w	r9, [sp]
    7510:	ldr	r3, [sp, #28]
    7512:	ldr	r0, [sp, #36]	; 0x24
    7514:	mov	r2, r5
    7516:	mov	r1, r6
    7518:	bl	644c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    751c:	b.n	71f4 <FatFile::open(FatFile*, fname_t*, int)+0x14>
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
    751e:	cmp	r0, #0
    7520:	ldr.w	r9, [sp, #32]
    7524:	it	ne
    7526:	movne.w	r9, #0
    752a:	b.n	722a <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    752c:	ldr	r1, [sp, #12]
    752e:	cmp	r1, #1
    7530:	bne.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    7534:	subs	r4, r3, #1
    7536:	adds	r3, #10
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    7538:	ldrb.w	r0, [r4, #1]!
    753c:	lsrs	r1, r2, #1
    753e:	orr.w	r2, r1, r2, lsl #7
    7542:	uxtab	r2, r0, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    7546:	cmp	r4, r3
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    7548:	uxtb	r2, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    754a:	bne.n	7538 <FatFile::open(FatFile*, fname_t*, int)+0x358>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    754c:	ldr	r3, [sp, #24]
    754e:	cmp	r3, r2
    7550:	bne.w	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    7554:	ldr	r3, [sp, #28]
    7556:	lsls	r1, r3, #20
    7558:	bpl.n	750c <FatFile::open(FatFile*, fname_t*, int)+0x32c>
    755a:	b.n	71f2 <FatFile::open(FatFile*, fname_t*, int)+0x12>
    755c:	movw	r3, #21025	; 0x5221
    7560:	strh	r3, [r4, #16]
    7562:	strh	r3, [r4, #24]
    7564:	strh	r3, [r4, #18]
    7566:	b.n	74fe <FatFile::open(FatFile*, fname_t*, int)+0x31e>
    7568:	.word	0x4ec4ec4f
    756c:	.word	0x20019b54

00007570 <FatFile::getSFN(char*)>:
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name) {
    7570:	push	{r3, r4, r5, r6, r7, lr}
    7572:	ldrb	r3, [r0, #0]
    7574:	mov	r5, r1
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t* dir;

  if (!isOpen()) {
    7576:	cbz	r3, 758a <FatFile::getSFN(char*)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    7578:	ands.w	r4, r3, #96	; 0x60
    757c:	beq.n	7590 <FatFile::getSFN(char*)+0x20>
    name[0] = '/';
    757e:	movs	r2, #47	; 0x2f
    name[1] = '\0';
    7580:	movs	r3, #0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    name[0] = '/';
    7582:	strb	r2, [r1, #0]
    name[1] = '\0';
    7584:	strb	r3, [r1, #1]
    return 1;
    7586:	movs	r0, #1
    7588:	pop	{r3, r4, r5, r6, r7, pc}
  }
  name[j] = '\0';
  return j;

 fail:
  name[0] = '\0';
    758a:	movs	r0, #0
    758c:	strb	r0, [r5, #0]
  return 0;
}
    758e:	pop	{r3, r4, r5, r6, r7, pc}
    name[0] = '/';
    name[1] = '\0';
    return 1;
  }
  // cache entry
  dir = reinterpret_cast<DirFat_t*>(cacheDirEntry(FsCache::CACHE_FOR_READ));
    7590:	mov	r1, r4
    7592:	bl	5b4c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    7596:	cmp	r0, #0
    7598:	beq.n	758a <FatFile::getSFN(char*)+0x1a>
    759a:	mov	r1, r4
    759c:	mov	r3, r4
    759e:	movs	r7, #8
    75a0:	subs	r4, r0, #1
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    75a2:	mov.w	lr, #46	; 0x2e
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    if (dir->name[i] == ' ') {
    75a6:	ldrb.w	r2, [r4, #1]!
    75aa:	cmp	r2, #32
    75ac:	beq.n	75ca <FatFile::getSFN(char*)+0x5a>
      continue;
    }
    if (i == 8) {
    75ae:	cmp	r1, #8
    75b0:	beq.n	75d8 <FatFile::getSFN(char*)+0x68>
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    }
    char c = dir->name[i];
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    75b2:	sub.w	r6, r2, #65	; 0x41
    75b6:	cmp	r6, #25
    75b8:	bhi.n	75c4 <FatFile::getSFN(char*)+0x54>
    75ba:	ldrb	r6, [r0, #12]
    75bc:	tst	r7, r6
      c += 'a' - 'A';
    75be:	itt	ne
    75c0:	addne	r2, #32
    75c2:	uxtbne	r2, r2
    }
    name[j++] = c;
    75c4:	strb	r2, [r5, r3]
    75c6:	adds	r3, #1
    75c8:	uxtb	r3, r3
    75ca:	adds	r1, #1
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    75cc:	cmp	r1, #11
    75ce:	bne.n	75a6 <FatFile::getSFN(char*)+0x36>
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = '\0';
    75d0:	movs	r2, #0
    75d2:	strb	r2, [r5, r3]
  return j;
    75d4:	mov	r0, r3
    75d6:	pop	{r3, r4, r5, r6, r7, pc}
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    75d8:	strb.w	lr, [r5, r3]
    75dc:	adds	r3, #1
    75de:	uxtb	r3, r3
    75e0:	ldrb	r2, [r4, #0]
    if (dir->name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
    75e2:	movs	r7, #16
    75e4:	b.n	75b2 <FatFile::getSFN(char*)+0x42>
    75e6:	nop

000075e8 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    75e8:	push	{r3, r4, r5, r6, r7, lr}
    75ea:	movs	r5, #0
    75ec:	str	r5, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    75ee:	ldr	r4, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    75f0:	str	r5, [r0, #60]	; 0x3c
    75f2:	mov	r6, r0
    75f4:	mov	r7, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    75f6:	cbz	r4, 761c <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    75f8:	mov	r1, r0
    75fa:	movs	r0, #36	; 0x24
    75fc:	bl	7858 <operator new(unsigned int, unsigned long*)>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    7600:	strb	r5, [r0, #0]
    7602:	strb	r5, [r0, #1]
    7604:	strb	r5, [r0, #2]
    7606:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    7608:	ldr	r5, [r7, #56]	; 0x38
    760a:	mov	r4, r0
    760c:	ldmia	r5!, {r0, r1, r2, r3}
    760e:	stmia	r4!, {r0, r1, r2, r3}
    7610:	ldmia	r5!, {r0, r1, r2, r3}
    7612:	stmia	r4!, {r0, r1, r2, r3}
    7614:	ldr	r3, [r5, #0]
    7616:	str	r3, [r4, #0]
  } else if (from.m_xFile) {
    m_xFile = new (m_fileMem) ExFatFile;
    *m_xFile = *from.m_xFile;
  }
}
    7618:	mov	r0, r6
    761a:	pop	{r3, r4, r5, r6, r7, pc}
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    m_fFile = new (m_fileMem) FatFile;
    *m_fFile = *from.m_fFile;
  } else if (from.m_xFile) {
    761c:	ldr	r3, [r1, #60]	; 0x3c
    761e:	cmp	r3, #0
    7620:	beq.n	7618 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>
    m_xFile = new (m_fileMem) ExFatFile;
    7622:	mov	r1, r0
    7624:	movs	r0, #56	; 0x38
    7626:	bl	7858 <operator new(unsigned int, unsigned long*)>
    762a:	strb.w	r4, [r0, #49]	; 0x31
    762e:	strb.w	r4, [r0, #50]	; 0x32
    7632:	strb.w	r4, [r0, #51]	; 0x33
    7636:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    7638:	ldr	r3, [r7, #60]	; 0x3c
    763a:	mov	r2, r0
    763c:	add.w	r1, r3, #48	; 0x30
    7640:	ldr	r5, [r3, #0]
    7642:	ldr	r4, [r3, #4]
    7644:	ldr	r0, [r3, #8]
    7646:	ldr	r7, [r3, #12]
    7648:	str	r7, [r2, #12]
    764a:	adds	r3, #16
    764c:	cmp	r3, r1
    764e:	str	r5, [r2, #0]
    7650:	str	r4, [r2, #4]
    7652:	str	r0, [r2, #8]
    7654:	add.w	r2, r2, #16
    7658:	bne.n	7640 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x58>
    765a:	ldr	r3, [r3, #0]
    765c:	str	r3, [r2, #0]
    765e:	b.n	7618 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>

00007660 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    7660:	push	{r4, lr}
    7662:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    7664:	ldr	r0, [r0, #56]	; 0x38
    7666:	cbz	r0, 7674 <FsBaseFile::close()+0x14>
    7668:	bl	5c00 <FatFile::close()>
    766c:	cbz	r0, 7674 <FsBaseFile::close()+0x14>
    m_fFile = nullptr;
    766e:	movs	r3, #0
    7670:	str	r3, [r4, #56]	; 0x38
    return true;
    7672:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    7674:	ldr	r0, [r4, #60]	; 0x3c
    7676:	cbz	r0, 7684 <FsBaseFile::close()+0x24>
    7678:	bl	415c <ExFatFile::close()>
    767c:	cbz	r0, 7684 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    767e:	movs	r3, #0
    7680:	str	r3, [r4, #60]	; 0x3c
    7682:	pop	{r4, pc}
    return true;
  }
  return false;
    7684:	movs	r0, #0
}
    7686:	pop	{r4, pc}

00007688 <FsBaseFile::open(FsVolume*, char const*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    7688:	cbz	r1, 76fe <FsBaseFile::open(FsVolume*, char const*, int)+0x76>
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    768a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    768e:	mov	r4, r1
    7690:	mov	r5, r0
    7692:	mov	r8, r3
    7694:	mov	r7, r2
  if (!vol) {
    return false;
  }
  close();
    7696:	bl	7660 <FsBaseFile::close()>
  if (vol->m_fVol) {
    769a:	ldr.w	r6, [r4, #1152]	; 0x480
    769e:	cbz	r6, 76cc <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    76a0:	mov	r1, r5
    76a2:	movs	r0, #36	; 0x24
    76a4:	bl	7858 <operator new(unsigned int, unsigned long*)>
    76a8:	movs	r1, #0
    76aa:	strb	r1, [r0, #0]
    76ac:	strb	r1, [r0, #1]
    76ae:	strb	r1, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    76b0:	ldr.w	r1, [r4, #1152]	; 0x480
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    76b4:	str	r0, [r5, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    76b6:	mov	r3, r8
    76b8:	mov	r2, r7
    76ba:	bl	5ef4 <FatFile::open(FatVolume*, char const*, int)>
    76be:	cbz	r0, 76c6 <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    76c0:	movs	r0, #1
    76c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
    76c6:	str	r0, [r5, #56]	; 0x38
    76c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (vol->m_xVol) {
    76cc:	ldr.w	r3, [r4, #1156]	; 0x484
    76d0:	cbz	r3, 7702 <FsBaseFile::open(FsVolume*, char const*, int)+0x7a>
    m_xFile = new (m_fileMem) ExFatFile;
    76d2:	mov	r1, r5
    76d4:	movs	r0, #56	; 0x38
    76d6:	bl	7858 <operator new(unsigned int, unsigned long*)>
    76da:	strb.w	r6, [r0, #49]	; 0x31
    76de:	strb.w	r6, [r0, #50]	; 0x32
    76e2:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    76e6:	ldr.w	r1, [r4, #1156]	; 0x484
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    76ea:	str	r0, [r5, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    76ec:	mov	r3, r8
    76ee:	mov	r2, r7
    76f0:	bl	4ac0 <ExFatFile::open(ExFatVolume*, char const*, int)>
    76f4:	cmp	r0, #0
    76f6:	bne.n	76c0 <FsBaseFile::open(FsVolume*, char const*, int)+0x38>
      return true;
    }
    m_xFile = nullptr;
    76f8:	str	r0, [r5, #60]	; 0x3c
  }
  return false;
}
    76fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    76fe:	movs	r0, #0
      return true;
    }
    m_xFile = nullptr;
  }
  return false;
}
    7700:	bx	lr
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    7702:	movs	r0, #0
    7704:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007708 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    7708:	push	{r3, r4, r5, r6, r7, lr}
    770a:	mov	r5, r1
    770c:	mov	r7, r2
    770e:	mov	r4, r0
  close();
    7710:	bl	7660 <FsBaseFile::close()>
  if (dir->m_fFile) {
    7714:	ldr	r6, [r5, #56]	; 0x38
    7716:	cbz	r6, 773c <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    7718:	mov	r1, r4
    771a:	movs	r0, #36	; 0x24
    771c:	bl	7858 <operator new(unsigned int, unsigned long*)>
    7720:	movs	r2, #0
    7722:	strb	r2, [r0, #0]
    7724:	strb	r2, [r0, #1]
    7726:	strb	r2, [r0, #2]
    7728:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    772a:	mov	r2, r7
    772c:	ldr	r1, [r5, #56]	; 0x38
    772e:	bl	6524 <FatFile::openNext(FatFile*, int)>
    7732:	cbz	r0, 7738 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    7734:	movs	r0, #1
    7736:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    7738:	str	r0, [r4, #56]	; 0x38
    773a:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    773c:	ldr	r0, [r5, #60]	; 0x3c
    773e:	cbz	r0, 7764 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    7740:	mov	r1, r4
    7742:	movs	r0, #56	; 0x38
    7744:	bl	7858 <operator new(unsigned int, unsigned long*)>
    7748:	strb.w	r6, [r0, #49]	; 0x31
    774c:	strb.w	r6, [r0, #50]	; 0x32
    7750:	strb.w	r6, [r0, #51]	; 0x33
    7754:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    7756:	mov	r2, r7
    7758:	ldr	r1, [r5, #60]	; 0x3c
    775a:	bl	4ad0 <ExFatFile::openNext(ExFatFile*, int)>
    775e:	cmp	r0, #0
    7760:	bne.n	7734 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    7762:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    7764:	pop	{r3, r4, r5, r6, r7, pc}
    7766:	nop

00007768 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    7768:	push	{r4, r5, r6, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    776a:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    776c:	mov	r4, r0
  m_blockDev = blockDev;
    776e:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    7772:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    7776:	mov	r1, r0
    7778:	mov.w	r0, #1152	; 0x480
    777c:	bl	7858 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    7780:	strb.w	r6, [r0, #1092]	; 0x444
    7784:	strb.w	r6, [r0, #1145]	; 0x479
    7788:	strb.w	r6, [r0, #1146]	; 0x47a
    778c:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7790:	movs	r2, #1
    7792:	ldr.w	r1, [r4, #1160]	; 0x488
    7796:	str.w	r0, [r4, #1156]	; 0x484
    779a:	mov	r5, r0
    779c:	bl	4ec0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    77a0:	cbnz	r0, 77de <FsVolume::begin(BlockDeviceInterface*)+0x76>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    77a2:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    77a4:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    77a6:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    77aa:	mov.w	r0, #1128	; 0x468
    77ae:	bl	7858 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    77b2:	strb	r6, [r0, #7]
    77b4:	strb.w	r6, [r0, #1092]	; 0x444
    77b8:	strb.w	r6, [r0, #1093]	; 0x445
    77bc:	strb.w	r6, [r0, #1094]	; 0x446
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    77c0:	movs	r2, #1
    77c2:	ldr.w	r1, [r4, #1160]	; 0x488
    77c6:	str.w	r0, [r4, #1152]	; 0x480
    77ca:	mov	r5, r0
    77cc:	bl	6b30 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    77d0:	cbnz	r0, 7802 <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    77d2:	ldr	r3, [pc, #80]	; (7824 <FsVolume::begin(BlockDeviceInterface*)+0xbc>)
    77d4:	movs	r0, #0
    77d6:	str	r0, [r3, #0]
  m_fVol = nullptr;
    77d8:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    77dc:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    77de:	add.w	r6, r5, #1096	; 0x448
    77e2:	mov	r0, r6
    77e4:	bl	415c <ExFatFile::close()>
    return m_vwd.openRoot(this);
    77e8:	mov	r1, r5
    77ea:	mov	r0, r6
    77ec:	bl	4220 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    77f0:	cmp	r0, #0
    77f2:	beq.n	77a2 <FsVolume::begin(BlockDeviceInterface*)+0x3a>
      return false;
    }
    if (setCwv || !m_cwv) {
    77f4:	ldr	r3, [pc, #48]	; (7828 <FsVolume::begin(BlockDeviceInterface*)+0xc0>)
    77f6:	ldr	r2, [r3, #0]
    77f8:	cbz	r2, 7820 <FsVolume::begin(BlockDeviceInterface*)+0xb8>
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    77fa:	ldr	r3, [pc, #40]	; (7824 <FsVolume::begin(BlockDeviceInterface*)+0xbc>)
  return true;
    77fc:	movs	r0, #1
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    77fe:	str	r4, [r3, #0]
  return true;
    7800:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    7802:	addw	r6, r5, #1092	; 0x444
    7806:	mov	r0, r6
    7808:	bl	5c00 <FatFile::close()>
    return m_vwd.openRoot(this);
    780c:	mov	r1, r5
    780e:	mov	r0, r6
    7810:	bl	5f04 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    7814:	cmp	r0, #0
    7816:	beq.n	77d2 <FsVolume::begin(BlockDeviceInterface*)+0x6a>
      return false;
    }
    if (setCwv || !m_cwv) {
    7818:	ldr	r3, [pc, #16]	; (782c <FsVolume::begin(BlockDeviceInterface*)+0xc4>)
    781a:	ldr	r2, [r3, #0]
    781c:	cmp	r2, #0
    781e:	bne.n	77fa <FsVolume::begin(BlockDeviceInterface*)+0x92>
      m_cwv = this;
    7820:	str	r5, [r3, #0]
    7822:	b.n	77fa <FsVolume::begin(BlockDeviceInterface*)+0x92>
    7824:	.word	0x20019b60
    7828:	.word	0x20019b58
    782c:	.word	0x20019b5c

00007830 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    7830:	push	{r3, r4, r5, r6, r7, lr}
    7832:	movs	r5, #0
    7834:	mov.w	r7, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    7838:	ldr	r6, [pc, #24]	; (7854 <FsVolume::open(char const*, int)+0x24>)
    783a:	str	r7, [r0, #8]
    783c:	mov	r4, r0
    783e:	strb	r5, [r0, #4]
    7840:	strb	r5, [r0, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    7842:	str	r5, [r0, #72]	; 0x48
    7844:	str	r5, [r0, #76]	; 0x4c
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    7846:	str.w	r6, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    784a:	bl	7688 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    784e:	mov	r0, r4
    7850:	pop	{r3, r4, r5, r6, r7, pc}
    7852:	nop
    7854:	.word	0x000130e8

00007858 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    7858:	mov	r0, r1
    785a:	bx	lr

0000785c <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    785c:	ldrb	r0, [r0, #19]
    785e:	bx	lr

00007860 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    7860:	ldrb	r0, [r0, #21]
    7862:	bx	lr

00007864 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    7864:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7866:	ldr	r4, [r0, #0]
    7868:	ldr	r4, [r4, #16]
    786a:	movs	r3, #1
    786c:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    786e:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7872:	bx	ip

00007874 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    7874:	ldrb	r0, [r0, #22]
    7876:	bx	lr

00007878 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    7878:	bx	lr
    787a:	nop

0000787c <SdSpiCard::~SdSpiCard()>:
    787c:	push	{r4, lr}
    787e:	movs	r1, #24
    7880:	mov	r4, r0
    7882:	bl	ae5c <operator delete(void*, unsigned int)>
    7886:	mov	r0, r4
    7888:	pop	{r4, pc}
    788a:	nop

0000788c <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>:
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    788c:	push	{r4, lr}
    788e:	mov	r4, r0
  bool waitNotBusy(SdMillis_t timeoutMS);
  bool writeData(uint8_t token, const uint8_t* src);

#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
    7890:	adds	r0, #4
    7892:	bl	909c <SdSpiArduinoDriver::activate()>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    7896:	ldrb	r0, [r4, #18]
    7898:	movs	r1, #0
    789a:	bl	921c <sdCsWrite(unsigned char, bool)>
  if (!m_spiActive) {
    spiActivate();
    spiSelect();
    m_spiActive = true;
    789e:	movs	r3, #1
    78a0:	strb	r3, [r4, #20]
    78a2:	pop	{r4, pc}

000078a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    78a4:	push	{r3, r4, r5, lr}
    78a6:	mov	r4, r0
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    78a8:	movs	r1, #1
    78aa:	ldrb	r0, [r0, #18]
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    78ac:	adds	r5, r4, #4
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    78ae:	bl	921c <sdCsWrite(unsigned char, bool)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    78b2:	mov	r0, r5
    78b4:	movs	r1, #255	; 0xff
    78b6:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
    78ba:	mov	r0, r5
    78bc:	bl	912c <SdSpiArduinoDriver::deactivate()>
  if (m_spiActive) {
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
    78c0:	movs	r3, #0
    78c2:	strb	r3, [r4, #20]
    78c4:	pop	{r3, r4, r5, pc}
    78c6:	nop

000078c8 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    78c8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    78cc:	mov	r6, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78ce:	ldrb	r1, [r0, #16]
    78d0:	cmp	r1, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    78d2:	mov	r5, r0
    78d4:	mov	r4, r2
    78d6:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78d8:	beq.n	791e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x56>
    if (!writeStart(sector)) {
    78da:	ldr	r3, [r5, #0]
    78dc:	mov	r1, r6
    78de:	ldr	r3, [r3, #72]	; 0x48
    78e0:	mov	r0, r5
    78e2:	blx	r3
    78e4:	cbz	r0, 790a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    78e6:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    78e8:	str	r6, [r5, #12]
    m_curState = WRITE_STATE;
    78ea:	strb	r3, [r5, #16]
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    78ec:	movs	r6, #0
    78ee:	cbnz	r7, 78f6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2e>
    78f0:	b.n	7926 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x5e>
    78f2:	cmp	r7, r6
    78f4:	beq.n	7926 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x5e>
    if (!writeData(src)) {
    78f6:	ldr	r3, [r5, #0]
    78f8:	mov	r1, r4
    78fa:	ldr	r3, [r3, #68]	; 0x44
    78fc:	mov	r0, r5
    78fe:	blx	r3
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    7900:	adds	r6, #1
    7902:	add.w	r4, r4, #512	; 0x200
    if (!writeData(src)) {
    7906:	cmp	r0, #0
    7908:	bne.n	78f2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    790a:	ldrb	r0, [r5, #20]
    790c:	cbnz	r0, 7912 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    790e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7912:	mov	r0, r5
    7914:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
    7918:	movs	r0, #0
}
    791a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    791e:	ldr	r3, [r0, #12]
    7920:	cmp	r3, r6
    7922:	bne.n	78da <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x12>
    7924:	b.n	78ec <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x24>
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7926:	ldr	r3, [r5, #12]
  return m_sharedSpi ? syncDevice() : true;
    7928:	ldrb	r2, [r5, #17]
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    792a:	add	r7, r3
    792c:	str	r7, [r5, #12]
  return m_sharedSpi ? syncDevice() : true;
    792e:	cbnz	r2, 7936 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6e>
    7930:	movs	r0, #1
    7932:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7936:	ldr	r3, [r5, #0]
    7938:	mov	r0, r5
    793a:	ldr	r3, [r3, #24]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    793c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7940:	bx	r3
    7942:	nop

00007944 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7944:	push	{r3, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7946:	ldrb	r3, [r0, #16]
    7948:	cmp	r3, #1
    794a:	beq.n	798e <SdSpiCard::isBusy()+0x4a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool rtn = true;
  bool spiActive = m_spiActive;
    794c:	ldrb	r7, [r0, #20]
    794e:	mov	r5, r0
  if (!spiActive) {
    7950:	cbz	r7, 797e <SdSpiCard::isBusy()+0x3a>
    7952:	adds	r6, r5, #4
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7954:	movs	r4, #8
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    7956:	mov	r0, r6
    7958:	bl	9174 <SdSpiArduinoDriver::receive()>
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
    795c:	cmp	r0, #255	; 0xff
    795e:	add.w	r3, r4, #4294967295
    7962:	beq.n	7976 <SdSpiCard::isBusy()+0x32>
  bool rtn = true;
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    7964:	ands.w	r4, r3, #255	; 0xff
    7968:	bne.n	7956 <SdSpiCard::isBusy()+0x12>
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool rtn = true;
    796a:	movs	r4, #1
    if (0XFF == spiReceive()) {
      rtn = false;
      break;
    }
  }
  if (!spiActive) {
    796c:	cbnz	r7, 7972 <SdSpiCard::isBusy()+0x2e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    796e:	ldrb	r3, [r5, #20]
    7970:	cbnz	r3, 7984 <SdSpiCard::isBusy()+0x40>
    }
  }
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    7972:	mov	r0, r4
}
    7974:	pop	{r3, r4, r5, r6, r7, pc}
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
      rtn = false;
    7976:	movs	r4, #0
      break;
    }
  }
  if (!spiActive) {
    7978:	cmp	r7, #0
    797a:	beq.n	796e <SdSpiCard::isBusy()+0x2a>
    797c:	b.n	7972 <SdSpiCard::isBusy()+0x2e>
    797e:	bl	788c <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    7982:	b.n	7952 <SdSpiCard::isBusy()+0xe>
    7984:	mov	r0, r5
    7986:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    spiStop();
  }
  return rtn;
    798a:	mov	r0, r4
    798c:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    798e:	movs	r0, #0
    7990:	pop	{r3, r4, r5, r6, r7, pc}
    7992:	nop

00007994 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    7994:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7998:	ldr	r6, [pc, #116]	; (7a10 <SdSpiCard::readData(unsigned char*, unsigned int)+0x7c>)
    799a:	sub	sp, #12
    799c:	ldr	r3, [r6, #0]
    799e:	str	r3, [sp, #0]
	return ret;
    79a0:	ldr	r5, [sp, #0]
    79a2:	mov	r4, r0
    79a4:	mov	r8, r1
    79a6:	mov	r9, r2

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    79a8:	uxth	r5, r5
    79aa:	adds	r7, r0, #4
    79ac:	b.n	79be <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    79ae:	ldr	r3, [r6, #0]
    79b0:	str	r3, [sp, #4]
	return ret;
    79b2:	ldr	r3, [sp, #4]
    79b4:	uxth	r3, r3
    79b6:	subs	r3, r3, r5
    79b8:	cmp.w	r3, #300	; 0x12c
    79bc:	bgt.n	79e4 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
    79be:	mov	r0, r7
    79c0:	bl	9174 <SdSpiArduinoDriver::receive()>
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    79c4:	cmp	r0, #255	; 0xff
    79c6:	strb	r0, [r4, #21]
    79c8:	beq.n	79ae <SdSpiCard::readData(unsigned char*, unsigned int)+0x1a>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    79ca:	cmp	r0, #254	; 0xfe
    79cc:	beq.n	79ea <SdSpiCard::readData(unsigned char*, unsigned int)+0x56>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    79ce:	movs	r3, #24
    79d0:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    79d2:	ldrb	r0, [r4, #20]
    79d4:	cbz	r0, 79de <SdSpiCard::readData(unsigned char*, unsigned int)+0x4a>
    79d6:	mov	r0, r4
    79d8:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
  return false;
    79dc:	movs	r0, #0
}
    79de:	add	sp, #12
    79e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    79e4:	movs	r3, #29
    79e6:	strb	r3, [r4, #19]
    79e8:	b.n	79d2 <SdSpiCard::readData(unsigned char*, unsigned int)+0x3e>
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
    79ea:	mov	r2, r9
    79ec:	mov	r1, r8
    79ee:	mov	r0, r7
    79f0:	bl	9190 <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>
  if (m_status != DATA_START_SECTOR) {
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    79f4:	strb	r0, [r4, #21]
    79f6:	cbz	r0, 79fe <SdSpiCard::readData(unsigned char*, unsigned int)+0x6a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    79f8:	movs	r3, #37	; 0x25
    79fa:	strb	r3, [r4, #19]
    79fc:	b.n	79d2 <SdSpiCard::readData(unsigned char*, unsigned int)+0x3e>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    79fe:	mov	r0, r7
    7a00:	bl	9174 <SdSpiArduinoDriver::receive()>
    7a04:	mov	r0, r7
    7a06:	bl	9174 <SdSpiArduinoDriver::receive()>
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
  spiReceive();
#endif  // USE_SD_CRC
  return true;
    7a0a:	movs	r0, #1
    7a0c:	b.n	79de <SdSpiCard::readData(unsigned char*, unsigned int)+0x4a>
    7a0e:	nop
    7a10:	.word	0x20019bc4

00007a14 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    7a14:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7a16:	ldr	r5, [pc, #52]	; (7a4c <SdSpiCard::waitNotBusy(unsigned short)+0x38>)
    7a18:	sub	sp, #12
    7a1a:	ldr	r3, [r5, #0]
    7a1c:	str	r3, [sp, #0]
	return ret;
    7a1e:	ldr	r4, [sp, #0]
    7a20:	mov	r7, r1
    7a22:	adds	r6, r0, #4
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    7a24:	uxth	r4, r4
    7a26:	b.n	7a36 <SdSpiCard::waitNotBusy(unsigned short)+0x22>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7a28:	ldr	r3, [r5, #0]
    7a2a:	str	r3, [sp, #4]
	return ret;
    7a2c:	ldr	r3, [sp, #4]
    7a2e:	uxth	r3, r3
    7a30:	subs	r3, r3, r4
    7a32:	cmp	r3, r7
    7a34:	bgt.n	7a46 <SdSpiCard::waitNotBusy(unsigned short)+0x32>
    7a36:	mov	r0, r6
    7a38:	bl	9174 <SdSpiArduinoDriver::receive()>
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    7a3c:	cmp	r0, #255	; 0xff
    7a3e:	bne.n	7a28 <SdSpiCard::waitNotBusy(unsigned short)+0x14>
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    }
  }
  return true;
    7a40:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    7a42:	add	sp, #12
    7a44:	pop	{r4, r5, r6, r7, pc}
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    7a46:	movs	r0, #0
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
    7a48:	add	sp, #12
    7a4a:	pop	{r4, r5, r6, r7, pc}
    7a4c:	.word	0x20019bc4

00007a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    7a50:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7a54:	sub	sp, #8
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7a56:	ldrb	r3, [r0, #16]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    7a58:	str	r2, [sp, #4]
    7a5a:	mov	r4, r0
    7a5c:	mov	r7, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7a5e:	cbnz	r3, 7ac0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x70>
    return 0XFF;
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    7a60:	ldrb	r3, [r4, #20]
    7a62:	cmp	r3, #0
    7a64:	beq.n	7ade <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x8e>
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    7a66:	cmp	r7, #0
    7a68:	bne.n	7ad2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x82>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    7a6a:	adds	r5, r4, #4
    7a6c:	mov	r0, r5
    7a6e:	orr.w	r1, r7, #64	; 0x40
    7a72:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
    7a76:	add.w	r8, sp, #4
    7a7a:	add	r6, sp, #8
    7a7c:	ldrb.w	r1, [r6, #-1]!
    7a80:	mov	r0, r5
    7a82:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    7a86:	cmp	r8, r6
    7a88:	bne.n	7a7c <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2c>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    7a8a:	cmp	r7, #0
    7a8c:	ite	eq
    7a8e:	moveq	r1, #149	; 0x95
    7a90:	movne	r1, #135	; 0x87
    7a92:	mov	r0, r5
    7a94:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    7a98:	mov	r0, r5
    7a9a:	bl	9174 <SdSpiArduinoDriver::receive()>
    7a9e:	movs	r6, #11
    7aa0:	mov	r0, r5
    7aa2:	bl	9174 <SdSpiArduinoDriver::receive()>

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    7aa6:	lsls	r3, r0, #24
    7aa8:	strb	r0, [r4, #21]
    7aaa:	bmi.n	7ab2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x62>
  }
  return m_status;
}
    7aac:	add	sp, #8
    7aae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7ab2:	subs	r3, r6, #1

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    7ab4:	ands.w	r6, r3, #255	; 0xff
    7ab8:	bne.n	7aa0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x50>
  }
  return m_status;
}
    7aba:	add	sp, #8
    7abc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7ac0:	ldr	r3, [r0, #0]
    7ac2:	ldr	r3, [r3, #24]
    7ac4:	blx	r3
    7ac6:	cmp	r0, #0
    7ac8:	bne.n	7a60 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x10>
    return 0XFF;
    7aca:	movs	r0, #255	; 0xff

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
  }
  return m_status;
}
    7acc:	add	sp, #8
    7ace:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    7ad2:	mov.w	r1, #300	; 0x12c
    7ad6:	mov	r0, r4
    7ad8:	bl	7a14 <SdSpiCard::waitNotBusy(unsigned short)>
    7adc:	b.n	7a6a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x1a>
    7ade:	mov	r0, r4
    7ae0:	bl	788c <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    7ae4:	b.n	7a66 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x16>
    7ae6:	nop

00007ae8 <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7ae8:	push	{r3, r4, r5, r6, r7, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7aea:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7aec:	mov	r5, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7aee:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7af0:	mov	r6, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7af2:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7af6:	cbnz	r0, 7b14 <SdSpiCard::readOCR(unsigned long*)+0x2c>
    7af8:	adds	r7, r6, #4
    7afa:	adds	r4, r5, #4
    7afc:	mov	r0, r7
    7afe:	bl	9174 <SdSpiArduinoDriver::receive()>
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    7b02:	strb.w	r0, [r4, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7b06:	cmp	r5, r4
    7b08:	bne.n	7afc <SdSpiCard::readOCR(unsigned long*)+0x14>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7b0a:	ldrb	r4, [r6, #20]
    7b0c:	cbnz	r4, 7b2a <SdSpiCard::readOCR(unsigned long*)+0x42>
    7b0e:	movs	r4, #1
  return true;

 fail:
  spiStop();
  return false;
}
    7b10:	mov	r0, r4
    7b12:	pop	{r3, r4, r5, r6, r7, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7b14:	ldrb	r4, [r6, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b16:	movs	r3, #18
    7b18:	strb	r3, [r6, #19]
    7b1a:	cmp	r4, #0
    7b1c:	beq.n	7b10 <SdSpiCard::readOCR(unsigned long*)+0x28>
    7b1e:	mov	r0, r6
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    7b20:	movs	r4, #0
    7b22:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
}
    7b26:	mov	r0, r4
    7b28:	pop	{r3, r4, r5, r6, r7, pc}
    7b2a:	mov	r0, r6
    7b2c:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7b30:	mov	r0, r4
    7b32:	pop	{r3, r4, r5, r6, r7, pc}

00007b34 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7b34:	push	{r3, r4, r5, lr}
    7b36:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7b38:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7b3a:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7b3c:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b40:	cbz	r0, 7b54 <SdSpiCard::readRegister(unsigned char, void*)+0x20>
    7b42:	movs	r3, #27
    7b44:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7b46:	ldrb	r0, [r4, #20]
    7b48:	cbz	r0, 7b52 <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    7b4a:	mov	r0, r4
    7b4c:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    7b50:	movs	r0, #0
}
    7b52:	pop	{r3, r4, r5, pc}
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7b54:	mov	r1, r5
    7b56:	movs	r2, #16
    7b58:	mov	r0, r4
    7b5a:	bl	7994 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7b5e:	cmp	r0, #0
    7b60:	beq.n	7b46 <SdSpiCard::readRegister(unsigned char, void*)+0x12>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7b62:	ldrb	r5, [r4, #20]
    7b64:	cmp	r5, #0
    7b66:	beq.n	7b52 <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    7b68:	mov	r0, r4
    7b6a:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7b6e:	mov	r0, r5
    7b70:	pop	{r3, r4, r5, pc}
    7b72:	nop

00007b74 <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7b74:	mov	r2, r1
    7b76:	movs	r1, #9
    7b78:	b.w	7b34 <SdSpiCard::readRegister(unsigned char, void*)>

00007b7c <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7b7c:	mov	r2, r1
    7b7e:	movs	r1, #10
    7b80:	b.w	7b34 <SdSpiCard::readRegister(unsigned char, void*)>

00007b84 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    7b84:	push	{r4, r5, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    7b86:	ldr	r3, [r0, #0]
    7b88:	ldr	r2, [pc, #140]	; (7c18 <SdSpiCard::sectorCount()+0x94>)
    7b8a:	ldr	r3, [r3, #52]	; 0x34
    7b8c:	cmp	r3, r2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    7b8e:	sub	sp, #20
    7b90:	bne.n	7bf2 <SdSpiCard::sectorCount()+0x6e>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7b92:	mov	r2, sp
    7b94:	movs	r1, #9
    7b96:	bl	7b34 <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    7b9a:	cbz	r0, 7bac <SdSpiCard::sectorCount()+0x28>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7b9c:	ldrb.w	r3, [sp]
    7ba0:	ands.w	r3, r3, #192	; 0xc0
    7ba4:	beq.n	7bb0 <SdSpiCard::sectorCount()+0x2c>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    7ba6:	cmp	r3, #64	; 0x40
    7ba8:	beq.n	7bf8 <SdSpiCard::sectorCount()+0x74>
    7baa:	movs	r0, #0
}
    7bac:	add	sp, #20
    7bae:	pop	{r4, r5, pc}
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    7bb0:	ldrb.w	r4, [sp, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    7bb4:	ldrb.w	r3, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7bb8:	ldrb.w	r2, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    7bbc:	ldrb.w	r0, [sp, #10]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7bc0:	ldrb.w	r1, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7bc4:	ldrb.w	r5, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7bc8:	and.w	r4, r4, #3
    7bcc:	lsls	r4, r4, #1
    7bce:	lsls	r2, r2, #2
    7bd0:	and.w	r3, r3, #3
    7bd4:	orr.w	r0, r4, r0, lsr #7
    7bd8:	and.w	r1, r1, #15
    7bdc:	orr.w	r3, r2, r3, lsl #10
    7be0:	add	r0, r1
    7be2:	orr.w	r3, r3, r5, lsr #6
    7be6:	adds	r3, #1
    7be8:	subs	r0, #7
    7bea:	lsl.w	r0, r3, r0
    7bee:	add	sp, #20
    7bf0:	pop	{r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    7bf2:	mov	r1, sp
    7bf4:	blx	r3
    7bf6:	b.n	7b9a <SdSpiCard::sectorCount()+0x16>
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7bf8:	ldrb.w	r3, [sp, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7bfc:	ldrb.w	r1, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7c00:	ldrb.w	r0, [sp, #8]
    7c04:	adds	r2, r3, #1
    7c06:	and.w	r3, r1, #63	; 0x3f
    7c0a:	add.w	r3, r2, r3, lsl #16
    7c0e:	add.w	r0, r3, r0, lsl #8
    7c12:	lsls	r0, r0, #10
}
    7c14:	add	sp, #20
    7c16:	pop	{r4, r5, pc}
    7c18:	.word	0x00007b75

00007c1c <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c1c:	push	{r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    7c1e:	ldr	r3, [r0, #0]
    7c20:	ldr	r5, [pc, #68]	; (7c68 <SdSpiCard::readStart(unsigned long)+0x4c>)
    7c22:	ldr	r3, [r3, #64]	; 0x40
    7c24:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c26:	sub	sp, #12
    7c28:	mov	r4, r0
    7c2a:	mov	r2, r1
    7c2c:	bne.n	7c5e <SdSpiCard::readStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    7c2e:	ldrb	r0, [r0, #22]
  if (type() != SD_CARD_TYPE_SDHC) {
    7c30:	cmp	r0, #3
    sector <<= 9;
    7c32:	it	ne
    7c34:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD18, sector)) {
    7c36:	movs	r1, #18
    7c38:	mov	r0, r4
    7c3a:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c3e:	cbz	r0, 7c58 <SdSpiCard::readStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7c40:	ldrb	r0, [r4, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7c42:	movs	r3, #12
    7c44:	strb	r3, [r4, #19]
    7c46:	cbnz	r0, 7c4c <SdSpiCard::readStart(unsigned long)+0x30>
  return true;

 fail:
  spiStop();
  return false;
}
    7c48:	add	sp, #12
    7c4a:	pop	{r4, r5, pc}
    7c4c:	mov	r0, r4
    7c4e:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7c52:	movs	r0, #0
    7c54:	add	sp, #12
    7c56:	pop	{r4, r5, pc}
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
//  spiStop();
  return true;
    7c58:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7c5a:	add	sp, #12
    7c5c:	pop	{r4, r5, pc}
    7c5e:	str	r1, [sp, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
  if (type() != SD_CARD_TYPE_SDHC) {
    7c60:	blx	r3
    7c62:	ldr	r2, [sp, #4]
    7c64:	b.n	7c30 <SdSpiCard::readStart(unsigned long)+0x14>
    7c66:	nop
    7c68:	.word	0x00007875

00007c6c <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c6c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7c70:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c72:	ldrb	r1, [r0, #16]
    7c74:	cmp	r1, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c76:	mov	r6, r0
    7c78:	mov	r4, r2
    7c7a:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c7c:	beq.n	7cb4 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    if (!readStart(sector)) {
    7c7e:	mov	r1, r5
    7c80:	mov	r0, r6
    7c82:	bl	7c1c <SdSpiCard::readStart(unsigned long)>
    7c86:	cbz	r0, 7cae <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x42>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7c88:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7c8a:	str	r5, [r6, #12]
    m_curState = READ_STATE;
    7c8c:	strb	r3, [r6, #16]
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7c8e:	movs	r5, #0
    7c90:	cbnz	r7, 7c98 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2c>
    7c92:	b.n	7cbc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x50>
    7c94:	cmp	r7, r5
    7c96:	beq.n	7cbc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x50>
    if (!readData(dst, 512)) {
    7c98:	mov	r1, r4
    7c9a:	mov.w	r2, #512	; 0x200
    7c9e:	mov	r0, r6
    7ca0:	bl	7994 <SdSpiCard::readData(unsigned char*, unsigned int)>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7ca4:	adds	r5, #1
    7ca6:	add.w	r4, r4, #512	; 0x200
    if (!readData(dst, 512)) {
    7caa:	cmp	r0, #0
    7cac:	bne.n	7c94 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7cae:	movs	r0, #0
    7cb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cb4:	ldr	r3, [r0, #12]
    7cb6:	cmp	r3, r5
    7cb8:	bne.n	7c7e <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x12>
    7cba:	b.n	7c8e <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7cbc:	ldr	r3, [r6, #12]
  return m_sharedSpi ? syncDevice() : true;
    7cbe:	ldrb	r2, [r6, #17]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7cc0:	add	r7, r3
    7cc2:	str	r7, [r6, #12]
  return m_sharedSpi ? syncDevice() : true;
    7cc4:	cbnz	r2, 7ccc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    7cc6:	movs	r0, #1
    7cc8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7ccc:	ldr	r3, [r6, #0]
    7cce:	mov	r0, r6
    7cd0:	ldr	r3, [r3, #24]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7cd2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7cd6:	bx	r3

00007cd8 <SdSpiCard::readStop()>:
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7cd8:	push	{r3, r4, r5, lr}
  if (cardCommand(CMD12, 0)) {
    7cda:	movs	r2, #0
    7cdc:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7cde:	mov	r5, r0
  if (cardCommand(CMD12, 0)) {
    7ce0:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7ce4:	ldrb	r4, [r5, #20]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    7ce6:	cbz	r0, 7cf2 <SdSpiCard::readStop()+0x1a>
    7ce8:	movs	r3, #9
    7cea:	strb	r3, [r5, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7cec:	cbnz	r4, 7d04 <SdSpiCard::readStop()+0x2c>
  return true;

 fail:
  spiStop();
  return false;
}
    7cee:	mov	r0, r4
    7cf0:	pop	{r3, r4, r5, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7cf2:	cbnz	r4, 7cfa <SdSpiCard::readStop()+0x22>
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
  return true;
    7cf4:	movs	r4, #1

 fail:
  spiStop();
  return false;
}
    7cf6:	mov	r0, r4
    7cf8:	pop	{r3, r4, r5, pc}
    7cfa:	mov	r0, r5
    7cfc:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7d00:	mov	r0, r4
    7d02:	pop	{r3, r4, r5, pc}
    7d04:	mov	r0, r5
    7d06:	movs	r4, #0
    7d08:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7d0c:	mov	r0, r4
    7d0e:	pop	{r3, r4, r5, pc}

00007d10 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    7d10:	ldrb	r2, [r0, #16]
  m_curState = IDLE_STATE;
    7d12:	movs	r1, #0
  if (state == WRITE_STATE) {
    7d14:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    7d16:	strb	r1, [r0, #16]
  if (state == WRITE_STATE) {
    7d18:	beq.n	7d26 <SdSpiCard::syncDevice()+0x16>
    return writeStop();
  }
  if (state == READ_STATE) {
    7d1a:	cmp	r2, #1
    7d1c:	beq.n	7d22 <SdSpiCard::syncDevice()+0x12>
    return readStop();
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    7d1e:	movs	r0, #1
    7d20:	bx	lr
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
  }
  if (state == READ_STATE) {
    return readStop();
    7d22:	b.w	7cd8 <SdSpiCard::readStop()>
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
    7d26:	ldr	r3, [r0, #0]
    7d28:	ldr	r3, [r3, #76]	; 0x4c
    7d2a:	bx	r3

00007d2c <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7d2c:	push	{r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7d2e:	ldr	r3, [r0, #0]
    7d30:	ldr	r5, [pc, #68]	; (7d78 <SdSpiCard::writeStart(unsigned long)+0x4c>)
    7d32:	ldr	r3, [r3, #64]	; 0x40
    7d34:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7d36:	sub	sp, #12
    7d38:	mov	r4, r0
    7d3a:	mov	r2, r1
    7d3c:	bne.n	7d6e <SdSpiCard::writeStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    7d3e:	ldrb	r0, [r0, #22]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7d40:	cmp	r0, #3
    sector <<= 9;
    7d42:	it	ne
    7d44:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD25, sector)) {
    7d46:	movs	r1, #25
    7d48:	mov	r0, r4
    7d4a:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d4e:	cbz	r0, 7d68 <SdSpiCard::writeStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7d50:	ldrb	r0, [r4, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7d52:	movs	r3, #14
    7d54:	strb	r3, [r4, #19]
    7d56:	cbnz	r0, 7d5c <SdSpiCard::writeStart(unsigned long)+0x30>
  return true;

 fail:
  spiStop();
  return false;
}
    7d58:	add	sp, #12
    7d5a:	pop	{r4, r5, pc}
    7d5c:	mov	r0, r4
    7d5e:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7d62:	movs	r0, #0
    7d64:	add	sp, #12
    7d66:	pop	{r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    7d68:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7d6a:	add	sp, #12
    7d6c:	pop	{r4, r5, pc}
    7d6e:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7d70:	blx	r3
    7d72:	ldr	r2, [sp, #4]
    7d74:	b.n	7d40 <SdSpiCard::writeStart(unsigned long)+0x14>
    7d76:	nop
    7d78:	.word	0x00007875

00007d7c <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7d7c:	push	{r4, r5, r6, r7, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    7d7e:	ldr	r3, [r0, #0]
    7d80:	ldr	r7, [pc, #172]	; (7e30 <SdSpiCard::erase(unsigned long, unsigned long)+0xb4>)
    7d82:	ldr	r3, [r3, #52]	; 0x34
    7d84:	cmp	r3, r7
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7d86:	sub	sp, #20
    7d88:	mov	r4, r0
    7d8a:	mov	r5, r1
    7d8c:	mov	r6, r2
    7d8e:	bne.n	7dec <SdSpiCard::erase(unsigned long, unsigned long)+0x70>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7d90:	mov	r2, sp
    7d92:	movs	r1, #9
    7d94:	bl	7b34 <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  if (!readCSD(&csd)) {
    7d98:	cbz	r0, 7dc0 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    7d9a:	ldrb.w	r3, [sp, #10]
    7d9e:	lsls	r2, r3, #25
    7da0:	bpl.n	7dd0 <SdSpiCard::erase(unsigned long, unsigned long)+0x54>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7da2:	ldrb	r3, [r4, #22]
    7da4:	cmp	r3, #3
    firstSector <<= 9;
    7da6:	it	ne
    7da8:	lslne	r5, r5, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7daa:	mov	r2, r5
    7dac:	mov.w	r1, #32
    7db0:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7db2:	it	ne
    7db4:	lslne	r6, r6, #9
  }
  if (cardCommand(CMD32, firstSector)
    7db6:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7dba:	cbz	r0, 7df2 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7dbc:	movs	r3, #38	; 0x26
    7dbe:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7dc0:	ldrb	r0, [r4, #20]
    7dc2:	cbz	r0, 7dcc <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    7dc4:	mov	r0, r4
    7dc6:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    7dca:	movs	r0, #0
}
    7dcc:	add	sp, #20
    7dce:	pop	{r4, r5, r6, r7, pc}
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7dd0:	and.w	r3, r3, #63	; 0x3f
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7dd4:	ldrb.w	r1, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7dd8:	lsls	r3, r3, #1
    7dda:	adds	r2, r6, #1
    7ddc:	orr.w	r3, r3, r1, lsr #7
    7de0:	orrs	r2, r5
    7de2:	tst	r3, r2
    7de4:	beq.n	7da2 <SdSpiCard::erase(unsigned long, unsigned long)+0x26>
    7de6:	movs	r3, #39	; 0x27
    7de8:	strb	r3, [r4, #19]
    7dea:	b.n	7dc0 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
  csd_t csd;
  if (!readCSD(&csd)) {
    7dec:	mov	r1, sp
    7dee:	blx	r3
    7df0:	b.n	7d98 <SdSpiCard::erase(unsigned long, unsigned long)+0x1c>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7df2:	mov	r2, r6
    7df4:	movs	r1, #33	; 0x21
    7df6:	mov	r0, r4
    7df8:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7dfc:	cmp	r0, #0
    7dfe:	bne.n	7dbc <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
      || cardCommand(CMD38, 0)) {
    7e00:	mov	r2, r0
    7e02:	movs	r1, #38	; 0x26
    7e04:	mov	r0, r4
    7e06:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7e0a:	cmp	r0, #0
    7e0c:	bne.n	7dbc <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7e0e:	movw	r1, #10000	; 0x2710
    7e12:	mov	r0, r4
    7e14:	bl	7a14 <SdSpiCard::waitNotBusy(unsigned short)>
    7e18:	cbnz	r0, 7e20 <SdSpiCard::erase(unsigned long, unsigned long)+0xa4>
    7e1a:	movs	r3, #40	; 0x28
    7e1c:	strb	r3, [r4, #19]
    7e1e:	b.n	7dc0 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7e20:	ldrb	r5, [r4, #20]
    7e22:	cmp	r5, #0
    7e24:	beq.n	7dcc <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    7e26:	mov	r0, r4
    7e28:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;
    7e2c:	mov	r0, r5
    7e2e:	b.n	7dcc <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    7e30:	.word	0x00007b75

00007e34 <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e34:	push	{r4, r5, r6, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e36:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e3a:	mov	r5, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e3c:	bl	7a14 <SdSpiCard::waitNotBusy(unsigned short)>
    7e40:	mov	r6, r0
    7e42:	cbnz	r0, 7e5c <SdSpiCard::writeStop()+0x28>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7e44:	ldrb	r4, [r5, #20]
    7e46:	movs	r3, #30
    7e48:	strb	r3, [r5, #19]
    7e4a:	cbnz	r4, 7e50 <SdSpiCard::writeStop()+0x1c>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    7e4c:	mov	r0, r4
    7e4e:	pop	{r4, r5, r6, pc}
    7e50:	mov	r0, r5
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
    7e52:	mov	r4, r6
    7e54:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
}
    7e58:	mov	r0, r4
    7e5a:	pop	{r4, r5, r6, pc}
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    7e5c:	movs	r1, #253	; 0xfd
    7e5e:	adds	r0, r5, #4
    7e60:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7e64:	ldrb	r4, [r5, #20]
    7e66:	cbnz	r4, 7e6e <SdSpiCard::writeStop()+0x3a>
    7e68:	mov	r4, r6

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    7e6a:	mov	r0, r4
    7e6c:	pop	{r4, r5, r6, pc}
    7e6e:	mov	r0, r5
    7e70:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7e74:	b.n	7e4c <SdSpiCard::writeStop()+0x18>
    7e76:	nop

00007e78 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7e78:	push	{r4, r5, r6, lr}
    7e7a:	adds	r4, r0, #4
    7e7c:	mov	r6, r2
    7e7e:	mov	r5, r0
    7e80:	mov	r0, r4
    7e82:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver.send(buf, n);
    7e86:	mov.w	r2, #512	; 0x200
    7e8a:	mov	r1, r6
    7e8c:	mov	r0, r4
    7e8e:	bl	91c8 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    7e92:	mov	r0, r4
    7e94:	movs	r1, #255	; 0xff
    7e96:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
    7e9a:	mov	r0, r4
    7e9c:	movs	r1, #255	; 0xff
    7e9e:	bl	91b0 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    7ea2:	mov	r0, r4
    7ea4:	bl	9174 <SdSpiArduinoDriver::receive()>
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7ea8:	and.w	r3, r0, #31
    7eac:	cmp	r3, #5
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
    7eae:	strb	r0, [r5, #21]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7eb0:	beq.n	7ec6 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x4e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7eb2:	ldrb	r0, [r5, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7eb4:	movs	r3, #32
    7eb6:	strb	r3, [r5, #19]
    7eb8:	cbnz	r0, 7ebc <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x44>
  return true;

 fail:
  spiStop();
  return false;
}
    7eba:	pop	{r4, r5, r6, pc}
    7ebc:	mov	r0, r5
    7ebe:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  }
  return true;

 fail:
  spiStop();
  return false;
    7ec2:	movs	r0, #0
    7ec4:	pop	{r4, r5, r6, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    7ec6:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7ec8:	pop	{r4, r5, r6, pc}
    7eca:	nop

00007ecc <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7ecc:	push	{r3, r4, r5, lr}
    7ece:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7ed0:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7ed4:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7ed6:	bl	7a14 <SdSpiCard::waitNotBusy(unsigned short)>
    7eda:	cbnz	r0, 7eee <SdSpiCard::writeData(unsigned char const*)+0x22>
    7edc:	movs	r3, #36	; 0x24
    7ede:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7ee0:	ldrb	r0, [r4, #20]
    7ee2:	cbz	r0, 7eec <SdSpiCard::writeData(unsigned char const*)+0x20>
    7ee4:	mov	r0, r4
    7ee6:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  }
  return true;

 fail:
  spiStop();
  return false;
    7eea:	movs	r0, #0
}
    7eec:	pop	{r3, r4, r5, pc}
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7eee:	mov	r2, r5
    7ef0:	movs	r1, #252	; 0xfc
    7ef2:	mov	r0, r4
    7ef4:	bl	7e78 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7ef8:	cmp	r0, #0
    7efa:	beq.n	7ee0 <SdSpiCard::writeData(unsigned char const*)+0x14>
  return true;

 fail:
  spiStop();
  return false;
}
    7efc:	pop	{r3, r4, r5, pc}
    7efe:	nop

00007f00 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7f00:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f02:	ldr	r3, [r0, #0]
    7f04:	ldr	r5, [pc, #88]	; (7f60 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x60>)
    7f06:	ldr	r3, [r3, #64]	; 0x40
    7f08:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7f0a:	sub	sp, #8
    7f0c:	mov	r4, r0
    7f0e:	mov	r6, r2
    7f10:	bne.n	7f58 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x58>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    7f12:	ldrb	r0, [r0, #22]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f14:	cmp	r0, #3
    sector <<= 9;
    7f16:	it	ne
    7f18:	lslne	r1, r1, #9
  }
  if (cardCommand(CMD24, sector)) {
    7f1a:	mov	r2, r1
    7f1c:	mov	r0, r4
    7f1e:	movs	r1, #24
    7f20:	bl	7a50 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7f24:	cbz	r0, 7f3a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7f26:	movs	r3, #13
    7f28:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7f2a:	ldrb	r0, [r4, #20]
    7f2c:	cbz	r0, 7f36 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    7f2e:	mov	r0, r4
    7f30:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    7f34:	movs	r0, #0
}
    7f36:	add	sp, #8
    7f38:	pop	{r4, r5, r6, pc}
  }
  if (cardCommand(CMD24, sector)) {
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7f3a:	mov	r2, r6
    7f3c:	movs	r1, #254	; 0xfe
    7f3e:	mov	r0, r4
    7f40:	bl	7e78 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7f44:	cmp	r0, #0
    7f46:	beq.n	7f2a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    7f48:	ldrb	r5, [r4, #20]
    7f4a:	cmp	r5, #0
    7f4c:	beq.n	7f36 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    7f4e:	mov	r0, r4
    7f50:	bl	78a4 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    7f54:	mov	r0, r5
    7f56:	b.n	7f36 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    7f58:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f5a:	blx	r3
    7f5c:	ldr	r1, [sp, #4]
    7f5e:	b.n	7f14 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x14>
    7f60:	.word	0x00007875

00007f64 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7f64:	push	{r4}
    if (m_sharedSpi) {
    7f66:	ldrb	r4, [r0, #17]
    7f68:	cbnz	r4, 7f78 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0x14>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7f6a:	ldr	r4, [r0, #0]
    7f6c:	ldr	r4, [r4, #32]
    7f6e:	movs	r3, #1
    7f70:	mov	ip, r4
    }
  }
    7f72:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7f76:	bx	ip
    }
  }
    7f78:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7f7c:	b.w	7f00 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>

00007f80 <sdIrs()>:
#endif  // USE_DEBUG_MODE
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
    7f80:	push	{r4}
  SDHC_IRQSIGEN = 0;
    7f82:	ldr	r4, [pc, #28]	; (7fa0 <sdIrs()+0x20>)
  m_irqstat = SDHC_IRQSTAT;
    7f84:	ldr	r2, [pc, #28]	; (7fa4 <sdIrs()+0x24>)
    7f86:	ldr	r1, [pc, #32]	; (7fa8 <sdIrs()+0x28>)
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7f88:	ldr	r0, [pc, #32]	; (7fac <sdIrs()+0x2c>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7f8a:	movs	r3, #0
    7f8c:	str	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    7f8e:	ldr	r4, [r2, #0]
    7f90:	str	r4, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    7f92:	ldr	r1, [r1, #0]
    7f94:	str	r1, [r2, #0]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
}
    7f96:	ldr.w	r4, [sp], #4
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7f9a:	strb	r3, [r0, #0]
}
    7f9c:	bx	lr
    7f9e:	nop
    7fa0:	.word	0x400b1038
    7fa4:	.word	0x400b1030
    7fa8:	.word	0x20019b8c
    7fac:	.word	0x20019ba4

00007fb0 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    7fb0:	ldr	r3, [pc, #12]	; (7fc0 <isBusyCommandComplete()+0x10>)
    7fb2:	ldr	r0, [pc, #16]	; (7fc4 <isBusyCommandComplete()+0x14>)
    7fb4:	ldr	r3, [r3, #0]
    7fb6:	ands	r0, r3
}
    7fb8:	clz	r0, r0
    7fbc:	lsrs	r0, r0, #5
    7fbe:	bx	lr
    7fc0:	.word	0x400b1030
    7fc4:	.word	0x000f0001

00007fc8 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    7fc8:	ldr	r3, [pc, #8]	; (7fd4 <isBusyCommandInhibit()+0xc>)
    7fca:	ldr	r0, [r3, #0]
}
    7fcc:	and.w	r0, r0, #1
    7fd0:	bx	lr
    7fd2:	nop
    7fd4:	.word	0x400b1024

00007fd8 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    7fd8:	ldr	r3, [pc, #12]	; (7fe8 <isBusyDat()+0x10>)
    7fda:	ldr	r0, [r3, #0]
    7fdc:	eor.w	r0, r0, #16777216	; 0x1000000
}
    7fe0:	ubfx	r0, r0, #24, #1
    7fe4:	bx	lr
    7fe6:	nop
    7fe8:	.word	0x400b1024

00007fec <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    7fec:	ldr	r3, [pc, #4]	; (7ff4 <isBusyDMA()+0x8>)
    7fee:	ldrb	r0, [r3, #0]
}
    7ff0:	bx	lr
    7ff2:	nop
    7ff4:	.word	0x20019ba4

00007ff8 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    7ff8:	ldr	r3, [pc, #12]	; (8008 <isBusyFifoRead()+0x10>)
    7ffa:	ldr	r0, [r3, #0]
    7ffc:	eor.w	r0, r0, #2048	; 0x800
}
    8000:	ubfx	r0, r0, #11, #1
    8004:	bx	lr
    8006:	nop
    8008:	.word	0x400b1024

0000800c <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    800c:	ldr	r3, [pc, #12]	; (801c <isBusyFifoWrite()+0x10>)
    800e:	ldr	r0, [r3, #0]
    8010:	eor.w	r0, r0, #1024	; 0x400
}
    8014:	ubfx	r0, r0, #10, #1
    8018:	bx	lr
    801a:	nop
    801c:	.word	0x400b1024

00008020 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    8020:	ldr	r3, [pc, #12]	; (8030 <isBusyTransferComplete()+0x10>)
    8022:	ldr	r0, [pc, #16]	; (8034 <isBusyTransferComplete()+0x14>)
    8024:	ldr	r3, [r3, #0]
    8026:	ands	r0, r3
}
    8028:	clz	r0, r0
    802c:	lsrs	r0, r0, #5
    802e:	bx	lr
    8030:	.word	0x400b1030
    8034:	.word	0x117f0002

00008038 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    8038:	mov.w	r2, #1000	; 0x3e8
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    803c:	ldr	r3, [pc, #176]	; (80f0 <setSdclk(unsigned long)+0xb8>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    803e:	mul.w	r0, r2, r0
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8042:	cmp	r0, r3
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    8044:	push	{r4, r5, r6, r7}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8046:	bhi.n	80e0 <setSdclk(unsigned long)+0xa8>
    8048:	ldr	r5, [pc, #168]	; (80f4 <setSdclk(unsigned long)+0xbc>)
    804a:	movs	r2, #8
    804c:	movs	r1, #1
    sdclkfs <<= 1;
    804e:	lsls	r1, r1, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8050:	lsls	r3, r1, #4
    8052:	udiv	r3, r5, r3
    8056:	cmp	r0, r3
    8058:	ldr	r4, [pc, #152]	; (80f4 <setSdclk(unsigned long)+0xbc>)
    805a:	bcs.n	80d8 <setSdclk(unsigned long)+0xa0>
    805c:	subs	r2, #1
    805e:	bne.n	804e <setSdclk(unsigned long)+0x16>
    8060:	udiv	r4, r4, r1
    8064:	lsrs	r3, r1, #1
    8066:	lsls	r7, r3, #8
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8068:	cmp	r0, r4
    806a:	bcs.n	80e8 <setSdclk(unsigned long)+0xb0>
    806c:	ldr	r6, [pc, #132]	; (80f4 <setSdclk(unsigned long)+0xbc>)
    806e:	lsls	r3, r1, #1
    8070:	movs	r2, #1
    8072:	b.n	8076 <setSdclk(unsigned long)+0x3e>
    8074:	mov	r3, r4
    8076:	udiv	r4, r6, r3
    807a:	cmp	r0, r4
    dvs++;
    807c:	add.w	r5, r2, #1
    8080:	add.w	r4, r3, r1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8084:	bcs.n	80d4 <setSdclk(unsigned long)+0x9c>
    8086:	cmp	r5, #16
    8088:	mov	r2, r5
    808a:	bne.n	8074 <setSdclk(unsigned long)+0x3c>
    808c:	movs	r2, #240	; 0xf0
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    808e:	ldr	r6, [pc, #104]	; (80f8 <setSdclk(unsigned long)+0xc0>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    8090:	ldr	r4, [pc, #104]	; (80fc <setSdclk(unsigned long)+0xc4>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    8092:	ldr	r0, [pc, #96]	; (80f4 <setSdclk(unsigned long)+0xbc>)

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    8094:	ldr	r1, [pc, #104]	; (8100 <setSdclk(unsigned long)+0xc8>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    8096:	mov.w	r5, #1000	; 0x3e8
    809a:	mul.w	r3, r5, r3
    809e:	udiv	r3, r0, r3
    80a2:	str	r3, [r6, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    80a4:	ldr	r3, [r4, #0]
    80a6:	bic.w	r3, r3, #8
    80aa:	str	r3, [r4, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    80ac:	ldr	r0, [r4, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    80ae:	bic.w	r3, r0, #1044480	; 0xff000
    80b2:	bic.w	r3, r3, #4080	; 0xff0
    80b6:	orr.w	r3, r3, #917504	; 0xe0000
    80ba:	orrs	r3, r7
    80bc:	orrs	r2, r3
    80be:	str	r2, [r4, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    80c0:	ldr	r3, [r1, #0]
    80c2:	lsls	r3, r3, #28
    80c4:	bpl.n	80c0 <setSdclk(unsigned long)+0x88>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    80c6:	ldr	r2, [pc, #52]	; (80fc <setSdclk(unsigned long)+0xc4>)
    80c8:	ldr	r3, [r2, #0]
    80ca:	orr.w	r3, r3, #8
    80ce:	str	r3, [r2, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
    80d0:	pop	{r4, r5, r6, r7}
    80d2:	bx	lr
    80d4:	lsls	r2, r2, #4
    80d6:	b.n	808e <setSdclk(unsigned long)+0x56>
    80d8:	udiv	r4, r4, r1
    80dc:	lsls	r7, r1, #7
    80de:	b.n	8068 <setSdclk(unsigned long)+0x30>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    80e0:	ldr	r4, [pc, #16]	; (80f4 <setSdclk(unsigned long)+0xbc>)
    80e2:	movs	r7, #0
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    80e4:	movs	r1, #1
    80e6:	b.n	8068 <setSdclk(unsigned long)+0x30>
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    80e8:	mov	r3, r1
    80ea:	movs	r2, #0
    80ec:	b.n	808e <setSdclk(unsigned long)+0x56>
    80ee:	nop
    80f0:	.word	0x005b8d7f
    80f4:	.word	0x05b8d800
    80f8:	.word	0x20019ba8
    80fc:	.word	0x400b102c
    8100:	.word	0x400b1024

00008104 <SdioCard::errorCode() const>:
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
    8104:	ldr	r3, [pc, #4]	; (810c <SdioCard::errorCode() const+0x8>)
}
    8106:	ldrb	r0, [r3, #0]
    8108:	bx	lr
    810a:	nop
    810c:	.word	0x200138d4

00008110 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    8110:	ldr	r3, [pc, #4]	; (8118 <SdioCard::errorData() const+0x8>)
    8112:	ldr	r0, [r3, #0]
}
    8114:	bx	lr
    8116:	nop
    8118:	.word	0x20019b8c

0000811c <SdioCard::readCID(CID*)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    811c:	push	{r4, r5}
  memcpy(cid, &m_cid, 16);
    811e:	ldr	r4, [pc, #20]	; (8134 <SdioCard::readCID(CID*)+0x18>)
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    8120:	mov	r5, r1
  memcpy(cid, &m_cid, 16);
    8122:	ldmia	r4!, {r0, r1, r2, r3}
    8124:	str	r0, [r5, #0]
    8126:	str	r1, [r5, #4]
    8128:	str	r2, [r5, #8]
    812a:	str	r3, [r5, #12]
  return true;
}
    812c:	movs	r0, #1
    812e:	pop	{r4, r5}
    8130:	bx	lr
    8132:	nop
    8134:	.word	0x20019b68

00008138 <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    8138:	push	{r4, r5}
  memcpy(csd, &m_csd, 16);
    813a:	ldr	r4, [pc, #20]	; (8150 <SdioCard::readCSD(csd_t*)+0x18>)
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    813c:	mov	r5, r1
  memcpy(csd, &m_csd, 16);
    813e:	ldmia	r4!, {r0, r1, r2, r3}
    8140:	str	r0, [r5, #0]
    8142:	str	r1, [r5, #4]
    8144:	str	r2, [r5, #8]
    8146:	str	r3, [r5, #12]
  return true;
}
    8148:	movs	r0, #1
    814a:	pop	{r4, r5}
    814c:	bx	lr
    814e:	nop
    8150:	.word	0x20019b94

00008154 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    8154:	ldr	r3, [pc, #8]	; (8160 <SdioCard::readOCR(unsigned long*)+0xc>)
    8156:	ldr	r3, [r3, #0]
    8158:	str	r3, [r1, #0]
  return true;
}
    815a:	movs	r0, #1
    815c:	bx	lr
    815e:	nop
    8160:	.word	0x20019b80

00008164 <SdioCard::~SdioCard()>:
    8164:	bx	lr
    8166:	nop

00008168 <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    8168:	push	{r3, r4, r5, r6, r7, lr}
    816a:	mov	r5, r0
  uint32_t m = micros();
    816c:	bl	9944 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8170:	ldr	r7, [pc, #24]	; (818c <waitTimeout(bool (*)())+0x24>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    8172:	mov	r6, r0
    8174:	b.n	8180 <waitTimeout(bool (*)())+0x18>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8176:	bl	9944 <micros>
    817a:	subs	r0, r0, r6
    817c:	cmp	r0, r7
    817e:	bhi.n	8188 <waitTimeout(bool (*)())+0x20>
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
  while (fcn()) {
    8180:	blx	r5
    8182:	mov	r4, r0
    8184:	cmp	r0, #0
    8186:	bne.n	8176 <waitTimeout(bool (*)())+0xe>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    8188:	mov	r0, r4
    818a:	pop	{r3, r4, r5, r6, r7, pc}
    818c:	.word	0x000f4240

00008190 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8190:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    8194:	ldr.w	r8, [pc, #64]	; 81d8 <yieldTimeout(bool (*)())+0x48>
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8198:	ldr	r7, [pc, #56]	; (81d4 <yieldTimeout(bool (*)())+0x44>)
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    819a:	str.w	r0, [r8]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    819e:	mov	r5, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    81a0:	bl	9944 <micros>
    81a4:	mov	r6, r0
    81a6:	b.n	81b6 <yieldTimeout(bool (*)())+0x26>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    81a8:	bl	9944 <micros>
    81ac:	subs	r0, r0, r6
    81ae:	cmp	r0, r7
    81b0:	bhi.n	81c8 <yieldTimeout(bool (*)())+0x38>
    81b2:	bl	a6c4 <yield>
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    81b6:	blx	r5
    81b8:	mov	r4, r0
    81ba:	cmp	r0, #0
    81bc:	bne.n	81a8 <yieldTimeout(bool (*)())+0x18>
      m_busyFcn = 0;
      return true;
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    81be:	str.w	r0, [r8]
  return false;  // Caller will set errorCode.
}
    81c2:	mov	r0, r4
    81c4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      m_busyFcn = 0;
    81c8:	movs	r3, #0
    81ca:	str.w	r3, [r8]
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
    81ce:	mov	r0, r4
    81d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    81d4:	.word	0x000f4240
    81d8:	.word	0x20019b78

000081dc <SdioCard::~SdioCard()>:
    81dc:	push	{r4, lr}
    81de:	movs	r1, #12
    81e0:	mov	r4, r0
    81e2:	bl	ae5c <operator delete(void*, unsigned int)>
    81e6:	mov	r0, r4
    81e8:	pop	{r4, pc}
    81ea:	nop

000081ec <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    81ec:	ldr	r3, [pc, #20]	; (8204 <SdioCard::type() const+0x18>)
    81ee:	ldrb	r3, [r3, #0]
    81f0:	cbz	r3, 8200 <SdioCard::type() const+0x14>
    81f2:	ldr	r3, [pc, #20]	; (8208 <SdioCard::type() const+0x1c>)
    81f4:	ldrb	r3, [r3, #0]
    81f6:	cmp	r3, #0
    81f8:	ite	ne
    81fa:	movne	r0, #3
    81fc:	moveq	r0, #2
    81fe:	bx	lr
    8200:	movs	r0, #1
}
    8202:	bx	lr
    8204:	.word	0x20019b64
    8208:	.word	0x20019b7c

0000820c <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    820c:	push	{r3, r4, r5, lr}
    820e:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    8210:	ldr	r0, [pc, #60]	; (8250 <cardCommand(unsigned long, unsigned long)+0x44>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    8212:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    8214:	bl	8168 <waitTimeout(bool (*)())>
    8218:	cbz	r0, 821e <cardCommand(unsigned long, unsigned long)+0x12>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    821a:	movs	r0, #0
    821c:	pop	{r3, r4, r5, pc}
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    821e:	ldr	r2, [pc, #52]	; (8254 <cardCommand(unsigned long, unsigned long)+0x48>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    8220:	ldr	r3, [pc, #52]	; (8258 <cardCommand(unsigned long, unsigned long)+0x4c>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    8222:	str	r5, [r2, #0]
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    8224:	ldr	r0, [pc, #52]	; (825c <cardCommand(unsigned long, unsigned long)+0x50>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    8226:	str	r4, [r3, #0]
  if (waitTimeout(isBusyCommandComplete)) {
    8228:	bl	8168 <waitTimeout(bool (*)())>
    822c:	cmp	r0, #0
    822e:	bne.n	821a <cardCommand(unsigned long, unsigned long)+0xe>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    8230:	ldr	r2, [pc, #44]	; (8260 <cardCommand(unsigned long, unsigned long)+0x54>)
    8232:	ldr	r3, [pc, #48]	; (8264 <cardCommand(unsigned long, unsigned long)+0x58>)
    8234:	ldr	r1, [r2, #0]
    8236:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8238:	ldr	r1, [r3, #0]
    823a:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    823c:	ldr	r2, [r3, #0]
    823e:	lsls	r2, r2, #31
    8240:	bpl.n	821a <cardCommand(unsigned long, unsigned long)+0xe>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    8242:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    8244:	tst.w	r3, #983040	; 0xf0000
    8248:	bne.n	821a <cardCommand(unsigned long, unsigned long)+0xe>
    824a:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    824c:	pop	{r3, r4, r5, pc}
    824e:	nop
    8250:	.word	0x00007fc9
    8254:	.word	0x400b1008
    8258:	.word	0x400b100c
    825c:	.word	0x00007fb1
    8260:	.word	0x400b1030
    8264:	.word	0x20019b8c

00008268 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    8268:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    826a:	ldr	r3, [pc, #28]	; (8288 <isBusyCMD13()+0x20>)
    826c:	ldr	r0, [pc, #28]	; (828c <isBusyCMD13()+0x24>)
    826e:	ldr	r1, [r3, #0]
    8270:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8274:	cbz	r0, 8284 <isBusyCMD13()+0x1c>
    8276:	ldr	r3, [pc, #24]	; (8290 <isBusyCMD13()+0x28>)
    8278:	ldr	r0, [r3, #0]
    827a:	eor.w	r0, r0, #256	; 0x100
    827e:	ubfx	r0, r0, #8, #1
    8282:	pop	{r3, pc}
    8284:	movs	r0, #1
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
    8286:	pop	{r3, pc}
    8288:	.word	0x20019b84
    828c:	.word	0x0d1a0000
    8290:	.word	0x400b1010

00008294 <SdioCard::status()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
    8294:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    8296:	ldr	r3, [pc, #16]	; (82a8 <SdioCard::status()+0x14>)
    8298:	ldr	r0, [pc, #16]	; (82ac <SdioCard::status()+0x18>)
    829a:	ldr	r1, [r3, #0]
    829c:	bl	820c <cardCommand(unsigned long, unsigned long)>
    82a0:	cbz	r0, 82a6 <SdioCard::status()+0x12>
    82a2:	ldr	r3, [pc, #12]	; (82b0 <SdioCard::status()+0x1c>)
    82a4:	ldr	r0, [r3, #0]
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
    82a6:	pop	{r3, pc}
    82a8:	.word	0x20019b84
    82ac:	.word	0x0d1a0000
    82b0:	.word	0x400b1010

000082b4 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    82b4:	push	{r4, r5, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    82b6:	ldr	r3, [pc, #84]	; (830c <readReg16(unsigned long, void*)+0x58>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    82b8:	sub	sp, #20
    82ba:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    82bc:	ldr	r1, [r3, #0]
    82be:	bl	820c <cardCommand(unsigned long, unsigned long)>
    82c2:	cbz	r0, 8306 <readReg16(unsigned long, void*)+0x52>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    82c4:	ldr	r2, [pc, #72]	; (8310 <readReg16(unsigned long, void*)+0x5c>)
    82c6:	ldr	r3, [pc, #76]	; (8314 <readReg16(unsigned long, void*)+0x60>)
    82c8:	ldr	r2, [r2, #0]
    82ca:	str	r2, [sp, #0]
    82cc:	ldr	r1, [r3, #0]
    82ce:	str	r1, [sp, #4]
    82d0:	ldr	r1, [r3, #4]
    82d2:	str	r1, [sp, #8]
    82d4:	adds	r3, #8
    82d6:	add.w	r4, r5, #15
    82da:	ldr	r3, [r3, #0]
    82dc:	str	r3, [sp, #12]
  for (int i = 0; i < 15; i++) {
    82de:	movs	r3, #0
    82e0:	b.n	82e6 <readReg16(unsigned long, void*)+0x32>
    82e2:	ldr.w	r2, [r1, #-16]
    d[14 - i] = sr[i/4] >> 8*(i%4);
    82e6:	and.w	r1, r3, #3
    82ea:	lsls	r1, r1, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    82ec:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    82ee:	lsrs	r2, r1
    82f0:	add.w	lr, sp, #16
    82f4:	bic.w	r1, r3, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    82f8:	cmp	r3, #15
    82fa:	add	r1, lr
    d[14 - i] = sr[i/4] >> 8*(i%4);
    82fc:	strb.w	r2, [r4, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    8300:	bne.n	82e2 <readReg16(unsigned long, void*)+0x2e>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    8302:	movs	r3, #0
    8304:	strb	r3, [r5, #15]
  return true;
}
    8306:	add	sp, #20
    8308:	pop	{r4, r5, pc}
    830a:	nop
    830c:	.word	0x20019b84
    8310:	.word	0x400b1010
    8314:	.word	0x400b1014

00008318 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8318:	ldr	r3, [pc, #20]	; (8330 <waitDmaStatus() [clone .part.4]+0x18>)
    831a:	ldr	r0, [r3, #0]
    831c:	ands.w	r0, r0, #2
    8320:	beq.n	832e <waitDmaStatus() [clone .part.4]+0x16>
    8322:	ldr	r3, [r3, #0]
    8324:	ldr	r0, [pc, #12]	; (8334 <waitDmaStatus() [clone .part.4]+0x1c>)
    8326:	ands	r0, r3
    8328:	clz	r0, r0
    832c:	lsrs	r0, r0, #5
}
    832e:	bx	lr
    8330:	.word	0x20019b8c
    8334:	.word	0x117f0000

00008338 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    8338:	push	{r3, r4, r5, r6, r7, lr}
  if ((3 & (uint32_t)buf) || n == 0) {
    833a:	lsls	r4, r2, #30
    833c:	bne.n	8340 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8>
    833e:	cbnz	r3, 8352 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8340:	ldr	r1, [pc, #124]	; (83c0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    8342:	ldr	r3, [pc, #128]	; (83c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8344:	movs	r0, #37	; 0x25
  m_errorLine = line;
    8346:	movw	r2, #503	; 0x1f7
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    834a:	strb	r0, [r1, #0]
  m_errorLine = line;
    834c:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    834e:	movs	r0, #0
    8350:	pop	{r3, r4, r5, r6, r7, pc}
    8352:	mov	r6, r0
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    8354:	ldr	r0, [pc, #112]	; (83c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
    8356:	mov	r4, r3
    8358:	mov	r7, r1
    835a:	mov	r5, r2
    835c:	bl	8190 <yieldTimeout(bool (*)())>
    8360:	cbnz	r0, 83aa <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8362:	ldr	r1, [pc, #104]	; (83cc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    8364:	ldr	r2, [pc, #104]	; (83d0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    8366:	ldr.w	lr, [pc, #128]	; 83e8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xb0>
    836a:	mov.w	ip, #1
    836e:	strb.w	ip, [lr]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8372:	lsls	r3, r4, #16
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8374:	str	r0, [r1, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8376:	ldr	r4, [pc, #92]	; (83d4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x9c>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    8378:	str	r5, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    837a:	ldr	r2, [pc, #92]	; (83d8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa0>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    837c:	ldr	r1, [pc, #92]	; (83dc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa4>)
    837e:	ldr	r0, [pc, #96]	; (83e0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa8>)
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8380:	orr.w	r3, r3, #512	; 0x200
    8384:	str	r3, [r4, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    8386:	ldrb	r3, [r2, #0]
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8388:	str	r0, [r1, #0]
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    838a:	cbnz	r3, 83ba <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x82>
    838c:	lsls	r1, r7, #9
    838e:	mov	r0, r6
    8390:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8394:	cmp	r0, #0
    8396:	beq.n	834e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    8398:	ldr	r0, [pc, #72]	; (83e4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xac>)
    839a:	bl	8190 <yieldTimeout(bool (*)())>
    839e:	cmp	r0, #0
    83a0:	bne.n	834e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    83a2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    83a6:	b.w	8318 <waitDmaStatus() [clone .part.4]>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83aa:	ldr	r1, [pc, #20]	; (83c0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    83ac:	ldr	r3, [pc, #20]	; (83c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83ae:	movs	r0, #10
  m_errorLine = line;
    83b0:	mov.w	r2, #506	; 0x1fa
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83b4:	strb	r0, [r1, #0]
  m_errorLine = line;
    83b6:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    83b8:	b.n	834e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    83ba:	mov	r1, r7
    83bc:	b.n	838e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x56>
    83be:	nop
    83c0:	.word	0x200138d4
    83c4:	.word	0x20019bac
    83c8:	.word	0x00008269
    83cc:	.word	0x20019b8c
    83d0:	.word	0x400b1000
    83d4:	.word	0x400b1004
    83d8:	.word	0x20019b7c
    83dc:	.word	0x400b1038
    83e0:	.word	0x117f0002
    83e4:	.word	0x00007fed
    83e8:	.word	0x20019ba4

000083ec <SdioCard::sectorCount()>:
//------------------------------------------------------------------------------
bool SdioCard::readStop() {
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
    83ec:	push	{r4, r5, r6}
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    83ee:	ldr	r1, [pc, #100]	; (8454 <SdioCard::sectorCount()+0x68>)
    83f0:	ldrb	r3, [r1, #0]
    83f2:	ands.w	r3, r3, #192	; 0xc0
    83f6:	beq.n	841c <SdioCard::sectorCount()+0x30>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    83f8:	cmp	r3, #64	; 0x40
    83fa:	beq.n	8402 <SdioCard::sectorCount()+0x16>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
  } else {
    return 0;
    83fc:	movs	r0, #0
  return sdCardCapacity(&m_csd);
}
    83fe:	pop	{r4, r5, r6}
    8400:	bx	lr
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    8402:	ldrb	r3, [r1, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    8404:	ldrb	r4, [r1, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    8406:	ldrb	r0, [r1, #8]
    8408:	adds	r2, r3, #1
    840a:	and.w	r3, r4, #63	; 0x3f
    840e:	add.w	r3, r2, r3, lsl #16
    8412:	add.w	r0, r3, r0, lsl #8
    8416:	lsls	r0, r0, #10
    8418:	pop	{r4, r5, r6}
    841a:	bx	lr
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    841c:	ldrb	r5, [r1, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    841e:	ldrb	r3, [r1, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8420:	ldrb	r2, [r1, #7]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    8422:	ldrb	r4, [r1, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    8424:	ldrb	r6, [r1, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    8426:	ldrb	r0, [r1, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8428:	and.w	r1, r5, #3
    842c:	lsls	r1, r1, #1
    842e:	and.w	r3, r3, #3
    8432:	lsls	r2, r2, #2
    8434:	orr.w	r0, r1, r0, lsr #7
    8438:	orr.w	r3, r2, r3, lsl #10
    843c:	and.w	r1, r4, #15
    8440:	orr.w	r3, r3, r6, lsr #6
    8444:	add	r0, r1
    8446:	subs	r0, #7
    8448:	adds	r3, #1
    844a:	lsl.w	r0, r3, r0
    844e:	pop	{r4, r5, r6}
    8450:	bx	lr
    8452:	nop
    8454:	.word	0x20019b94

00008458 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    8458:	push	{r4, r5, r6, lr}
    845a:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    845c:	ldrb	r1, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    845e:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    8460:	cbnz	r1, 84be <SdioCard::erase(unsigned long, unsigned long)+0x66>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    8462:	ldr	r2, [pc, #192]	; (8524 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    8464:	ldrb	r3, [r2, #10]
    8466:	and.w	r0, r3, #64	; 0x40
    846a:	and.w	r4, r0, #255	; 0xff
    846e:	cbz	r0, 8498 <SdioCard::erase(unsigned long, unsigned long)+0x40>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    8470:	ldr	r3, [pc, #180]	; (8528 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    8472:	ldrb	r3, [r3, #0]
    8474:	cbnz	r3, 847a <SdioCard::erase(unsigned long, unsigned long)+0x22>
    firstSector <<= 9;
    8476:	lsls	r5, r5, #9
    lastSector <<= 9;
    8478:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    847a:	mov	r1, r5
    847c:	ldr	r0, [pc, #172]	; (852c <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    847e:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8482:	mov	r4, r0
    8484:	cbnz	r0, 84ce <SdioCard::erase(unsigned long, unsigned long)+0x76>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8486:	ldr	r1, [pc, #168]	; (8530 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    8488:	ldr	r3, [pc, #168]	; (8534 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    848a:	movs	r0, #15
  m_errorLine = line;
    848c:	mov.w	r2, #752	; 0x2f0
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8490:	strb	r0, [r1, #0]
  m_errorLine = line;
    8492:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    8494:	mov	r0, r4
    8496:	pop	{r4, r5, r6, pc}
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    8498:	ldrb	r1, [r2, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    849a:	and.w	r3, r3, #63	; 0x3f
    849e:	lsls	r3, r3, #1
    84a0:	adds	r2, r6, #1
    84a2:	orr.w	r3, r3, r1, lsr #7
    84a6:	orrs	r2, r5
    84a8:	tst	r3, r2
    84aa:	beq.n	8470 <SdioCard::erase(unsigned long, unsigned long)+0x18>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84ac:	ldr	r1, [pc, #128]	; (8530 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    84ae:	ldr	r3, [pc, #132]	; (8534 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84b0:	movs	r0, #39	; 0x27
  m_errorLine = line;
    84b2:	mov.w	r2, #744	; 0x2e8
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84b6:	strb	r0, [r1, #0]
  m_errorLine = line;
    84b8:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    84ba:	mov	r0, r4
    84bc:	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    84be:	ldr	r3, [r0, #0]
    84c0:	ldr	r3, [r3, #24]
    84c2:	blx	r3
    84c4:	mov	r4, r0
    84c6:	cmp	r0, #0
    84c8:	bne.n	8462 <SdioCard::erase(unsigned long, unsigned long)+0xa>
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    84ca:	mov	r0, r4
    84cc:	pop	{r4, r5, r6, pc}
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    84ce:	mov	r1, r6
    84d0:	ldr	r0, [pc, #100]	; (8538 <SdioCard::erase(unsigned long, unsigned long)+0xe0>)
    84d2:	bl	820c <cardCommand(unsigned long, unsigned long)>
    84d6:	mov	r4, r0
    84d8:	cbnz	r0, 84ea <SdioCard::erase(unsigned long, unsigned long)+0x92>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84da:	ldr	r1, [pc, #84]	; (8530 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    84dc:	ldr	r3, [pc, #84]	; (8534 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84de:	movs	r0, #16
  m_errorLine = line;
    84e0:	movw	r2, #755	; 0x2f3
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84e4:	strb	r0, [r1, #0]
  m_errorLine = line;
    84e6:	str	r2, [r3, #0]
    84e8:	b.n	8494 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    84ea:	movs	r1, #0
    84ec:	ldr	r0, [pc, #76]	; (853c <SdioCard::erase(unsigned long, unsigned long)+0xe4>)
    84ee:	bl	820c <cardCommand(unsigned long, unsigned long)>
    84f2:	mov	r4, r0
    84f4:	cbnz	r0, 8506 <SdioCard::erase(unsigned long, unsigned long)+0xae>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84f6:	ldr	r1, [pc, #56]	; (8530 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    84f8:	ldr	r3, [pc, #56]	; (8534 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84fa:	movs	r0, #17
  m_errorLine = line;
    84fc:	movw	r2, #758	; 0x2f6
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8500:	strb	r0, [r1, #0]
  m_errorLine = line;
    8502:	str	r2, [r3, #0]
    8504:	b.n	8494 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    8506:	ldr	r0, [pc, #56]	; (8540 <SdioCard::erase(unsigned long, unsigned long)+0xe8>)
    8508:	bl	8168 <waitTimeout(bool (*)())>
    850c:	cmp	r0, #0
    850e:	beq.n	8494 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8510:	ldr	r1, [pc, #28]	; (8530 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    8512:	ldr	r3, [pc, #32]	; (8534 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8514:	movs	r0, #40	; 0x28
  m_errorLine = line;
    8516:	movw	r2, #761	; 0x2f9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    851a:	strb	r0, [r1, #0]
  m_errorLine = line;
    851c:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    851e:	movs	r4, #0
    8520:	b.n	8494 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
    8522:	nop
    8524:	.word	0x20019b94
    8528:	.word	0x20019b7c
    852c:	.word	0x201a0000
    8530:	.word	0x200138d4
    8534:	.word	0x20019bac
    8538:	.word	0x211a0000
    853c:	.word	0x261b0000
    8540:	.word	0x00008269

00008544 <waitTransferComplete() [clone .part.8]>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    8544:	push	{r4, lr}
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    8546:	ldr	r0, [pc, #56]	; (8580 <waitTransferComplete() [clone .part.8]+0x3c>)
    8548:	bl	8168 <waitTimeout(bool (*)())>
  m_transferActive = false;
    854c:	ldr	r1, [pc, #52]	; (8584 <waitTransferComplete() [clone .part.8]+0x40>)
  m_irqstat = SDHC_IRQSTAT;
    854e:	ldr	r2, [pc, #56]	; (8588 <waitTransferComplete() [clone .part.8]+0x44>)
    8550:	ldr	r3, [pc, #56]	; (858c <waitTransferComplete() [clone .part.8]+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    8552:	movs	r4, #0
    8554:	strb	r4, [r1, #0]
  m_irqstat = SDHC_IRQSTAT;
    8556:	ldr	r1, [r2, #0]
    8558:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    855a:	ldr	r1, [r3, #0]
    855c:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    855e:	cbnz	r0, 8568 <waitTransferComplete() [clone .part.8]+0x24>
    8560:	ldr	r2, [r3, #0]
    8562:	ldr	r3, [pc, #44]	; (8590 <waitTransferComplete() [clone .part.8]+0x4c>)
    8564:	ands	r3, r2
    8566:	cbz	r3, 857a <waitTransferComplete() [clone .part.8]+0x36>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8568:	ldr	r1, [pc, #40]	; (8594 <waitTransferComplete() [clone .part.8]+0x50>)
  m_errorLine = line;
    856a:	ldr	r3, [pc, #44]	; (8598 <waitTransferComplete() [clone .part.8]+0x54>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    856c:	movs	r0, #31
  m_errorLine = line;
    856e:	movw	r2, #638	; 0x27e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8572:	strb	r0, [r1, #0]
  m_errorLine = line;
    8574:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    8576:	movs	r0, #0
  }
  return true;
}
    8578:	pop	{r4, pc}
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
  }
  return true;
    857a:	movs	r0, #1
    857c:	pop	{r4, pc}
    857e:	nop
    8580:	.word	0x00008021
    8584:	.word	0x20019b88
    8588:	.word	0x400b1030
    858c:	.word	0x20019b8c
    8590:	.word	0x117f0000
    8594:	.word	0x200138d4
    8598:	.word	0x20019bac

0000859c <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    859c:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    859e:	ldr	r4, [pc, #104]	; (8608 <SdioCard::readStop()+0x6c>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    85a0:	ldr	r0, [pc, #104]	; (860c <SdioCard::readStop()+0x70>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    85a2:	ldr	r3, [r4, #0]
    85a4:	bic.w	r3, r3, #65536	; 0x10000
    85a8:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    85aa:	movs	r1, #0
    85ac:	bl	820c <cardCommand(unsigned long, unsigned long)>
    85b0:	mov	r5, r0
    85b2:	cbnz	r0, 85c6 <SdioCard::readStop()+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85b4:	ldr	r1, [pc, #88]	; (8610 <SdioCard::readStop()+0x74>)
  m_errorLine = line;
    85b6:	ldr	r3, [pc, #92]	; (8614 <SdioCard::readStop()+0x78>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85b8:	movs	r0, #9
  m_errorLine = line;
    85ba:	movw	r2, #575	; 0x23f
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85be:	strb	r0, [r1, #0]
  m_errorLine = line;
    85c0:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    85c2:	mov	r0, r5
    85c4:	pop	{r4, r5, r6, pc}
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    85c6:	ldr	r0, [pc, #80]	; (8618 <SdioCard::readStop()+0x7c>)
    85c8:	bl	8190 <yieldTimeout(bool (*)())>
    85cc:	cbnz	r0, 85f2 <SdioCard::readStop()+0x56>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    85ce:	ldr	r3, [pc, #76]	; (861c <SdioCard::readStop()+0x80>)
    85d0:	ldr	r3, [r3, #0]
    85d2:	lsls	r3, r3, #30
    85d4:	bpl.n	85c2 <SdioCard::readStop()+0x26>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    85d6:	ldr	r1, [pc, #72]	; (8620 <SdioCard::readStop()+0x84>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    85d8:	ldr	r0, [pc, #72]	; (8624 <SdioCard::readStop()+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    85da:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    85dc:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    85de:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    85e0:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    85e4:	orr.w	r2, r2, #67108864	; 0x4000000
    85e8:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    85ea:	str	r6, [r1, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    85ec:	mov	r0, r5
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    SDHC_PROCTL = proctl;
    85ee:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    85f0:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85f2:	ldr	r1, [pc, #28]	; (8610 <SdioCard::readStop()+0x74>)
  m_errorLine = line;
    85f4:	ldr	r3, [pc, #28]	; (8614 <SdioCard::readStop()+0x78>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85f6:	movs	r0, #10
  m_errorLine = line;
    85f8:	movw	r2, #579	; 0x243
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85fc:	strb	r0, [r1, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    85fe:	movs	r5, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8600:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    8602:	mov	r0, r5
    8604:	pop	{r4, r5, r6, pc}
    8606:	nop
    8608:	.word	0x400b1028
    860c:	.word	0x0cdb0000
    8610:	.word	0x200138d4
    8614:	.word	0x20019bac
    8618:	.word	0x00007fd9
    861c:	.word	0x400b1024
    8620:	.word	0x400b1034
    8624:	.word	0x400b102c

00008628 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    8628:	push	{r4, r5, r6, lr}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    862a:	ldr	r6, [pc, #124]	; (86a8 <SdioCard::writeData(unsigned char const*)+0x80>)
    862c:	ldrb	r3, [r6, #0]
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    862e:	mov	r5, r1
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    8630:	cmp	r3, #0
    8632:	bne.n	869c <SdioCard::writeData(unsigned char const*)+0x74>
  if (!waitTransferComplete()) {
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    8634:	ldr	r3, [pc, #116]	; (86ac <SdioCard::writeData(unsigned char const*)+0x84>)
    8636:	ldr	r3, [r3, #0]
    8638:	lsls	r1, r3, #23
    863a:	bmi.n	864e <SdioCard::writeData(unsigned char const*)+0x26>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    863c:	ldr	r3, [pc, #112]	; (86b0 <SdioCard::writeData(unsigned char const*)+0x88>)
    863e:	ldr	r2, [r3, #0]
    8640:	bic.w	r2, r2, #65536	; 0x10000
    8644:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8646:	ldr	r2, [r3, #0]
    8648:	orr.w	r2, r2, #131072	; 0x20000
    864c:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    864e:	ldr	r2, [pc, #96]	; (86b0 <SdioCard::writeData(unsigned char const*)+0x88>)
  if (waitTimeout(isBusyFifoWrite)) {
    8650:	ldr	r0, [pc, #96]	; (86b4 <SdioCard::writeData(unsigned char const*)+0x8c>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8652:	ldr	r3, [r2, #0]
    8654:	orr.w	r3, r3, #65536	; 0x10000
    8658:	str	r3, [r2, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    865a:	bl	8168 <waitTimeout(bool (*)())>
    865e:	cbnz	r0, 868a <SdioCard::writeData(unsigned char const*)+0x62>
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    8660:	ldr	r4, [pc, #72]	; (86ac <SdioCard::writeData(unsigned char const*)+0x84>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    8662:	ldr	r0, [pc, #84]	; (86b8 <SdioCard::writeData(unsigned char const*)+0x90>)
    8664:	subs	r3, r5, #4
    8666:	add.w	r5, r5, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    866a:	ldr	r2, [r4, #0]
    866c:	lsls	r2, r2, #21
    866e:	bpl.n	866a <SdioCard::writeData(unsigned char const*)+0x42>
    8670:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    8674:	ldr.w	r2, [r3, #4]!
    8678:	str	r2, [r0, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    867a:	cmp	r1, r3
    867c:	bne.n	8674 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    867e:	cmp	r5, r1
    8680:	mov	r3, r1
    8682:	bne.n	866a <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    8684:	movs	r0, #1
    8686:	strb	r0, [r6, #0]
    8688:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    868a:	ldr	r1, [pc, #48]	; (86bc <SdioCard::writeData(unsigned char const*)+0x94>)
  m_errorLine = line;
    868c:	ldr	r3, [pc, #48]	; (86c0 <SdioCard::writeData(unsigned char const*)+0x98>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    868e:	movs	r0, #33	; 0x21
  m_errorLine = line;
    8690:	mov.w	r2, #1012	; 0x3f4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8694:	strb	r0, [r1, #0]
  m_errorLine = line;
    8696:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    8698:	movs	r0, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    869a:	pop	{r4, r5, r6, pc}
    869c:	bl	8544 <waitTransferComplete() [clone .part.8]>
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    86a0:	cmp	r0, #0
    86a2:	bne.n	8634 <SdioCard::writeData(unsigned char const*)+0xc>
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    86a4:	pop	{r4, r5, r6, pc}
    86a6:	nop
    86a8:	.word	0x20019b88
    86ac:	.word	0x400b1024
    86b0:	.word	0x400b1028
    86b4:	.word	0x0000800d
    86b8:	.word	0x400b1020
    86bc:	.word	0x200138d4
    86c0:	.word	0x20019bac

000086c4 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    86c4:	push	{r3, r4, r5, lr}
  if (yieldTimeout(isBusyCMD13)) {
    86c6:	ldr	r0, [pc, #80]	; (8718 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    86c8:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    86ca:	bl	8190 <yieldTimeout(bool (*)())>
    86ce:	cbnz	r0, 8704 <SdioCard::writeStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    86d0:	ldr	r2, [pc, #72]	; (871c <SdioCard::writeStart(unsigned long)+0x58>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    86d2:	ldr	r1, [pc, #76]	; (8720 <SdioCard::writeStart(unsigned long)+0x5c>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    86d4:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    86d6:	ldr	r0, [pc, #76]	; (8724 <SdioCard::writeStart(unsigned long)+0x60>)
    86d8:	ldr	r5, [pc, #76]	; (8728 <SdioCard::writeStart(unsigned long)+0x64>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    86da:	bic.w	r3, r3, #65536	; 0x10000
    86de:	str	r3, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    86e0:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    86e2:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    86e4:	cbnz	r3, 8700 <SdioCard::writeStart(unsigned long)+0x3c>
    86e6:	lsls	r1, r4, #9
    86e8:	ldr	r0, [pc, #64]	; (872c <SdioCard::writeStart(unsigned long)+0x68>)
    86ea:	bl	820c <cardCommand(unsigned long, unsigned long)>
    86ee:	cbnz	r0, 86fe <SdioCard::writeStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86f0:	ldr	r1, [pc, #60]	; (8730 <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    86f2:	ldr	r3, [pc, #64]	; (8734 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86f4:	movs	r4, #14
  m_errorLine = line;
    86f6:	mov.w	r2, #1128	; 0x468
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86fa:	strb	r4, [r1, #0]
  m_errorLine = line;
    86fc:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    86fe:	pop	{r3, r4, r5, pc}
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8700:	mov	r1, r4
    8702:	b.n	86e8 <SdioCard::writeStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8704:	ldr	r1, [pc, #40]	; (8730 <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    8706:	ldr	r3, [pc, #44]	; (8734 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8708:	movs	r0, #10
  m_errorLine = line;
    870a:	movw	r2, #1116	; 0x45c
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    870e:	strb	r0, [r1, #0]
  m_errorLine = line;
    8710:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8712:	movs	r0, #0
    8714:	pop	{r3, r4, r5, pc}
    8716:	nop
    8718:	.word	0x00008269
    871c:	.word	0x400b1028
    8720:	.word	0x20019b7c
    8724:	.word	0x400b1004
    8728:	.word	0xffff0200
    872c:	.word	0x193a0022
    8730:	.word	0x200138d4
    8734:	.word	0x20019bac

00008738 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    8738:	push	{r3, r4, r5, r6, r7, lr}
    873a:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    873c:	ldrb	r0, [r0, #8]
    873e:	lsls	r0, r0, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    8740:	mov	r4, r1
    8742:	mov	r5, r2
    8744:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    8746:	bmi.n	8770 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8748:	cbz	r3, 876c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    874a:	add	r7, r1
    874c:	b.n	8752 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x1a>
    874e:	cmp	r4, r7
    8750:	beq.n	876c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
      if (!writeSector(sector + i, src + i*512UL)) {
    8752:	ldr	r3, [r6, #0]
    8754:	mov	r2, r5
    8756:	mov	r1, r4
    8758:	ldr	r3, [r3, #28]
    875a:	mov	r0, r6
    875c:	blx	r3
    875e:	adds	r4, #1
    8760:	add.w	r5, r5, #512	; 0x200
    8764:	cmp	r0, #0
    8766:	bne.n	874e <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x16>
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
    8768:	movs	r0, #0
    876a:	pop	{r3, r4, r5, r6, r7, pc}
      if (!writeSector(sector + i, src + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    876c:	movs	r0, #1
    876e:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    8770:	lsls	r0, r2, #30
    8772:	beq.n	879a <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    8774:	cmp	r3, #0
    8776:	beq.n	876c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    8778:	add	r7, r1
    877a:	b.n	8780 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x48>
    877c:	cmp	r7, r4
    877e:	beq.n	876c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
        if (!writeSector(sector, ptr)) {
    8780:	ldr	r3, [r6, #0]
    8782:	mov	r2, r5
    8784:	mov	r1, r4
    8786:	ldr	r3, [r3, #28]
    8788:	mov	r0, r6
    878a:	blx	r3
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    878c:	adds	r4, #1
    878e:	add.w	r5, r5, #512	; 0x200
        if (!writeSector(sector, ptr)) {
    8792:	cmp	r0, #0
    8794:	bne.n	877c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x44>
          return false;  // writeSector will set errorCode.
    8796:	movs	r0, #0
    8798:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    879a:	ldr	r0, [pc, #24]	; (87b4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x7c>)
    879c:	bl	8338 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    87a0:	cmp	r0, #0
    87a2:	bne.n	876c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87a4:	ldr	r1, [pc, #16]	; (87b8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x80>)
  m_errorLine = line;
    87a6:	ldr	r3, [pc, #20]	; (87bc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87a8:	movs	r4, #14
  m_errorLine = line;
    87aa:	movw	r2, #1102	; 0x44e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87ae:	strb	r4, [r1, #0]
  m_errorLine = line;
    87b0:	str	r2, [r3, #0]
    87b2:	pop	{r3, r4, r5, r6, r7, pc}
    87b4:	.word	0x193a0027
    87b8:	.word	0x200138d4
    87bc:	.word	0x20019bac

000087c0 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    87c0:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    87c2:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    87c4:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    87c6:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    87c8:	sub.w	sp, sp, #512	; 0x200
    87cc:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    87ce:	bpl.n	8804 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    87d0:	lsls	r3, r5, #30
    87d2:	beq.n	87e2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x22>
      ptr = aligned;
      memcpy(aligned, src, 512);
    87d4:	mov	r1, r5
    87d6:	mov	r0, sp
    87d8:	mov.w	r2, #512	; 0x200
    87dc:	bl	9220 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    87e0:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    87e2:	mov	r2, r5
    87e4:	mov	r1, r6
    87e6:	movs	r3, #1
    87e8:	ldr	r0, [pc, #144]	; (887c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    87ea:	bl	8338 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    87ee:	cbnz	r0, 87fe <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87f0:	ldr	r1, [pc, #140]	; (8880 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc0>)
  m_errorLine = line;
    87f2:	ldr	r3, [pc, #144]	; (8884 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87f4:	movs	r4, #13
  m_errorLine = line;
    87f6:	movw	r2, #1046	; 0x416
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87fa:	strb	r4, [r1, #0]
  m_errorLine = line;
    87fc:	str	r2, [r3, #0]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    87fe:	add.w	sp, sp, #512	; 0x200
    8802:	pop	{r4, r5, r6, pc}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    8804:	ldr	r3, [pc, #128]	; (8888 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc8>)
    8806:	ldrb	r3, [r3, #0]
    8808:	mov	r4, r0
    880a:	cbnz	r3, 882e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
    if (!waitTransferComplete()) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    880c:	ldr	r3, [pc, #124]	; (888c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xcc>)
    880e:	ldr	r3, [r3, #0]
    8810:	lsrs	r3, r3, #16
    8812:	lsls	r3, r3, #16
    8814:	cbz	r3, 886c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xac>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8816:	ldrb	r3, [r4, #9]
    8818:	cmp	r3, #2
    881a:	beq.n	883a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x7a>
      if (!syncDevice()) {
    881c:	ldr	r3, [r4, #0]
    881e:	mov	r0, r4
    8820:	ldr	r3, [r3, #24]
    8822:	blx	r3
    8824:	cbnz	r0, 8842 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x82>
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    8826:	movs	r0, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    8828:	add.w	sp, sp, #512	; 0x200
    882c:	pop	{r4, r5, r6, pc}
    882e:	bl	8544 <waitTransferComplete() [clone .part.8]>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8832:	cmp	r0, #0
    8834:	bne.n	880c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4c>
      return false;
    8836:	movs	r0, #0
    8838:	b.n	8828 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x68>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    883a:	ldr	r3, [r4, #4]
    883c:	cmp	r6, r3
    883e:	bne.n	881c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x5c>
    8840:	b.n	8856 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x96>
      if (!syncDevice()) {
        return false;
      }
      if (!writeStart(sector )) {
    8842:	ldr	r3, [r4, #0]
    8844:	mov	r1, r6
    8846:	ldr	r3, [r3, #72]	; 0x48
    8848:	mov	r0, r4
    884a:	blx	r3
    884c:	cmp	r0, #0
    884e:	beq.n	8826 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    8850:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    8852:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    8854:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    8856:	ldr	r3, [r4, #0]
    8858:	mov	r1, r5
    885a:	ldr	r3, [r3, #68]	; 0x44
    885c:	mov	r0, r4
    885e:	blx	r3
    8860:	cmp	r0, #0
    8862:	beq.n	8826 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
      return false;
    }
    m_curSector++;
    8864:	ldr	r3, [r4, #4]
    8866:	adds	r3, #1
    8868:	str	r3, [r4, #4]
    886a:	b.n	87fe <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    886c:	ldr	r3, [r4, #0]
    886e:	mov	r0, r4
    8870:	ldr	r3, [r3, #24]
    8872:	blx	r3
    8874:	cmp	r0, #0
    8876:	bne.n	8816 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x56>
    8878:	b.n	8826 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
    887a:	nop
    887c:	.word	0x183a0001
    8880:	.word	0x200138d4
    8884:	.word	0x20019bac
    8888:	.word	0x20019b88
    888c:	.word	0x400b1004

00008890 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    8890:	push	{r3, r4, r5, r6, r7, lr}
    8892:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    8894:	ldrb	r0, [r0, #8]
    8896:	lsls	r0, r0, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    8898:	mov	r4, r1
    889a:	mov	r5, r2
    889c:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    889e:	bmi.n	88c8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    88a0:	cbz	r3, 88c4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    88a2:	add	r7, r1
    88a4:	b.n	88aa <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x1a>
    88a6:	cmp	r4, r7
    88a8:	beq.n	88c4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
      if (!readSector(sector + i, dst + i*512UL)) {
    88aa:	ldr	r3, [r6, #0]
    88ac:	mov	r2, r5
    88ae:	mov	r1, r4
    88b0:	ldr	r3, [r3, #12]
    88b2:	mov	r0, r6
    88b4:	blx	r3
    88b6:	adds	r4, #1
    88b8:	add.w	r5, r5, #512	; 0x200
    88bc:	cmp	r0, #0
    88be:	bne.n	88a6 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x16>
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
    88c0:	movs	r0, #0
    88c2:	pop	{r3, r4, r5, r6, r7, pc}
      if (!readSector(sector + i, dst + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    88c4:	movs	r0, #1
    88c6:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
    88c8:	lsls	r0, r2, #30
    88ca:	beq.n	88f2 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    88cc:	cmp	r3, #0
    88ce:	beq.n	88c4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    88d0:	add	r7, r1
    88d2:	b.n	88d8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    88d4:	cmp	r7, r4
    88d6:	beq.n	88c4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
        if (!readSector(sector, dst)) {
    88d8:	ldr	r3, [r6, #0]
    88da:	mov	r2, r5
    88dc:	mov	r1, r4
    88de:	ldr	r3, [r3, #12]
    88e0:	mov	r0, r6
    88e2:	blx	r3
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    88e4:	adds	r4, #1
    88e6:	add.w	r5, r5, #512	; 0x200
        if (!readSector(sector, dst)) {
    88ea:	cmp	r0, #0
    88ec:	bne.n	88d4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x44>
          return false;  // readSector will set errorCode.
    88ee:	movs	r0, #0
    88f0:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    88f2:	ldr	r0, [pc, #24]	; (890c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x7c>)
    88f4:	bl	8338 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    88f8:	cmp	r0, #0
    88fa:	bne.n	88c4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    88fc:	ldr	r1, [pc, #16]	; (8910 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x80>)
  m_errorLine = line;
    88fe:	ldr	r3, [pc, #20]	; (8914 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8900:	movs	r4, #12
  m_errorLine = line;
    8902:	movw	r2, #909	; 0x38d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8906:	strb	r4, [r1, #0]
  m_errorLine = line;
    8908:	str	r2, [r3, #0]
    890a:	pop	{r3, r4, r5, r6, r7, pc}
    890c:	.word	0x123a0037
    8910:	.word	0x200138d4
    8914:	.word	0x20019bac

00008918 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8918:	push	{r3, r4, r5, r6, r7, lr}
    891a:	mov	r5, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    891c:	ldr	r0, [pc, #116]	; (8994 <cardCMD6(unsigned long, unsigned char*)+0x7c>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    891e:	mov	r4, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8920:	bl	8168 <waitTimeout(bool (*)())>
    8924:	cbz	r0, 8938 <cardCMD6(unsigned long, unsigned char*)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8926:	ldr	r1, [pc, #112]	; (8998 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    8928:	ldr	r3, [pc, #112]	; (899c <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    892a:	movs	r0, #10
  m_errorLine = line;
    892c:	mov.w	r2, #410	; 0x19a
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8930:	strb	r0, [r1, #0]
  m_errorLine = line;
    8932:	str	r2, [r3, #0]
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8934:	movs	r0, #0
    8936:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8938:	ldr	r2, [pc, #100]	; (89a0 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    893a:	ldr.w	lr, [pc, #132]	; 89c0 <cardCMD6(unsigned long, unsigned char*)+0xa8>
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    893e:	ldr	r7, [pc, #100]	; (89a4 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8940:	ldr	r6, [pc, #100]	; (89a8 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8942:	ldr	r3, [pc, #104]	; (89ac <cardCMD6(unsigned long, unsigned char*)+0x94>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    8944:	mov.w	ip, #1
    8948:	strb.w	ip, [lr]
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    894c:	mov	r1, r5
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    894e:	str	r0, [r2, #0]
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8950:	ldr	r5, [pc, #92]	; (89b0 <cardCMD6(unsigned long, unsigned char*)+0x98>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8952:	ldr	r2, [pc, #96]	; (89b4 <cardCMD6(unsigned long, unsigned char*)+0x9c>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    8954:	str	r4, [r7, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8956:	ldr	r0, [pc, #96]	; (89b8 <cardCMD6(unsigned long, unsigned char*)+0xa0>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8958:	str	r5, [r6, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    895a:	str	r2, [r3, #0]
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    895c:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8960:	cbnz	r0, 8972 <cardCMD6(unsigned long, unsigned char*)+0x5a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8962:	ldr	r1, [pc, #52]	; (8998 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    8964:	ldr	r3, [pc, #52]	; (899c <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8966:	movs	r4, #4
  m_errorLine = line;
    8968:	movw	r2, #417	; 0x1a1
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    896c:	strb	r4, [r1, #0]
  m_errorLine = line;
    896e:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    8970:	pop	{r3, r4, r5, r6, r7, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    8972:	ldr	r0, [pc, #72]	; (89bc <cardCMD6(unsigned long, unsigned char*)+0xa4>)
    8974:	bl	8190 <yieldTimeout(bool (*)())>
    8978:	cbnz	r0, 8982 <cardCMD6(unsigned long, unsigned char*)+0x6a>
    897a:	bl	8318 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    897e:	cbz	r0, 8982 <cardCMD6(unsigned long, unsigned char*)+0x6a>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    8980:	pop	{r3, r4, r5, r6, r7, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8982:	ldr	r1, [pc, #20]	; (8998 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    8984:	ldr	r3, [pc, #20]	; (899c <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8986:	movs	r0, #37	; 0x25
  m_errorLine = line;
    8988:	mov.w	r2, #420	; 0x1a4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    898c:	strb	r0, [r1, #0]
  m_errorLine = line;
    898e:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    8990:	movs	r0, #0
    8992:	pop	{r3, r4, r5, r6, r7, pc}
    8994:	.word	0x00008269
    8998:	.word	0x200138d4
    899c:	.word	0x20019bac
    89a0:	.word	0x20019b8c
    89a4:	.word	0x400b1000
    89a8:	.word	0x400b1004
    89ac:	.word	0x400b1038
    89b0:	.word	0x00010040
    89b4:	.word	0x117f0002
    89b8:	.word	0x063a0011
    89bc:	.word	0x00007fed
    89c0:	.word	0x20019ba4

000089c4 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    89c4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    89c8:	ldr	r5, [pc, #568]	; (8c04 <SdioCard::begin(SdioConfig)+0x240>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    89ca:	ldr	r4, [pc, #572]	; (8c08 <SdioCard::begin(SdioConfig)+0x244>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    89cc:	ldr.w	r8, [pc, #684]	; 8c7c <SdioCard::begin(SdioConfig)+0x2b8>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    89d0:	ldr	r7, [pc, #568]	; (8c0c <SdioCard::begin(SdioConfig)+0x248>)
  m_version2 = false;
    89d2:	ldr	r6, [pc, #572]	; (8c10 <SdioCard::begin(SdioConfig)+0x24c>)
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    89d4:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    89d6:	movs	r3, #0
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    89d8:	strb	r3, [r5, #0]
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
    89da:	strb	r3, [r0, #9]
  m_initDone = false;
    89dc:	strb.w	r3, [r8]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    89e0:	strb	r3, [r7, #0]
  m_version2 = false;
    89e2:	strb	r3, [r6, #0]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    89e4:	ldr	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    89e6:	ldr	r2, [pc, #556]	; (8c14 <SdioCard::begin(SdioConfig)+0x250>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    89e8:	ldr	r0, [pc, #556]	; (8c18 <SdioCard::begin(SdioConfig)+0x254>)
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    89ea:	ldr	r1, [pc, #560]	; (8c1c <SdioCard::begin(SdioConfig)+0x258>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    89ec:	ldr.w	lr, [pc, #656]	; 8c80 <SdioCard::begin(SdioConfig)+0x2bc>
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    89f0:	orr.w	r3, r3, #201326592	; 0xc000000
    89f4:	str	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    89f6:	ldr	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    89f8:	add.w	r4, r4, #260096	; 0x3f800
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    89fc:	orr.w	r3, r3, #131072	; 0x20000
    8a00:	str	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8a02:	adds	r4, #12
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8a04:	add.w	r2, r2, #428032	; 0x68800
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a08:	movw	r3, #259	; 0x103
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8a0c:	addw	r2, r2, #2044	; 0x7fc
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a10:	str	r3, [r0, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8a12:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8a16:	str	r3, [r1, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8a18:	str	r3, [r4, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8a1a:	str	r3, [r0, #16]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8a1c:	str	r3, [r1, #12]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8a1e:	ldr	r3, [r2, #0]
    8a20:	orr.w	r3, r3, #16777216	; 0x1000000
    8a24:	orr.w	r3, r3, #32768	; 0x8000
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    8a28:	sub	sp, #68	; 0x44
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8a2a:	str	r3, [r2, #0]

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    8a2c:	ldr	r3, [r2, #0]
    8a2e:	ldr	r4, [pc, #496]	; (8c20 <SdioCard::begin(SdioConfig)+0x25c>)
    8a30:	lsls	r1, r3, #7
    8a32:	bmi.n	8a2c <SdioCard::begin(SdioConfig)+0x68>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8a34:	mov.w	r0, #400	; 0x190
    8a38:	bl	8038 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a3c:	ldr.w	ip, [pc, #472]	; 8c18 <SdioCard::begin(SdioConfig)+0x254>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8a40:	ldr.w	lr, [pc, #572]	; 8c80 <SdioCard::begin(SdioConfig)+0x2bc>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8a44:	ldr	r1, [pc, #468]	; (8c1c <SdioCard::begin(SdioConfig)+0x258>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8a46:	ldr	r2, [pc, #476]	; (8c24 <SdioCard::begin(SdioConfig)+0x260>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8a48:	ldr	r0, [pc, #476]	; (8c28 <SdioCard::begin(SdioConfig)+0x264>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a4a:	movw	r3, #1091	; 0x443
    8a4e:	str.w	r3, [ip]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8a52:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8a56:	mov.w	lr, #1088	; 0x440
    8a5a:	str.w	lr, [r1]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8a5e:	str	r3, [r2, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8a60:	add.w	r2, r2, #409600	; 0x64000
    8a64:	adds	r2, #40	; 0x28

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8a66:	str	r3, [r0, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8a68:	ldr	r0, [pc, #448]	; (8c2c <SdioCard::begin(SdioConfig)+0x268>)
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8a6a:	str	r3, [r1, #12]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8a6c:	str	r0, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    8a6e:	ldr	r1, [pc, #448]	; (8c30 <SdioCard::begin(SdioConfig)+0x26c>)
    8a70:	movs	r0, #81	; 0x51
    8a72:	bl	98d0 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8a76:	ldr	r3, [pc, #444]	; (8c34 <SdioCard::begin(SdioConfig)+0x270>)

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8a78:	ldr	r1, [pc, #444]	; (8c38 <SdioCard::begin(SdioConfig)+0x274>)
    8a7a:	movs	r0, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8a7c:	mov.w	r2, #131072	; 0x20000

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8a80:	strb	r0, [r1, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8a82:	str	r2, [r3, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    8a84:	ldr	r3, [r4, #0]
    8a86:	orr.w	r3, r3, #134217728	; 0x8000000
    8a8a:	str	r3, [r4, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    8a8c:	ldr	r1, [r4, #0]
    8a8e:	ands.w	r1, r1, #134217728	; 0x8000000
    8a92:	bne.n	8a8c <SdioCard::begin(SdioConfig)+0xc8>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    8a94:	mov	r0, r1
    8a96:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8a9a:	mov	r4, r0
    8a9c:	cmp	r0, #0
    8a9e:	beq.n	8b3e <SdioCard::begin(SdioConfig)+0x17a>
    8aa0:	movs	r4, #3
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    8aa2:	mov.w	r1, #426	; 0x1aa
    8aa6:	ldr	r0, [pc, #404]	; (8c3c <SdioCard::begin(SdioConfig)+0x278>)
    8aa8:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8aac:	cmp	r0, #0
    8aae:	bne.n	8b6c <SdioCard::begin(SdioConfig)+0x1a8>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    8ab0:	subs	r4, #1
    8ab2:	bne.n	8aa2 <SdioCard::begin(SdioConfig)+0xde>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    8ab4:	ldrb	r3, [r6, #0]
    8ab6:	ldr	r6, [pc, #392]	; (8c40 <SdioCard::begin(SdioConfig)+0x27c>)
    8ab8:	cmp	r3, #0
    8aba:	it	eq
    8abc:	moveq.w	r6, #3145728	; 0x300000
  int m = micros();
    8ac0:	bl	9944 <micros>
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8ac4:	ldr	r4, [pc, #380]	; (8c44 <SdioCard::begin(SdioConfig)+0x280>)
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
    8ac6:	mov	r9, r0
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8ac8:	movs	r1, #0
    8aca:	ldr	r0, [pc, #380]	; (8c48 <SdioCard::begin(SdioConfig)+0x284>)
    8acc:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8ad0:	cbnz	r0, 8ae8 <SdioCard::begin(SdioConfig)+0x124>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8ad2:	ldr	r2, [pc, #376]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8ad4:	mov.w	r1, #676	; 0x2a4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8ad8:	movs	r3, #23
  m_errorLine = line;
    8ada:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8adc:	strb	r3, [r5, #0]
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    8ade:	movs	r4, #0

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    8ae0:	mov	r0, r4
    8ae2:	add	sp, #68	; 0x44
    8ae4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8ae8:	mov	r1, r6
    8aea:	ldr	r0, [pc, #356]	; (8c50 <SdioCard::begin(SdioConfig)+0x28c>)
    8aec:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8af0:	cmp	r0, #0
    8af2:	beq.n	8ad2 <SdioCard::begin(SdioConfig)+0x10e>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    8af4:	bl	9944 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8af8:	ldr	r3, [pc, #344]	; (8c54 <SdioCard::begin(SdioConfig)+0x290>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8afa:	ldr	r2, [pc, #328]	; (8c44 <SdioCard::begin(SdioConfig)+0x280>)
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8afc:	rsb	r0, r9, r0
    8b00:	cmp	r0, r3
    8b02:	bhi.n	8ad2 <SdioCard::begin(SdioConfig)+0x10e>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8b04:	ldr	r3, [r4, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    8b06:	cmp	r3, #0
    8b08:	bge.n	8ac8 <SdioCard::begin(SdioConfig)+0x104>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    8b0a:	ldr	r3, [pc, #332]	; (8c58 <SdioCard::begin(SdioConfig)+0x294>)
    8b0c:	ldr	r1, [r2, #0]
    8b0e:	str	r1, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8b10:	ldr	r3, [r2, #0]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8b12:	ldr	r0, [pc, #328]	; (8c5c <SdioCard::begin(SdioConfig)+0x298>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    8b14:	lsls	r2, r3, #1
    // Is high capacity.
    m_highCapacity = true;
    8b16:	it	mi
    8b18:	movmi	r3, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8b1a:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8b1e:	it	mi
    8b20:	strbmi	r3, [r7, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8b22:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8b26:	mov	r4, r0
    8b28:	cbnz	r0, 8b52 <SdioCard::begin(SdioConfig)+0x18e>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b2a:	ldr	r2, [pc, #288]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8b2c:	movw	r1, #685	; 0x2ad
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b30:	movs	r3, #2

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    8b32:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b34:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b36:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    8b38:	add	sp, #68	; 0x44
    8b3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b3e:	ldr	r2, [pc, #268]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8b40:	movw	r1, #659	; 0x293
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b44:	movs	r3, #1

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    8b46:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b48:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b4a:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    8b4c:	add	sp, #68	; 0x44
    8b4e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    8b52:	movs	r1, #0
    8b54:	ldr	r0, [pc, #264]	; (8c60 <SdioCard::begin(SdioConfig)+0x29c>)
    8b56:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8b5a:	mov	r4, r0
    8b5c:	cbnz	r0, 8b8e <SdioCard::begin(SdioConfig)+0x1ca>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b5e:	ldr	r2, [pc, #236]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8b60:	mov.w	r1, #688	; 0x2b0
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b64:	movs	r3, #3
  m_errorLine = line;
    8b66:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b68:	strb	r3, [r5, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
    8b6a:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
    8b6c:	ldr	r3, [pc, #212]	; (8c44 <SdioCard::begin(SdioConfig)+0x280>)
    8b6e:	ldr	r3, [r3, #0]
    8b70:	cmp.w	r3, #426	; 0x1aa
    8b74:	beq.n	8b86 <SdioCard::begin(SdioConfig)+0x1c2>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b76:	ldr	r2, [pc, #212]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8b78:	movw	r1, #665	; 0x299
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b7c:	movs	r3, #6
  m_errorLine = line;
    8b7e:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b80:	strb	r3, [r5, #0]
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
    8b82:	movs	r4, #0
    8b84:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>
      }
      m_version2 = true;
    8b86:	movs	r3, #1
    8b88:	strb	r3, [r6, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    8b8a:	ldr	r6, [pc, #180]	; (8c40 <SdioCard::begin(SdioConfig)+0x27c>)
    8b8c:	b.n	8ac0 <SdioCard::begin(SdioConfig)+0xfc>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8b8e:	ldr	r3, [pc, #180]	; (8c44 <SdioCard::begin(SdioConfig)+0x280>)
    8b90:	ldr	r6, [pc, #208]	; (8c64 <SdioCard::begin(SdioConfig)+0x2a0>)
    8b92:	ldr	r3, [r3, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8b94:	ldr	r1, [pc, #208]	; (8c68 <SdioCard::begin(SdioConfig)+0x2a4>)
    8b96:	ldr	r0, [pc, #212]	; (8c6c <SdioCard::begin(SdioConfig)+0x2a8>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8b98:	lsrs	r3, r3, #16
    8b9a:	lsls	r3, r3, #16
    8b9c:	str	r3, [r6, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8b9e:	bl	82b4 <readReg16(unsigned long, void*)>
    8ba2:	mov	r4, r0
    8ba4:	cbnz	r0, 8bb4 <SdioCard::begin(SdioConfig)+0x1f0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8ba6:	ldr	r2, [pc, #164]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8ba8:	movw	r1, #693	; 0x2b5
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bac:	movs	r3, #7
  m_errorLine = line;
    8bae:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bb0:	strb	r3, [r5, #0]
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
    8bb2:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    8bb4:	ldr	r1, [pc, #184]	; (8c70 <SdioCard::begin(SdioConfig)+0x2ac>)
    8bb6:	ldr	r0, [pc, #188]	; (8c74 <SdioCard::begin(SdioConfig)+0x2b0>)
    8bb8:	bl	82b4 <readReg16(unsigned long, void*)>
    8bbc:	mov	r4, r0
    8bbe:	cbnz	r0, 8bce <SdioCard::begin(SdioConfig)+0x20a>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8bc0:	ldr	r2, [pc, #136]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8bc2:	mov.w	r1, #696	; 0x2b8
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bc6:	movs	r3, #8
  m_errorLine = line;
    8bc8:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bca:	strb	r3, [r5, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
    8bcc:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    8bce:	ldr	r1, [r6, #0]
    8bd0:	ldr	r0, [pc, #164]	; (8c78 <SdioCard::begin(SdioConfig)+0x2b4>)
    8bd2:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8bd6:	mov	r4, r0
    8bd8:	cbnz	r0, 8be8 <SdioCard::begin(SdioConfig)+0x224>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8bda:	ldr	r2, [pc, #112]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8bdc:	movw	r1, #699	; 0x2bb
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8be0:	movs	r3, #5
  m_errorLine = line;
    8be2:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8be4:	strb	r3, [r5, #0]
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
    8be6:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8be8:	ldr	r1, [r6, #0]
    8bea:	ldr	r0, [pc, #92]	; (8c48 <SdioCard::begin(SdioConfig)+0x284>)
    8bec:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8bf0:	cmp	r0, #0
    8bf2:	bne.n	8c84 <SdioCard::begin(SdioConfig)+0x2c0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8bf4:	ldr	r2, [pc, #84]	; (8c4c <SdioCard::begin(SdioConfig)+0x288>)
    8bf6:	movw	r1, #703	; 0x2bf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bfa:	movs	r3, #20
  m_errorLine = line;
    8bfc:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bfe:	strb	r3, [r5, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8c00:	movs	r4, #0
    8c02:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>
    8c04:	.word	0x200138d4
    8c08:	.word	0x4000d800
    8c0c:	.word	0x20019b7c
    8c10:	.word	0x20019b64
    8c14:	.word	0x40048030
    8c18:	.word	0x4004d000
    8c1c:	.word	0x4004d008
    8c20:	.word	0x400b102c
    8c24:	.word	0x4004d00c
    8c28:	.word	0x4004d010
    8c2c:	.word	0x117f000b
    8c30:	.word	0x00007f81
    8c34:	.word	0xe000e108
    8c38:	.word	0xe000e451
    8c3c:	.word	0x081a0000
    8c40:	.word	0x40300000
    8c44:	.word	0x400b1010
    8c48:	.word	0x371a0000
    8c4c:	.word	0x20019bac
    8c50:	.word	0x29020000
    8c54:	.word	0x000f4240
    8c58:	.word	0x20019b80
    8c5c:	.word	0x02090000
    8c60:	.word	0x031a0000
    8c64:	.word	0x20019b84
    8c68:	.word	0x20019b94
    8c6c:	.word	0x09090000
    8c70:	.word	0x20019b68
    8c74:	.word	0x0a090000
    8c78:	.word	0x071b0000
    8c7c:	.word	0x20019b90
    8c80:	.word	0x4004d004
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8c84:	movs	r1, #2
    8c86:	ldr	r0, [pc, #168]	; (8d30 <SdioCard::begin(SdioConfig)+0x36c>)
    8c88:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8c8c:	mov	r4, r0
    8c8e:	cmp	r0, #0
    8c90:	beq.n	8bf4 <SdioCard::begin(SdioConfig)+0x230>
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8c92:	ldr	r3, [pc, #160]	; (8d34 <SdioCard::begin(SdioConfig)+0x370>)
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8c94:	ldr	r0, [pc, #160]	; (8d38 <SdioCard::begin(SdioConfig)+0x374>)
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8c96:	ldr	r2, [r3, #0]
    8c98:	bic.w	r2, r2, #6
    8c9c:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8c9e:	ldr	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8ca0:	mov.w	r5, #1048592	; 0x100010
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8ca4:	orr.w	r2, r2, #2
    8ca8:	str	r2, [r3, #0]
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8caa:	mov	r1, sp
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8cac:	str	r5, [r0, #0]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8cae:	mvn.w	r0, #4278190080	; 0xff000000
    8cb2:	bl	8918 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8cb6:	cbz	r0, 8cc0 <SdioCard::begin(SdioConfig)+0x2fc>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8cb8:	ldrb.w	r3, [sp, #13]
    8cbc:	lsls	r3, r3, #30
    8cbe:	bmi.n	8d12 <SdioCard::begin(SdioConfig)+0x34e>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8cc0:	movw	r0, #25000	; 0x61a8
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8cc4:	ldr.w	fp, [pc, #132]	; 8d4c <SdioCard::begin(SdioConfig)+0x388>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8cc8:	ldr.w	sl, [pc, #132]	; 8d50 <SdioCard::begin(SdioConfig)+0x38c>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8ccc:	ldr.w	r9, [pc, #132]	; 8d54 <SdioCard::begin(SdioConfig)+0x390>
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8cd0:	ldr	r7, [pc, #104]	; (8d3c <SdioCard::begin(SdioConfig)+0x378>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8cd2:	ldr	r6, [pc, #108]	; (8d40 <SdioCard::begin(SdioConfig)+0x37c>)
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8cd4:	ldr	r5, [pc, #108]	; (8d44 <SdioCard::begin(SdioConfig)+0x380>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8cd6:	movw	r3, #259	; 0x103
    8cda:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8cde:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8ce2:	str.w	r3, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8ce6:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8ce8:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8cea:	str	r3, [r5, #0]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8cec:	bl	8038 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8cf0:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8cf4:	mov.w	r1, #1088	; 0x440
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8cf8:	movs	r2, #1
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8cfa:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8cfe:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8d02:	str.w	r1, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8d06:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8d08:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8d0a:	str	r3, [r5, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8d0c:	strb.w	r2, [r8]
  return true;
    8d10:	b.n	8ae0 <SdioCard::begin(SdioConfig)+0x11c>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8d12:	mov	r1, sp
    8d14:	ldr	r0, [pc, #48]	; (8d48 <SdioCard::begin(SdioConfig)+0x384>)
    8d16:	bl	8918 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8d1a:	cmp	r0, #0
    8d1c:	beq.n	8cc0 <SdioCard::begin(SdioConfig)+0x2fc>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8d1e:	ldrb.w	r3, [sp, #16]
    8d22:	and.w	r3, r3, #15
    8d26:	cmp	r3, #1
    8d28:	bne.n	8cc0 <SdioCard::begin(SdioConfig)+0x2fc>
    kHzSdClk = 50000;
    8d2a:	movw	r0, #50000	; 0xc350
    8d2e:	b.n	8cc4 <SdioCard::begin(SdioConfig)+0x300>
    8d30:	.word	0x061a0000
    8d34:	.word	0x400b1028
    8d38:	.word	0x400b1044
    8d3c:	.word	0x4004d00c
    8d40:	.word	0x4004d010
    8d44:	.word	0x4004d014
    8d48:	.word	0x80fffff1
    8d4c:	.word	0x4004d000
    8d50:	.word	0x4004d004
    8d54:	.word	0x4004d008

00008d58 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8d58:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8d5a:	ldr	r3, [pc, #160]	; (8dfc <SdioCard::readData(unsigned char*)+0xa4>)
    8d5c:	ldr	r3, [r3, #0]
    8d5e:	lsls	r0, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8d60:	mov	r5, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8d62:	bmi.n	8d82 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8d64:	ldr	r3, [pc, #152]	; (8e00 <SdioCard::readData(unsigned char*)+0xa8>)
    8d66:	ldr	r2, [r3, #0]
    8d68:	bic.w	r2, r2, #65536	; 0x10000
    8d6c:	str	r2, [r3, #0]
    noInterrupts();
    8d6e:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8d70:	ldr	r2, [r3, #0]
    8d72:	orr.w	r2, r2, #131072	; 0x20000
    8d76:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8d78:	ldr	r2, [r3, #0]
    8d7a:	orr.w	r2, r2, #65536	; 0x10000
    8d7e:	str	r2, [r3, #0]
    interrupts();
    8d80:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8d82:	ldr	r0, [pc, #128]	; (8e04 <SdioCard::readData(unsigned char*)+0xac>)
    8d84:	bl	8168 <waitTimeout(bool (*)())>
    8d88:	cmp	r0, #0
    8d8a:	bne.n	8dea <SdioCard::readData(unsigned char*)+0x92>
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8d8c:	ldr	r4, [pc, #108]	; (8dfc <SdioCard::readData(unsigned char*)+0xa4>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8d8e:	ldr	r0, [pc, #120]	; (8e08 <SdioCard::readData(unsigned char*)+0xb0>)
    8d90:	subs	r3, r5, #4
    8d92:	add.w	r5, r5, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8d96:	ldr	r2, [r4, #0]
    8d98:	lsls	r1, r2, #20
    8d9a:	bpl.n	8d96 <SdioCard::readData(unsigned char*)+0x3e>
    8d9c:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8da0:	ldr	r2, [r0, #0]
    8da2:	str.w	r2, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8da6:	cmp	r1, r3
    8da8:	bne.n	8da0 <SdioCard::readData(unsigned char*)+0x48>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8daa:	cmp	r5, r1
    8dac:	mov	r3, r1
    8dae:	bne.n	8d96 <SdioCard::readData(unsigned char*)+0x3e>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    8db0:	ldr	r0, [pc, #88]	; (8e0c <SdioCard::readData(unsigned char*)+0xb4>)
    8db2:	bl	8168 <waitTimeout(bool (*)())>
    8db6:	cbnz	r0, 8dd8 <SdioCard::readData(unsigned char*)+0x80>
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    8db8:	ldr	r2, [pc, #84]	; (8e10 <SdioCard::readData(unsigned char*)+0xb8>)
    8dba:	ldr	r3, [pc, #88]	; (8e14 <SdioCard::readData(unsigned char*)+0xbc>)
    8dbc:	ldr	r1, [r2, #0]
    8dbe:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8dc0:	ldr	r1, [r3, #0]
    8dc2:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8dc4:	ldr	r2, [r3, #0]
    8dc6:	lsls	r2, r2, #30
    8dc8:	bpl.n	8dfa <SdioCard::readData(unsigned char*)+0xa2>
    8dca:	ldr	r3, [r3, #0]
    8dcc:	ldr	r0, [pc, #72]	; (8e18 <SdioCard::readData(unsigned char*)+0xc0>)
    8dce:	ands	r0, r3
    8dd0:	clz	r0, r0
    8dd4:	lsrs	r0, r0, #5
    8dd6:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8dd8:	ldr	r1, [pc, #64]	; (8e1c <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    8dda:	ldr	r3, [pc, #68]	; (8e20 <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8ddc:	movs	r0, #29
  m_errorLine = line;
    8dde:	movw	r2, #843	; 0x34b
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8de2:	strb	r0, [r1, #0]
  m_errorLine = line;
    8de4:	str	r2, [r3, #0]
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
    8de6:	movs	r0, #0
    8de8:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8dea:	ldr	r1, [pc, #48]	; (8e1c <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    8dec:	ldr	r3, [pc, #48]	; (8e20 <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8dee:	movs	r0, #26
  m_errorLine = line;
    8df0:	mov.w	r2, #832	; 0x340
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8df4:	strb	r0, [r1, #0]
  m_errorLine = line;
    8df6:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    8df8:	movs	r0, #0
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    8dfa:	pop	{r3, r4, r5, pc}
    8dfc:	.word	0x400b1024
    8e00:	.word	0x400b1028
    8e04:	.word	0x00007ff9
    8e08:	.word	0x400b1020
    8e0c:	.word	0x00008021
    8e10:	.word	0x400b1030
    8e14:	.word	0x20019b8c
    8e18:	.word	0x117f0000
    8e1c:	.word	0x200138d4
    8e20:	.word	0x20019bac

00008e24 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8e24:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8e26:	ldr	r0, [pc, #80]	; (8e78 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8e28:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8e2a:	bl	8190 <yieldTimeout(bool (*)())>
    8e2e:	cbnz	r0, 8e64 <SdioCard::readStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8e30:	ldr	r2, [pc, #72]	; (8e7c <SdioCard::readStart(unsigned long)+0x58>)
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8e32:	ldr	r1, [pc, #76]	; (8e80 <SdioCard::readStart(unsigned long)+0x5c>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8e34:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8e36:	ldr	r0, [pc, #76]	; (8e84 <SdioCard::readStart(unsigned long)+0x60>)
    8e38:	ldr	r5, [pc, #76]	; (8e88 <SdioCard::readStart(unsigned long)+0x64>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8e3a:	orr.w	r3, r3, #65536	; 0x10000
    8e3e:	str	r3, [r2, #0]
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8e40:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8e42:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8e44:	cbnz	r3, 8e60 <SdioCard::readStart(unsigned long)+0x3c>
    8e46:	lsls	r1, r4, #9
    8e48:	ldr	r0, [pc, #64]	; (8e8c <SdioCard::readStart(unsigned long)+0x68>)
    8e4a:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8e4e:	cbnz	r0, 8e5e <SdioCard::readStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e50:	ldr	r1, [pc, #60]	; (8e90 <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    8e52:	ldr	r3, [pc, #64]	; (8e94 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e54:	movs	r4, #12
  m_errorLine = line;
    8e56:	movw	r2, #937	; 0x3a9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e5a:	strb	r4, [r1, #0]
  m_errorLine = line;
    8e5c:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    8e5e:	pop	{r3, r4, r5, pc}
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8e60:	mov	r1, r4
    8e62:	b.n	8e48 <SdioCard::readStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e64:	ldr	r1, [pc, #40]	; (8e90 <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    8e66:	ldr	r3, [pc, #44]	; (8e94 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e68:	movs	r0, #10
  m_errorLine = line;
    8e6a:	movw	r2, #925	; 0x39d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e6e:	strb	r0, [r1, #0]
  m_errorLine = line;
    8e70:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8e72:	movs	r0, #0
    8e74:	pop	{r3, r4, r5, pc}
    8e76:	nop
    8e78:	.word	0x00008269
    8e7c:	.word	0x400b1028
    8e80:	.word	0x20019b7c
    8e84:	.word	0x400b1004
    8e88:	.word	0xffff0200
    8e8c:	.word	0x123a0032
    8e90:	.word	0x200138d4
    8e94:	.word	0x20019bac

00008e98 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8e98:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8e9a:	ldrb	r3, [r0, #8]
    8e9c:	lsls	r4, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8e9e:	sub.w	sp, sp, #512	; 0x200
    8ea2:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8ea4:	bpl.n	8ecc <SdioCard::readSector(unsigned long, unsigned char*)+0x34>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8ea6:	lsls	r3, r2, #30
    8ea8:	beq.n	8ef0 <SdioCard::readSector(unsigned long, unsigned char*)+0x58>

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    8eaa:	mov	r2, sp
    8eac:	movs	r3, #1
    8eae:	ldr	r0, [pc, #196]	; (8f74 <SdioCard::readSector(unsigned long, unsigned char*)+0xdc>)
    8eb0:	bl	8338 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8eb4:	cbz	r0, 8efc <SdioCard::readSector(unsigned long, unsigned char*)+0x64>
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    8eb6:	mov	r1, sp
    8eb8:	mov	r0, r5
    8eba:	mov.w	r2, #512	; 0x200
    8ebe:	bl	9220 <memcpy>
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
    8ec2:	movs	r5, #1
}
    8ec4:	mov	r0, r5
    8ec6:	add.w	sp, sp, #512	; 0x200
    8eca:	pop	{r4, r5, r6, pc}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    8ecc:	ldr	r3, [pc, #168]	; (8f78 <SdioCard::readSector(unsigned long, unsigned char*)+0xe0>)
    8ece:	ldrb	r3, [r3, #0]
    8ed0:	mov	r4, r0
    8ed2:	mov	r6, r1
    8ed4:	cbnz	r3, 8f28 <SdioCard::readSector(unsigned long, unsigned char*)+0x90>
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    8ed6:	ldrb	r3, [r4, #9]
    8ed8:	cmp	r3, #1
    8eda:	beq.n	8f14 <SdioCard::readSector(unsigned long, unsigned char*)+0x7c>
      if (!syncDevice()) {
    8edc:	ldr	r3, [r4, #0]
    8ede:	mov	r0, r4
    8ee0:	ldr	r3, [r3, #24]
    8ee2:	blx	r3
    8ee4:	cbnz	r0, 8f34 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
      memcpy(dst, aligned, 512);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    8ee6:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8ee8:	mov	r0, r5
    8eea:	add.w	sp, sp, #512	; 0x200
    8eee:	pop	{r4, r5, r6, pc}
  if (m_sdioConfig.useDma()) {
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    8ef0:	movs	r3, #1
    8ef2:	ldr	r0, [pc, #128]	; (8f74 <SdioCard::readSector(unsigned long, unsigned char*)+0xdc>)
    8ef4:	bl	8338 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8ef8:	cmp	r0, #0
    8efa:	bne.n	8ec2 <SdioCard::readSector(unsigned long, unsigned char*)+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8efc:	ldr	r1, [pc, #124]	; (8f7c <SdioCard::readSector(unsigned long, unsigned char*)+0xe4>)
  m_errorLine = line;
    8efe:	ldr	r3, [pc, #128]	; (8f80 <SdioCard::readSector(unsigned long, unsigned char*)+0xe8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8f00:	movs	r0, #11
  m_errorLine = line;
    8f02:	movw	r2, #862	; 0x35e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8f06:	strb	r0, [r1, #0]
  m_errorLine = line;
    8f08:	str	r2, [r3, #0]
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    8f0a:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8f0c:	mov	r0, r5
    8f0e:	add.w	sp, sp, #512	; 0x200
    8f12:	pop	{r4, r5, r6, pc}
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    8f14:	ldr	r3, [r4, #4]
    8f16:	cmp	r6, r3
    8f18:	beq.n	8f46 <SdioCard::readSector(unsigned long, unsigned char*)+0xae>
      if (!syncDevice()) {
    8f1a:	ldr	r3, [r4, #0]
    8f1c:	mov	r0, r4
    8f1e:	ldr	r3, [r3, #24]
    8f20:	blx	r3
    8f22:	cmp	r0, #0
    8f24:	beq.n	8ee6 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
    8f26:	b.n	8f34 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
    8f28:	bl	8544 <waitTransferComplete() [clone .part.8]>
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8f2c:	cmp	r0, #0
    8f2e:	bne.n	8ed6 <SdioCard::readSector(unsigned long, unsigned char*)+0x3e>
      return false;
    8f30:	movs	r5, #0
    8f32:	b.n	8ee8 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
      if (!syncDevice()) {
        return false;
      }
      if (!readStart(sector)) {
    8f34:	mov	r1, r6
    8f36:	mov	r0, r4
    8f38:	bl	8e24 <SdioCard::readStart(unsigned long)>
    8f3c:	cmp	r0, #0
    8f3e:	beq.n	8ee6 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    8f40:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    8f42:	str	r6, [r4, #4]
      m_curState = READ_STATE;
    8f44:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8f46:	mov	r1, r5
    8f48:	mov	r0, r4
    8f4a:	bl	8d58 <SdioCard::readData(unsigned char*)>
    8f4e:	mov	r5, r0
    8f50:	cmp	r0, #0
    8f52:	beq.n	8ee6 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8f54:	ldr	r3, [pc, #44]	; (8f84 <SdioCard::readSector(unsigned long, unsigned char*)+0xec>)
    8f56:	ldr	r3, [r3, #0]
    8f58:	lsrs	r3, r3, #16
    8f5a:	lsls	r3, r3, #16
    8f5c:	cbz	r3, 8f66 <SdioCard::readSector(unsigned long, unsigned char*)+0xce>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8f5e:	ldr	r3, [r4, #4]
    8f60:	adds	r3, #1
    8f62:	str	r3, [r4, #4]
    8f64:	b.n	8f0c <SdioCard::readSector(unsigned long, unsigned char*)+0x74>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8f66:	ldr	r3, [r4, #0]
    8f68:	mov	r0, r4
    8f6a:	ldr	r3, [r3, #24]
    8f6c:	blx	r3
    8f6e:	cmp	r0, #0
    8f70:	bne.n	8f5e <SdioCard::readSector(unsigned long, unsigned char*)+0xc6>
    8f72:	b.n	8ee6 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
    8f74:	.word	0x113a0011
    8f78:	.word	0x20019b88
    8f7c:	.word	0x200138d4
    8f80:	.word	0x20019bac
    8f84:	.word	0x400b1004

00008f88 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8f88:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8f8a:	ldr	r2, [pc, #80]	; (8fdc <SdioCard::stopTransmission(bool)+0x54>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8f8c:	movs	r5, #0
    8f8e:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8f90:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8f92:	ldr	r0, [pc, #76]	; (8fe0 <SdioCard::stopTransmission(bool)+0x58>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8f94:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8f98:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8f9a:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8f9c:	mov	r1, r5
    8f9e:	bl	820c <cardCommand(unsigned long, unsigned long)>
    8fa2:	mov	r4, r0
    8fa4:	cbz	r0, 8fca <SdioCard::stopTransmission(bool)+0x42>
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    8fa6:	cbnz	r6, 8fac <SdioCard::stopTransmission(bool)+0x24>
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    8fa8:	mov	r0, r4
    8faa:	pop	{r4, r5, r6, pc}
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
    8fac:	ldr	r0, [pc, #52]	; (8fe4 <SdioCard::stopTransmission(bool)+0x5c>)
    8fae:	bl	8190 <yieldTimeout(bool (*)())>
    8fb2:	cmp	r0, #0
    8fb4:	beq.n	8fa8 <SdioCard::stopTransmission(bool)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8fb6:	ldr	r1, [pc, #48]	; (8fe8 <SdioCard::stopTransmission(bool)+0x60>)
  m_errorLine = line;
    8fb8:	ldr	r3, [pc, #48]	; (8fec <SdioCard::stopTransmission(bool)+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8fba:	movs	r0, #10
  m_errorLine = line;
    8fbc:	movw	r2, #963	; 0x3c3
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    8fc0:	mov	r4, r5
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8fc2:	strb	r0, [r1, #0]
  m_errorLine = line;
    8fc4:	str	r2, [r3, #0]
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    8fc6:	mov	r0, r4
    8fc8:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8fca:	ldr	r1, [pc, #28]	; (8fe8 <SdioCard::stopTransmission(bool)+0x60>)
  m_errorLine = line;
    8fcc:	ldr	r3, [pc, #28]	; (8fec <SdioCard::stopTransmission(bool)+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8fce:	movs	r0, #9
  m_errorLine = line;
    8fd0:	movw	r2, #959	; 0x3bf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8fd4:	strb	r0, [r1, #0]
  m_errorLine = line;
    8fd6:	str	r2, [r3, #0]
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    8fd8:	mov	r0, r4
    8fda:	pop	{r4, r5, r6, pc}
    8fdc:	.word	0x400b1028
    8fe0:	.word	0x0cdb0000
    8fe4:	.word	0x00007fd9
    8fe8:	.word	0x200138d4
    8fec:	.word	0x20019bac

00008ff0 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8ff0:	push	{r4, r5, r6, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8ff2:	ldrb	r3, [r0, #8]
    8ff4:	ands.w	r3, r3, #1
    8ff8:	beq.n	9006 <SdioCard::isBusy()+0x16>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ffa:	ldr	r3, [pc, #88]	; (9054 <SdioCard::isBusy()+0x64>)
    8ffc:	ldr	r3, [r3, #0]
    8ffe:	cbz	r3, 9038 <SdioCard::isBusy()+0x48>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    9000:	ldmia.w	sp!, {r4, r5, r6, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    9004:	bx	r3
  } else {
    if (m_transferActive) {
    9006:	ldr	r2, [pc, #80]	; (9058 <SdioCard::isBusy()+0x68>)
    9008:	ldrb	r4, [r2, #0]
    900a:	cbnz	r4, 901c <SdioCard::isBusy()+0x2c>
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    900c:	ldr	r3, [pc, #76]	; (905c <SdioCard::isBusy()+0x6c>)
    900e:	ldr	r4, [r3, #0]
    9010:	eor.w	r4, r4, #16777216	; 0x1000000
    9014:	ubfx	r4, r4, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    9018:	mov	r0, r4
    901a:	pop	{r4, r5, r6, pc}
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
}
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    901c:	ldr	r5, [pc, #64]	; (9060 <SdioCard::isBusy()+0x70>)
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
  } else {
    if (m_transferActive) {
      if (isBusyTransferComplete()) {
    901e:	ldr	r1, [pc, #68]	; (9064 <SdioCard::isBusy()+0x74>)
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
}
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    9020:	ldr	r5, [r5, #0]
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
  } else {
    if (m_transferActive) {
      if (isBusyTransferComplete()) {
    9022:	ands	r1, r5
    9024:	cmp	r1, #0
    9026:	beq.n	9018 <SdioCard::isBusy()+0x28>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    9028:	ldr	r1, [pc, #60]	; (9068 <SdioCard::isBusy()+0x78>)
    902a:	ldr	r5, [r1, #0]
    902c:	lsrs	r5, r5, #16
    902e:	lsls	r5, r5, #16
    9030:	cbz	r5, 9048 <SdioCard::isBusy()+0x58>
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    9032:	mov	r4, r3
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    9034:	mov	r0, r4
    9036:	pop	{r4, r5, r6, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    9038:	ldr	r3, [pc, #48]	; (906c <SdioCard::isBusy()+0x7c>)
    903a:	ldrb	r4, [r3, #0]
    903c:	cmp	r4, #0
    903e:	beq.n	9018 <SdioCard::isBusy()+0x28>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    9040:	ldmia.w	sp!, {r4, r5, r6, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    9044:	b.w	8268 <isBusyCMD13()>
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
        return false;
      }
      m_transferActive = false;
      stopTransmission(false);
    9048:	mov	r1, r5
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
        return false;
      }
      m_transferActive = false;
    904a:	strb	r5, [r2, #0]
      stopTransmission(false);
    904c:	bl	8f88 <SdioCard::stopTransmission(bool)>
    9050:	b.n	9018 <SdioCard::isBusy()+0x28>
    9052:	nop
    9054:	.word	0x20019b78
    9058:	.word	0x20019b88
    905c:	.word	0x400b1024
    9060:	.word	0x400b1030
    9064:	.word	0x117f0002
    9068:	.word	0x400b1004
    906c:	.word	0x20019b90

00009070 <SdioCard::syncDevice()>:
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    9070:	ldr	r3, [pc, #36]	; (9098 <SdioCard::syncDevice()+0x28>)
    9072:	ldrb	r3, [r3, #0]
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    9074:	push	{r4, lr}
    9076:	mov	r4, r0
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    9078:	cbnz	r3, 908e <SdioCard::syncDevice()+0x1e>
bool SdioCard::syncDevice() {
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    907a:	ldrb	r3, [r4, #9]
    907c:	cbnz	r3, 9082 <SdioCard::syncDevice()+0x12>
    if (!writeStop()) {
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
    907e:	movs	r0, #1
    9080:	pop	{r4, pc}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    9082:	mov	r0, r4
    9084:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    9086:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    908a:	b.w	8f88 <SdioCard::stopTransmission(bool)>
    908e:	bl	8544 <waitTransferComplete() [clone .part.8]>
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    9092:	cmp	r0, #0
    9094:	bne.n	907a <SdioCard::syncDevice()+0xa>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    9096:	pop	{r4, pc}
    9098:	.word	0x20019b88

0000909c <SdSpiArduinoDriver::activate()>:
 */
#include "SdSpiDriver.h"
#if defined(SD_USE_CUSTOM_SPI) &&  defined(__arm__) && defined(CORE_TEENSY)
#define USE_BLOCK_TRANSFER 1
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::activate() {
    909c:	push	{r4}
  m_spi->beginTransaction(m_spiSettings);
    909e:	ldr	r3, [r0, #0]
    90a0:	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    90a2:	ldrb	r1, [r3, #11]
    90a4:	cbz	r1, 90e6 <SdSpiArduinoDriver::activate()+0x4a>
			__disable_irq();
    90a6:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    90a8:	ldrb	r1, [r3, #11]
    90aa:	lsls	r0, r1, #31
    90ac:	bpl.n	90bc <SdSpiArduinoDriver::activate()+0x20>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    90ae:	ldr	r0, [pc, #100]	; (9114 <SdSpiArduinoDriver::activate()+0x78>)
    90b0:	ldr	r1, [r3, #12]
    90b2:	ldr	r4, [r0, #0]
    90b4:	ands	r1, r4
    90b6:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    90b8:	str	r1, [r0, #0]
    90ba:	ldrb	r1, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    90bc:	lsls	r4, r1, #30
    90be:	bpl.n	90ce <SdSpiArduinoDriver::activate()+0x32>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    90c0:	ldr	r0, [pc, #84]	; (9118 <SdSpiArduinoDriver::activate()+0x7c>)
    90c2:	ldr	r1, [r3, #16]
    90c4:	ldr	r4, [r0, #0]
    90c6:	ands	r1, r4
    90c8:	str	r1, [r3, #32]
				NVIC_ICER1 = interruptSave[1];
    90ca:	str	r1, [r0, #0]
    90cc:	ldrb	r1, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    90ce:	lsls	r0, r1, #29
    90d0:	bpl.n	90e0 <SdSpiArduinoDriver::activate()+0x44>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    90d2:	ldr	r0, [pc, #72]	; (911c <SdSpiArduinoDriver::activate()+0x80>)
    90d4:	ldr	r1, [r3, #20]
    90d6:	ldr	r4, [r0, #0]
    90d8:	ands	r1, r4
    90da:	str	r1, [r3, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    90dc:	str	r1, [r0, #0]
    90de:	ldrb	r1, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    90e0:	lsls	r1, r1, #28
    90e2:	bmi.n	9104 <SdSpiArduinoDriver::activate()+0x68>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    90e4:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    90e6:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    90e8:	ldr	r1, [r3, #12]
    90ea:	cmp	r1, r2
    90ec:	beq.n	90fe <SdSpiArduinoDriver::activate()+0x62>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    90ee:	ldr	r0, [pc, #48]	; (9120 <SdSpiArduinoDriver::activate()+0x84>)
    90f0:	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    90f2:	ldr	r1, [pc, #48]	; (9124 <SdSpiArduinoDriver::activate()+0x88>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    90f4:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    90f6:	orr.w	r0, r2, #1073741824	; 0x40000000
    90fa:	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    90fc:	str	r1, [r3, #0]
}
    90fe:	ldr.w	r4, [sp], #4
    9102:	bx	lr
				NVIC_ICER2 = interruptSave[2];
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    9104:	ldr	r0, [pc, #32]	; (9128 <SdSpiArduinoDriver::activate()+0x8c>)
    9106:	ldr	r1, [r3, #24]
    9108:	ldr	r4, [r0, #0]
    910a:	ands	r1, r4
    910c:	str	r1, [r3, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    910e:	str	r1, [r0, #0]
    9110:	b.n	90e4 <SdSpiArduinoDriver::activate()+0x48>
    9112:	nop
    9114:	.word	0xe000e180
    9118:	.word	0xe000e184
    911c:	.word	0xe000e188
    9120:	.word	0x003f4001
    9124:	.word	0x803f0000
    9128:	.word	0xe000e18c

0000912c <SdSpiArduinoDriver::deactivate()>:
  }
  m_spi->begin();
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::deactivate() {
  m_spi->endTransaction();
    912c:	ldr	r2, [r0, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    912e:	ldrb	r3, [r2, #11]
    9130:	cbz	r3, 9160 <SdSpiArduinoDriver::deactivate()+0x34>
			if (interruptMasksUsed & 0x01) {
    9132:	lsls	r1, r3, #31
    9134:	bpl.n	913e <SdSpiArduinoDriver::deactivate()+0x12>
				NVIC_ISER0 = interruptSave[0];
    9136:	ldr	r3, [pc, #44]	; (9164 <SdSpiArduinoDriver::deactivate()+0x38>)
    9138:	ldr	r1, [r2, #28]
    913a:	str	r1, [r3, #0]
    913c:	ldrb	r3, [r2, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    913e:	lsls	r0, r3, #30
    9140:	bpl.n	914a <SdSpiArduinoDriver::deactivate()+0x1e>
				NVIC_ISER1 = interruptSave[1];
    9142:	ldr	r3, [pc, #36]	; (9168 <SdSpiArduinoDriver::deactivate()+0x3c>)
    9144:	ldr	r1, [r2, #32]
    9146:	str	r1, [r3, #0]
    9148:	ldrb	r3, [r2, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    914a:	lsls	r1, r3, #29
    914c:	bpl.n	9156 <SdSpiArduinoDriver::deactivate()+0x2a>
				NVIC_ISER2 = interruptSave[2];
    914e:	ldr	r3, [pc, #28]	; (916c <SdSpiArduinoDriver::deactivate()+0x40>)
    9150:	ldr	r1, [r2, #36]	; 0x24
    9152:	str	r1, [r3, #0]
    9154:	ldrb	r3, [r2, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    9156:	lsls	r3, r3, #28
    9158:	bpl.n	9160 <SdSpiArduinoDriver::deactivate()+0x34>
				NVIC_ISER3 = interruptSave[3];
    915a:	ldr	r3, [pc, #20]	; (9170 <SdSpiArduinoDriver::deactivate()+0x44>)
    915c:	ldr	r2, [r2, #40]	; 0x28
    915e:	str	r2, [r3, #0]
    9160:	bx	lr
    9162:	nop
    9164:	.word	0xe000e100
    9168:	.word	0xe000e104
    916c:	.word	0xe000e108
    9170:	.word	0xe000e10c

00009174 <SdSpiArduinoDriver::receive()>:
}
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive() {
    9174:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    9176:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    9178:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    917c:	movs	r3, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    917e:	str	r1, [r2, #44]	; 0x2c
		port().PUSHR = data;
    9180:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    9182:	ldr	r3, [r2, #44]	; 0x2c
    9184:	cmp	r3, #0
    9186:	bge.n	9182 <SdSpiArduinoDriver::receive()+0xe>
		return port().POPR;
    9188:	ldr	r0, [r2, #56]	; 0x38
  return m_spi->transfer(0XFF);
}
    918a:	uxtb	r0, r0
    918c:	bx	lr
    918e:	nop

00009190 <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive(uint8_t* buf, size_t count) {
    9190:	push	{r4, r5, r6, lr}
    9192:	mov	r5, r0
    9194:	mov	r4, r1
    9196:	mov	r6, r2
#if USE_BLOCK_TRANSFER
  memset(buf, 0XFF, count);
    9198:	mov	r0, r1
    919a:	movs	r1, #255	; 0xff
    919c:	bl	c49c <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    91a0:	ldr	r0, [r5, #0]
    91a2:	mov	r3, r6
    91a4:	mov	r2, r4
    91a6:	mov	r1, r4
    91a8:	bl	2338 <SPIClass::transfer(void const*, void*, unsigned int)>
  for (size_t i = 0; i < count; i++) {
    buf[i] = m_spi->transfer(0XFF);
  }
#endif  // USE_BLOCK_TRANSFER
  return 0;
}
    91ac:	movs	r0, #0
    91ae:	pop	{r4, r5, r6, pc}

000091b0 <SdSpiArduinoDriver::send(unsigned char)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
    91b0:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    91b2:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    91b4:	mov.w	r3, #2147483648	; 0x80000000
    91b8:	str	r3, [r2, #44]	; 0x2c
		port().PUSHR = data;
    91ba:	str	r1, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    91bc:	ldr	r3, [r2, #44]	; 0x2c
    91be:	cmp	r3, #0
    91c0:	bge.n	91bc <SdSpiArduinoDriver::send(unsigned char)+0xc>
		return port().POPR;
    91c2:	ldr	r3, [r2, #56]	; 0x38
    91c4:	bx	lr
    91c6:	nop

000091c8 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>:
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    91c8:	push	{r4, r5, lr}
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    91ca:	subs	r5, r2, #1
    91cc:	cmp.w	r5, #512	; 0x200
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    91d0:	sub.w	sp, sp, #516	; 0x204
    91d4:	mov	r3, r2
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    91d6:	bcc.n	91fe <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x36>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    91d8:	cbz	r2, 91f8 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x30>
    91da:	ldr	r2, [r0, #0]
    91dc:	ldr	r2, [r2, #0]
    91de:	adds	r0, r1, r3
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    91e0:	mov.w	r4, #2147483648	; 0x80000000
    m_spi->transfer(buf[i]);
    91e4:	ldrb.w	r3, [r1], #1
    91e8:	str	r4, [r2, #44]	; 0x2c
		port().PUSHR = data;
    91ea:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    91ec:	ldr	r3, [r2, #44]	; 0x2c
    91ee:	cmp	r3, #0
    91f0:	bge.n	91ec <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x24>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    91f2:	cmp	r1, r0
		return port().POPR;
    91f4:	ldr	r3, [r2, #56]	; 0x38
    91f6:	bne.n	91e4 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x1c>
    m_spi->transfer(buf[i]);
  }
}
    91f8:	add.w	sp, sp, #516	; 0x204
    91fc:	pop	{r4, r5, pc}
    91fe:	mov	r5, r0
    9200:	mov	r4, r2
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    memcpy(tmp, buf, count);
    9202:	mov	r0, sp
    9204:	bl	9220 <memcpy>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    9208:	mov	r3, r4
    920a:	mov	r2, sp
    920c:	mov	r1, sp
    920e:	ldr	r0, [r5, #0]
    9210:	bl	2338 <SPIClass::transfer(void const*, void*, unsigned int)>
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    m_spi->transfer(buf[i]);
  }
}
    9214:	add.w	sp, sp, #516	; 0x204
    9218:	pop	{r4, r5, pc}
    921a:	nop

0000921c <sdCsWrite(unsigned char, bool)>:
void sdCsInit(SdCsPin_t pin) {
  pinMode(pin, OUTPUT);
}
//------------------------------------------------------------------------------
void sdCsWrite(SdCsPin_t pin, bool level) {
  digitalWrite(pin, level);
    921c:	b.w	9910 <digitalWrite>

00009220 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    9220:	push	{r0}
#endif
	orr	r3, r1, r0
    9222:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    9226:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    922a:	bne.n	930c <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    922c:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    922e:	bcc.n	92b4 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    9230:	ldr.w	r3, [r1], #4
    9234:	str.w	r3, [r0], #4
    9238:	ldr.w	r3, [r1], #4
    923c:	str.w	r3, [r0], #4
    9240:	ldr.w	r3, [r1], #4
    9244:	str.w	r3, [r0], #4
    9248:	ldr.w	r3, [r1], #4
    924c:	str.w	r3, [r0], #4
    9250:	ldr.w	r3, [r1], #4
    9254:	str.w	r3, [r0], #4
    9258:	ldr.w	r3, [r1], #4
    925c:	str.w	r3, [r0], #4
    9260:	ldr.w	r3, [r1], #4
    9264:	str.w	r3, [r0], #4
    9268:	ldr.w	r3, [r1], #4
    926c:	str.w	r3, [r0], #4
    9270:	ldr.w	r3, [r1], #4
    9274:	str.w	r3, [r0], #4
    9278:	ldr.w	r3, [r1], #4
    927c:	str.w	r3, [r0], #4
    9280:	ldr.w	r3, [r1], #4
    9284:	str.w	r3, [r0], #4
    9288:	ldr.w	r3, [r1], #4
    928c:	str.w	r3, [r0], #4
    9290:	ldr.w	r3, [r1], #4
    9294:	str.w	r3, [r0], #4
    9298:	ldr.w	r3, [r1], #4
    929c:	str.w	r3, [r0], #4
    92a0:	ldr.w	r3, [r1], #4
    92a4:	str.w	r3, [r0], #4
    92a8:	ldr.w	r3, [r1], #4
    92ac:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    92b0:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    92b2:	bcs.n	9230 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    92b4:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    92b6:	bcc.n	92dc <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    92b8:	ldr.w	r3, [r1], #4
    92bc:	str.w	r3, [r0], #4
    92c0:	ldr.w	r3, [r1], #4
    92c4:	str.w	r3, [r0], #4
    92c8:	ldr.w	r3, [r1], #4
    92cc:	str.w	r3, [r0], #4
    92d0:	ldr.w	r3, [r1], #4
    92d4:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    92d8:	subs	r2, #16
	bhs	.Lmid_block_loop
    92da:	bcs.n	92b8 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    92dc:	adds	r2, #12
	blo	.Lcopy_less_than_4
    92de:	bcc.n	92ec <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    92e0:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    92e4:	str.w	r3, [r0], #4
	subs	r2, #4
    92e8:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    92ea:	bcs.n	92e0 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    92ec:	adds	r2, #4
	beq	.Ldone
    92ee:	beq.n	9306 <memcpy+0xe6>

	lsls	r2, r2, #31
    92f0:	lsls	r2, r2, #31
	itt ne
    92f2:	itt	ne
	ldrbne  r3, [r1], #1
    92f4:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    92f8:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    92fc:	bcc.n	9306 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    92fe:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    9300:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    9302:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    9304:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    9306:	pop	{r0}
#endif
	bx	lr
    9308:	bx	lr
    930a:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    930c:	cmp	r2, #12
	blo	.Lbyte_copy
    930e:	bcc.n	93a6 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    9310:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    9314:	beq.n	933a <memcpy+0x11a>

	rsb	r3, #4
    9316:	rsb	r3, r3, #4
	subs	r2, r3
    931a:	subs	r2, r2, r3

	lsls    r3, r3, #31
    931c:	lsls	r3, r3, #31
	itt ne
    931e:	itt	ne
	ldrbne  r3, [r1], #1
    9320:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    9324:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    9328:	bcc.n	933a <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    932a:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    932e:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    9332:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    9336:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    933a:	ands.w	r3, r1, #3
	beq	.Lbig_block
    933e:	beq.w	922c <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    9342:	push	{r4, r5}
	subs	r2, #4
    9344:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    9346:	subs	r1, r1, r3
	rsb	ip, r3, #4
    9348:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    934c:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    9350:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    9352:	beq.n	9388 <memcpy+0x168>
	cmp	r3, #3
    9354:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    9356:	beq.n	9370 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    9358:	lsrs	r4, r4, #8
    935a:	ldr.w	r3, [r1], #4
    935e:	lsls	r5, r3, #24
    9360:	orr.w	r4, r4, r5
    9364:	str.w	r4, [r0], #4
    9368:	mov	r4, r3
    936a:	subs	r2, #4
    936c:	bcs.n	9358 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    936e:	b.n	939e <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    9370:	lsrs	r4, r4, #24
    9372:	ldr.w	r3, [r1], #4
    9376:	lsls	r5, r3, #8
    9378:	orr.w	r4, r4, r5
    937c:	str.w	r4, [r0], #4
    9380:	mov	r4, r3
    9382:	subs	r2, #4
    9384:	bcs.n	9370 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    9386:	b.n	939e <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    9388:	lsrs	r4, r4, #16
    938a:	ldr.w	r3, [r1], #4
    938e:	lsls	r5, r3, #16
    9390:	orr.w	r4, r4, r5
    9394:	str.w	r4, [r0], #4
    9398:	mov	r4, r3
    939a:	subs	r2, #4
    939c:	bcs.n	9388 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    939e:	adds	r2, #4
	subs	r1, ip
    93a0:	subs.w	r1, r1, ip
	pop	{r4, r5}
    93a4:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    93a6:	subs	r2, #4
	blo	.Lcopy_less_than_4
    93a8:	bcc.n	92ec <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    93aa:	subs	r2, #1
	ldrb    r3, [r1], #1
    93ac:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    93b0:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    93b4:	bcs.n	93aa <memcpy+0x18a>

	ldrb	r3, [r1]
    93b6:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    93b8:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    93ba:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    93bc:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    93be:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    93c0:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    93c2:	pop	{r0}
#endif
	bx	lr
    93c4:	bx	lr
    93c6:	nop

000093c8 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    93c8:	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    93ca:	ldr	r5, [pc, #60]	; (9408 <usb_serial_getchar+0x40>)
    93cc:	ldr	r0, [r5, #0]
    93ce:	cbz	r0, 93f0 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    93d0:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    93d2:	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    93d4:	adds	r1, r0, r3
    93d6:	adds	r3, #1
	if (i >= rx_packet->len) {
    93d8:	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    93da:	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    93dc:	bcs.n	93e4 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    93de:	strh	r3, [r0, #2]
	}
	return c;
    93e0:	mov	r0, r4
}
    93e2:	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    93e4:	bl	9bd0 <usb_free>
		rx_packet = NULL;
    93e8:	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    93ea:	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    93ec:	str	r3, [r5, #0]
    93ee:	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    93f0:	ldr	r3, [pc, #24]	; (940c <usb_serial_getchar+0x44>)
    93f2:	ldrb	r3, [r3, #0]
    93f4:	cbz	r3, 9402 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    93f6:	movs	r0, #3
    93f8:	bl	9c1c <usb_rx>
    93fc:	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    93fe:	cmp	r0, #0
    9400:	bne.n	93d0 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9402:	mov.w	r0, #4294967295
    9406:	pop	{r3, r4, r5, pc}
    9408:	.word	0x20019bbc
    940c:	.word	0x20019ca8

00009410 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    9410:	push	{r4, lr}
	if (!rx_packet) {
    9412:	ldr	r4, [pc, #36]	; (9438 <usb_serial_peekchar+0x28>)
    9414:	ldr	r0, [r4, #0]
    9416:	cbz	r0, 9420 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    9418:	ldrh	r3, [r0, #2]
    941a:	add	r0, r3
    941c:	ldrb	r0, [r0, #8]
}
    941e:	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9420:	ldr	r3, [pc, #24]	; (943c <usb_serial_peekchar+0x2c>)
    9422:	ldrb	r3, [r3, #0]
    9424:	cbz	r3, 9432 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    9426:	movs	r0, #3
    9428:	bl	9c1c <usb_rx>
    942c:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    942e:	cmp	r0, #0
    9430:	bne.n	9418 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9432:	mov.w	r0, #4294967295
    9436:	pop	{r4, pc}
    9438:	.word	0x20019bbc
    943c:	.word	0x20019ca8

00009440 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    9440:	ldr	r3, [pc, #16]	; (9454 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    9442:	ldr	r2, [pc, #20]	; (9458 <usb_serial_available+0x18>)
    9444:	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    9446:	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    9448:	cbz	r3, 9452 <usb_serial_available+0x12>
    944a:	ldrh	r2, [r3, #0]
    944c:	ldrh	r3, [r3, #2]
    944e:	subs	r3, r2, r3
    9450:	add	r0, r3
	return count;
}
    9452:	bx	lr
    9454:	.word	0x20019bbc
    9458:	.word	0x20019dac

0000945c <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    945c:	ldr	r3, [pc, #44]	; (948c <usb_serial_flush_input+0x30>)
    945e:	ldrb	r3, [r3, #0]
    9460:	cbz	r3, 948a <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    9462:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    9464:	ldr	r4, [pc, #40]	; (9490 <usb_serial_flush_input+0x34>)
    9466:	ldr	r0, [r4, #0]
    9468:	cbz	r0, 947e <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    946a:	bl	9bd0 <usb_free>
		rx_packet = NULL;
    946e:	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    9470:	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    9472:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    9474:	bl	9c1c <usb_rx>
		if (!rx) break;
    9478:	cbz	r0, 9488 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    947a:	bl	9bd0 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    947e:	movs	r0, #3
    9480:	bl	9c1c <usb_rx>
		if (!rx) break;
    9484:	cmp	r0, #0
    9486:	bne.n	947a <usb_serial_flush_input+0x1e>
    9488:	pop	{r4, pc}
    948a:	bx	lr
    948c:	.word	0x20019ca8
    9490:	.word	0x20019bbc

00009494 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    9494:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    9498:	ldr.w	r9, [pc, #248]	; 9594 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    949c:	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    949e:	movs	r2, #1
    94a0:	strb.w	r2, [r9]
	while (size > 0) {
    94a4:	str	r1, [sp, #4]
    94a6:	cbz	r1, 9504 <usb_serial_write+0x70>
    94a8:	ldr.w	r8, [pc, #236]	; 9598 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    94ac:	ldr	r7, [pc, #216]	; (9588 <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    94ae:	ldr	r6, [sp, #4]
    94b0:	mov	fp, r0
		if (!tx_packet) {
    94b2:	ldr.w	r0, [r8]
    94b6:	cbz	r0, 9526 <usb_serial_write+0x92>
    94b8:	ldr	r5, [pc, #208]	; (958c <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    94ba:	ldrh	r4, [r0, #2]
    94bc:	rsb	r1, r4, #64	; 0x40
    94c0:	cmp	r1, r6
    94c2:	it	cs
    94c4:	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    94c6:	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    94ca:	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    94cc:	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    94d0:	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    94d2:	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    94d4:	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    94d8:	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    94dc:	cbz	r1, 94f4 <usb_serial_write+0x60>
    94de:	subs	r4, #1
    94e0:	add	r2, r4
    94e2:	add	r1, fp
    94e4:	ldrb.w	r4, [fp], #1
    94e8:	strb.w	r4, [r2, #1]!
    94ec:	cmp	fp, r1
    94ee:	bne.n	94e4 <usb_serial_write+0x50>
    94f0:	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    94f4:	cmp.w	lr, #63	; 0x3f
    94f8:	bhi.n	9512 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    94fa:	ldr	r2, [pc, #148]	; (9590 <usb_serial_write+0xfc>)
    94fc:	movs	r1, #5
    94fe:	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    9500:	cmp	r6, #0
    9502:	bne.n	94b2 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    9504:	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    9506:	movs	r3, #0
    9508:	strb.w	r3, [r9]
	return ret;
}
    950c:	add	sp, #12
    950e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    9512:	movs	r2, #64	; 0x40
    9514:	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9516:	mov	r1, r0
    9518:	movs	r0, #4
    951a:	bl	9d08 <usb_tx>
			tx_packet = NULL;
    951e:	movs	r2, #0
    9520:	str.w	r2, [r8]
    9524:	b.n	94fa <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    9526:	ldrb	r2, [r7, #0]
    9528:	cbz	r2, 9576 <usb_serial_write+0xe2>
    952a:	ldr	r5, [pc, #96]	; (958c <usb_serial_write+0xf8>)
    952c:	movw	r4, #41721	; 0xa2f9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    9530:	mov.w	sl, #1
    9534:	b.n	9546 <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    9536:	subs	r4, #1
    9538:	beq.n	9568 <usb_serial_write+0xd4>
    953a:	ldrb	r2, [r5, #0]
    953c:	cbnz	r2, 9568 <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    953e:	bl	a6c4 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    9542:	ldrb	r2, [r7, #0]
    9544:	cbz	r2, 9576 <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    9546:	movs	r0, #4
    9548:	bl	9c58 <usb_tx_packet_count>
    954c:	cmp	r0, #7
    954e:	bhi.n	9536 <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    9550:	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    9554:	bl	9b90 <usb_malloc>
    9558:	str.w	r0, [r8]
					if (tx_packet) break;
    955c:	cmp	r0, #0
    955e:	bne.n	94ba <usb_serial_write+0x26>
					tx_noautoflush = 0;
    9560:	ldr	r3, [pc, #48]	; (9594 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    9562:	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    9564:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    9566:	bne.n	953a <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    9568:	movs	r3, #1
					return -1;
    956a:	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    956e:	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    9570:	add	sp, #12
    9572:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    9576:	movs	r3, #0
					return -1;
    9578:	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    957c:	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    9580:	add	sp, #12
    9582:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9586:	nop
    9588:	.word	0x20019ca8
    958c:	.word	0x20019bb8
    9590:	.word	0x20019bb0
    9594:	.word	0x20019bb1
    9598:	.word	0x20019bb4

0000959c <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    959c:	push	{lr}
    959e:	sub	sp, #12
    95a0:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    95a2:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    95a4:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    95a8:	mov	r0, r3
    95aa:	bl	9494 <usb_serial_write>
}
    95ae:	add	sp, #12
    95b0:	ldr.w	pc, [sp], #4

000095b4 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    95b4:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    95b6:	ldr	r5, [pc, #56]	; (95f0 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    95b8:	ldr	r4, [pc, #56]	; (95f4 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    95ba:	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    95bc:	movs	r3, #1
    95be:	strb	r3, [r4, #0]
	if (!tx_packet) {
    95c0:	cbz	r0, 95ce <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    95c2:	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    95c4:	movs	r3, #0
    95c6:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    95c8:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    95cc:	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    95ce:	ldr	r3, [pc, #40]	; (95f8 <usb_serial_write_buffer_free+0x44>)
    95d0:	ldrb	r3, [r3, #0]
    95d2:	cbnz	r3, 95da <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    95d4:	movs	r0, #0
    95d6:	strb	r0, [r4, #0]
			return 0;
    95d8:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    95da:	movs	r0, #4
    95dc:	bl	9c58 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    95e0:	cmp	r0, #7
    95e2:	bhi.n	95d4 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    95e4:	bl	9b90 <usb_malloc>
    95e8:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    95ea:	cmp	r0, #0
    95ec:	bne.n	95c2 <usb_serial_write_buffer_free+0xe>
    95ee:	b.n	95d4 <usb_serial_write_buffer_free+0x20>
    95f0:	.word	0x20019bb4
    95f4:	.word	0x20019bb1
    95f8:	.word	0x20019ca8

000095fc <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    95fc:	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    95fe:	ldr	r3, [pc, #68]	; (9644 <usb_serial_flush_output+0x48>)
    9600:	ldrb	r3, [r3, #0]
    9602:	cbz	r3, 9628 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    9604:	ldr	r6, [pc, #64]	; (9648 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    9606:	ldr	r5, [pc, #68]	; (964c <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    9608:	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    960a:	movs	r7, #1
    960c:	strb	r7, [r5, #0]
	if (tx_packet) {
    960e:	cbz	r4, 962a <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    9610:	ldr	r2, [pc, #60]	; (9650 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    9612:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    9614:	movs	r7, #0
    9616:	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9618:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    961a:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    961c:	movs	r0, #4
    961e:	bl	9d08 <usb_tx>
		tx_packet = NULL;
    9622:	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    9624:	movs	r3, #0
    9626:	strb	r3, [r5, #0]
    9628:	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    962a:	bl	9b90 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    962e:	ldr	r3, [pc, #32]	; (9650 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    9630:	cbz	r0, 963e <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    9632:	mov	r1, r0
    9634:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    9636:	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    9638:	bl	9d08 <usb_tx>
    963c:	b.n	9624 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    963e:	strb	r7, [r3, #0]
    9640:	b.n	9624 <usb_serial_flush_output+0x28>
    9642:	nop
    9644:	.word	0x20019ca8
    9648:	.word	0x20019bb4
    964c:	.word	0x20019bb1
    9650:	.word	0x20019bb0

00009654 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    9654:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    9656:	ldr	r3, [pc, #56]	; (9690 <usb_serial_flush_callback+0x3c>)
    9658:	ldrb	r3, [r3, #0]
    965a:	cbnz	r3, 967a <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    965c:	ldr	r4, [pc, #52]	; (9694 <usb_serial_flush_callback+0x40>)
    965e:	ldr	r1, [r4, #0]
    9660:	cbz	r1, 967c <usb_serial_flush_callback+0x28>
    9662:	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    9666:	ldrh	r3, [r1, #2]
    9668:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    966a:	movs	r0, #4
    966c:	bl	9d08 <usb_tx>
		tx_packet = NULL;
    9670:	str	r5, [r4, #0]
    9672:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    9674:	ldr	r3, [pc, #32]	; (9698 <usb_serial_flush_callback+0x44>)
    9676:	movs	r2, #1
    9678:	strb	r2, [r3, #0]
    967a:	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    967c:	bl	9b90 <usb_malloc>
		if (tx) {
    9680:	cmp	r0, #0
    9682:	beq.n	9674 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    9684:	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    9686:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    968a:	movs	r0, #4
    968c:	b.w	9d08 <usb_tx>
    9690:	.word	0x20019bb1
    9694:	.word	0x20019bb4
    9698:	.word	0x20019bb0

0000969c <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    969c:	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    969e:	ldr	r0, [pc, #164]	; (9744 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    96a0:	ldr	r2, [pc, #164]	; (9748 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    96a2:	ldr	r3, [pc, #168]	; (974c <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    96a4:	ldr	r5, [pc, #168]	; (9750 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    96a6:	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    96a8:	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    96aa:	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    96ac:	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    96ae:	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    96b0:	ldr	r4, [pc, #160]	; (9754 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    96b2:	cmp	r3, #8
    96b4:	beq.n	9718 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    96b6:	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    96b8:	ldr	r0, [pc, #156]	; (9758 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    96ba:	ldr	r1, [pc, #160]	; (975c <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    96bc:	beq.n	972e <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    96be:	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    96c0:	ite	eq
    96c2:	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    96c4:	movne	r2, #61	; 0x3d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    96c6:	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    96c8:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    96ca:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    96cc:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    96ce:	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    96d0:	ldr	r3, [pc, #140]	; (9760 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96d2:	ldr	r1, [pc, #144]	; (9764 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    96d4:	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96d6:	ldr	r2, [pc, #144]	; (9768 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    96d8:	cbz	r3, 970a <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96da:	movs	r3, #1
    96dc:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96de:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    96e0:	ldr	r3, [pc, #136]	; (976c <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    96e2:	ldr	r1, [pc, #140]	; (9770 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    96e4:	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    96e6:	ldr	r2, [pc, #140]	; (9774 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    96e8:	cmp	r3, #1
    96ea:	bls.n	973a <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    96ec:	cmp	r3, #4
    96ee:	bls.n	9710 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    96f0:	cmp	r3, #8
    96f2:	bls.n	9732 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    96f4:	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    96f6:	ite	ls
    96f8:	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    96fa:	movhi	r3, #135	; 0x87
    96fc:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    96fe:	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    9700:	ldr	r3, [pc, #116]	; (9778 <analog_init+0xdc>)
    9702:	movs	r2, #1
    9704:	strb	r2, [r3, #0]
}
    9706:	pop	{r4, r5}
    9708:	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    970a:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    970c:	str	r3, [r2, #0]
    970e:	b.n	96e0 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    9710:	movs	r3, #132	; 0x84
    9712:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    9714:	str	r3, [r2, #0]
    9716:	b.n	9700 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    9718:	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    971c:	ldr	r1, [pc, #60]	; (975c <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    971e:	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    9720:	movs	r2, #1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    9722:	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    9724:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    9726:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    9728:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    972a:	str	r3, [r1, #0]
    972c:	b.n	96d0 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    972e:	movs	r2, #57	; 0x39
    9730:	b.n	9722 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    9732:	movs	r3, #133	; 0x85
    9734:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    9736:	str	r3, [r2, #0]
    9738:	b.n	9700 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    973a:	movs	r3, #128	; 0x80
    973c:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    973e:	str	r3, [r2, #0]
    9740:	b.n	9700 <analog_init+0x64>
    9742:	nop
    9744:	.word	0x40074000
    9748:	.word	0x40074001
    974c:	.word	0x200138d5
    9750:	.word	0x4003b008
    9754:	.word	0x4003b00c
    9758:	.word	0x400bb008
    975c:	.word	0x400bb00c
    9760:	.word	0x20019bc2
    9764:	.word	0x4003b020
    9768:	.word	0x400bb020
    976c:	.word	0x200138d6
    9770:	.word	0x4003b024
    9774:	.word	0x400bb024
    9778:	.word	0x20019bc1

0000977c <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    977c:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    977e:	ldr	r4, [pc, #64]	; (97c0 <fault_isr+0x44>)
    9780:	b.n	9794 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    9782:	ldr	r3, [r4, #0]
    9784:	lsls	r1, r3, #21
    9786:	bmi.n	97a4 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    9788:	ldr	r3, [r4, #0]
    978a:	lsls	r2, r3, #20
    978c:	bmi.n	97ae <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    978e:	ldr	r3, [r4, #0]
    9790:	lsls	r3, r3, #19
    9792:	bmi.n	97b8 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    9794:	ldr	r3, [r4, #0]
    9796:	lsls	r0, r3, #13
    9798:	bpl.n	9782 <fault_isr+0x6>
    979a:	bl	9d8c <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    979e:	ldr	r3, [r4, #0]
    97a0:	lsls	r1, r3, #21
    97a2:	bpl.n	9788 <fault_isr+0xc>
    97a4:	bl	97c4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    97a8:	ldr	r3, [r4, #0]
    97aa:	lsls	r2, r3, #20
    97ac:	bpl.n	978e <fault_isr+0x12>
    97ae:	bl	97c4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    97b2:	ldr	r3, [r4, #0]
    97b4:	lsls	r3, r3, #19
    97b6:	bpl.n	9794 <fault_isr+0x18>
    97b8:	bl	97c4 <unused_isr>
    97bc:	b.n	9794 <fault_isr+0x18>
    97be:	nop
    97c0:	.word	0x40048034

000097c4 <unused_isr>:
	}
}

void unused_isr(void)
{
    97c4:	push	{r3, lr}
	fault_isr();
    97c6:	bl	977c <fault_isr>
    97ca:	nop

000097cc <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    97cc:	ldr	r3, [pc, #4]	; (97d4 <startup_early_hook+0x8>)
    97ce:	movs	r2, #16
    97d0:	strh	r2, [r3, #0]
    97d2:	bx	lr
    97d4:	.word	0x40052000

000097d8 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    97d8:	bx	lr
    97da:	nop

000097dc <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    97dc:	ldr	r1, [pc, #36]	; (9804 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    97de:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    97e0:	ldr	r3, [r1, #0]
	if (incr != 0) {
    97e2:	cbz	r0, 97f2 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    97e4:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    97e6:	add	r0, r3
    97e8:	sub.w	r2, r2, #8192	; 0x2000
    97ec:	cmp	r0, r2
    97ee:	bcs.n	97f6 <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    97f0:	str	r0, [r1, #0]
	}
	return prev;
    97f2:	mov	r0, r3
}
    97f4:	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    97f6:	bl	bc64 <__errno>
    97fa:	movs	r3, #12
    97fc:	str	r3, [r0, #0]
			return (void *)-1;
    97fe:	mov.w	r0, #4294967295
    9802:	pop	{r3, pc}
    9804:	.word	0x200138d8

00009808 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    9808:	b.n	9808 <__cxa_pure_virtual>
    980a:	nop

0000980c <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    980c:	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    980e:	ldr	r3, [pc, #68]	; (9854 <digitalWrite.part.1+0x48>)
    9810:	ldr.w	r2, [r3, r0, lsl #3]
    9814:	ldrb.w	r4, [r2, #640]	; 0x280
    9818:	cbz	r4, 9828 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    981a:	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    981c:	cbz	r1, 983e <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    981e:	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9822:	ldr.w	r4, [sp], #4
    9826:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    9828:	add.w	r3, r3, r0, lsl #3
    982c:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    982e:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    9830:	cbnz	r1, 9848 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    9832:	bic.w	r2, r2, #2
    9836:	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9838:	ldr.w	r4, [sp], #4
    983c:	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    983e:	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9842:	ldr.w	r4, [sp], #4
    9846:	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9848:	orr.w	r2, r2, #3
    984c:	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    984e:	ldr.w	r4, [sp], #4
    9852:	bx	lr
    9854:	.word	0x00013864

00009858 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    9858:	ldr	r2, [pc, #112]	; (98cc <pinMode.part.2+0x74>)
    985a:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    985e:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    9860:	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    9862:	beq.n	9888 <pinMode.part.2+0x30>
    9864:	cmp	r1, #4
    9866:	beq.n	98a0 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    9868:	ldr.w	r0, [r2, r0, lsl #3]
    986c:	movs	r2, #0
    986e:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    9872:	cbz	r1, 9880 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    9874:	cmp	r1, #2
    9876:	beq.n	98ba <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    9878:	cmp	r1, #3
    987a:	beq.n	98c2 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    987c:	str	r2, [r3, #0]
    987e:	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    9880:	mov.w	r2, #256	; 0x100
    9884:	str	r2, [r3, #0]
    9886:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9888:	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    988c:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9890:	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9894:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    9896:	ldr	r2, [r3, #0]
    9898:	bic.w	r2, r2, #32
    989c:	str	r2, [r3, #0]
    989e:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    98a0:	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    98a4:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    98a8:	movs	r0, #1
    98aa:	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    98ae:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    98b0:	ldr	r2, [r3, #0]
    98b2:	orr.w	r2, r2, #32
    98b6:	str	r2, [r3, #0]
    98b8:	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    98ba:	movw	r2, #259	; 0x103
    98be:	str	r2, [r3, #0]
    98c0:	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    98c2:	mov.w	r2, #258	; 0x102
    98c6:	str	r2, [r3, #0]
    98c8:	bx	lr
    98ca:	nop
    98cc:	.word	0x00013864

000098d0 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    98d0:	adds	r0, #16
    98d2:	ldr	r3, [pc, #8]	; (98dc <attachInterruptVector+0xc>)
    98d4:	str.w	r1, [r3, r0, lsl #2]
    98d8:	bx	lr
    98da:	nop
    98dc:	.word	0x20013200

000098e0 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    98e0:	ldr	r3, [pc, #4]	; (98e8 <rtc_get+0x8>)
    98e2:	ldr	r0, [r3, #0]
}
    98e4:	bx	lr
    98e6:	nop
    98e8:	.word	0x4003d000

000098ec <rtc_set>:

void rtc_set(unsigned long t)
{
    98ec:	push	{r4, r5}
	RTC_SR = 0;
    98ee:	ldr	r3, [pc, #20]	; (9904 <rtc_set+0x18>)
	RTC_TPR = 0;
    98f0:	ldr	r5, [pc, #20]	; (9908 <rtc_set+0x1c>)
	RTC_TSR = t;
    98f2:	ldr	r4, [pc, #24]	; (990c <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    98f4:	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    98f6:	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    98f8:	str	r2, [r3, #0]
	RTC_TPR = 0;
    98fa:	str	r2, [r5, #0]
	RTC_TSR = t;
    98fc:	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    98fe:	str	r1, [r3, #0]
}
    9900:	pop	{r4, r5}
    9902:	bx	lr
    9904:	.word	0x4003d014
    9908:	.word	0x4003d004
    990c:	.word	0x4003d000

00009910 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    9910:	cmp	r0, #63	; 0x3f
    9912:	bhi.n	9918 <digitalWrite+0x8>
    9914:	b.w	980c <digitalWrite.part.1>
    9918:	bx	lr
    991a:	nop

0000991c <digitalRead>:
#endif
}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    991c:	cmp	r0, #63	; 0x3f
    991e:	bhi.n	992e <digitalRead+0x12>
#ifdef KINETISK
	return *portInputRegister(pin);
    9920:	ldr	r3, [pc, #16]	; (9934 <digitalRead+0x18>)
    9922:	ldr.w	r3, [r3, r0, lsl #3]
    9926:	ldrb.w	r0, [r3, #512]	; 0x200
    992a:	uxtb	r0, r0
    992c:	bx	lr
#endif
}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    992e:	movs	r0, #0
#ifdef KINETISK
	return *portInputRegister(pin);
#else
	return (*portInputRegister(pin) & digitalPinToBitMask(pin)) ? 1 : 0;
#endif
}
    9930:	bx	lr
    9932:	nop
    9934:	.word	0x00013864

00009938 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    9938:	cmp	r0, #63	; 0x3f
    993a:	bhi.n	9940 <pinMode+0x8>
    993c:	b.w	9858 <pinMode.part.2>
    9940:	bx	lr
    9942:	nop

00009944 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9944:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    9946:	ldr	r1, [pc, #48]	; (9978 <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9948:	ldr	r3, [pc, #48]	; (997c <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    994a:	ldr	r2, [pc, #52]	; (9980 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    994c:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    994e:	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9950:	ldr	r2, [r2, #0]
	__enable_irq();
    9952:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9954:	lsls	r2, r2, #5
    9956:	bpl.n	995e <micros+0x1a>
    9958:	cmp	r3, #50	; 0x32
    995a:	it	hi
    995c:	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    995e:	ldr	r1, [pc, #36]	; (9984 <micros+0x40>)
    9960:	rsb	r3, r3, #95744	; 0x17600
    9964:	mov.w	r2, #1000	; 0x3e8
    9968:	adds	r3, #255	; 0xff
    996a:	umull	r1, r3, r1, r3
    996e:	mul.w	r0, r2, r0
}
    9972:	add.w	r0, r0, r3, lsr #6
    9976:	bx	lr
    9978:	.word	0x20019bc4
    997c:	.word	0xe000e018
    9980:	.word	0xe000ed04
    9984:	.word	0xaaaaaaab

00009988 <delay>:

void delay(uint32_t ms)
{
    9988:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    998c:	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    998e:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    9990:	ldr	r7, [pc, #128]	; (9a14 <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9992:	ldr	r3, [pc, #132]	; (9a18 <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9994:	ldr	r2, [pc, #132]	; (9a1c <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9996:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    9998:	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    999a:	ldr	r2, [r2, #0]
	__enable_irq();
    999c:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    999e:	lsls	r2, r2, #5
    99a0:	bpl.n	99a8 <delay+0x20>
    99a2:	cmp	r3, #50	; 0x32
    99a4:	it	hi
    99a6:	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    99a8:	cbz	r5, 9a10 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    99aa:	rsb	r3, r3, #95744	; 0x17600
    99ae:	ldr	r6, [pc, #112]	; (9a20 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    99b0:	ldr.w	r9, [pc, #100]	; 9a18 <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    99b4:	ldr.w	r8, [pc, #100]	; 9a1c <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    99b8:	adds	r3, #255	; 0xff
    99ba:	mov.w	r2, #1000	; 0x3e8
    99be:	umull	r1, r3, r6, r3
    99c2:	mul.w	r4, r2, r4
    99c6:	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    99ca:	cpsid	i
	current = SYST_CVR;
    99cc:	ldr.w	r1, [r9]
	count = systick_millis_count;
    99d0:	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    99d2:	ldr.w	lr, [r8]
	__enable_irq();
    99d6:	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    99d8:	rsb	r3, r1, #95744	; 0x17600
    99dc:	adds	r3, #255	; 0xff
    99de:	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    99e2:	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    99e6:	rsb	r3, r4, r3, lsr #6
    99ea:	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    99ee:	beq.n	99f6 <delay+0x6e>
    99f0:	cmp	r1, #50	; 0x32
    99f2:	it	hi
    99f4:	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    99f6:	mla	r3, r0, r2, r3
    99fa:	cmp.w	r3, #1000	; 0x3e8
    99fe:	bcc.n	9a0a <delay+0x82>
				ms--;
				if (ms == 0) return;
    9a00:	subs	r5, #1
    9a02:	beq.n	9a10 <delay+0x88>
				start += 1000;
    9a04:	add.w	r4, r4, #1000	; 0x3e8
    9a08:	b.n	99ca <delay+0x42>
			}
			yield();
    9a0a:	bl	a6c4 <yield>
		}
    9a0e:	b.n	99ca <delay+0x42>
    9a10:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9a14:	.word	0x20019bc4
    9a18:	.word	0xe000e018
    9a1c:	.word	0xe000ed04
    9a20:	.word	0xaaaaaaab

00009a24 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    9a24:	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9a26:	ldr	r3, [pc, #312]	; (9b60 <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    9a28:	ldr	r0, [pc, #312]	; (9b64 <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    9a2a:	ldr.w	ip, [pc, #348]	; 9b88 <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    9a2e:	ldr	r4, [pc, #312]	; (9b68 <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    9a30:	ldr	r1, [pc, #312]	; (9b6c <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9a32:	ldr.w	lr, [pc, #344]	; 9b8c <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    9a36:	ldr	r6, [pc, #312]	; (9b70 <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    9a38:	ldr	r5, [pc, #312]	; (9b74 <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    9a3a:	ldr	r7, [pc, #316]	; (9b78 <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9a3c:	mov.w	r2, #134217728	; 0x8000000
    9a40:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    9a42:	mov.w	r2, #268435456	; 0x10000000
    9a46:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    9a48:	mov.w	r2, #536870912	; 0x20000000
    9a4c:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    9a4e:	mov.w	r2, #1073741824	; 0x40000000
    9a52:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    9a54:	mov.w	r2, #2147483648	; 0x80000000
    9a58:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    9a5a:	movs	r2, #0
    9a5c:	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9a5e:	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    9a60:	movw	r0, #49151	; 0xbfff
    9a64:	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9a68:	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    9a6c:	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    9a6e:	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    9a72:	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    9a74:	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    9a76:	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9a78:	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    9a7c:	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    9a7e:	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    9a82:	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    9a84:	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    9a88:	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    9a8a:	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    9a8e:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9a92:	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    9a96:	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    9a9a:	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    9a9e:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    9aa0:	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    9aa4:	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9aa6:	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    9aa8:	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    9aaa:	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    9aae:	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    9ab0:	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    9ab2:	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9ab4:	ldr	r4, [pc, #196]	; (9b7c <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    9ab6:	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    9ab8:	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9aba:	movs	r1, #9
    9abc:	str	r1, [r4, #0]
	FTM1_CNT = 0;
    9abe:	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    9ac2:	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    9ac6:	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    9ac8:	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    9aca:	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    9acc:	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    9ace:	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    9ad0:	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9ad2:	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    9ad6:	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    9ada:	add.w	r7, r7, #520192	; 0x7f000
    9ade:	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    9ae0:	addw	r4, r4, #2044	; 0x7fc
    9ae4:	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    9ae6:	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    9ae8:	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    9aea:	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9aec:	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    9af0:	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    9af2:	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    9af6:	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    9afa:	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9afc:	sub.w	r4, r4, #460800	; 0x70800
    9b00:	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    9b04:	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    9b06:	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9b08:	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9b0c:	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9b0e:	ldr	r0, [pc, #112]	; (9b80 <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9b10:	orr.w	r1, r1, #512	; 0x200
    9b14:	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9b16:	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9b18:	ldr	r4, [pc, #104]	; (9b84 <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    9b1a:	add.w	lr, lr, #65280	; 0xff00
    9b1e:	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    9b22:	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    9b26:	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    9b2a:	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9b2e:	orr.w	r1, r1, #33554432	; 0x2000000
    9b32:	str	r1, [r0, #0]
	TPM1_CNT = 0;
    9b34:	str.w	r2, [lr]
	TPM1_MOD = 32767;
    9b38:	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9b3c:	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    9b3e:	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    9b40:	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    9b42:	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9b44:	str	r2, [r4, #0]
#endif
	analog_init();
    9b46:	bl	969c <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    9b4a:	movs	r0, #25
    9b4c:	bl	9988 <delay>
	usb_init();
    9b50:	bl	a600 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9b54:	movw	r0, #275	; 0x113
}
    9b58:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9b5c:	b.w	9988 <delay>
    9b60:	.word	0xe000e104
    9b64:	.word	0x40038004
    9b68:	.word	0x40038014
    9b6c:	.word	0x4003801c
    9b70:	.word	0x40038024
    9b74:	.word	0x4003802c
    9b78:	.word	0x40038034
    9b7c:	.word	0x40038000
    9b80:	.word	0x40048004
    9b84:	.word	0x400c9000
    9b88:	.word	0x40038008
    9b8c:	.word	0x4003800c

00009b90 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    9b90:	cpsid	i
	avail = usb_buffer_available;
    9b92:	ldr	r0, [pc, #52]	; (9bc8 <usb_malloc+0x38>)
    9b94:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    9b96:	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    9b9a:	cmp	r3, #11
    9b9c:	bgt.n	9bc0 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    9b9e:	mov.w	r1, #2147483648	; 0x80000000
    9ba2:	lsrs	r1, r3
    9ba4:	bic.w	r2, r2, r1
    9ba8:	str	r2, [r0, #0]
	__enable_irq();
    9baa:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    9bac:	ldr	r0, [pc, #28]	; (9bcc <usb_malloc+0x3c>)
    9bae:	add.w	r3, r3, r3, lsl #3
    9bb2:	lsls	r3, r3, #3
    9bb4:	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    9bb6:	movs	r1, #0
    9bb8:	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    9bba:	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    9bbc:	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    9bbe:	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    9bc0:	cpsie	i
		return NULL;
    9bc2:	movs	r0, #0
    9bc4:	bx	lr
    9bc6:	nop
    9bc8:	.word	0x200138dc
    9bcc:	.word	0x200133d0

00009bd0 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    9bd0:	ldr	r3, [pc, #52]	; (9c08 <usb_free+0x38>)
    9bd2:	ldr	r2, [pc, #56]	; (9c0c <usb_free+0x3c>)
    9bd4:	subs	r3, r0, r3
    9bd6:	umull	r2, r3, r2, r3
    9bda:	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    9bdc:	cmp	r3, #11
    9bde:	bhi.n	9bfa <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    9be0:	ldr	r2, [pc, #44]	; (9c10 <usb_free+0x40>)
    9be2:	ldrb	r2, [r2, #0]
    9be4:	cbnz	r2, 9bfc <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    9be6:	cpsid	i
	usb_buffer_available |= mask;
    9be8:	ldr	r0, [pc, #40]	; (9c14 <usb_free+0x44>)
    9bea:	mov.w	r1, #2147483648	; 0x80000000
    9bee:	ldr	r2, [r0, #0]
    9bf0:	lsr.w	r3, r1, r3
    9bf4:	orrs	r2, r3
    9bf6:	str	r2, [r0, #0]
	__enable_irq();
    9bf8:	cpsie	i
    9bfa:	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    9bfc:	ldr	r2, [pc, #24]	; (9c18 <usb_free+0x48>)
    9bfe:	ldrb	r2, [r2, #0]
    9c00:	cmp	r2, #0
    9c02:	beq.n	9be6 <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    9c04:	b.w	9c84 <usb_rx_memory>
    9c08:	.word	0x200133d0
    9c0c:	.word	0x38e38e39
    9c10:	.word	0x20019c9d
    9c14:	.word	0x200138dc
    9c18:	.word	0x20019ca8

00009c1c <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    9c1c:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9c1e:	cmp	r3, #3
    9c20:	bhi.n	9c4c <usb_rx+0x30>
	__disable_irq();
    9c22:	cpsid	i
	ret = rx_first[endpoint];
    9c24:	ldr	r1, [pc, #40]	; (9c50 <usb_rx+0x34>)
    9c26:	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    9c2a:	cbz	r0, 9c48 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    9c2c:	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9c2e:	ldr	r4, [pc, #36]	; (9c54 <usb_rx+0x38>)
    9c30:	ldrh	r5, [r0, #0]
    9c32:	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    9c36:	ldr	r6, [r0, #4]
    9c38:	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9c3c:	subs	r2, r2, r5
    9c3e:	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    9c42:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9c44:	pop	{r4, r5, r6}
    9c46:	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    9c48:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9c4a:	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9c4c:	movs	r0, #0
    9c4e:	bx	lr
    9c50:	.word	0x20019c20
    9c54:	.word	0x20019dac

00009c58 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9c58:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9c5a:	cmp	r0, #3
    9c5c:	bhi.n	9c76 <usb_tx_packet_count+0x1e>
	__disable_irq();
    9c5e:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9c60:	ldr	r3, [pc, #28]	; (9c80 <usb_tx_packet_count+0x28>)
    9c62:	ldr.w	r3, [r3, r0, lsl #2]
    9c66:	cbz	r3, 9c7a <usb_tx_packet_count+0x22>
    9c68:	movs	r0, #0
    9c6a:	ldr	r3, [r3, #4]
    9c6c:	adds	r0, #1
    9c6e:	cmp	r3, #0
    9c70:	bne.n	9c6a <usb_tx_packet_count+0x12>
	__enable_irq();
    9c72:	cpsie	i
	return count;
    9c74:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9c76:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    9c78:	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    9c7a:	mov	r0, r3
    9c7c:	b.n	9c72 <usb_tx_packet_count+0x1a>
    9c7e:	nop
    9c80:	.word	0x20019c74

00009c84 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    9c84:	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    9c86:	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    9c88:	ldr	r1, [pc, #104]	; (9cf4 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    9c8a:	ldr	r6, [pc, #108]	; (9cf8 <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9c8c:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9c8e:	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    9c92:	ldr	r7, [pc, #100]	; (9cf8 <usb_rx_memory+0x74>)
    9c94:	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9c96:	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9c98:	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9c9c:	bpl.n	9caa <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9c9e:	ldr.w	r4, [r6, r2, lsl #3]
    9ca2:	cbz	r4, 9cbe <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9ca4:	ldr.w	r2, [r6, r5, lsl #3]
    9ca8:	cbz	r2, 9cda <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9caa:	adds	r3, #1
    9cac:	cmp	r3, #5
    9cae:	bne.n	9c8e <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    9cb0:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9cb2:	ldr	r3, [pc, #72]	; (9cfc <usb_rx_memory+0x78>)
    9cb4:	movs	r2, #0
    9cb6:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    9cb8:	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    9cba:	b.w	9bd0 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    9cbe:	ldr	r4, [pc, #60]	; (9cfc <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9cc0:	ldr	r5, [pc, #60]	; (9d00 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    9cc2:	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    9cc4:	add.w	r3, r7, r3, lsl #5
    9cc8:	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    9cca:	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    9ccc:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    9cce:	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9cd0:	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    9cd4:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    9cd6:	pop	{r4, r5, r6, r7}
    9cd8:	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    9cda:	ldr	r2, [pc, #32]	; (9cfc <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9cdc:	ldr	r1, [pc, #36]	; (9d04 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    9cde:	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    9ce0:	add.w	r4, r7, r5, lsl #3
    9ce4:	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    9ce6:	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    9ce8:	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    9cea:	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9cec:	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    9cf0:	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    9cf2:	b.n	9cd6 <usb_rx_memory+0x52>
    9cf4:	.word	0x00013a90
    9cf8:	.word	0x1fff0000
    9cfc:	.word	0x20019c9d
    9d00:	.word	0x00400088
    9d04:	.word	0x004000c8

00009d08 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    9d08:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    9d0a:	cmp	r3, #3
    9d0c:	bhi.n	9d4a <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9d0e:	ldr	r2, [pc, #108]	; (9d7c <usb_tx+0x74>)
    9d10:	lsls	r0, r0, #5
    9d12:	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    9d16:	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9d18:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    9d1a:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    9d1c:	ldr	r4, [pc, #96]	; (9d80 <usb_tx+0x78>)
    9d1e:	ldrb	r2, [r4, r3]
    9d20:	cmp	r2, #3
    9d22:	bhi.n	9d5c <usb_tx+0x54>
    9d24:	tbb	[pc, r2]
    9d28:	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9d2c:	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9d2e:	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    9d30:	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9d32:	tst.w	r0, #8
    9d36:	ite	ne
    9d38:	movne	r3, #200	; 0xc8
    9d3a:	moveq	r3, #136	; 0x88
    9d3c:	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9d40:	adds	r1, #8
    9d42:	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9d44:	str	r3, [r0, #0]
	__enable_irq();
    9d46:	cpsie	i
}
    9d48:	pop	{r4, r5}
    9d4a:	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    9d4c:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    9d4e:	movs	r2, #2
		break;
    9d50:	b.n	9d2e <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    9d52:	movs	r2, #5
    9d54:	b.n	9d2e <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    9d56:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9d58:	movs	r2, #4
		break;
    9d5a:	b.n	9d2e <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    9d5c:	ldr	r2, [pc, #36]	; (9d84 <usb_tx+0x7c>)
    9d5e:	ldr.w	r0, [r2, r3, lsl #2]
    9d62:	cbz	r0, 9d74 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    9d64:	ldr	r2, [pc, #32]	; (9d88 <usb_tx+0x80>)
    9d66:	ldr.w	r0, [r2, r3, lsl #2]
    9d6a:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    9d6c:	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    9d70:	cpsie	i
		return;
    9d72:	b.n	9d48 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    9d74:	str.w	r1, [r2, r3, lsl #2]
    9d78:	ldr	r2, [pc, #12]	; (9d88 <usb_tx+0x80>)
    9d7a:	b.n	9d6c <usb_tx+0x64>
    9d7c:	.word	0x1fff0000
    9d80:	.word	0x20019cac
    9d84:	.word	0x20019c74
    9d88:	.word	0x20019c84

00009d8c <usb_isr>:
}



void usb_isr(void)
{
    9d8c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    9d90:	ldr.w	fp, [pc, #788]	; a0a8 <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    9d94:	ldr.w	sl, [pc, #788]	; a0ac <usb_isr+0x320>
}



void usb_isr(void)
{
    9d98:	sub	sp, #28
    9d9a:	b.n	9e26 <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9d9c:	ldr	r7, [pc, #692]	; (a054 <usb_isr+0x2c8>)
    9d9e:	mov.w	r8, r3, lsr #2
    9da2:	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9da6:	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9da8:	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9dac:	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9db0:	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9db2:	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9db6:	and.w	r4, r3, #255	; 0xff
    9dba:	cmp	r3, #0
    9dbc:	bne.w	9fc6 <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9dc0:	ldr.w	r3, [r7, r8, lsl #3]
    9dc4:	lsrs	r3, r3, #16
    9dc6:	uxth	r1, r3
    9dc8:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9dcc:	cmp	r3, #0
    9dce:	beq.w	9fb4 <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9dd2:	ldr	r3, [pc, #644]	; (a058 <usb_isr+0x2cc>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9dd4:	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    9dd8:	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9ddc:	ldr.w	r2, [r3, r6, lsl #2]
    9de0:	cmp	r2, #0
    9de2:	beq.w	a0be <usb_isr+0x332>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9de6:	ldr	r5, [pc, #628]	; (a05c <usb_isr+0x2d0>)
    9de8:	ldr.w	r3, [r5, r6, lsl #2]
    9dec:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9dee:	ldr	r4, [pc, #624]	; (a060 <usb_isr+0x2d4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9df0:	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9df4:	ldrh.w	r3, [r4, r6, lsl #1]
    9df8:	add	r1, r3
    9dfa:	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9dfe:	bl	9b90 <usb_malloc>
					if (packet) {
    9e02:	cmp	r0, #0
    9e04:	beq.w	a0b0 <usb_isr+0x324>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    9e08:	ldr	r2, [pc, #600]	; (a064 <usb_isr+0x2d8>)
    9e0a:	ldr	r3, [pc, #604]	; (a068 <usb_isr+0x2dc>)
    9e0c:	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    9e10:	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    9e14:	it	ne
    9e16:	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    9e18:	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    9e1c:	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9e20:	movs	r3, #8
    9e22:	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    9e26:	ldrb.w	r4, [fp]
    9e2a:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    9e2c:	lsls	r0, r4, #29
    9e2e:	bpl.n	9e68 <usb_isr+0xdc>
		if (usb_configuration) {
    9e30:	ldr	r3, [pc, #568]	; (a06c <usb_isr+0x2e0>)
    9e32:	ldrb	r3, [r3, #0]
    9e34:	cbz	r3, 9e62 <usb_isr+0xd6>
			t = usb_reboot_timer;
    9e36:	ldr	r1, [pc, #568]	; (a070 <usb_isr+0x2e4>)
    9e38:	ldrb	r2, [r1, #0]
			if (t) {
    9e3a:	and.w	r3, r2, #255	; 0xff
    9e3e:	cbz	r2, 9e4c <usb_isr+0xc0>
				usb_reboot_timer = --t;
    9e40:	subs	r3, #1
    9e42:	uxtb	r3, r3
    9e44:	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    9e46:	cmp	r3, #0
    9e48:	beq.w	a5b6 <usb_isr+0x82a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    9e4c:	ldr	r1, [pc, #548]	; (a074 <usb_isr+0x2e8>)
    9e4e:	ldrb	r2, [r1, #0]
			if (t) {
    9e50:	and.w	r3, r2, #255	; 0xff
    9e54:	cbz	r2, 9e62 <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    9e56:	subs	r3, #1
    9e58:	uxtb	r3, r3
    9e5a:	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    9e5c:	cmp	r3, #0
    9e5e:	beq.w	a04e <usb_isr+0x2c2>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    9e62:	movs	r3, #4
    9e64:	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    9e68:	and.w	r3, r4, #8
    9e6c:	and.w	r2, r3, #255	; 0xff
    9e70:	cmp	r3, #0
    9e72:	beq.w	a020 <usb_isr+0x294>
		uint8_t endpoint;
		stat = USB0_STAT;
    9e76:	ldrb.w	r3, [sl]
    9e7a:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    9e7c:	lsrs	r6, r3, #4
    9e7e:	bne.n	9d9c <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9e80:	lsrs	r4, r3, #2
    9e82:	ldr	r7, [pc, #464]	; (a054 <usb_isr+0x2c8>)
	pid = BDT_PID(b->desc);
    9e84:	ldr.w	r2, [r7, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9e88:	add.w	r1, r7, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9e8c:	ubfx	r2, r2, #2, #4
    9e90:	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    9e92:	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9e94:	cmp	r2, #12
    9e96:	bhi.n	9f96 <usb_isr+0x20a>
    9e98:	tbb	[pc, r2]
    9e9c:	.word	0x7d7d8181
    9ea0:	.word	0x7d7d7d7d
    9ea4:	.word	0x7d7d7d42
    9ea8:	.byte	0x07
    9ea9:	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9eaa:	ldr	r0, [r1, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9eac:	ldr	r3, [pc, #456]	; (a078 <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9eae:	ldr	r5, [pc, #460]	; (a07c <usb_isr+0x2f0>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9eb0:	str	r3, [sp, #4]
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9eb2:	ldr	r3, [pc, #432]	; (a064 <usb_isr+0x2d8>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    9eb4:	ldr	r2, [r1, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9eb6:	ldr	r6, [pc, #456]	; (a080 <usb_isr+0x2f4>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9eb8:	str.w	r3, [r7, r4, lsl #3]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9ebc:	uxth	r1, r0
    9ebe:	movw	r4, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9ec2:	ldr	r3, [pc, #436]	; (a078 <usb_isr+0x2ec>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    9ec4:	str	r2, [r5, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9ec6:	str	r0, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9ec8:	movs	r2, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9eca:	movs	r0, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9ecc:	cmp	r1, r4
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    9ece:	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9ed0:	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    9ed2:	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9ed4:	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9ed6:	bhi.w	a0c6 <usb_isr+0x33a>
    9eda:	cmp.w	r1, #1664	; 0x680
    9ede:	bcs.w	a4b2 <usb_isr+0x726>
    9ee2:	cmp.w	r1, #258	; 0x102
    9ee6:	beq.w	a490 <usb_isr+0x704>
    9eea:	bhi.w	a29e <usb_isr+0x512>
    9eee:	cmp	r1, #128	; 0x80
    9ef0:	beq.w	a18e <usb_isr+0x402>
    9ef4:	cmp	r1, #130	; 0x82
    9ef6:	bne.w	a41e <usb_isr+0x692>
    9efa:	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9efc:	ldr	r3, [pc, #388]	; (a084 <usb_isr+0x2f8>)
    9efe:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9f02:	cmp	r1, #4
    9f04:	bhi.w	a420 <usb_isr+0x694>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9f08:	ldr	r4, [pc, #380]	; (a088 <usb_isr+0x2fc>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9f0a:	lsls	r1, r1, #2
    9f0c:	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9f0e:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    9f10:	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9f12:	ldrb	r2, [r3, #0]
    9f14:	lsls	r3, r2, #30
    9f16:	bpl.w	a58a <usb_isr+0x7fe>
    9f1a:	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    9f1c:	movs	r0, #2
    9f1e:	b.n	a196 <usb_isr+0x40a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    9f20:	ldr	r3, [pc, #340]	; (a078 <usb_isr+0x2ec>)
    9f22:	str	r3, [sp, #4]
    9f24:	ldr	r2, [r3, #0]
		if (data) {
    9f26:	cbz	r2, 9f82 <usb_isr+0x1f6>
			size = ep0_tx_len;
    9f28:	ldr	r3, [pc, #352]	; (a08c <usb_isr+0x300>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9f2a:	ldr	r1, [pc, #356]	; (a090 <usb_isr+0x304>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9f2c:	ldr	r6, [pc, #336]	; (a080 <usb_isr+0x2f4>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    9f2e:	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9f30:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9f32:	ldrb.w	lr, [r6]
    9f36:	cmp	r0, #64	; 0x40
    9f38:	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9f3a:	eor.w	ip, r4, #1
    9f3e:	it	cs
    9f40:	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9f42:	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9f46:	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9f4a:	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    9f4e:	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9f52:	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9f56:	ite	eq
    9f58:	moveq	r1, #136	; 0x88
    9f5a:	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    9f5c:	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    9f5e:	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9f62:	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9f66:	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    9f6a:	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    9f6c:	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    9f70:	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9f72:	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9f76:	cbnz	r0, 9f7e <usb_isr+0x1f2>
    9f78:	cmp	r5, #64	; 0x40
    9f7a:	it	ne
    9f7c:	movne	r2, #0
    9f7e:	ldr	r3, [sp, #4]
    9f80:	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    9f82:	ldr	r3, [pc, #248]	; (a07c <usb_isr+0x2f0>)
    9f84:	ldrh	r2, [r3, #0]
    9f86:	cmp.w	r2, #1280	; 0x500
    9f8a:	bne.n	9f96 <usb_isr+0x20a>
			setup.bRequest = 0;
    9f8c:	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    9f8e:	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    9f90:	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    9f92:	ldr	r3, [pc, #256]	; (a094 <usb_isr+0x308>)
    9f94:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9f96:	ldr	r2, [pc, #256]	; (a098 <usb_isr+0x30c>)
    9f98:	movs	r3, #1
    9f9a:	strb	r3, [r2, #0]
    9f9c:	b.n	9e20 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    9f9e:	ldr	r2, [pc, #220]	; (a07c <usb_isr+0x2f0>)
    9fa0:	ldrh	r5, [r2, #0]
    9fa2:	movw	r0, #8225	; 0x2021
    9fa6:	cmp	r5, r0
    9fa8:	beq.w	a250 <usb_isr+0x4c4>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9fac:	ldr	r2, [pc, #180]	; (a064 <usb_isr+0x2d8>)
    9fae:	str.w	r2, [r7, r4, lsl #3]
    9fb2:	b.n	9f96 <usb_isr+0x20a>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9fb4:	ldr	r2, [pc, #172]	; (a064 <usb_isr+0x2d8>)
    9fb6:	ldr	r3, [pc, #176]	; (a068 <usb_isr+0x2dc>)
    9fb8:	tst.w	r9, #8
    9fbc:	it	ne
    9fbe:	movne	r3, r2
    9fc0:	str.w	r3, [r7, r8, lsl #3]
    9fc4:	b.n	9e20 <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    9fc6:	bl	9bd0 <usb_free>
				packet = tx_first[endpoint];
    9fca:	ldr	r2, [pc, #208]	; (a09c <usb_isr+0x310>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    9fcc:	ldr	r1, [pc, #208]	; (a0a0 <usb_isr+0x314>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    9fce:	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    9fd2:	cmp	r3, #0
    9fd4:	beq.w	a232 <usb_isr+0x4a6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9fd8:	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    9fda:	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9fdc:	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    9fe0:	add.w	r2, r3, #8
    9fe4:	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    9fe8:	cmp	r4, #3
    9fea:	bhi.n	9ff8 <usb_isr+0x26c>
    9fec:	tbb	[pc, r4]
    9ff0:	.word	0x02150f12
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9ff4:	movs	r2, #4
    9ff6:	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    9ff8:	ldrh	r2, [r3, #0]
    9ffa:	tst.w	r9, #8
    9ffe:	ite	eq
    a000:	moveq	r3, #136	; 0x88
    a002:	movne	r3, #200	; 0xc8
    a004:	orr.w	r3, r3, r2, lsl #16
    a008:	str.w	r3, [r7, r8, lsl #3]
    a00c:	b.n	9e20 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    a00e:	movs	r2, #2
    a010:	strb	r2, [r1, r6]
						break;
    a012:	b.n	9ff8 <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    a014:	movs	r2, #3
    a016:	strb	r2, [r1, r6]
						break;
    a018:	b.n	9ff8 <usb_isr+0x26c>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    a01a:	movs	r2, #5
    a01c:	strb	r2, [r1, r6]
						break;
    a01e:	b.n	9ff8 <usb_isr+0x26c>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    a020:	lsls	r0, r4, #31
    a022:	bmi.w	a316 <usb_isr+0x58a>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    a026:	lsls	r1, r4, #24
    a028:	bmi.w	a370 <usb_isr+0x5e4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    a02c:	lsls	r2, r4, #30
    a02e:	bpl.n	a03e <usb_isr+0x2b2>
		uint8_t err = USB0_ERRSTAT;
    a030:	ldr	r2, [pc, #112]	; (a0a4 <usb_isr+0x318>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    a032:	ldr	r1, [pc, #116]	; (a0a8 <usb_isr+0x31c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    a034:	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    a036:	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    a038:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    a03a:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    a03c:	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    a03e:	lsls	r3, r4, #27
    a040:	bpl.n	a048 <usb_isr+0x2bc>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    a042:	ldr	r3, [pc, #100]	; (a0a8 <usb_isr+0x31c>)
    a044:	movs	r2, #16
    a046:	strb	r2, [r3, #0]
	}

}
    a048:	add	sp, #28
    a04a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    a04e:	bl	9654 <usb_serial_flush_callback>
    a052:	b.n	9e62 <usb_isr+0xd6>
    a054:	.word	0x1fff0000
    a058:	.word	0x20019c20
    a05c:	.word	0x20019bcc
    a060:	.word	0x20019dac
    a064:	.word	0x004000c8
    a068:	.word	0x00400088
    a06c:	.word	0x20019ca8
    a070:	.word	0x20019c31
    a074:	.word	0x20019bb0
    a078:	.word	0x20019bc8
    a07c:	.word	0x20019c94
    a080:	.word	0x20019c30
    a084:	.word	0x400720c0
    a088:	.word	0x20019ca0
    a08c:	.word	0x20019bdc
    a090:	.word	0x20019c9c
    a094:	.word	0x40072098
    a098:	.word	0x40072094
    a09c:	.word	0x20019c74
    a0a0:	.word	0x20019cac
    a0a4:	.word	0x40072088
    a0a8:	.word	0x40072080
    a0ac:	.word	0x40072090
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    a0b0:	ldr	r2, [pc, #732]	; (a390 <usb_isr+0x604>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    a0b2:	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    a0b6:	ldrb	r3, [r2, #0]
    a0b8:	adds	r3, #1
    a0ba:	strb	r3, [r2, #0]
    a0bc:	b.n	9e20 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    a0be:	str.w	r0, [r3, r6, lsl #2]
    a0c2:	ldr	r5, [pc, #720]	; (a394 <usb_isr+0x608>)
    a0c4:	b.n	9dee <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a0c6:	movw	r4, #8225	; 0x2021
    a0ca:	cmp	r1, r4
    a0cc:	beq.w	a22a <usb_isr+0x49e>
    a0d0:	bhi.w	a2f0 <usb_isr+0x564>
    a0d4:	cmp.w	r1, #2176	; 0x880
    a0d8:	beq.w	a384 <usb_isr+0x5f8>
    a0dc:	cmp.w	r1, #2304	; 0x900
    a0e0:	bne.w	a41e <usb_isr+0x692>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    a0e4:	ldr	r2, [pc, #688]	; (a398 <usb_isr+0x60c>)
    a0e6:	ldrb	r1, [r5, #2]
    a0e8:	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    a0ea:	ldr	r5, [pc, #688]	; (a39c <usb_isr+0x610>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    a0ec:	movs	r4, #4
    a0ee:	b.n	a0f6 <usb_isr+0x36a>
    a0f0:	adds	r4, #1
    a0f2:	cmp	r4, #20
    a0f4:	beq.n	a110 <usb_isr+0x384>
			if (table[i].desc & BDT_OWN) {
    a0f6:	ldr.w	r3, [r7, r4, lsl #3]
    a0fa:	lsls	r1, r3, #24
    a0fc:	bpl.n	a0f0 <usb_isr+0x364>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    a0fe:	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    a102:	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    a104:	ldr	r0, [r3, #4]
    a106:	subs	r0, #8
    a108:	bl	9bd0 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    a10c:	cmp	r4, #20
    a10e:	bne.n	a0f6 <usb_isr+0x36a>
    a110:	ldr	r1, [pc, #652]	; (a3a0 <usb_isr+0x614>)
    a112:	ldr	r3, [pc, #656]	; (a3a4 <usb_isr+0x618>)
    a114:	ldr	r2, [pc, #656]	; (a3a8 <usb_isr+0x61c>)
    a116:	str	r1, [sp, #8]
    a118:	ldr	r1, [pc, #656]	; (a3ac <usb_isr+0x620>)
    a11a:	ldr	r4, [pc, #660]	; (a3b0 <usb_isr+0x624>)
    a11c:	ldr	r5, [pc, #628]	; (a394 <usb_isr+0x608>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a11e:	str	r4, [sp, #12]
    a120:	str	r6, [sp, #20]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    a122:	mov.w	r9, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a126:	mov	r8, r1
    a128:	mov	r4, r3
    a12a:	mov	r6, r2
    a12c:	str	r5, [sp, #16]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    a12e:	ldr	r0, [r4, #0]
			while (p) {
    a130:	cbz	r0, a13e <usb_isr+0x3b2>
				n = p->next;
    a132:	ldr	r5, [r0, #4]
				usb_free(p);
    a134:	bl	9bd0 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    a138:	mov	r0, r5
    a13a:	cmp	r5, #0
    a13c:	bne.n	a132 <usb_isr+0x3a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    a13e:	movs	r3, #0
    a140:	str	r3, [r4, #0]
			rx_last[i] = NULL;
    a142:	ldr	r3, [sp, #16]
			p = tx_first[i];
    a144:	ldr	r0, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    a146:	mov	r2, r3
    a148:	movs	r3, #0
    a14a:	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    a14e:	cbz	r0, a15c <usb_isr+0x3d0>
				n = p->next;
    a150:	ldr	r5, [r0, #4]
				usb_free(p);
    a152:	bl	9bd0 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    a156:	mov	r0, r5
    a158:	cmp	r5, #0
    a15a:	bne.n	a150 <usb_isr+0x3c4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    a15c:	movs	r2, #0
    a15e:	str	r2, [r6, #0]
			tx_last[i] = NULL;
    a160:	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    a162:	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    a166:	mov	r1, r2
    a168:	movs	r2, #0
    a16a:	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    a16e:	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    a170:	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    a172:	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    a174:	mov.w	r1, #0
    a178:	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    a17c:	cmp	r3, #3
    a17e:	bhi.w	a4ea <usb_isr+0x75e>
    a182:	tbh	[pc, r3, lsl #1]
    a186:	.short	0x01e2
    a188:	.word	0x01e201ae
    a18c:	.short	0x01ae
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    a18e:	ldr	r4, [pc, #548]	; (a3b4 <usb_isr+0x628>)
		reply_buffer[1] = 0;
		datalen = 2;
    a190:	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    a192:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    a194:	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    a196:	ldrh	r2, [r5, #6]
    a198:	cmp	r2, r0
    a19a:	bcs.w	a5b8 <usb_isr+0x82c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a19e:	ldr	r1, [pc, #536]	; (a3b8 <usb_isr+0x62c>)
    a1a0:	ldrb	r5, [r1, #0]
    a1a2:	cmp	r2, #64	; 0x40
    a1a4:	orr.w	lr, r5, #2
    a1a8:	mov	ip, r2
    a1aa:	add.w	r0, r7, lr, lsl #3
    a1ae:	it	cs
    a1b0:	movcs.w	ip, #64	; 0x40
    a1b4:	add.w	r3, r4, ip
    a1b8:	str	r4, [r0, #4]
    a1ba:	str	r3, [sp, #8]
    a1bc:	rsb	r0, ip, r2
    a1c0:	mov.w	r8, ip, lsl #16
    a1c4:	mov.w	r9, #1
    a1c8:	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a1ca:	movs	r4, #200	; 0xc8
    a1cc:	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a1d0:	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a1d4:	str.w	r3, [r7, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    a1d8:	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    a1da:	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a1dc:	ldr.w	lr, [pc, #444]	; a39c <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    a1e0:	ldr	r3, [pc, #472]	; (a3bc <usb_isr+0x630>)
	ep0_tx_bdt_bank ^= 1;
    a1e2:	ldr.w	r8, [pc, #468]	; a3b8 <usb_isr+0x62c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    a1e6:	cmp	r0, #0
    a1e8:	bne.w	a42c <usb_isr+0x6a0>
    a1ec:	cmp.w	ip, #64	; 0x40
    a1f0:	bne.n	a22a <usb_isr+0x49e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a1f2:	orr.w	r4, r4, #2
    a1f6:	add.w	r3, r7, r4, lsl #3
    a1fa:	ldr	r7, [sp, #8]
    a1fc:	ldr.w	lr, [pc, #412]	; a39c <usb_isr+0x610>
    a200:	str	r7, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a202:	cmp	r2, #0
    a204:	bne.w	a456 <usb_isr+0x6ca>
    a208:	lsls	r2, r0, #16
    a20a:	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    a20e:	strb.w	r9, [r6]
	ep0_tx_bdt_bank ^= 1;
    a212:	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a214:	add	r7, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a216:	str.w	r2, [lr, r4, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a21a:	mov	r3, r7
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    a21c:	cmp	r0, #64	; 0x40
    a21e:	bne.n	a22a <usb_isr+0x49e>
    a220:	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    a222:	ldr	r2, [pc, #412]	; (a3c0 <usb_isr+0x634>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    a224:	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    a226:	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    a228:	str	r3, [r1, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    a22a:	ldr	r2, [pc, #408]	; (a3c4 <usb_isr+0x638>)
    a22c:	movs	r3, #1
    a22e:	strb	r3, [r2, #0]
    a230:	b.n	9f96 <usb_isr+0x20a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    a232:	ldrb	r3, [r1, r6]
    a234:	cmp	r3, #3
    a236:	bhi.w	a482 <usb_isr+0x6f6>
    a23a:	add	r2, pc, #4	; (adr r2, a240 <usb_isr+0x4b4>)
    a23c:	ldr.w	pc, [r2, r3, lsl #2]
    a240:	.word	0x00009e21
    a244:	.word	0x00009e21
    a248:	.word	0x0000a365
    a24c:	.word	0x0000a36b
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    a250:	ldrh	r2, [r2, #4]
    a252:	cbnz	r2, a26e <usb_isr+0x4e2>
    a254:	ldr	r2, [pc, #368]	; (a3c8 <usb_isr+0x63c>)
    a256:	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    a258:	ldrb.w	r3, [r1], #1
    a25c:	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    a260:	cmp	r5, r1
    a262:	bne.n	a258 <usb_isr+0x4cc>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    a264:	ldr	r2, [pc, #356]	; (a3cc <usb_isr+0x640>)
    a266:	ldr	r2, [r2, #0]
    a268:	cmp	r2, #134	; 0x86
    a26a:	beq.w	a400 <usb_isr+0x674>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a26e:	ldr	r1, [pc, #328]	; (a3b8 <usb_isr+0x62c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a270:	ldr	r6, [pc, #328]	; (a3bc <usb_isr+0x630>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a272:	ldrb	r0, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a274:	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a276:	orr.w	r5, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a27a:	eor.w	r0, r0, #1
    a27e:	strb	r0, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a280:	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a284:	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a286:	mov.w	r0, #0
    a28a:	str	r0, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    a28c:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a290:	ite	eq
    a292:	moveq	r1, #136	; 0x88
    a294:	movne	r1, #200	; 0xc8
    a296:	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    a29a:	strb	r2, [r6, #0]
    a29c:	b.n	9fac <usb_isr+0x220>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a29e:	movw	r2, #770	; 0x302
    a2a2:	cmp	r1, r2
    a2a4:	bne.w	a408 <usb_isr+0x67c>
    a2a8:	ldrh	r1, [r5, #4]
    a2aa:	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    a2ae:	cmp	r1, #4
    a2b0:	bhi.w	a41e <usb_isr+0x692>
    a2b4:	ldrh	r2, [r5, #2]
    a2b6:	cmp	r2, #0
    a2b8:	bne.w	a41e <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    a2bc:	ldr	r4, [pc, #272]	; (a3d0 <usb_isr+0x644>)
    a2be:	lsls	r1, r1, #2
    a2c0:	add	r4, r1
    a2c2:	mov	r9, r0
    a2c4:	ldrb	r1, [r4, #0]
    a2c6:	orr.w	r1, r1, #2
    a2ca:	strb	r1, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    a2cc:	movs	r0, #0
    a2ce:	str	r0, [sp, #8]
    a2d0:	mov	r8, r0
    a2d2:	mov	ip, r0
    a2d4:	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a2d6:	ldr	r1, [pc, #224]	; (a3b8 <usb_isr+0x62c>)
    a2d8:	ldrb	r5, [r1, #0]
    a2da:	orr.w	lr, r5, #2
    a2de:	add.w	r3, r7, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a2e2:	cmp.w	r9, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a2e6:	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a2e8:	ite	eq
    a2ea:	moveq	r4, #136	; 0x88
    a2ec:	movne	r4, #200	; 0xc8
    a2ee:	b.n	a1cc <usb_isr+0x440>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a2f0:	movw	r4, #8737	; 0x2221
    a2f4:	cmp	r1, r4
    a2f6:	bne.w	a416 <usb_isr+0x68a>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    a2fa:	ldrh	r1, [r5, #4]
    a2fc:	cmp	r1, #0
    a2fe:	bne.w	a586 <usb_isr+0x7fa>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    a302:	ldr	r3, [pc, #208]	; (a3d4 <usb_isr+0x648>)
    a304:	ldr	r2, [pc, #208]	; (a3d8 <usb_isr+0x64c>)
			usb_cdc_line_rtsdtr = setup.wValue;
    a306:	ldr	r4, [pc, #212]	; (a3dc <usb_isr+0x650>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    a308:	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    a30a:	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    a30c:	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    a30e:	mov	r9, r0
    a310:	mov	r2, r1
    a312:	strb	r5, [r4, #0]
    a314:	b.n	a2cc <usb_isr+0x540>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    a316:	ldr	r1, [pc, #172]	; (a3c4 <usb_isr+0x638>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    a318:	ldr	r3, [pc, #128]	; (a39c <usb_isr+0x610>)
    a31a:	ldr	r0, [pc, #196]	; (a3e0 <usb_isr+0x654>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    a31c:	ldr	r6, [pc, #152]	; (a3b8 <usb_isr+0x62c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a31e:	ldr.w	ip, [pc, #176]	; a3d0 <usb_isr+0x644>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    a322:	ldr	r5, [pc, #192]	; (a3e4 <usb_isr+0x658>)
		USB0_ISTAT = 0xFF;
    a324:	ldr.w	lr, [pc, #212]	; a3fc <usb_isr+0x670>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    a328:	ldr	r7, [pc, #188]	; (a3e8 <usb_isr+0x65c>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    a32a:	movs	r4, #2
    a32c:	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    a32e:	ldr	r4, [pc, #188]	; (a3ec <usb_isr+0x660>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    a330:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    a332:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    a334:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    a336:	ldr	r0, [pc, #184]	; (a3f0 <usb_isr+0x664>)
    a338:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    a33a:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    a33c:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a33e:	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    a340:	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    a342:	ldr	r4, [pc, #176]	; (a3f4 <usb_isr+0x668>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a344:	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    a348:	ldr	r6, [pc, #172]	; (a3f8 <usb_isr+0x66c>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    a34a:	movs	r3, #255	; 0xff
    a34c:	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    a34e:	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    a350:	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    a352:	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    a356:	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    a358:	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    a35a:	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    a35c:	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    a35e:	add	sp, #28
    a360:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    a364:	movs	r3, #0
    a366:	strb	r3, [r1, r6]
						break;
    a368:	b.n	9e20 <usb_isr+0x94>
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a36a:	movs	r3, #1
    a36c:	strb	r3, [r1, r6]
						break;
    a36e:	b.n	9e20 <usb_isr+0x94>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a370:	ldr	r1, [pc, #92]	; (a3d0 <usb_isr+0x644>)
		USB0_ISTAT = USB_ISTAT_STALL;
    a372:	ldr	r3, [pc, #136]	; (a3fc <usb_isr+0x670>)
    a374:	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a376:	movs	r0, #13
    a378:	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    a37a:	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    a37c:	lsls	r2, r4, #30
    a37e:	bpl.w	a03e <usb_isr+0x2b2>
    a382:	b.n	a030 <usb_isr+0x2a4>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    a384:	ldr	r2, [pc, #16]	; (a398 <usb_isr+0x60c>)
    a386:	ldr	r4, [pc, #44]	; (a3b4 <usb_isr+0x628>)
    a388:	ldrb	r2, [r2, #0]
    a38a:	strb	r2, [r4, #0]
    a38c:	b.n	a196 <usb_isr+0x40a>
    a38e:	nop
    a390:	.word	0x20019c9d
    a394:	.word	0x20019bcc
    a398:	.word	0x20019ca8
    a39c:	.word	0x1fff0000
    a3a0:	.word	0x20019c84
    a3a4:	.word	0x20019c20
    a3a8:	.word	0x20019c74
    a3ac:	.word	0x20019cac
    a3b0:	.word	0x20019dac
    a3b4:	.word	0x20019ca0
    a3b8:	.word	0x20019c9c
    a3bc:	.word	0x20019c30
    a3c0:	.word	0x20019bdc
    a3c4:	.word	0x40072094
    a3c8:	.word	0x20019d9f
    a3cc:	.word	0x20019da0
    a3d0:	.word	0x400720c0
    a3d4:	.word	0x20019bc4
    a3d8:	.word	0x20019da8
    a3dc:	.word	0x20019bc0
    a3e0:	.word	0x00400088
    a3e4:	.word	0x40072088
    a3e8:	.word	0x40072098
    a3ec:	.word	0x20019be0
    a3f0:	.word	0x20019c34
    a3f4:	.word	0x40072084
    a3f8:	.word	0x4007208c
    a3fc:	.word	0x40072080
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    a400:	ldr	r2, [pc, #468]	; (a5d8 <usb_isr+0x84c>)
    a402:	movs	r1, #15
    a404:	strb	r1, [r2, #0]
    a406:	b.n	a26e <usb_isr+0x4e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a408:	cmp.w	r1, #1280	; 0x500
    a40c:	bne.n	a41e <usb_isr+0x692>
    a40e:	movs	r2, #0
    a410:	mov.w	r9, #1
    a414:	b.n	a2cc <usb_isr+0x540>
    a416:	movw	r2, #8993	; 0x2321
    a41a:	cmp	r1, r2
    a41c:	beq.n	a40e <usb_isr+0x682>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a41e:	ldr	r3, [pc, #444]	; (a5dc <usb_isr+0x850>)
    a420:	movs	r2, #15
    a422:	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    a424:	ldr	r2, [pc, #440]	; (a5e0 <usb_isr+0x854>)
    a426:	movs	r3, #1
    a428:	strb	r3, [r2, #0]
    a42a:	b.n	9f96 <usb_isr+0x20a>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    a42c:	cmp	r0, #64	; 0x40
    a42e:	bls.w	a1f2 <usb_isr+0x466>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a432:	orr.w	r4, r4, #2
    a436:	add.w	r1, lr, r4, lsl #3
    a43a:	ldr	r6, [sp, #8]
    a43c:	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a43e:	cbz	r2, a46c <usb_isr+0x6e0>
	ep0_tx_data_toggle ^= 1;
    a440:	strb.w	r9, [r3]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a444:	ldr	r2, [pc, #412]	; (a5e4 <usb_isr+0x858>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a446:	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a44a:	mov	r3, r6
    a44c:	subs	r0, #64	; 0x40
    a44e:	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a450:	str.w	r2, [lr, r4, lsl #3]
    a454:	b.n	a222 <usb_isr+0x496>
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a456:	ldr	r3, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    a458:	strb.w	r9, [r6]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a45c:	lsls	r2, r0, #16
    a45e:	orr.w	r2, r2, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a462:	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a464:	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a466:	str.w	r2, [lr, r4, lsl #3]
    a46a:	b.n	a21c <usb_isr+0x490>
	ep0_tx_data_toggle ^= 1;
    a46c:	strb.w	r9, [r3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a470:	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a472:	ldr	r2, [pc, #372]	; (a5e8 <usb_isr+0x85c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a474:	strb.w	r5, [r8]
    a478:	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a47a:	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a47c:	str.w	r2, [lr, r4, lsl #3]
    a480:	b.n	a222 <usb_isr+0x496>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    a482:	tst.w	r9, #8
    a486:	ite	eq
    a488:	moveq	r3, #2
    a48a:	movne	r3, #3
    a48c:	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    a48e:	b.n	9e20 <usb_isr+0x94>
    a490:	ldrh	r1, [r5, #4]
    a492:	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    a496:	cmp	r1, #4
    a498:	bhi.n	a41e <usb_isr+0x692>
    a49a:	ldrh	r2, [r5, #2]
    a49c:	cmp	r2, #0
    a49e:	bne.n	a41e <usb_isr+0x692>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    a4a0:	ldr	r4, [pc, #312]	; (a5dc <usb_isr+0x850>)
    a4a2:	lsls	r1, r1, #2
    a4a4:	add	r4, r1
    a4a6:	mov	r9, r0
    a4a8:	ldrb	r1, [r4, #0]
    a4aa:	bic.w	r1, r1, #2
    a4ae:	strb	r1, [r4, #0]
    a4b0:	b.n	a2cc <usb_isr+0x540>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    a4b2:	ldr	r2, [pc, #312]	; (a5ec <usb_isr+0x860>)
    a4b4:	ldr	r4, [r2, #4]
    a4b6:	cmp	r4, #0
    a4b8:	beq.n	a41e <usb_isr+0x692>
    a4ba:	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    a4bc:	ldrh.w	lr, [r5, #4]
    a4c0:	b.n	a4ca <usb_isr+0x73e>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    a4c2:	adds	r2, #12
			if (list->addr == NULL) break;
    a4c4:	ldr	r4, [r2, #4]
    a4c6:	cmp	r4, #0
    a4c8:	beq.n	a41e <usb_isr+0x692>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    a4ca:	ldrh	r3, [r2, #0]
    a4cc:	cmp	r3, r0
    a4ce:	bne.n	a4c2 <usb_isr+0x736>
    a4d0:	ldrh	r3, [r2, #2]
    a4d2:	cmp	r3, lr
    a4d4:	bne.n	a4c2 <usb_isr+0x736>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    a4d6:	lsrs	r0, r0, #8
    a4d8:	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    a4da:	ite	eq
    a4dc:	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    a4de:	ldrhne	r0, [r2, #8]
    a4e0:	b.n	a196 <usb_isr+0x40a>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a4e2:	mov.w	r3, #1
    a4e6:	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    a4ea:	add.w	r9, r9, #1
    a4ee:	cmp.w	r9, #4
    a4f2:	add.w	r4, r4, #4
    a4f6:	add.w	r6, r6, #4
    a4fa:	add.w	r8, r8, #1
    a4fe:	bne.w	a12e <usb_isr+0x3a2>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    a502:	ldr	r3, [pc, #236]	; (a5f0 <usb_isr+0x864>)
    a504:	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    a506:	ldr	r5, [pc, #236]	; (a5f4 <usb_isr+0x868>)
		cfg = usb_endpoint_config_table;
    a508:	ldr.w	r8, [pc, #240]	; a5fc <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    a50c:	movs	r0, #0
    a50e:	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    a510:	mov.w	r9, #1
			epconf = *cfg++;
    a514:	ldrb.w	r3, [r8], #1
			*reg = epconf;
    a518:	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a51c:	lsls	r2, r3, #28
    a51e:	bmi.n	a554 <usb_isr+0x7c8>
    a520:	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a524:	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    a528:	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a52c:	movs	r3, #0
    a52e:	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    a532:	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    a536:	ldr	r3, [pc, #192]	; (a5f8 <usb_isr+0x86c>)
    a538:	cmp	r5, r3
    a53a:	add.w	r9, r9, #1
    a53e:	bne.n	a514 <usb_isr+0x788>
    a540:	ldrb.w	r9, [r6]
    a544:	eor.w	r2, r9, #1
    a548:	b.n	a2cc <usb_isr+0x540>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    a54a:	mov.w	r3, #0
    a54e:	strb.w	r3, [r8]
    a552:	b.n	a4ea <usb_isr+0x75e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a554:	bl	9b90 <usb_malloc>
				if (p) {
    a558:	cbz	r0, a5a2 <usb_isr+0x816>
					table[index(i, RX, EVEN)].addr = p->buf;
    a55a:	add.w	r3, r7, r9, lsl #5
    a55e:	mov.w	r4, r9, lsl #2
    a562:	adds	r0, #8
    a564:	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a566:	ldr	r3, [pc, #128]	; (a5e8 <usb_isr+0x85c>)
    a568:	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a56c:	bl	9b90 <usb_malloc>
				if (p) {
    a570:	cbz	r0, a58e <usb_isr+0x802>
					table[index(i, RX, ODD)].addr = p->buf;
    a572:	orr.w	r3, r4, #1
    a576:	add.w	r2, r7, r3, lsl #3
    a57a:	adds	r0, #8
    a57c:	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a57e:	ldr	r2, [pc, #100]	; (a5e4 <usb_isr+0x858>)
    a580:	str.w	r2, [r7, r3, lsl #3]
    a584:	b.n	a524 <usb_isr+0x798>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    a586:	mov	r9, r0
    a588:	b.n	a2cc <usb_isr+0x540>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    a58a:	movs	r0, #2
    a58c:	b.n	a196 <usb_isr+0x40a>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a58e:	ldr	r3, [pc, #96]	; (a5f0 <usb_isr+0x864>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a590:	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    a594:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a596:	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    a59a:	ldr	r2, [pc, #84]	; (a5f0 <usb_isr+0x864>)
    a59c:	adds	r3, #1
    a59e:	strb	r3, [r2, #0]
    a5a0:	b.n	a524 <usb_isr+0x798>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a5a2:	ldr	r3, [pc, #76]	; (a5f0 <usb_isr+0x864>)
    a5a4:	ldr	r2, [pc, #72]	; (a5f0 <usb_isr+0x864>)
    a5a6:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a5a8:	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    a5ac:	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a5ae:	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    a5b2:	strb	r3, [r2, #0]
    a5b4:	b.n	a56c <usb_isr+0x7e0>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    a5b6:	bkpt	0x0000
    a5b8:	cmp	r0, #64	; 0x40
    a5ba:	mov	ip, r0
    a5bc:	it	cs
    a5be:	movcs.w	ip, #64	; 0x40
    a5c2:	add.w	r3, r4, ip
    a5c6:	rsb	r0, ip, r0
    a5ca:	mov.w	r8, ip, lsl #16
    a5ce:	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    a5d0:	movs	r2, #0
    a5d2:	mov.w	r9, #1
    a5d6:	b.n	a2d6 <usb_isr+0x54a>
    a5d8:	.word	0x20019c31
    a5dc:	.word	0x400720c0
    a5e0:	.word	0x40072094
    a5e4:	.word	0x004000c8
    a5e8:	.word	0x00400088
    a5ec:	.word	0x00013a94
    a5f0:	.word	0x20019c9d
    a5f4:	.word	0x400720c4
    a5f8:	.word	0x400720d4
    a5fc:	.word	0x00013a90

0000a600 <usb_init>:
}



void usb_init(void)
{
    a600:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    a604:	bl	ae60 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    a608:	movs	r3, #0
    a60a:	ldr	r1, [pc, #140]	; (a698 <usb_init+0x98>)
		table[i].desc = 0;
    a60c:	mov	r2, r3
		table[i].addr = 0;
    a60e:	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    a612:	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    a616:	adds	r3, #1
    a618:	cmp	r3, #20
		table[i].desc = 0;
		table[i].addr = 0;
    a61a:	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    a61c:	mov.w	r4, #0
    a620:	ldr	r0, [pc, #116]	; (a698 <usb_init+0x98>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    a622:	bne.n	a60e <usb_init+0xe>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    a624:	ldr	r1, [pc, #116]	; (a69c <usb_init+0x9c>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    a626:	ldr	r2, [pc, #120]	; (a6a0 <usb_init+0xa0>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    a628:	ldr	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    a62a:	ldr.w	r8, [pc, #140]	; a6b8 <usb_init+0xb8>
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    a62e:	ldr	r7, [pc, #116]	; (a6a4 <usb_init+0xa4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    a630:	ldr	r5, [pc, #116]	; (a6a8 <usb_init+0xa8>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    a632:	ldr	r6, [pc, #120]	; (a6ac <usb_init+0xac>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    a634:	ldr.w	ip, [pc, #132]	; a6bc <usb_init+0xbc>
	USB0_ERRSTAT = 0xFF;
    a638:	ldr.w	lr, [pc, #132]	; a6c0 <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    a63c:	orr.w	r3, r3, #262144	; 0x40000
    a640:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    a642:	ldr	r3, [r2, #0]
    a644:	orr.w	r3, r3, #50331648	; 0x3000000
    a648:	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    a64a:	ubfx	r3, r0, #8, #8
    a64e:	strb.w	r3, [r8]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    a652:	add.w	r1, r1, #172032	; 0x2a000
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    a656:	ubfx	r3, r0, #16, #8
    a65a:	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    a65c:	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    a65e:	movs	r3, #255	; 0xff

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    a660:	adds	r1, #204	; 0xcc
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a662:	add.w	r2, r2, #411648	; 0x64800
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    a666:	strb	r0, [r5, #0]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a668:	add.w	r2, r2, #264	; 0x108
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    a66c:	strb.w	r3, [ip]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    a670:	ldr	r5, [pc, #60]	; (a6b0 <usb_init+0xb0>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    a672:	strb.w	r3, [lr]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    a676:	ldr	r0, [pc, #60]	; (a6b4 <usb_init+0xb4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    a678:	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    a67a:	movs	r3, #1
    a67c:	strb.w	r3, [r8, #-8]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    a680:	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    a682:	strb	r4, [r1, #0]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    a684:	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a688:	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    a68a:	strb.w	r3, [r7, #-44]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    a68e:	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    a690:	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a692:	strb	r1, [r2, #0]
    a694:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a698:	.word	0x1fff0000
    a69c:	.word	0x40048034
    a6a0:	.word	0x4000d800
    a6a4:	.word	0x400720b0
    a6a8:	.word	0x400720b4
    a6ac:	.word	0x40072010
    a6b0:	.word	0xe000e435
    a6b4:	.word	0xe000e104
    a6b8:	.word	0x4007209c
    a6bc:	.word	0x40072080
    a6c0:	.word	0x40072088

0000a6c4 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    a6c4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    a6c8:	ldr	r6, [pc, #196]	; (a790 <yield+0xcc>)
    a6ca:	ldrb	r3, [r6, #0]
    a6cc:	cbz	r3, a6f4 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    a6ce:	ldr	r7, [pc, #196]	; (a794 <yield+0xd0>)
    a6d0:	ldrb	r2, [r7, #0]
    a6d2:	cbnz	r2, a6f4 <yield+0x30>
	running = 1;
    a6d4:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    a6d6:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    a6d8:	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    a6da:	bmi.n	a74a <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    a6dc:	lsls	r2, r3, #30
    a6de:	bmi.n	a714 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    a6e0:	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    a6e2:	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    a6e4:	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    a6e6:	bpl.n	a6f4 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    a6e8:	ldr	r3, [pc, #172]	; (a798 <yield+0xd4>)
    a6ea:	ldr	r2, [r3, #0]
    a6ec:	cbz	r2, a6f4 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    a6ee:	mrs	r2, IPSR
		if (ipsr != 0) return;
    a6f2:	cbz	r2, a6f8 <yield+0x34>
    a6f4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a6f8:	mrs	r1, PRIMASK
		__disable_irq();
    a6fc:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    a6fe:	ldr	r0, [r3, #0]
		if (first == nullptr) {
    a700:	cbz	r0, a70a <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    a702:	ldr	r4, [pc, #152]	; (a79c <yield+0xd8>)
    a704:	ldrb	r2, [r4, #0]
    a706:	cmp	r2, #0
    a708:	beq.n	a768 <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    a70a:	cmp	r1, #0
    a70c:	bne.n	a6f4 <yield+0x30>
    a70e:	cpsie	i
    a710:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    a714:	ldr.w	r8, [pc, #144]	; a7a8 <yield+0xe4>
    a718:	ldrb.w	r2, [r8]
    a71c:	cmp	r2, #0
    a71e:	beq.n	a6e0 <yield+0x1c>
    a720:	ldr.w	r9, [pc, #136]	; a7ac <yield+0xe8>
    a724:	movs	r4, #0
    a726:	b.n	a734 <yield+0x70>
    a728:	adds	r4, #1
    a72a:	ldrb.w	r3, [r8]
    a72e:	uxtb	r4, r4
    a730:	cmp	r3, r4
    a732:	bls.n	a75a <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    a734:	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    a738:	ldr	r3, [r5, #0]
    a73a:	mov	r0, r5
    a73c:	ldr	r3, [r3, #16]
    a73e:	blx	r3
    a740:	cmp	r0, #0
    a742:	beq.n	a728 <yield+0x64>
    a744:	ldr	r3, [r5, #16]
    a746:	blx	r3
    a748:	b.n	a728 <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    a74a:	bl	9440 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    a74e:	cbnz	r0, a784 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    a750:	ldr	r3, [pc, #76]	; (a7a0 <yield+0xdc>)
    a752:	ldrb	r3, [r3, #0]
    a754:	cbnz	r3, a75e <yield+0x9a>
    a756:	ldrb	r3, [r6, #0]
    a758:	b.n	a6dc <yield+0x18>
    a75a:	ldrb	r3, [r6, #0]
    a75c:	b.n	a6e0 <yield+0x1c>
    a75e:	ldrb	r3, [r6, #0]
    a760:	and.w	r3, r3, #254	; 0xfe
    a764:	strb	r3, [r6, #0]
    a766:	b.n	a6dc <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    a768:	ldr	r5, [r0, #20]
    a76a:	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    a76c:	movs	r3, #1
    a76e:	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    a770:	cbz	r5, a78a <yield+0xc6>
			firstYield->_prev = nullptr;
    a772:	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    a774:	cbnz	r1, a778 <yield+0xb4>
    a776:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    a778:	movs	r5, #0
    a77a:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    a77c:	ldr	r3, [r0, #8]
    a77e:	blx	r3
		runningFromYield = false;
    a780:	strb	r5, [r4, #0]
    a782:	b.n	a6f4 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    a784:	bl	ae54 <serialEvent()>
    a788:	b.n	a750 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    a78a:	ldr	r3, [pc, #24]	; (a7a4 <yield+0xe0>)
    a78c:	str	r5, [r3, #0]
    a78e:	b.n	a774 <yield+0xb0>
    a790:	.word	0x200138e0
    a794:	.word	0x20019cb0
    a798:	.word	0x20019cc0
    a79c:	.word	0x20019cc4
    a7a0:	.word	0x200138f4
    a7a4:	.word	0x20019cbc
    a7a8:	.word	0x20019d68
    a7ac:	.word	0x20019d50

0000a7b0 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    a7b0:	push	{r4, r5, r6, r7, lr}
	uint32_t ch = 0;

	__disable_irq();
    a7b2:	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    a7b4:	cbnz	r1, a7de <DMAChannel::begin(bool)+0x2e>
    a7b6:	ldr	r2, [r0, #0]
    a7b8:	cbz	r2, a7de <DMAChannel::begin(bool)+0x2e>
    a7ba:	ldrb	r3, [r0, #4]
    a7bc:	cmp	r3, #15
    a7be:	bhi.n	a7de <DMAChannel::begin(bool)+0x2e>
	  && (dma_channel_allocated_mask & (1 << channel))
    a7c0:	ldr	r4, [pc, #160]	; (a864 <DMAChannel::begin(bool)+0xb4>)
    a7c2:	ldrh	r1, [r4, #0]
    a7c4:	asr.w	r5, r1, r3
    a7c8:	lsls	r5, r5, #31
    a7ca:	bpl.n	a7e2 <DMAChannel::begin(bool)+0x32>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    a7cc:	add.w	r3, r3, #33554432	; 0x2000000
    a7d0:	add.w	r3, r3, #1152	; 0x480
    a7d4:	cmp.w	r2, r3, lsl #5
    a7d8:	bne.n	a7e2 <DMAChannel::begin(bool)+0x32>
		// DMA channel already allocated
		__enable_irq();
    a7da:	cpsie	i
		return;
    a7dc:	pop	{r4, r5, r6, r7, pc}
    a7de:	ldr	r4, [pc, #132]	; (a864 <DMAChannel::begin(bool)+0xb4>)
    a7e0:	ldrh	r1, [r4, #0]
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    a7e2:	movs	r3, #0
		// DMA channel already allocated
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    a7e4:	asr.w	r2, r1, r3
    a7e8:	ands.w	r2, r2, #1
    a7ec:	beq.n	a7fe <DMAChannel::begin(bool)+0x4e>
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    a7ee:	adds	r3, #1
    a7f0:	cmp	r3, #16
    a7f2:	bne.n	a7e4 <DMAChannel::begin(bool)+0x34>
			__enable_irq();
    a7f4:	cpsie	i
			TCD = (TCD_t *)0;
    a7f6:	movs	r2, #0
			channel = DMA_MAX_CHANNELS;
    a7f8:	strb	r3, [r0, #4]
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
			__enable_irq();
			TCD = (TCD_t *)0;
    a7fa:	str	r2, [r0, #0]
    a7fc:	pop	{r4, r5, r6, r7, pc}
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
    a7fe:	movs	r5, #1
    a800:	lsls	r5, r3
    a802:	orrs	r1, r5
    a804:	strh	r1, [r4, #0]
			__enable_irq();
    a806:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a808:	ldr	r6, [pc, #92]	; (a868 <DMAChannel::begin(bool)+0xb8>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a80a:	ldr	r5, [pc, #96]	; (a86c <DMAChannel::begin(bool)+0xbc>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a80c:	ldr	r7, [pc, #96]	; (a870 <DMAChannel::begin(bool)+0xc0>)
#endif
	DMA_CERQ = ch;
    a80e:	ldr.w	lr, [pc, #104]	; a878 <DMAChannel::begin(bool)+0xc8>
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    a812:	uxtb	r1, r3
    a814:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a816:	ldr	r4, [r6, #0]
    a818:	orr.w	r4, r4, #2
    a81c:	str	r4, [r6, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a81e:	ldr	r4, [r5, #0]
    a820:	orr.w	r4, r4, #2
    a824:	str	r4, [r5, #0]
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    a826:	sub.w	r6, r6, #262144	; 0x40000
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a82a:	movw	r4, #1154	; 0x482
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
    a82e:	sub.w	r5, r5, #262144	; 0x40000
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a832:	add.w	r3, r3, #33554432	; 0x2000000
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a836:	str	r4, [r7, #0]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a838:	add.w	r3, r3, #1152	; 0x480
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    a83c:	subs	r6, #34	; 0x22
	DMA_CEEI = ch;
    a83e:	subs	r5, #36	; 0x24
	DMA_CINT = ch;
    a840:	ldr	r4, [pc, #48]	; (a874 <DMAChannel::begin(bool)+0xc4>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    a842:	strb.w	r1, [lr]
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a846:	lsls	r3, r3, #5
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    a848:	strb	r1, [r6, #0]
	DMA_CEEI = ch;
    a84a:	strb	r1, [r5, #0]
	DMA_CINT = ch;
    a84c:	strb	r1, [r4, #0]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a84e:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    a850:	str	r2, [r3, #0]
	*p++ = 0;
    a852:	str	r2, [r3, #4]
	*p++ = 0;
    a854:	str	r2, [r3, #8]
	*p++ = 0;
    a856:	str	r2, [r3, #12]
	*p++ = 0;
    a858:	str	r2, [r3, #16]
	*p++ = 0;
    a85a:	str	r2, [r3, #20]
	*p++ = 0;
    a85c:	str	r2, [r3, #24]
	*p++ = 0;
    a85e:	str	r2, [r3, #28]
    a860:	pop	{r4, r5, r6, r7, pc}
    a862:	nop
    a864:	.word	0x20019cb2
    a868:	.word	0x40048040
    a86c:	.word	0x4004803c
    a870:	.word	0x40008000
    a874:	.word	0x4000801f
    a878:	.word	0x4000801a

0000a87c <DMAChannel::release()>:
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    a87c:	ldrb	r3, [r0, #4]
    a87e:	cmp	r3, #15
    a880:	bhi.n	a8a8 <DMAChannel::release()+0x2c>
	DMA_CERQ = channel;
    a882:	ldr	r2, [pc, #40]	; (a8ac <DMAChannel::release()+0x30>)
	*p++ = 0;
	*p++ = 0;
}

void DMAChannel::release(void)
{
    a884:	push	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
    a886:	strb	r3, [r2, #0]
	__disable_irq();
    a888:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    a88a:	ldr	r1, [pc, #36]	; (a8b0 <DMAChannel::release()+0x34>)
    a88c:	ldrb	r4, [r0, #4]
    a88e:	ldrh	r2, [r1, #0]
    a890:	movs	r3, #1
    a892:	lsls	r3, r4
    a894:	bic.w	r3, r2, r3
    a898:	strh	r3, [r1, #0]
	__enable_irq();
    a89a:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    a89c:	movs	r2, #16
	TCD = (TCD_t *)0;
    a89e:	movs	r3, #0
}
    a8a0:	ldr.w	r4, [sp], #4
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
	__disable_irq();
	dma_channel_allocated_mask &= ~(1 << channel);
	__enable_irq();
	channel = DMA_MAX_CHANNELS;
    a8a4:	strb	r2, [r0, #4]
	TCD = (TCD_t *)0;
    a8a6:	str	r3, [r0, #0]
}
    a8a8:	bx	lr
    a8aa:	nop
    a8ac:	.word	0x4000801a
    a8b0:	.word	0x20019cb2

0000a8b4 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    a8b4:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a8b6:	mrs	r2, PRIMASK
		__disable_irq();
    a8ba:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    a8bc:	ldr	r4, [pc, #48]	; (a8f0 <EventResponder::runFromInterrupt()+0x3c>)
    a8be:	ldr	r0, [r4, #0]
		if (first) {
    a8c0:	cbz	r0, a8e4 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    a8c2:	ldr	r6, [pc, #48]	; (a8f4 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    a8c4:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    a8c6:	ldr	r3, [r0, #20]
    a8c8:	str	r3, [r4, #0]
			if (firstInterrupt) {
    a8ca:	cbz	r3, a8ea <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    a8cc:	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    a8ce:	cbnz	r2, a8d2 <EventResponder::runFromInterrupt()+0x1e>
    a8d0:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    a8d2:	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    a8d4:	ldr	r3, [r0, #8]
    a8d6:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a8d8:	mrs	r2, PRIMASK
		__disable_irq();
    a8dc:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    a8de:	ldr	r0, [r4, #0]
		if (first) {
    a8e0:	cmp	r0, #0
    a8e2:	bne.n	a8c6 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    a8e4:	cbnz	r2, a8e8 <EventResponder::runFromInterrupt()+0x34>
    a8e6:	cpsie	i
    a8e8:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    a8ea:	str	r3, [r6, #0]
    a8ec:	b.n	a8ce <EventResponder::runFromInterrupt()+0x1a>
    a8ee:	nop
    a8f0:	.word	0x20019cb4
    a8f4:	.word	0x20019cb8

0000a8f8 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    a8f8:	b.w	a8b4 <EventResponder::runFromInterrupt()>

0000a8fc <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    a8fc:	ldr	r2, [pc, #8]	; (a908 <systick_isr+0xc>)
    a8fe:	ldr	r3, [r2, #0]
    a900:	adds	r3, #1
    a902:	str	r3, [r2, #0]
    a904:	bx	lr
    a906:	nop
    a908:	.word	0x20019bc4

0000a90c <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    a90c:	b.w	945c <usb_serial_flush_input>

0000a910 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    a910:	b.w	9410 <usb_serial_peekchar>

0000a914 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    a914:	b.w	93c8 <usb_serial_getchar>

0000a918 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    a918:	b.w	9440 <usb_serial_available>

0000a91c <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    a91c:	b.w	95fc <usb_serial_flush_output>

0000a920 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    a920:	b.w	95b4 <usb_serial_write_buffer_free>

0000a924 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    a924:	mov	r0, r1
    a926:	mov	r1, r2
    a928:	b.w	9494 <usb_serial_write>

0000a92c <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    a92c:	mov	r0, r1
    a92e:	b.w	959c <usb_serial_putchar>
    a932:	nop

0000a934 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    a934:	push	{r3, r4, r5, r6, r7, lr}
	if (buffer == nullptr) return 0;
    a936:	mov	r6, r1
    a938:	cbz	r1, a958 <Print::write(unsigned char const*, unsigned int)+0x24>
	size_t count = 0;
	while (size--) count += write(*buffer++);
    a93a:	cbz	r2, a95c <Print::write(unsigned char const*, unsigned int)+0x28>
    a93c:	mov	r7, r0
    a93e:	mov	r4, r2
    a940:	movs	r5, #0
    a942:	ldr	r3, [r7, #0]
    a944:	ldrb.w	r1, [r6], #1
    a948:	ldr	r3, [r3, #0]
    a94a:	mov	r0, r7
    a94c:	blx	r3
    a94e:	subs	r4, #1
    a950:	add	r5, r0
    a952:	bne.n	a942 <Print::write(unsigned char const*, unsigned int)+0xe>
    a954:	mov	r0, r5
    a956:	pop	{r3, r4, r5, r6, r7, pc}
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    a958:	mov	r0, r1
    a95a:	pop	{r3, r4, r5, r6, r7, pc}
    a95c:	mov	r0, r2
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    a95e:	pop	{r3, r4, r5, r6, r7, pc}

0000a960 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    a960:	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    a962:	ldr	r2, [pc, #24]	; (a97c <Print::println()+0x1c>)
	return write(buf, 2);
    a964:	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    a966:	ldrh	r2, [r2, #0]
	return write(buf, 2);
    a968:	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    a96a:	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    a96c:	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    a96e:	strh.w	r2, [sp, #4]
	return write(buf, 2);
    a972:	movs	r2, #2
    a974:	blx	r3
}
    a976:	add	sp, #12
    a978:	ldr.w	pc, [sp], #4
    a97c:	.word	0x00013a8c

0000a980 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    a980:	push	{r4, lr}
	((class Print *)file)->write((uint8_t *)ptr, len);
    a982:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    a984:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    a986:	ldr	r3, [r3, #4]
    a988:	blx	r3
	return len;
}
    a98a:	mov	r0, r4
    a98c:	pop	{r4, pc}
    a98e:	nop

0000a990 <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    a990:	push	{r1, r2, r3}
    a992:	push	{lr}
    a994:	sub	sp, #8
    a996:	add	r2, sp, #12
    a998:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    a99c:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	return 0;  // TODO: make this work with -std=c++0x
#else
	return vdprintf((int)this, format, ap);
    a99e:	bl	10348 <vdprintf>
#endif
}
    a9a2:	add	sp, #8
    a9a4:	ldr.w	lr, [sp], #4
    a9a8:	add	sp, #12
    a9aa:	bx	lr

0000a9ac <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    a9ac:	push	{r4, r5, r6, r7, lr}
    a9ae:	mov	r7, r0
    a9b0:	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    a9b2:	cmp	r2, #0
    a9b4:	beq.n	aa1e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    a9b6:	cmp	r2, #1
    a9b8:	it	eq
    a9ba:	moveq	r2, #10
	}


	if (n == 0) {
    a9bc:	cbz	r1, aa14 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    a9be:	movs	r4, #33	; 0x21
    a9c0:	b.n	a9c4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    a9c2:	uxtb	r4, r6
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a9c4:	udiv	r5, r1, r2
    a9c8:	mls	r1, r2, r5, r1
    a9cc:	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a9ce:	cmp	r1, #9
    a9d0:	add.w	r1, r0, #48	; 0x30
    a9d4:	it	ls
    a9d6:	uxtbls	r0, r1
    a9d8:	add	r1, sp, #40	; 0x28
    a9da:	it	hi
    a9dc:	addhi	r0, #55	; 0x37
    a9de:	add	r1, r4
    a9e0:	it	hi
    a9e2:	uxtbhi	r0, r0
    a9e4:	strb.w	r0, [r1, #-36]
			n /= base;
			if (n == 0) break;
			i--;
    a9e8:	subs	r6, r4, #1
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    a9ea:	mov	r1, r5
    a9ec:	cmp	r5, #0
    a9ee:	bne.n	a9c2 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    a9f0:	cbz	r3, aa00 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    a9f2:	subs	r4, #1
    a9f4:	uxtb	r4, r4
		buf[i] = '-';
    a9f6:	add	r3, sp, #40	; 0x28
    a9f8:	add	r3, r4
    a9fa:	movs	r2, #45	; 0x2d
    a9fc:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    aa00:	ldr	r3, [r7, #0]
    aa02:	add	r2, sp, #4
    aa04:	adds	r1, r2, r4
    aa06:	ldr	r3, [r3, #4]
    aa08:	mov	r0, r7
    aa0a:	rsb	r2, r4, #34	; 0x22
    aa0e:	blx	r3
}
    aa10:	add	sp, #44	; 0x2c
    aa12:	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    aa14:	movs	r2, #48	; 0x30
    aa16:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    aa1a:	movs	r4, #33	; 0x21
    aa1c:	b.n	a9f0 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    aa1e:	ldr	r3, [r0, #0]
    aa20:	uxtb	r1, r1
    aa22:	ldr	r3, [r3, #0]
    aa24:	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    aa26:	add	sp, #44	; 0x2c
    aa28:	pop	{r4, r5, r6, r7, pc}
    aa2a:	nop

0000aa2c <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    aa2c:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    aa2e:	bl	17c0 <setup>
	while (1) {
		loop();
    aa32:	bl	1b60 <loop>
		yield();
    aa36:	bl	a6c4 <yield>
    aa3a:	b.n	aa32 <main+0x6>

0000aa3c <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>:


// Set up the pool of audio data blocks
// placing them all onto the free list
void AudioStream::initialize_memory(audio_block_t *data, unsigned int num)
{
    aa3c:	cmp.w	r1, #896	; 0x380
    aa40:	push	{r4, r5, r6, r7}
    aa42:	it	cs
    aa44:	movcs.w	r1, #896	; 0x380
	unsigned int maxnum = MAX_AUDIO_MEMORY / AUDIO_BLOCK_SAMPLES / 2;

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
    aa48:	cpsid	i
	memory_pool = data;
    aa4a:	ldr	r2, [pc, #76]	; (aa98 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x5c>)
	memory_pool_first_mask = 0;
    aa4c:	ldr	r4, [pc, #76]	; (aa9c <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x60>)
    aa4e:	ldr	r3, [pc, #80]	; (aaa0 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x64>)

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
    aa50:	str	r0, [r2, #0]
	memory_pool_first_mask = 0;
    aa52:	movs	r2, #0
    aa54:	strh	r2, [r4, #0]
    aa56:	add.w	r4, r3, #112	; 0x70
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
    aa5a:	str.w	r2, [r3, #4]!
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
    aa5e:	cmp	r3, r4
    aa60:	bne.n	aa5a <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x1e>
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    aa62:	cbz	r1, aa92 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x56>
    aa64:	ldr	r6, [pc, #60]	; (aaa4 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x68>)
    aa66:	movs	r3, #0
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    aa68:	movs	r7, #1
    aa6a:	lsrs	r5, r3, #5
    aa6c:	and.w	r4, r3, #31
    aa70:	ldr.w	r2, [r6, r5, lsl #2]
    aa74:	lsl.w	r4, r7, r4
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    aa78:	adds	r3, #1
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    aa7a:	orrs	r2, r4
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    aa7c:	cmp	r3, r1
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    aa7e:	str.w	r2, [r6, r5, lsl #2]
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    aa82:	bne.n	aa6a <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x2e>
    aa84:	movs	r3, #0
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
		data[i].memory_pool_index = i;
    aa86:	strh	r3, [r0, #2]
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
    aa88:	adds	r3, #1
    aa8a:	cmp	r3, r1
    aa8c:	add.w	r0, r0, #260	; 0x104
    aa90:	bne.n	aa86 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x4a>
		data[i].memory_pool_index = i;
	}
	__enable_irq();
    aa92:	cpsie	i

}
    aa94:	pop	{r4, r5, r6, r7}
    aa96:	bx	lr
    aa98:	.word	0x20019cd0
    aa9c:	.word	0x20019d4a
    aaa0:	.word	0x20019cd4
    aaa4:	.word	0x20019cd8

0000aaa8 <AudioStream::allocate()>:

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_t * AudioStream::allocate(void)
{
    aaa8:	push	{r4, r5, r6, r7}
	audio_block_t *block;
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
    aaaa:	cpsid	i
	index = memory_pool_first_mask;
    aaac:	ldr	r7, [pc, #140]	; (ab3c <AudioStream::allocate()+0x94>)
	p += index;
    aaae:	ldr	r6, [pc, #144]	; (ab40 <AudioStream::allocate()+0x98>)
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
    aab0:	ldrh	r4, [r7, #0]
	p += index;
	while (1) {
		if (p >= end) {
    aab2:	add.w	r3, r6, #112	; 0x70

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
    aab6:	add.w	r0, r6, r4, lsl #2
	while (1) {
		if (p >= end) {
    aaba:	cmp	r0, r3
    aabc:	bcs.n	aae4 <AudioStream::allocate()+0x3c>
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
    aabe:	ldr.w	r1, [r6, r4, lsl #2]
		if (avail) break;
    aac2:	cbnz	r1, aaec <AudioStream::allocate()+0x44>
    aac4:	adds	r2, r0, #4
    aac6:	add.w	r5, r6, #115	; 0x73
    aaca:	adds	r3, r4, #1
    aacc:	subs	r5, r5, r2
    aace:	add.w	r5, r3, r5, lsr #2
    aad2:	b.n	aadc <AudioStream::allocate()+0x34>
		if (p >= end) {
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
    aad4:	ldr.w	r1, [r2], #4
		if (avail) break;
    aad8:	cbnz	r1, aaec <AudioStream::allocate()+0x44>
    aada:	adds	r3, #1
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
		if (p >= end) {
    aadc:	cmp	r3, r5
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
		if (avail) break;
		index++;
    aade:	mov	r4, r3
		p++;
    aae0:	mov	r0, r2
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
		if (p >= end) {
    aae2:	bne.n	aad4 <AudioStream::allocate()+0x2c>
			__enable_irq();
    aae4:	cpsie	i
			//Serial.println("alloc:null");
			return NULL;
    aae6:	movs	r0, #0
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    aae8:	pop	{r4, r5, r6, r7}
    aaea:	bx	lr
		avail = *p;
		if (avail) break;
		index++;
		p++;
	}
	n = __builtin_clz(avail);
    aaec:	clz	r3, r1
	avail &= ~(0x80000000 >> n);
    aaf0:	mov.w	r2, #2147483648	; 0x80000000
    aaf4:	lsrs	r2, r3
    aaf6:	bic.w	r1, r1, r2
	*p = avail;
    aafa:	str	r1, [r0, #0]
	if (!avail) index++;
    aafc:	cbnz	r1, ab00 <AudioStream::allocate()+0x58>
    aafe:	adds	r4, #1
	memory_pool_first_mask = index;
	used = memory_used + 1;
    ab00:	ldr	r1, [pc, #64]	; (ab44 <AudioStream::allocate()+0x9c>)
	}
	n = __builtin_clz(avail);
	avail &= ~(0x80000000 >> n);
	*p = avail;
	if (!avail) index++;
	memory_pool_first_mask = index;
    ab02:	strh	r4, [r7, #0]
	used = memory_used + 1;
    ab04:	ldrh	r2, [r1, #0]
    ab06:	adds	r2, #1
	memory_used = used;
    ab08:	uxth	r4, r2
    ab0a:	strh	r4, [r1, #0]
	__enable_irq();
    ab0c:	cpsie	i
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    ab0e:	subs	r0, r0, r6
    ab10:	asrs	r0, r0, #2
    ab12:	rsb	r0, r3, r0, lsl #5
    ab16:	add.w	r0, r0, r0, lsl #6
    ab1a:	lsls	r3, r0, #2
    ab1c:	ldr	r0, [pc, #40]	; (ab48 <AudioStream::allocate()+0xa0>)
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
    ab1e:	ldr	r1, [pc, #44]	; (ab4c <AudioStream::allocate()+0xa4>)
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    ab20:	ldr	r0, [r0, #0]
    ab22:	add.w	r3, r3, #8032	; 0x1f60
    ab26:	adds	r3, #28
	block->ref_count = 1;
    ab28:	movs	r5, #1
    ab2a:	strb	r5, [r0, r3]
	if (used > memory_used_max) memory_used_max = used;
    ab2c:	ldrh	r5, [r1, #0]
    ab2e:	cmp	r2, r5
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    ab30:	add	r0, r3
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
    ab32:	it	hi
    ab34:	strhhi	r4, [r1, #0]
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    ab36:	pop	{r4, r5, r6, r7}
    ab38:	bx	lr
    ab3a:	nop
    ab3c:	.word	0x20019d4a
    ab40:	.word	0x20019cd8
    ab44:	.word	0x20019d4c
    ab48:	.word	0x20019cd0
    ab4c:	.word	0x20019ccc

0000ab50 <AudioStream::release(audio_block_struct*)>:
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
    ab50:	ldrh	r2, [r0, #2]
	uint32_t index = block->memory_pool_index >> 5;

	__disable_irq();
    ab52:	cpsid	i
	if (block->ref_count > 1) {
    ab54:	ldrb	r3, [r0, #0]
    ab56:	cmp	r3, #1
    ab58:	bls.n	ab62 <AudioStream::release(audio_block_struct*)+0x12>
		block->ref_count--;
    ab5a:	subs	r3, #1
    ab5c:	strb	r3, [r0, #0]
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
		memory_used--;
	}
	__enable_irq();
    ab5e:	cpsie	i
    ab60:	bx	lr
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
	uint32_t index = block->memory_pool_index >> 5;
    ab62:	asrs	r3, r2, #5

// Release ownership of a data block.  If no
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
    ab64:	push	{r4, r5, r6}
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    ab66:	ldr	r4, [pc, #48]	; (ab98 <AudioStream::release(audio_block_struct*)+0x48>)
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    ab68:	ldr	r5, [pc, #48]	; (ab9c <AudioStream::release(audio_block_struct*)+0x4c>)
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    ab6a:	ldr.w	r1, [r4, r3, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    ab6e:	ldrh	r6, [r5, #0]
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    ab70:	mvns	r2, r2
    ab72:	mov.w	r0, #2147483648	; 0x80000000
    ab76:	and.w	r2, r2, #31
    ab7a:	lsr.w	r2, r0, r2
    ab7e:	orrs	r1, r2
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
		memory_used--;
    ab80:	ldr	r2, [pc, #28]	; (aba0 <AudioStream::release(audio_block_struct*)+0x50>)
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    ab82:	str.w	r1, [r4, r3, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    ab86:	cmp	r3, r6
    ab88:	it	cc
    ab8a:	strhcc	r3, [r5, #0]
		memory_used--;
    ab8c:	ldrh	r3, [r2, #0]
    ab8e:	subs	r3, #1
    ab90:	strh	r3, [r2, #0]
	}
	__enable_irq();
    ab92:	cpsie	i
}
    ab94:	pop	{r4, r5, r6}
    ab96:	bx	lr
    ab98:	.word	0x20019cd8
    ab9c:	.word	0x20019d4a
    aba0:	.word	0x20019d4c

0000aba4 <AudioStream::transmit(audio_block_struct*, unsigned char)>:
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    aba4:	ldr	r3, [r0, #12]
    aba6:	cbz	r3, abd6 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x32>
// owned by this object.  Normally, a block must be released
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
    aba8:	push	{r4, r5}
    abaa:	b.n	abb0 <AudioStream::transmit(audio_block_struct*, unsigned char)+0xc>
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    abac:	ldr	r3, [r3, #12]
    abae:	cbz	r3, abd4 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x30>
		if (c->src_index == index) {
    abb0:	ldrb	r0, [r3, #8]
    abb2:	cmp	r0, r2
    abb4:	bne.n	abac <AudioStream::transmit(audio_block_struct*, unsigned char)+0x8>
			if (c->dst.inputQueue[c->dest_index] == NULL) {
    abb6:	ldr	r0, [r3, #4]
    abb8:	ldrb	r4, [r3, #9]
    abba:	ldr	r0, [r0, #16]
    abbc:	ldr.w	r5, [r0, r4, lsl #2]
    abc0:	cmp	r5, #0
    abc2:	bne.n	abac <AudioStream::transmit(audio_block_struct*, unsigned char)+0x8>
				c->dst.inputQueue[c->dest_index] = block;
    abc4:	str.w	r1, [r0, r4, lsl #2]
				block->ref_count++;
    abc8:	ldrb	r0, [r1, #0]
    abca:	adds	r0, #1
    abcc:	strb	r0, [r1, #0]
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    abce:	ldr	r3, [r3, #12]
    abd0:	cmp	r3, #0
    abd2:	bne.n	abb0 <AudioStream::transmit(audio_block_struct*, unsigned char)+0xc>
				c->dst.inputQueue[c->dest_index] = block;
				block->ref_count++;
			}
		}
	}
}
    abd4:	pop	{r4, r5}
    abd6:	bx	lr

0000abd8 <AudioStream::receiveReadOnly(unsigned int)>:
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
    abd8:	ldrb	r3, [r0, #9]
    abda:	cmp	r3, r1
    abdc:	bls.n	abec <AudioStream::receiveReadOnly(unsigned int)+0x14>
	in = inputQueue[index];
    abde:	ldr	r3, [r0, #16]
	inputQueue[index] = NULL;
    abe0:	movs	r2, #0
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
	in = inputQueue[index];
    abe2:	ldr.w	r0, [r3, r1, lsl #2]
	inputQueue[index] = NULL;
    abe6:	str.w	r2, [r3, r1, lsl #2]
	return in;
    abea:	bx	lr
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
    abec:	movs	r0, #0
	in = inputQueue[index];
	inputQueue[index] = NULL;
	return in;
}
    abee:	bx	lr

0000abf0 <AudioConnection::connect()>:

void AudioConnection::connect(void)
{
	AudioConnection *p;

	if (isConnected) return;
    abf0:	ldrb	r3, [r0, #16]
    abf2:	cbnz	r3, ac3e <AudioConnection::connect()+0x4e>
	if (dest_index > dst.num_inputs) return;
    abf4:	ldr	r3, [r0, #4]
    abf6:	ldrb	r2, [r0, #9]
    abf8:	ldrb	r3, [r3, #9]
    abfa:	cmp	r2, r3
    abfc:	bhi.n	ac3e <AudioConnection::connect()+0x4e>
	return in;
}


void AudioConnection::connect(void)
{
    abfe:	push	{r4, r5}
	AudioConnection *p;

	if (isConnected) return;
	if (dest_index > dst.num_inputs) return;
	__disable_irq();
    ac00:	cpsid	i
	p = src.destination_list;
    ac02:	ldr	r4, [r0, #0]
    ac04:	ldr	r3, [r4, #12]
	if (p == NULL) {
    ac06:	cbz	r3, ac54 <AudioConnection::connect()+0x64>
		src.destination_list = this;
	} else {
		while (p->next_dest) {
    ac08:	ldr	r2, [r3, #12]
    ac0a:	cbz	r2, ac1a <AudioConnection::connect()+0x2a>
			if (&p->src == &this->src && &p->dst == &this->dst
    ac0c:	ldr	r1, [r3, #0]
    ac0e:	cmp	r4, r1
    ac10:	beq.n	ac40 <AudioConnection::connect()+0x50>
	return in;
}


void AudioConnection::connect(void)
{
    ac12:	mov	r3, r2
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
    ac14:	ldr	r2, [r3, #12]
    ac16:	cmp	r2, #0
    ac18:	bne.n	ac0c <AudioConnection::connect()+0x1c>
				__enable_irq();
				return;
			}
			p = p->next_dest;
		}
		p->next_dest = this;
    ac1a:	str	r0, [r3, #12]
	}
	this->next_dest = NULL;
    ac1c:	movs	r3, #0
    ac1e:	str	r3, [r0, #12]
	src.numConnections++;
    ac20:	ldrb	r3, [r4, #10]
    ac22:	adds	r3, #1
    ac24:	strb	r3, [r4, #10]
	src.active = true;
    ac26:	ldr	r2, [r0, #0]

	dst.numConnections++;
    ac28:	ldr	r1, [r0, #4]
		}
		p->next_dest = this;
	}
	this->next_dest = NULL;
	src.numConnections++;
	src.active = true;
    ac2a:	movs	r3, #1
    ac2c:	strb	r3, [r2, #8]

	dst.numConnections++;
    ac2e:	ldrb	r2, [r1, #10]
    ac30:	add	r2, r3
    ac32:	strb	r2, [r1, #10]
	dst.active = true;
    ac34:	ldr	r2, [r0, #4]
    ac36:	strb	r3, [r2, #8]

	isConnected = true;
    ac38:	strb	r3, [r0, #16]

	__enable_irq();
    ac3a:	cpsie	i
}
    ac3c:	pop	{r4, r5}
    ac3e:	bx	lr
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
			if (&p->src == &this->src && &p->dst == &this->dst
    ac40:	ldr	r5, [r3, #4]
    ac42:	ldr	r1, [r0, #4]
    ac44:	cmp	r5, r1
    ac46:	bne.n	ac12 <AudioConnection::connect()+0x22>
				&& p->src_index == this->src_index && p->dest_index == this->dest_index) {
    ac48:	ldrh	r1, [r3, #8]
    ac4a:	ldrh	r3, [r0, #8]
    ac4c:	cmp	r1, r3
    ac4e:	beq.n	ac3a <AudioConnection::connect()+0x4a>
	return in;
}


void AudioConnection::connect(void)
{
    ac50:	mov	r3, r2
    ac52:	b.n	ac14 <AudioConnection::connect()+0x24>
	if (isConnected) return;
	if (dest_index > dst.num_inputs) return;
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
    ac54:	str	r0, [r4, #12]
    ac56:	b.n	ac1c <AudioConnection::connect()+0x2c>

0000ac58 <AudioConnection::disconnect()>:

void AudioConnection::disconnect(void)
{
	AudioConnection *p;

	if (!isConnected) return;
    ac58:	ldrb	r3, [r0, #16]

	__enable_irq();
}

void AudioConnection::disconnect(void)
{
    ac5a:	push	{r4, lr}
	AudioConnection *p;

	if (!isConnected) return;
    ac5c:	cmp	r3, #0
    ac5e:	beq.n	acc6 <AudioConnection::disconnect()+0x6e>
	if (dest_index > dst.num_inputs) return;
    ac60:	ldr	r3, [r0, #4]
    ac62:	ldrb	r2, [r0, #9]
    ac64:	ldrb	r3, [r3, #9]
    ac66:	cmp	r2, r3
    ac68:	bhi.n	acc6 <AudioConnection::disconnect()+0x6e>
	__disable_irq();
    ac6a:	cpsid	i
	// Remove destination from source list
	p = src.destination_list;
    ac6c:	ldr	r2, [r0, #0]
    ac6e:	ldr	r3, [r2, #12]
	if (p == NULL) {
    ac70:	cbz	r3, acc4 <AudioConnection::disconnect()+0x6c>
//>>> PAH re-enable the IRQ
		__enable_irq();
		return;
	} else if (p == this) {
    ac72:	cmp	r0, r3
    ac74:	bne.n	ac7c <AudioConnection::disconnect()+0x24>
    ac76:	b.n	accc <AudioConnection::disconnect()+0x74>
		} else {
			src.destination_list = NULL;
		}
	} else {
		while (p) {
			if (p == this) {
    ac78:	cmp	r0, r3
    ac7a:	beq.n	ac82 <AudioConnection::disconnect()+0x2a>
				} else {
					p = NULL;
					break;
				}
			}
			p = p->next_dest;
    ac7c:	ldr	r3, [r3, #12]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
		}
	} else {
		while (p) {
    ac7e:	cmp	r3, #0
    ac80:	bne.n	ac78 <AudioConnection::disconnect()+0x20>
			p = p->next_dest;
		}
	}
//>>> PAH release the audio buffer properly
	//Remove possible pending src block from destination
	if(dst.inputQueue[dest_index] != NULL) {
    ac82:	ldr	r3, [r0, #4]
    ac84:	ldrb	r1, [r0, #9]
    ac86:	ldr	r3, [r3, #16]
    ac88:	mov	r4, r0
    ac8a:	ldr.w	r0, [r3, r1, lsl #2]
    ac8e:	cbz	r0, aca4 <AudioConnection::disconnect()+0x4c>
		AudioStream::release(dst.inputQueue[dest_index]);
    ac90:	bl	ab50 <AudioStream::release(audio_block_struct*)>
		// release() re-enables the IRQ. Need it to be disabled a little longer
		__disable_irq();
    ac94:	cpsid	i
		dst.inputQueue[dest_index] = NULL;
    ac96:	ldr	r3, [r4, #4]
    ac98:	ldrb	r2, [r4, #9]
    ac9a:	ldr	r3, [r3, #16]
    ac9c:	movs	r1, #0
    ac9e:	str.w	r1, [r3, r2, lsl #2]
    aca2:	ldr	r2, [r4, #0]
	}

	//Check if the disconnected AudioStream objects should still be active
	src.numConnections--;
    aca4:	ldrb	r3, [r2, #10]
    aca6:	subs	r3, #1
    aca8:	strb	r3, [r2, #10]
	if (src.numConnections == 0) {
    acaa:	ldr	r3, [r4, #0]
    acac:	ldrb	r2, [r3, #10]
    acae:	cbnz	r2, acb2 <AudioConnection::disconnect()+0x5a>
		src.active = false;
    acb0:	strb	r2, [r3, #8]
	}

	dst.numConnections--;
    acb2:	ldr	r2, [r4, #4]
    acb4:	ldrb	r3, [r2, #10]
    acb6:	subs	r3, #1
    acb8:	strb	r3, [r2, #10]
	if (dst.numConnections == 0) {
    acba:	ldr	r3, [r4, #4]
    acbc:	ldrb	r2, [r3, #10]
    acbe:	cbz	r2, acc8 <AudioConnection::disconnect()+0x70>
		dst.active = false;
	}

	isConnected = false;
    acc0:	movs	r3, #0
    acc2:	strb	r3, [r4, #16]

	__enable_irq();
    acc4:	cpsie	i
    acc6:	pop	{r4, pc}
		src.active = false;
	}

	dst.numConnections--;
	if (dst.numConnections == 0) {
		dst.active = false;
    acc8:	strb	r2, [r3, #8]
    acca:	b.n	acc0 <AudioConnection::disconnect()+0x68>
	if (p == NULL) {
//>>> PAH re-enable the IRQ
		__enable_irq();
		return;
	} else if (p == this) {
		if (p->next_dest) {
    accc:	ldr	r3, [r0, #12]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
    acce:	str	r3, [r2, #12]
    acd0:	b.n	ac82 <AudioConnection::disconnect()+0x2a>
    acd2:	nop

0000acd4 <AudioStream::update_setup()>:
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    acd4:	ldr	r3, [pc, #32]	; (acf8 <AudioStream::update_setup()+0x24>)
    acd6:	ldrb	r2, [r3, #0]
    acd8:	cbnz	r2, acf2 <AudioStream::update_setup()+0x1e>
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
    acda:	ldr	r0, [pc, #32]	; (acfc <AudioStream::update_setup()+0x28>)
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    acdc:	ldr	r1, [pc, #32]	; (ad00 <AudioStream::update_setup()+0x2c>)
// input and output based on interrupts, must check this variable in
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
    acde:	push	{r4}
	if (update_scheduled) return false;
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
    ace0:	movs	r4, #208	; 0xd0
    ace2:	strb	r4, [r0, #0]
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    ace4:	movs	r2, #1
	update_scheduled = true;
	return true;
    ace6:	mov	r0, r2

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    ace8:	str	r2, [r1, #0]
	update_scheduled = true;
    acea:	strb	r2, [r3, #0]
	return true;
}
    acec:	ldr.w	r4, [sp], #4
    acf0:	bx	lr
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    acf2:	movs	r0, #0
    acf4:	bx	lr
    acf6:	nop
    acf8:	.word	0x20019cd4
    acfc:	.word	0xe000e440
    ad00:	.word	0xe000e108

0000ad04 <software_isr>:
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    ad04:	ldr	r1, [pc, #104]	; (ad70 <software_isr+0x6c>)
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    ad06:	ldr	r2, [pc, #108]	; (ad74 <software_isr+0x70>)
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    ad08:	ldr	r0, [pc, #108]	; (ad78 <software_isr+0x74>)
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    ad0a:	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    ad0c:	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    ad0e:	ldr	r5, [pc, #108]	; (ad7c <software_isr+0x78>)
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    ad10:	ldr	r4, [r0, #0]
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    ad12:	orr.w	r3, r3, #16777216	; 0x1000000
    ad16:	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    ad18:	ldr	r3, [r2, #0]
    ad1a:	orr.w	r3, r3, #1
    ad1e:	str	r3, [r2, #0]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    ad20:	ldr	r6, [r5, #0]
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    ad22:	cbnz	r4, ad2a <software_isr+0x26>
    ad24:	b.n	ad52 <software_isr+0x4e>
    ad26:	ldr	r4, [r4, #20]
    ad28:	cbz	r4, ad52 <software_isr+0x4e>
		if (p->active) {
    ad2a:	ldrb	r3, [r4, #8]
    ad2c:	cmp	r3, #0
    ad2e:	beq.n	ad26 <software_isr+0x22>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
    ad30:	ldr	r3, [r4, #0]
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
    ad32:	ldr	r7, [r5, #0]
			p->update();
    ad34:	ldr	r3, [r3, #0]
    ad36:	mov	r0, r4
    ad38:	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    ad3a:	ldr	r3, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    ad3c:	ldrh	r1, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    ad3e:	subs	r3, r3, r7
    ad40:	lsrs	r3, r3, #4
			p->cpu_cycles = cycles;
    ad42:	uxth	r2, r3
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    ad44:	cmp	r3, r1
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
			p->cpu_cycles = cycles;
    ad46:	strh	r2, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    ad48:	it	hi
    ad4a:	strhhi	r2, [r4, #6]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    ad4c:	ldr	r4, [r4, #20]
    ad4e:	cmp	r4, #0
    ad50:	bne.n	ad2a <software_isr+0x26>
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    ad52:	ldr	r3, [pc, #40]	; (ad7c <software_isr+0x78>)
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    ad54:	ldr	r2, [pc, #40]	; (ad80 <software_isr+0x7c>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    ad56:	ldr	r3, [r3, #0]
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    ad58:	ldrh	r0, [r2, #0]
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    ad5a:	ldr	r4, [pc, #40]	; (ad84 <software_isr+0x80>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    ad5c:	subs	r3, r3, r6
    ad5e:	lsrs	r3, r3, #4
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    ad60:	uxth	r1, r3
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    ad62:	cmp	r3, r0
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    ad64:	strh	r1, [r4, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    ad66:	bls.n	ad6c <software_isr+0x68>
		AudioStream::cpu_cycles_total_max = totalcycles;
    ad68:	strh	r1, [r2, #0]
    ad6a:	pop	{r3, r4, r5, r6, r7, pc}
    ad6c:	pop	{r3, r4, r5, r6, r7, pc}
    ad6e:	nop
    ad70:	.word	0xe000edfc
    ad74:	.word	0xe0001000
    ad78:	.word	0x20019cc8
    ad7c:	.word	0xe0001004
    ad80:	.word	0x20019d48
    ad84:	.word	0x20019d4e

0000ad88 <Stream::timedPeek()>:
  return -1;     // -1 indicates timeout
}

// private method to peek stream with timeout
int Stream::timedPeek()
{
    ad88:	push	{r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    ad8a:	ldr	r5, [pc, #56]	; (adc4 <Stream::timedPeek()+0x3c>)
    ad8c:	sub	sp, #8
    ad8e:	ldr	r3, [r5, #0]
    ad90:	str	r3, [sp, #0]
	return ret;
    ad92:	ldr	r6, [sp, #0]
    ad94:	mov	r4, r0
    ad96:	b.n	adaa <Stream::timedPeek()+0x22>
  int c;
  unsigned long startMillis = millis();
  do {
    c = peek();
    if (c >= 0) return c;
    yield();
    ad98:	bl	a6c4 <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    ad9c:	ldr	r3, [r5, #0]
    ad9e:	str	r3, [sp, #4]
	return ret;
    ada0:	ldr	r3, [sp, #4]
// private method to peek stream with timeout
int Stream::timedPeek()
{
  int c;
  unsigned long startMillis = millis();
  do {
    ada2:	ldr	r2, [r4, #8]
    ada4:	subs	r3, r3, r6
    ada6:	cmp	r3, r2
    ada8:	bcs.n	adba <Stream::timedPeek()+0x32>
    c = peek();
    adaa:	ldr	r3, [r4, #0]
    adac:	mov	r0, r4
    adae:	ldr	r3, [r3, #24]
    adb0:	blx	r3
    if (c >= 0) return c;
    adb2:	cmp	r0, #0
    adb4:	blt.n	ad98 <Stream::timedPeek()+0x10>
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
}
    adb6:	add	sp, #8
    adb8:	pop	{r4, r5, r6, pc}
  do {
    c = peek();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    adba:	mov.w	r0, #4294967295
}
    adbe:	add	sp, #8
    adc0:	pop	{r4, r5, r6, pc}
    adc2:	nop
    adc4:	.word	0x20019bc4

0000adc8 <Stream::peekNextDigit()>:

// returns peek of the next digit in the stream or -1 if timeout
// discards non-numeric characters
int Stream::peekNextDigit()
{
    adc8:	push	{r4, lr}
    adca:	mov	r4, r0
    adcc:	b.n	addc <Stream::peekNextDigit()+0x14>
  int c;
  while (1) {
    c = timedPeek();
    if (c < 0) return c;  // timeout
    if (c == '-') return c;
    adce:	cmp	r3, #45	; 0x2d
    add0:	beq.n	adec <Stream::peekNextDigit()+0x24>
    if (c >= '0' && c <= '9') return c;
    add2:	cmp	r2, #9
    add4:	bls.n	adec <Stream::peekNextDigit()+0x24>
    read();  // discard non-numeric
    add6:	ldr	r3, [r4, #0]
    add8:	ldr	r3, [r3, #20]
    adda:	blx	r3
// discards non-numeric characters
int Stream::peekNextDigit()
{
  int c;
  while (1) {
    c = timedPeek();
    addc:	mov	r0, r4
    adde:	bl	ad88 <Stream::timedPeek()>
    if (c < 0) return c;  // timeout
    ade2:	subs	r3, r0, #0
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    ade4:	sub.w	r2, r3, #48	; 0x30
    read();  // discard non-numeric
    ade8:	mov	r0, r4
int Stream::peekNextDigit()
{
  int c;
  while (1) {
    c = timedPeek();
    if (c < 0) return c;  // timeout
    adea:	bge.n	adce <Stream::peekNextDigit()+0x6>
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    read();  // discard non-numeric
  }
}
    adec:	mov	r0, r3
    adee:	pop	{r4, pc}

0000adf0 <Stream::parseInt(char)>:
}

// as above but a given skipChar is ignored
// this allows format characters (typically commas) in values to be ignored
long Stream::parseInt(char skipChar)
{
    adf0:	push	{r3, r4, r5, r6, r7, lr}
    adf2:	mov	r5, r1
    adf4:	mov	r4, r0
  boolean isNegative = false;
  long value = 0;
  int c;

  c = peekNextDigit();
    adf6:	bl	adc8 <Stream::peekNextDigit()>
  // ignore non numeric leading characters
  if(c < 0)
    adfa:	cmp	r0, #0
    adfc:	blt.n	ae46 <Stream::parseInt(char)+0x56>
    adfe:	movs	r6, #0
    ae00:	mov	r7, r6
    return 0; // zero returned if timeout

  do{
    if(c == skipChar)
    ae02:	cmp	r0, r5
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    ae04:	sub.w	r2, r0, #48	; 0x30
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout

  do{
    if(c == skipChar)
    ae08:	beq.n	ae1e <Stream::parseInt(char)+0x2e>
      ; // ignore this charactor
    else if(c == '-')
    ae0a:	cmp	r0, #45	; 0x2d
    ae0c:	beq.n	ae3e <Stream::parseInt(char)+0x4e>
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
      value = value * 10 + c - '0';
    ae0e:	add.w	r3, r6, r6, lsl #2
  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    ae12:	cmp	r2, #9
      value = value * 10 + c - '0';
    ae14:	add.w	r0, r0, r3, lsl #1
  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    ae18:	bhi.n	ae1e <Stream::parseInt(char)+0x2e>
      value = value * 10 + c - '0';
    ae1a:	sub.w	r6, r0, #48	; 0x30
    read();  // consume the character we got with peek
    ae1e:	ldr	r3, [r4, #0]
    ae20:	mov	r0, r4
    ae22:	ldr	r3, [r3, #20]
    ae24:	blx	r3
    c = timedPeek();
    ae26:	mov	r0, r4
    ae28:	bl	ad88 <Stream::timedPeek()>
  }
  while( (c >= '0' && c <= '9') || c == skipChar );
    ae2c:	sub.w	r3, r0, #48	; 0x30
    ae30:	cmp	r3, #9
    ae32:	bls.n	ae02 <Stream::parseInt(char)+0x12>
    ae34:	cmp	r0, r5
    ae36:	beq.n	ae02 <Stream::parseInt(char)+0x12>

  if(isNegative)
    ae38:	cbz	r7, ae42 <Stream::parseInt(char)+0x52>
    value = -value;
    ae3a:	negs	r0, r6
    ae3c:	pop	{r3, r4, r5, r6, r7, pc}

  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    ae3e:	movs	r7, #1
    ae40:	b.n	ae1e <Stream::parseInt(char)+0x2e>
    ae42:	mov	r0, r6
  while( (c >= '0' && c <= '9') || c == skipChar );

  if(isNegative)
    value = -value;
  return value;
}
    ae44:	pop	{r3, r4, r5, r6, r7, pc}
  int c;

  c = peekNextDigit();
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout
    ae46:	movs	r0, #0
    ae48:	pop	{r3, r4, r5, r6, r7, pc}
    ae4a:	nop

0000ae4c <Stream::parseInt()>:
// returns the first valid (long) integer value from the current position.
// initial characters that are not digits (or the minus sign) are skipped
// function is terminated by the first character that is not a digit.
long Stream::parseInt()
{
  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
    ae4c:	movs	r1, #1
    ae4e:	b.w	adf0 <Stream::parseInt(char)>
    ae52:	nop

0000ae54 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    ae54:	bx	lr
    ae56:	nop

0000ae58 <operator new(unsigned int)>:
    ae58:	b.w	bd10 <malloc>

0000ae5c <operator delete(void*, unsigned int)>:
    ae5c:	b.w	bd20 <free>

0000ae60 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    ae60:	cpsid	i
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    ae62:	ldr	r2, [pc, #96]	; (aec4 <usb_init_serialnumber+0x64>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    ae64:	ldr	r3, [pc, #96]	; (aec8 <usb_init_serialnumber+0x68>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    ae66:	ldr	r1, [pc, #100]	; (aecc <usb_init_serialnumber+0x6c>)
    ae68:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    ae6a:	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    ae6c:	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    ae6e:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    ae70:	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    ae72:	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    ae74:	ldrb	r3, [r2, #0]
    ae76:	lsls	r3, r3, #24
    ae78:	bpl.n	ae74 <usb_init_serialnumber+0x14>
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    ae7a:	push	{r4, lr}
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    ae7c:	ldr	r3, [pc, #80]	; (aed0 <usb_init_serialnumber+0x70>)
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    ae7e:	sub	sp, #16
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    ae80:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    ae82:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    ae84:	ldr	r3, [pc, #76]	; (aed4 <usb_init_serialnumber+0x74>)
    ae86:	ldr	r4, [pc, #80]	; (aed8 <usb_init_serialnumber+0x78>)
    ae88:	cmp	r0, r3
    ae8a:	it	ls
    ae8c:	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    ae90:	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    ae92:	it	ls
    ae94:	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    ae96:	movs	r2, #10
    ae98:	bl	aedc <ultoa>
    ae9c:	add	r1, sp, #4
    ae9e:	mov	r0, r4
	for (i=0; i<10; i++) {
    aea0:	movs	r3, #0
		char c = buf[i];
    aea2:	ldrb.w	r2, [r1], #1
    aea6:	adds	r3, #1
		if (!c) break;
    aea8:	cbz	r2, aeba <usb_init_serialnumber+0x5a>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    aeaa:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    aeac:	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    aeb0:	bne.n	aea2 <usb_init_serialnumber+0x42>
    aeb2:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    aeb4:	strb	r3, [r4, #0]
}
    aeb6:	add	sp, #16
    aeb8:	pop	{r4, pc}
    aeba:	lsls	r3, r3, #1
    aebc:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    aebe:	strb	r3, [r4, #0]
}
    aec0:	add	sp, #16
    aec2:	pop	{r4, pc}
    aec4:	.word	0x40020004
    aec8:	.word	0x40020000
    aecc:	.word	0x41070000
    aed0:	.word	0x4002000c
    aed4:	.word	0x0098967f
    aed8:	.word	0x20013984

0000aedc <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    aedc:	push	{r4, r5, r6, r7}
    aede:	subs	r5, r1, #1
    aee0:	mov	r6, r5
	unsigned digit;
	int i=0, j;
    aee2:	movs	r4, #0
    aee4:	b.n	aee8 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    aee6:	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    aee8:	udiv	r3, r0, r2
    aeec:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    aef0:	cmp	r0, #9
    aef2:	add.w	r7, r0, #48	; 0x30
    aef6:	itet	hi
    aef8:	addhi	r0, #55	; 0x37
    aefa:	uxtbls	r0, r7
    aefc:	uxtbhi	r0, r0
    aefe:	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    af02:	mov	r0, r3
    af04:	cmp	r3, #0
    af06:	bne.n	aee6 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    af08:	adds	r2, r1, r4
    af0a:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    af0c:	cbz	r4, af22 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    af0e:	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    af10:	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    af14:	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    af16:	adds	r3, #1
    af18:	subs	r0, r4, r3
    af1a:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    af1c:	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    af20:	blt.n	af0e <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    af22:	mov	r0, r1
    af24:	pop	{r4, r5, r6, r7}
    af26:	bx	lr

0000af28 <nanf>:
    af28:	vldr	s0, [pc, #4]	; af30 <nanf+0x8>
    af2c:	bx	lr
    af2e:	nop
    af30:	.word	0x7fc00000

0000af34 <__aeabi_atexit>:
    af34:	mov	r3, r1
    af36:	mov	r1, r0
    af38:	mov	r0, r3
    af3a:	b.w	bc58 <__cxa_atexit>
    af3e:	nop

0000af40 <__aeabi_drsub>:
    af40:	eor.w	r1, r1, #2147483648	; 0x80000000
    af44:	b.n	af4c <__adddf3>
    af46:	nop

0000af48 <__aeabi_dsub>:
    af48:	eor.w	r3, r3, #2147483648	; 0x80000000

0000af4c <__adddf3>:
    af4c:	push	{r4, r5, lr}
    af4e:	mov.w	r4, r1, lsl #1
    af52:	mov.w	r5, r3, lsl #1
    af56:	teq	r4, r5
    af5a:	it	eq
    af5c:	teqeq	r0, r2
    af60:	itttt	ne
    af62:	orrsne.w	ip, r4, r0
    af66:	orrsne.w	ip, r5, r2
    af6a:	mvnsne.w	ip, r4, asr #21
    af6e:	mvnsne.w	ip, r5, asr #21
    af72:	beq.w	b13a <__adddf3+0x1ee>
    af76:	mov.w	r4, r4, lsr #21
    af7a:	rsbs	r5, r4, r5, lsr #21
    af7e:	it	lt
    af80:	neglt	r5, r5
    af82:	ble.n	af9e <__adddf3+0x52>
    af84:	add	r4, r5
    af86:	eor.w	r2, r0, r2
    af8a:	eor.w	r3, r1, r3
    af8e:	eor.w	r0, r2, r0
    af92:	eor.w	r1, r3, r1
    af96:	eor.w	r2, r0, r2
    af9a:	eor.w	r3, r1, r3
    af9e:	cmp	r5, #54	; 0x36
    afa0:	it	hi
    afa2:	pophi	{r4, r5, pc}
    afa4:	tst.w	r1, #2147483648	; 0x80000000
    afa8:	mov.w	r1, r1, lsl #12
    afac:	mov.w	ip, #1048576	; 0x100000
    afb0:	orr.w	r1, ip, r1, lsr #12
    afb4:	beq.n	afbc <__adddf3+0x70>
    afb6:	negs	r0, r0
    afb8:	sbc.w	r1, r1, r1, lsl #1
    afbc:	tst.w	r3, #2147483648	; 0x80000000
    afc0:	mov.w	r3, r3, lsl #12
    afc4:	orr.w	r3, ip, r3, lsr #12
    afc8:	beq.n	afd0 <__adddf3+0x84>
    afca:	negs	r2, r2
    afcc:	sbc.w	r3, r3, r3, lsl #1
    afd0:	teq	r4, r5
    afd4:	beq.w	b126 <__adddf3+0x1da>
    afd8:	sub.w	r4, r4, #1
    afdc:	rsbs	lr, r5, #32
    afe0:	blt.n	affe <__adddf3+0xb2>
    afe2:	lsl.w	ip, r2, lr
    afe6:	lsr.w	r2, r2, r5
    afea:	adds	r0, r0, r2
    afec:	adc.w	r1, r1, #0
    aff0:	lsl.w	r2, r3, lr
    aff4:	adds	r0, r0, r2
    aff6:	asr.w	r3, r3, r5
    affa:	adcs	r1, r3
    affc:	b.n	b01c <__adddf3+0xd0>
    affe:	sub.w	r5, r5, #32
    b002:	add.w	lr, lr, #32
    b006:	cmp	r2, #1
    b008:	lsl.w	ip, r3, lr
    b00c:	it	cs
    b00e:	orrcs.w	ip, ip, #2
    b012:	asr.w	r3, r3, r5
    b016:	adds	r0, r0, r3
    b018:	adcs.w	r1, r1, r3, asr #31
    b01c:	and.w	r5, r1, #2147483648	; 0x80000000
    b020:	bpl.n	b032 <__adddf3+0xe6>
    b022:	mov.w	lr, #0
    b026:	rsbs	ip, ip, #0
    b02a:	sbcs.w	r0, lr, r0
    b02e:	sbc.w	r1, lr, r1
    b032:	cmp.w	r1, #1048576	; 0x100000
    b036:	bcc.n	b070 <__adddf3+0x124>
    b038:	cmp.w	r1, #2097152	; 0x200000
    b03c:	bcc.n	b058 <__adddf3+0x10c>
    b03e:	lsrs	r1, r1, #1
    b040:	movs.w	r0, r0, rrx
    b044:	mov.w	ip, ip, rrx
    b048:	add.w	r4, r4, #1
    b04c:	mov.w	r2, r4, lsl #21
    b050:	cmn.w	r2, #4194304	; 0x400000
    b054:	bcs.w	b18c <__adddf3+0x240>
    b058:	cmp.w	ip, #2147483648	; 0x80000000
    b05c:	it	eq
    b05e:	movseq.w	ip, r0, lsr #1
    b062:	adcs.w	r0, r0, #0
    b066:	adc.w	r1, r1, r4, lsl #20
    b06a:	orr.w	r1, r1, r5
    b06e:	pop	{r4, r5, pc}
    b070:	movs.w	ip, ip, lsl #1
    b074:	adcs	r0, r0
    b076:	adc.w	r1, r1, r1
    b07a:	tst.w	r1, #1048576	; 0x100000
    b07e:	sub.w	r4, r4, #1
    b082:	bne.n	b058 <__adddf3+0x10c>
    b084:	teq	r1, #0
    b088:	itt	eq
    b08a:	moveq	r1, r0
    b08c:	moveq	r0, #0
    b08e:	clz	r3, r1
    b092:	it	eq
    b094:	addeq	r3, #32
    b096:	sub.w	r3, r3, #11
    b09a:	subs.w	r2, r3, #32
    b09e:	bge.n	b0ba <__adddf3+0x16e>
    b0a0:	adds	r2, #12
    b0a2:	ble.n	b0b6 <__adddf3+0x16a>
    b0a4:	add.w	ip, r2, #20
    b0a8:	rsb	r2, r2, #12
    b0ac:	lsl.w	r0, r1, ip
    b0b0:	lsr.w	r1, r1, r2
    b0b4:	b.n	b0d0 <__adddf3+0x184>
    b0b6:	add.w	r2, r2, #20
    b0ba:	it	le
    b0bc:	rsble	ip, r2, #32
    b0c0:	lsl.w	r1, r1, r2
    b0c4:	lsr.w	ip, r0, ip
    b0c8:	itt	le
    b0ca:	orrle.w	r1, r1, ip
    b0ce:	lslle	r0, r2
    b0d0:	subs	r4, r4, r3
    b0d2:	ittt	ge
    b0d4:	addge.w	r1, r1, r4, lsl #20
    b0d8:	orrge	r1, r5
    b0da:	popge	{r4, r5, pc}
    b0dc:	mvn.w	r4, r4
    b0e0:	subs	r4, #31
    b0e2:	bge.n	b11e <__adddf3+0x1d2>
    b0e4:	adds	r4, #12
    b0e6:	bgt.n	b106 <__adddf3+0x1ba>
    b0e8:	add.w	r4, r4, #20
    b0ec:	rsb	r2, r4, #32
    b0f0:	lsr.w	r0, r0, r4
    b0f4:	lsl.w	r3, r1, r2
    b0f8:	orr.w	r0, r0, r3
    b0fc:	lsr.w	r3, r1, r4
    b100:	orr.w	r1, r5, r3
    b104:	pop	{r4, r5, pc}
    b106:	rsb	r4, r4, #12
    b10a:	rsb	r2, r4, #32
    b10e:	lsr.w	r0, r0, r2
    b112:	lsl.w	r3, r1, r4
    b116:	orr.w	r0, r0, r3
    b11a:	mov	r1, r5
    b11c:	pop	{r4, r5, pc}
    b11e:	lsr.w	r0, r1, r4
    b122:	mov	r1, r5
    b124:	pop	{r4, r5, pc}
    b126:	teq	r4, #0
    b12a:	eor.w	r3, r3, #1048576	; 0x100000
    b12e:	itte	eq
    b130:	eoreq.w	r1, r1, #1048576	; 0x100000
    b134:	addeq	r4, #1
    b136:	subne	r5, #1
    b138:	b.n	afd8 <__adddf3+0x8c>
    b13a:	mvns.w	ip, r4, asr #21
    b13e:	it	ne
    b140:	mvnsne.w	ip, r5, asr #21
    b144:	beq.n	b19a <__adddf3+0x24e>
    b146:	teq	r4, r5
    b14a:	it	eq
    b14c:	teqeq	r0, r2
    b150:	beq.n	b15e <__adddf3+0x212>
    b152:	orrs.w	ip, r4, r0
    b156:	itt	eq
    b158:	moveq	r1, r3
    b15a:	moveq	r0, r2
    b15c:	pop	{r4, r5, pc}
    b15e:	teq	r1, r3
    b162:	ittt	ne
    b164:	movne	r1, #0
    b166:	movne	r0, #0
    b168:	popne	{r4, r5, pc}
    b16a:	movs.w	ip, r4, lsr #21
    b16e:	bne.n	b17c <__adddf3+0x230>
    b170:	lsls	r0, r0, #1
    b172:	adcs	r1, r1
    b174:	it	cs
    b176:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    b17a:	pop	{r4, r5, pc}
    b17c:	adds.w	r4, r4, #4194304	; 0x400000
    b180:	itt	cc
    b182:	addcc.w	r1, r1, #1048576	; 0x100000
    b186:	popcc	{r4, r5, pc}
    b188:	and.w	r5, r1, #2147483648	; 0x80000000
    b18c:	orr.w	r1, r5, #2130706432	; 0x7f000000
    b190:	orr.w	r1, r1, #15728640	; 0xf00000
    b194:	mov.w	r0, #0
    b198:	pop	{r4, r5, pc}
    b19a:	mvns.w	ip, r4, asr #21
    b19e:	itte	ne
    b1a0:	movne	r1, r3
    b1a2:	movne	r0, r2
    b1a4:	mvnseq.w	ip, r5, asr #21
    b1a8:	itt	ne
    b1aa:	movne	r3, r1
    b1ac:	movne	r2, r0
    b1ae:	orrs.w	r4, r0, r1, lsl #12
    b1b2:	itte	eq
    b1b4:	orrseq.w	r5, r2, r3, lsl #12
    b1b8:	teqeq	r1, r3
    b1bc:	orrne.w	r1, r1, #524288	; 0x80000
    b1c0:	pop	{r4, r5, pc}
    b1c2:	nop

0000b1c4 <__aeabi_ui2d>:
    b1c4:	teq	r0, #0
    b1c8:	itt	eq
    b1ca:	moveq	r1, #0
    b1cc:	bxeq	lr
    b1ce:	push	{r4, r5, lr}
    b1d0:	mov.w	r4, #1024	; 0x400
    b1d4:	add.w	r4, r4, #50	; 0x32
    b1d8:	mov.w	r5, #0
    b1dc:	mov.w	r1, #0
    b1e0:	b.n	b084 <__adddf3+0x138>
    b1e2:	nop

0000b1e4 <__aeabi_i2d>:
    b1e4:	teq	r0, #0
    b1e8:	itt	eq
    b1ea:	moveq	r1, #0
    b1ec:	bxeq	lr
    b1ee:	push	{r4, r5, lr}
    b1f0:	mov.w	r4, #1024	; 0x400
    b1f4:	add.w	r4, r4, #50	; 0x32
    b1f8:	ands.w	r5, r0, #2147483648	; 0x80000000
    b1fc:	it	mi
    b1fe:	negmi	r0, r0
    b200:	mov.w	r1, #0
    b204:	b.n	b084 <__adddf3+0x138>
    b206:	nop

0000b208 <__aeabi_f2d>:
    b208:	lsls	r2, r0, #1
    b20a:	mov.w	r1, r2, asr #3
    b20e:	mov.w	r1, r1, rrx
    b212:	mov.w	r0, r2, lsl #28
    b216:	itttt	ne
    b218:	andsne.w	r3, r2, #4278190080	; 0xff000000
    b21c:	teqne	r3, #4278190080	; 0xff000000
    b220:	eorne.w	r1, r1, #939524096	; 0x38000000
    b224:	bxne	lr
    b226:	teq	r2, #0
    b22a:	ite	ne
    b22c:	teqne	r3, #4278190080	; 0xff000000
    b230:	bxeq	lr
    b232:	push	{r4, r5, lr}
    b234:	mov.w	r4, #896	; 0x380
    b238:	and.w	r5, r1, #2147483648	; 0x80000000
    b23c:	bic.w	r1, r1, #2147483648	; 0x80000000
    b240:	b.n	b084 <__adddf3+0x138>
    b242:	nop

0000b244 <__aeabi_ul2d>:
    b244:	orrs.w	r2, r0, r1
    b248:	it	eq
    b24a:	bxeq	lr
    b24c:	push	{r4, r5, lr}
    b24e:	mov.w	r5, #0
    b252:	b.n	b26a <__aeabi_l2d+0x16>

0000b254 <__aeabi_l2d>:
    b254:	orrs.w	r2, r0, r1
    b258:	it	eq
    b25a:	bxeq	lr
    b25c:	push	{r4, r5, lr}
    b25e:	ands.w	r5, r1, #2147483648	; 0x80000000
    b262:	bpl.n	b26a <__aeabi_l2d+0x16>
    b264:	negs	r0, r0
    b266:	sbc.w	r1, r1, r1, lsl #1
    b26a:	mov.w	r4, #1024	; 0x400
    b26e:	add.w	r4, r4, #50	; 0x32
    b272:	movs.w	ip, r1, lsr #22
    b276:	beq.w	b032 <__adddf3+0xe6>
    b27a:	mov.w	r2, #3
    b27e:	movs.w	ip, ip, lsr #3
    b282:	it	ne
    b284:	addne	r2, #3
    b286:	movs.w	ip, ip, lsr #3
    b28a:	it	ne
    b28c:	addne	r2, #3
    b28e:	add.w	r2, r2, ip, lsr #3
    b292:	rsb	r3, r2, #32
    b296:	lsl.w	ip, r0, r3
    b29a:	lsr.w	r0, r0, r2
    b29e:	lsl.w	lr, r1, r3
    b2a2:	orr.w	r0, r0, lr
    b2a6:	lsr.w	r1, r1, r2
    b2aa:	add	r4, r2
    b2ac:	b.n	b032 <__adddf3+0xe6>
    b2ae:	nop

0000b2b0 <__aeabi_dmul>:
    b2b0:	push	{r4, r5, r6, lr}
    b2b2:	mov.w	ip, #255	; 0xff
    b2b6:	orr.w	ip, ip, #1792	; 0x700
    b2ba:	ands.w	r4, ip, r1, lsr #20
    b2be:	ittte	ne
    b2c0:	andsne.w	r5, ip, r3, lsr #20
    b2c4:	teqne	r4, ip
    b2c8:	teqne	r5, ip
    b2cc:	bleq	b48c <__aeabi_dmul+0x1dc>
    b2d0:	add	r4, r5
    b2d2:	eor.w	r6, r1, r3
    b2d6:	bic.w	r1, r1, ip, lsl #21
    b2da:	bic.w	r3, r3, ip, lsl #21
    b2de:	orrs.w	r5, r0, r1, lsl #12
    b2e2:	it	ne
    b2e4:	orrsne.w	r5, r2, r3, lsl #12
    b2e8:	orr.w	r1, r1, #1048576	; 0x100000
    b2ec:	orr.w	r3, r3, #1048576	; 0x100000
    b2f0:	beq.n	b364 <__aeabi_dmul+0xb4>
    b2f2:	umull	ip, lr, r0, r2
    b2f6:	mov.w	r5, #0
    b2fa:	umlal	lr, r5, r1, r2
    b2fe:	and.w	r2, r6, #2147483648	; 0x80000000
    b302:	umlal	lr, r5, r0, r3
    b306:	mov.w	r6, #0
    b30a:	umlal	r5, r6, r1, r3
    b30e:	teq	ip, #0
    b312:	it	ne
    b314:	orrne.w	lr, lr, #1
    b318:	sub.w	r4, r4, #255	; 0xff
    b31c:	cmp.w	r6, #512	; 0x200
    b320:	sbc.w	r4, r4, #768	; 0x300
    b324:	bcs.n	b330 <__aeabi_dmul+0x80>
    b326:	movs.w	lr, lr, lsl #1
    b32a:	adcs	r5, r5
    b32c:	adc.w	r6, r6, r6
    b330:	orr.w	r1, r2, r6, lsl #11
    b334:	orr.w	r1, r1, r5, lsr #21
    b338:	mov.w	r0, r5, lsl #11
    b33c:	orr.w	r0, r0, lr, lsr #21
    b340:	mov.w	lr, lr, lsl #11
    b344:	subs.w	ip, r4, #253	; 0xfd
    b348:	it	hi
    b34a:	cmphi.w	ip, #1792	; 0x700
    b34e:	bhi.n	b38e <__aeabi_dmul+0xde>
    b350:	cmp.w	lr, #2147483648	; 0x80000000
    b354:	it	eq
    b356:	movseq.w	lr, r0, lsr #1
    b35a:	adcs.w	r0, r0, #0
    b35e:	adc.w	r1, r1, r4, lsl #20
    b362:	pop	{r4, r5, r6, pc}
    b364:	and.w	r6, r6, #2147483648	; 0x80000000
    b368:	orr.w	r1, r6, r1
    b36c:	orr.w	r0, r0, r2
    b370:	eor.w	r1, r1, r3
    b374:	subs.w	r4, r4, ip, lsr #1
    b378:	ittt	gt
    b37a:	rsbsgt	r5, r4, ip
    b37e:	orrgt.w	r1, r1, r4, lsl #20
    b382:	popgt	{r4, r5, r6, pc}
    b384:	orr.w	r1, r1, #1048576	; 0x100000
    b388:	mov.w	lr, #0
    b38c:	subs	r4, #1
    b38e:	bgt.w	b4e8 <__aeabi_dmul+0x238>
    b392:	cmn.w	r4, #54	; 0x36
    b396:	ittt	le
    b398:	movle	r0, #0
    b39a:	andle.w	r1, r1, #2147483648	; 0x80000000
    b39e:	pople	{r4, r5, r6, pc}
    b3a0:	rsb	r4, r4, #0
    b3a4:	subs	r4, #32
    b3a6:	bge.n	b414 <__aeabi_dmul+0x164>
    b3a8:	adds	r4, #12
    b3aa:	bgt.n	b3e4 <__aeabi_dmul+0x134>
    b3ac:	add.w	r4, r4, #20
    b3b0:	rsb	r5, r4, #32
    b3b4:	lsl.w	r3, r0, r5
    b3b8:	lsr.w	r0, r0, r4
    b3bc:	lsl.w	r2, r1, r5
    b3c0:	orr.w	r0, r0, r2
    b3c4:	and.w	r2, r1, #2147483648	; 0x80000000
    b3c8:	bic.w	r1, r1, #2147483648	; 0x80000000
    b3cc:	adds.w	r0, r0, r3, lsr #31
    b3d0:	lsr.w	r6, r1, r4
    b3d4:	adc.w	r1, r2, r6
    b3d8:	orrs.w	lr, lr, r3, lsl #1
    b3dc:	it	eq
    b3de:	biceq.w	r0, r0, r3, lsr #31
    b3e2:	pop	{r4, r5, r6, pc}
    b3e4:	rsb	r4, r4, #12
    b3e8:	rsb	r5, r4, #32
    b3ec:	lsl.w	r3, r0, r4
    b3f0:	lsr.w	r0, r0, r5
    b3f4:	lsl.w	r2, r1, r4
    b3f8:	orr.w	r0, r0, r2
    b3fc:	and.w	r1, r1, #2147483648	; 0x80000000
    b400:	adds.w	r0, r0, r3, lsr #31
    b404:	adc.w	r1, r1, #0
    b408:	orrs.w	lr, lr, r3, lsl #1
    b40c:	it	eq
    b40e:	biceq.w	r0, r0, r3, lsr #31
    b412:	pop	{r4, r5, r6, pc}
    b414:	rsb	r5, r4, #32
    b418:	lsl.w	r2, r0, r5
    b41c:	orr.w	lr, lr, r2
    b420:	lsr.w	r3, r0, r4
    b424:	lsl.w	r2, r1, r5
    b428:	orr.w	r3, r3, r2
    b42c:	lsr.w	r0, r1, r4
    b430:	and.w	r1, r1, #2147483648	; 0x80000000
    b434:	lsr.w	r2, r1, r4
    b438:	bic.w	r0, r0, r2
    b43c:	add.w	r0, r0, r3, lsr #31
    b440:	orrs.w	lr, lr, r3, lsl #1
    b444:	it	eq
    b446:	biceq.w	r0, r0, r3, lsr #31
    b44a:	pop	{r4, r5, r6, pc}
    b44c:	teq	r4, #0
    b450:	bne.n	b472 <__aeabi_dmul+0x1c2>
    b452:	and.w	r6, r1, #2147483648	; 0x80000000
    b456:	lsls	r0, r0, #1
    b458:	adc.w	r1, r1, r1
    b45c:	tst.w	r1, #1048576	; 0x100000
    b460:	it	eq
    b462:	subeq	r4, #1
    b464:	beq.n	b456 <__aeabi_dmul+0x1a6>
    b466:	orr.w	r1, r1, r6
    b46a:	teq	r5, #0
    b46e:	it	ne
    b470:	bxne	lr
    b472:	and.w	r6, r3, #2147483648	; 0x80000000
    b476:	lsls	r2, r2, #1
    b478:	adc.w	r3, r3, r3
    b47c:	tst.w	r3, #1048576	; 0x100000
    b480:	it	eq
    b482:	subeq	r5, #1
    b484:	beq.n	b476 <__aeabi_dmul+0x1c6>
    b486:	orr.w	r3, r3, r6
    b48a:	bx	lr
    b48c:	teq	r4, ip
    b490:	and.w	r5, ip, r3, lsr #20
    b494:	it	ne
    b496:	teqne	r5, ip
    b49a:	beq.n	b4b6 <__aeabi_dmul+0x206>
    b49c:	orrs.w	r6, r0, r1, lsl #1
    b4a0:	it	ne
    b4a2:	orrsne.w	r6, r2, r3, lsl #1
    b4a6:	bne.n	b44c <__aeabi_dmul+0x19c>
    b4a8:	eor.w	r1, r1, r3
    b4ac:	and.w	r1, r1, #2147483648	; 0x80000000
    b4b0:	mov.w	r0, #0
    b4b4:	pop	{r4, r5, r6, pc}
    b4b6:	orrs.w	r6, r0, r1, lsl #1
    b4ba:	itte	eq
    b4bc:	moveq	r0, r2
    b4be:	moveq	r1, r3
    b4c0:	orrsne.w	r6, r2, r3, lsl #1
    b4c4:	beq.n	b4fa <__aeabi_dmul+0x24a>
    b4c6:	teq	r4, ip
    b4ca:	bne.n	b4d2 <__aeabi_dmul+0x222>
    b4cc:	orrs.w	r6, r0, r1, lsl #12
    b4d0:	bne.n	b4fa <__aeabi_dmul+0x24a>
    b4d2:	teq	r5, ip
    b4d6:	bne.n	b4e4 <__aeabi_dmul+0x234>
    b4d8:	orrs.w	r6, r2, r3, lsl #12
    b4dc:	itt	ne
    b4de:	movne	r0, r2
    b4e0:	movne	r1, r3
    b4e2:	bne.n	b4fa <__aeabi_dmul+0x24a>
    b4e4:	eor.w	r1, r1, r3
    b4e8:	and.w	r1, r1, #2147483648	; 0x80000000
    b4ec:	orr.w	r1, r1, #2130706432	; 0x7f000000
    b4f0:	orr.w	r1, r1, #15728640	; 0xf00000
    b4f4:	mov.w	r0, #0
    b4f8:	pop	{r4, r5, r6, pc}
    b4fa:	orr.w	r1, r1, #2130706432	; 0x7f000000
    b4fe:	orr.w	r1, r1, #16252928	; 0xf80000
    b502:	pop	{r4, r5, r6, pc}

0000b504 <__aeabi_ddiv>:
    b504:	push	{r4, r5, r6, lr}
    b506:	mov.w	ip, #255	; 0xff
    b50a:	orr.w	ip, ip, #1792	; 0x700
    b50e:	ands.w	r4, ip, r1, lsr #20
    b512:	ittte	ne
    b514:	andsne.w	r5, ip, r3, lsr #20
    b518:	teqne	r4, ip
    b51c:	teqne	r5, ip
    b520:	bleq	b672 <__aeabi_ddiv+0x16e>
    b524:	sub.w	r4, r4, r5
    b528:	eor.w	lr, r1, r3
    b52c:	orrs.w	r5, r2, r3, lsl #12
    b530:	mov.w	r1, r1, lsl #12
    b534:	beq.w	b648 <__aeabi_ddiv+0x144>
    b538:	mov.w	r3, r3, lsl #12
    b53c:	mov.w	r5, #268435456	; 0x10000000
    b540:	orr.w	r3, r5, r3, lsr #4
    b544:	orr.w	r3, r3, r2, lsr #24
    b548:	mov.w	r2, r2, lsl #8
    b54c:	orr.w	r5, r5, r1, lsr #4
    b550:	orr.w	r5, r5, r0, lsr #24
    b554:	mov.w	r6, r0, lsl #8
    b558:	and.w	r1, lr, #2147483648	; 0x80000000
    b55c:	cmp	r5, r3
    b55e:	it	eq
    b560:	cmpeq	r6, r2
    b562:	adc.w	r4, r4, #253	; 0xfd
    b566:	add.w	r4, r4, #768	; 0x300
    b56a:	bcs.n	b572 <__aeabi_ddiv+0x6e>
    b56c:	lsrs	r3, r3, #1
    b56e:	mov.w	r2, r2, rrx
    b572:	subs	r6, r6, r2
    b574:	sbc.w	r5, r5, r3
    b578:	lsrs	r3, r3, #1
    b57a:	mov.w	r2, r2, rrx
    b57e:	mov.w	r0, #1048576	; 0x100000
    b582:	mov.w	ip, #524288	; 0x80000
    b586:	subs.w	lr, r6, r2
    b58a:	sbcs.w	lr, r5, r3
    b58e:	ittt	cs
    b590:	subcs	r6, r6, r2
    b592:	movcs	r5, lr
    b594:	orrcs.w	r0, r0, ip
    b598:	lsrs	r3, r3, #1
    b59a:	mov.w	r2, r2, rrx
    b59e:	subs.w	lr, r6, r2
    b5a2:	sbcs.w	lr, r5, r3
    b5a6:	ittt	cs
    b5a8:	subcs	r6, r6, r2
    b5aa:	movcs	r5, lr
    b5ac:	orrcs.w	r0, r0, ip, lsr #1
    b5b0:	lsrs	r3, r3, #1
    b5b2:	mov.w	r2, r2, rrx
    b5b6:	subs.w	lr, r6, r2
    b5ba:	sbcs.w	lr, r5, r3
    b5be:	ittt	cs
    b5c0:	subcs	r6, r6, r2
    b5c2:	movcs	r5, lr
    b5c4:	orrcs.w	r0, r0, ip, lsr #2
    b5c8:	lsrs	r3, r3, #1
    b5ca:	mov.w	r2, r2, rrx
    b5ce:	subs.w	lr, r6, r2
    b5d2:	sbcs.w	lr, r5, r3
    b5d6:	ittt	cs
    b5d8:	subcs	r6, r6, r2
    b5da:	movcs	r5, lr
    b5dc:	orrcs.w	r0, r0, ip, lsr #3
    b5e0:	orrs.w	lr, r5, r6
    b5e4:	beq.n	b618 <__aeabi_ddiv+0x114>
    b5e6:	mov.w	r5, r5, lsl #4
    b5ea:	orr.w	r5, r5, r6, lsr #28
    b5ee:	mov.w	r6, r6, lsl #4
    b5f2:	mov.w	r3, r3, lsl #3
    b5f6:	orr.w	r3, r3, r2, lsr #29
    b5fa:	mov.w	r2, r2, lsl #3
    b5fe:	movs.w	ip, ip, lsr #4
    b602:	bne.n	b586 <__aeabi_ddiv+0x82>
    b604:	tst.w	r1, #1048576	; 0x100000
    b608:	bne.n	b622 <__aeabi_ddiv+0x11e>
    b60a:	orr.w	r1, r1, r0
    b60e:	mov.w	r0, #0
    b612:	mov.w	ip, #2147483648	; 0x80000000
    b616:	b.n	b586 <__aeabi_ddiv+0x82>
    b618:	tst.w	r1, #1048576	; 0x100000
    b61c:	itt	eq
    b61e:	orreq	r1, r0
    b620:	moveq	r0, #0
    b622:	subs.w	ip, r4, #253	; 0xfd
    b626:	it	hi
    b628:	cmphi.w	ip, #1792	; 0x700
    b62c:	bhi.w	b38e <__aeabi_dmul+0xde>
    b630:	subs.w	ip, r5, r3
    b634:	itt	eq
    b636:	subseq.w	ip, r6, r2
    b63a:	movseq.w	ip, r0, lsr #1
    b63e:	adcs.w	r0, r0, #0
    b642:	adc.w	r1, r1, r4, lsl #20
    b646:	pop	{r4, r5, r6, pc}
    b648:	and.w	lr, lr, #2147483648	; 0x80000000
    b64c:	orr.w	r1, lr, r1, lsr #12
    b650:	adds.w	r4, r4, ip, lsr #1
    b654:	ittt	gt
    b656:	rsbsgt	r5, r4, ip
    b65a:	orrgt.w	r1, r1, r4, lsl #20
    b65e:	popgt	{r4, r5, r6, pc}
    b660:	orr.w	r1, r1, #1048576	; 0x100000
    b664:	mov.w	lr, #0
    b668:	subs	r4, #1
    b66a:	b.n	b38e <__aeabi_dmul+0xde>
    b66c:	orr.w	lr, r5, r6
    b670:	b.n	b38e <__aeabi_dmul+0xde>
    b672:	and.w	r5, ip, r3, lsr #20
    b676:	teq	r4, ip
    b67a:	it	eq
    b67c:	teqeq	r5, ip
    b680:	beq.w	b4fa <__aeabi_dmul+0x24a>
    b684:	teq	r4, ip
    b688:	bne.n	b6a0 <__aeabi_ddiv+0x19c>
    b68a:	orrs.w	r4, r0, r1, lsl #12
    b68e:	bne.w	b4fa <__aeabi_dmul+0x24a>
    b692:	teq	r5, ip
    b696:	bne.w	b4e4 <__aeabi_dmul+0x234>
    b69a:	mov	r0, r2
    b69c:	mov	r1, r3
    b69e:	b.n	b4fa <__aeabi_dmul+0x24a>
    b6a0:	teq	r5, ip
    b6a4:	bne.n	b6b4 <__aeabi_ddiv+0x1b0>
    b6a6:	orrs.w	r5, r2, r3, lsl #12
    b6aa:	beq.w	b4a8 <__aeabi_dmul+0x1f8>
    b6ae:	mov	r0, r2
    b6b0:	mov	r1, r3
    b6b2:	b.n	b4fa <__aeabi_dmul+0x24a>
    b6b4:	orrs.w	r6, r0, r1, lsl #1
    b6b8:	it	ne
    b6ba:	orrsne.w	r6, r2, r3, lsl #1
    b6be:	bne.w	b44c <__aeabi_dmul+0x19c>
    b6c2:	orrs.w	r4, r0, r1, lsl #1
    b6c6:	bne.w	b4e4 <__aeabi_dmul+0x234>
    b6ca:	orrs.w	r5, r2, r3, lsl #1
    b6ce:	bne.w	b4a8 <__aeabi_dmul+0x1f8>
    b6d2:	b.n	b4fa <__aeabi_dmul+0x24a>

0000b6d4 <__gedf2>:
    b6d4:	mov.w	ip, #4294967295
    b6d8:	b.n	b6e8 <__cmpdf2+0x4>
    b6da:	nop

0000b6dc <__ledf2>:
    b6dc:	mov.w	ip, #1
    b6e0:	b.n	b6e8 <__cmpdf2+0x4>
    b6e2:	nop

0000b6e4 <__cmpdf2>:
    b6e4:	mov.w	ip, #1
    b6e8:	str.w	ip, [sp, #-4]!
    b6ec:	mov.w	ip, r1, lsl #1
    b6f0:	mvns.w	ip, ip, asr #21
    b6f4:	mov.w	ip, r3, lsl #1
    b6f8:	it	ne
    b6fa:	mvnsne.w	ip, ip, asr #21
    b6fe:	beq.n	b738 <__cmpdf2+0x54>
    b700:	add	sp, #4
    b702:	orrs.w	ip, r0, r1, lsl #1
    b706:	ite	eq
    b708:	orrseq.w	ip, r2, r3, lsl #1
    b70c:	teqne	r1, r3
    b710:	ittt	eq
    b712:	teqeq	r0, r2
    b716:	moveq	r0, #0
    b718:	bxeq	lr
    b71a:	cmn.w	r0, #0
    b71e:	teq	r1, r3
    b722:	it	pl
    b724:	cmppl	r1, r3
    b726:	it	eq
    b728:	cmpeq	r0, r2
    b72a:	ite	cs
    b72c:	asrcs	r0, r3, #31
    b72e:	mvncc.w	r0, r3, asr #31
    b732:	orr.w	r0, r0, #1
    b736:	bx	lr
    b738:	mov.w	ip, r1, lsl #1
    b73c:	mvns.w	ip, ip, asr #21
    b740:	bne.n	b748 <__cmpdf2+0x64>
    b742:	orrs.w	ip, r0, r1, lsl #12
    b746:	bne.n	b758 <__cmpdf2+0x74>
    b748:	mov.w	ip, r3, lsl #1
    b74c:	mvns.w	ip, ip, asr #21
    b750:	bne.n	b700 <__cmpdf2+0x1c>
    b752:	orrs.w	ip, r2, r3, lsl #12
    b756:	beq.n	b700 <__cmpdf2+0x1c>
    b758:	ldr.w	r0, [sp], #4
    b75c:	bx	lr
    b75e:	nop

0000b760 <__aeabi_cdrcmple>:
    b760:	mov	ip, r0
    b762:	mov	r0, r2
    b764:	mov	r2, ip
    b766:	mov	ip, r1
    b768:	mov	r1, r3
    b76a:	mov	r3, ip
    b76c:	b.n	b770 <__aeabi_cdcmpeq>
    b76e:	nop

0000b770 <__aeabi_cdcmpeq>:
    b770:	push	{r0, lr}
    b772:	bl	b6e4 <__cmpdf2>
    b776:	cmp	r0, #0
    b778:	it	mi
    b77a:	cmnmi.w	r0, #0
    b77e:	pop	{r0, pc}

0000b780 <__aeabi_dcmpeq>:
    b780:	str.w	lr, [sp, #-8]!
    b784:	bl	b770 <__aeabi_cdcmpeq>
    b788:	ite	eq
    b78a:	moveq	r0, #1
    b78c:	movne	r0, #0
    b78e:	ldr.w	pc, [sp], #8
    b792:	nop

0000b794 <__aeabi_dcmplt>:
    b794:	str.w	lr, [sp, #-8]!
    b798:	bl	b770 <__aeabi_cdcmpeq>
    b79c:	ite	cc
    b79e:	movcc	r0, #1
    b7a0:	movcs	r0, #0
    b7a2:	ldr.w	pc, [sp], #8
    b7a6:	nop

0000b7a8 <__aeabi_dcmple>:
    b7a8:	str.w	lr, [sp, #-8]!
    b7ac:	bl	b770 <__aeabi_cdcmpeq>
    b7b0:	ite	ls
    b7b2:	movls	r0, #1
    b7b4:	movhi	r0, #0
    b7b6:	ldr.w	pc, [sp], #8
    b7ba:	nop

0000b7bc <__aeabi_dcmpge>:
    b7bc:	str.w	lr, [sp, #-8]!
    b7c0:	bl	b760 <__aeabi_cdrcmple>
    b7c4:	ite	ls
    b7c6:	movls	r0, #1
    b7c8:	movhi	r0, #0
    b7ca:	ldr.w	pc, [sp], #8
    b7ce:	nop

0000b7d0 <__aeabi_dcmpgt>:
    b7d0:	str.w	lr, [sp, #-8]!
    b7d4:	bl	b760 <__aeabi_cdrcmple>
    b7d8:	ite	cc
    b7da:	movcc	r0, #1
    b7dc:	movcs	r0, #0
    b7de:	ldr.w	pc, [sp], #8
    b7e2:	nop

0000b7e4 <__aeabi_dcmpun>:
    b7e4:	mov.w	ip, r1, lsl #1
    b7e8:	mvns.w	ip, ip, asr #21
    b7ec:	bne.n	b7f4 <__aeabi_dcmpun+0x10>
    b7ee:	orrs.w	ip, r0, r1, lsl #12
    b7f2:	bne.n	b80a <__aeabi_dcmpun+0x26>
    b7f4:	mov.w	ip, r3, lsl #1
    b7f8:	mvns.w	ip, ip, asr #21
    b7fc:	bne.n	b804 <__aeabi_dcmpun+0x20>
    b7fe:	orrs.w	ip, r2, r3, lsl #12
    b802:	bne.n	b80a <__aeabi_dcmpun+0x26>
    b804:	mov.w	r0, #0
    b808:	bx	lr
    b80a:	mov.w	r0, #1
    b80e:	bx	lr

0000b810 <__aeabi_d2iz>:
    b810:	mov.w	r2, r1, lsl #1
    b814:	adds.w	r2, r2, #2097152	; 0x200000
    b818:	bcs.n	b846 <__aeabi_d2iz+0x36>
    b81a:	bpl.n	b840 <__aeabi_d2iz+0x30>
    b81c:	mvn.w	r3, #992	; 0x3e0
    b820:	subs.w	r2, r3, r2, asr #21
    b824:	bls.n	b84c <__aeabi_d2iz+0x3c>
    b826:	mov.w	r3, r1, lsl #11
    b82a:	orr.w	r3, r3, #2147483648	; 0x80000000
    b82e:	orr.w	r3, r3, r0, lsr #21
    b832:	tst.w	r1, #2147483648	; 0x80000000
    b836:	lsr.w	r0, r3, r2
    b83a:	it	ne
    b83c:	negne	r0, r0
    b83e:	bx	lr
    b840:	mov.w	r0, #0
    b844:	bx	lr
    b846:	orrs.w	r0, r0, r1, lsl #12
    b84a:	bne.n	b858 <__aeabi_d2iz+0x48>
    b84c:	ands.w	r0, r1, #2147483648	; 0x80000000
    b850:	it	eq
    b852:	mvneq.w	r0, #2147483648	; 0x80000000
    b856:	bx	lr
    b858:	mov.w	r0, #0
    b85c:	bx	lr
    b85e:	nop

0000b860 <__aeabi_d2uiz>:
    b860:	lsls	r2, r1, #1
    b862:	bcs.n	b888 <__aeabi_d2uiz+0x28>
    b864:	adds.w	r2, r2, #2097152	; 0x200000
    b868:	bcs.n	b88e <__aeabi_d2uiz+0x2e>
    b86a:	bpl.n	b888 <__aeabi_d2uiz+0x28>
    b86c:	mvn.w	r3, #992	; 0x3e0
    b870:	subs.w	r2, r3, r2, asr #21
    b874:	bmi.n	b894 <__aeabi_d2uiz+0x34>
    b876:	mov.w	r3, r1, lsl #11
    b87a:	orr.w	r3, r3, #2147483648	; 0x80000000
    b87e:	orr.w	r3, r3, r0, lsr #21
    b882:	lsr.w	r0, r3, r2
    b886:	bx	lr
    b888:	mov.w	r0, #0
    b88c:	bx	lr
    b88e:	orrs.w	r0, r0, r1, lsl #12
    b892:	bne.n	b89a <__aeabi_d2uiz+0x3a>
    b894:	mov.w	r0, #4294967295
    b898:	bx	lr
    b89a:	mov.w	r0, #0
    b89e:	bx	lr

0000b8a0 <__aeabi_d2f>:
    b8a0:	mov.w	r2, r1, lsl #1
    b8a4:	subs.w	r3, r2, #1879048192	; 0x70000000
    b8a8:	itt	cs
    b8aa:	subscs.w	ip, r3, #2097152	; 0x200000
    b8ae:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    b8b2:	bls.n	b8d0 <__aeabi_d2f+0x30>
    b8b4:	and.w	ip, r1, #2147483648	; 0x80000000
    b8b8:	mov.w	r2, r0, lsl #3
    b8bc:	orr.w	r0, ip, r0, lsr #29
    b8c0:	cmp.w	r2, #2147483648	; 0x80000000
    b8c4:	adc.w	r0, r0, r3, lsl #2
    b8c8:	it	eq
    b8ca:	biceq.w	r0, r0, #1
    b8ce:	bx	lr
    b8d0:	tst.w	r1, #1073741824	; 0x40000000
    b8d4:	bne.n	b91a <__aeabi_d2f+0x7a>
    b8d6:	adds.w	r2, r3, #48234496	; 0x2e00000
    b8da:	itt	lt
    b8dc:	andlt.w	r0, r1, #2147483648	; 0x80000000
    b8e0:	bxlt	lr
    b8e2:	orr.w	r1, r1, #1048576	; 0x100000
    b8e6:	mov.w	r2, r2, lsr #21
    b8ea:	rsb	r2, r2, #24
    b8ee:	rsb	ip, r2, #32
    b8f2:	lsls.w	r3, r0, ip
    b8f6:	lsr.w	r0, r0, r2
    b8fa:	it	ne
    b8fc:	orrne.w	r0, r0, #1
    b900:	mov.w	r3, r1, lsl #11
    b904:	mov.w	r3, r3, lsr #11
    b908:	lsl.w	ip, r3, ip
    b90c:	orr.w	r0, r0, ip
    b910:	lsr.w	r3, r3, r2
    b914:	mov.w	r3, r3, lsl #1
    b918:	b.n	b8b4 <__aeabi_d2f+0x14>
    b91a:	mvns.w	r3, r2, asr #21
    b91e:	bne.n	b930 <__aeabi_d2f+0x90>
    b920:	orrs.w	r3, r0, r1, lsl #12
    b924:	ittt	ne
    b926:	movne.w	r0, #2130706432	; 0x7f000000
    b92a:	orrne.w	r0, r0, #12582912	; 0xc00000
    b92e:	bxne	lr
    b930:	and.w	r0, r1, #2147483648	; 0x80000000
    b934:	orr.w	r0, r0, #2130706432	; 0x7f000000
    b938:	orr.w	r0, r0, #8388608	; 0x800000
    b93c:	bx	lr
    b93e:	nop

0000b940 <__aeabi_uldivmod>:
    b940:	cbnz	r3, b958 <__aeabi_uldivmod+0x18>
    b942:	cbnz	r2, b958 <__aeabi_uldivmod+0x18>
    b944:	cmp	r1, #0
    b946:	it	eq
    b948:	cmpeq	r0, #0
    b94a:	itt	ne
    b94c:	movne.w	r1, #4294967295
    b950:	movne.w	r0, #4294967295
    b954:	b.w	bc54 <__aeabi_idiv0>
    b958:	sub.w	ip, sp, #8
    b95c:	strd	ip, lr, [sp, #-16]!
    b960:	bl	b970 <__udivmoddi4>
    b964:	ldr.w	lr, [sp, #4]
    b968:	ldrd	r2, r3, [sp, #8]
    b96c:	add	sp, #16
    b96e:	bx	lr

0000b970 <__udivmoddi4>:
    b970:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b974:	mov	ip, r1
    b976:	mov	r6, r1
    b978:	mov	r4, r0
    b97a:	ldr	r5, [sp, #32]
    b97c:	cmp	r3, #0
    b97e:	bne.n	ba22 <__udivmoddi4+0xb2>
    b980:	cmp	r2, r1
    b982:	mov	r7, r2
    b984:	bls.n	ba60 <__udivmoddi4+0xf0>
    b986:	clz	lr, r2
    b98a:	cmp.w	lr, #0
    b98e:	beq.n	b9a8 <__udivmoddi4+0x38>
    b990:	rsb	r4, lr, #32
    b994:	lsr.w	r4, r0, r4
    b998:	lsl.w	r6, r1, lr
    b99c:	orr.w	ip, r4, r6
    b9a0:	lsl.w	r7, r2, lr
    b9a4:	lsl.w	r4, r0, lr
    b9a8:	mov.w	r9, r7, lsr #16
    b9ac:	lsrs	r2, r4, #16
    b9ae:	udiv	r0, ip, r9
    b9b2:	uxth.w	r8, r7
    b9b6:	mls	r6, r9, r0, ip
    b9ba:	orr.w	r6, r2, r6, lsl #16
    b9be:	mul.w	r3, r0, r8
    b9c2:	cmp	r3, r6
    b9c4:	bls.n	b9da <__udivmoddi4+0x6a>
    b9c6:	adds	r6, r6, r7
    b9c8:	add.w	r2, r0, #4294967295
    b9cc:	bcs.w	bc14 <__udivmoddi4+0x2a4>
    b9d0:	cmp	r3, r6
    b9d2:	bls.w	bc14 <__udivmoddi4+0x2a4>
    b9d6:	subs	r0, #2
    b9d8:	add	r6, r7
    b9da:	subs	r6, r6, r3
    b9dc:	uxth	r2, r4
    b9de:	udiv	r3, r6, r9
    b9e2:	mls	r6, r9, r3, r6
    b9e6:	orr.w	r4, r2, r6, lsl #16
    b9ea:	mul.w	r8, r3, r8
    b9ee:	cmp	r8, r4
    b9f0:	bls.n	ba06 <__udivmoddi4+0x96>
    b9f2:	adds	r4, r4, r7
    b9f4:	add.w	r2, r3, #4294967295
    b9f8:	bcs.w	bc10 <__udivmoddi4+0x2a0>
    b9fc:	cmp	r8, r4
    b9fe:	bls.w	bc10 <__udivmoddi4+0x2a0>
    ba02:	subs	r3, #2
    ba04:	add	r4, r7
    ba06:	rsb	r4, r8, r4
    ba0a:	orr.w	r0, r3, r0, lsl #16
    ba0e:	movs	r1, #0
    ba10:	cmp	r5, #0
    ba12:	beq.n	bada <__udivmoddi4+0x16a>
    ba14:	lsr.w	r4, r4, lr
    ba18:	movs	r3, #0
    ba1a:	str	r4, [r5, #0]
    ba1c:	str	r3, [r5, #4]
    ba1e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ba22:	cmp	r3, r1
    ba24:	bls.n	ba36 <__udivmoddi4+0xc6>
    ba26:	cmp	r5, #0
    ba28:	beq.n	bad6 <__udivmoddi4+0x166>
    ba2a:	movs	r1, #0
    ba2c:	stmia.w	r5, {r0, r6}
    ba30:	mov	r0, r1
    ba32:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ba36:	clz	r1, r3
    ba3a:	cmp	r1, #0
    ba3c:	bne.w	bb60 <__udivmoddi4+0x1f0>
    ba40:	cmp	r3, r6
    ba42:	bcc.n	ba4a <__udivmoddi4+0xda>
    ba44:	cmp	r2, r0
    ba46:	bhi.w	bc3a <__udivmoddi4+0x2ca>
    ba4a:	subs	r4, r0, r2
    ba4c:	sbc.w	r6, r6, r3
    ba50:	movs	r0, #1
    ba52:	mov	ip, r6
    ba54:	cmp	r5, #0
    ba56:	beq.n	bada <__udivmoddi4+0x16a>
    ba58:	stmia.w	r5, {r4, ip}
    ba5c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ba60:	cbnz	r2, ba68 <__udivmoddi4+0xf8>
    ba62:	movs	r7, #1
    ba64:	udiv	r7, r7, r2
    ba68:	clz	lr, r7
    ba6c:	cmp.w	lr, #0
    ba70:	bne.n	bade <__udivmoddi4+0x16e>
    ba72:	subs	r3, r6, r7
    ba74:	mov.w	r8, r7, lsr #16
    ba78:	uxth.w	ip, r7
    ba7c:	movs	r1, #1
    ba7e:	udiv	r0, r3, r8
    ba82:	lsrs	r2, r4, #16
    ba84:	mls	r6, r8, r0, r3
    ba88:	orr.w	r6, r2, r6, lsl #16
    ba8c:	mul.w	r3, ip, r0
    ba90:	cmp	r3, r6
    ba92:	bls.n	baa4 <__udivmoddi4+0x134>
    ba94:	adds	r6, r6, r7
    ba96:	add.w	r2, r0, #4294967295
    ba9a:	bcs.n	baa2 <__udivmoddi4+0x132>
    ba9c:	cmp	r3, r6
    ba9e:	bhi.w	bc3e <__udivmoddi4+0x2ce>
    baa2:	mov	r0, r2
    baa4:	subs	r6, r6, r3
    baa6:	uxth	r2, r4
    baa8:	udiv	r3, r6, r8
    baac:	mls	r6, r8, r3, r6
    bab0:	orr.w	r4, r2, r6, lsl #16
    bab4:	mul.w	ip, ip, r3
    bab8:	cmp	ip, r4
    baba:	bls.n	bacc <__udivmoddi4+0x15c>
    babc:	adds	r4, r4, r7
    babe:	add.w	r2, r3, #4294967295
    bac2:	bcs.n	baca <__udivmoddi4+0x15a>
    bac4:	cmp	ip, r4
    bac6:	bhi.w	bc34 <__udivmoddi4+0x2c4>
    baca:	mov	r3, r2
    bacc:	rsb	r4, ip, r4
    bad0:	orr.w	r0, r3, r0, lsl #16
    bad4:	b.n	ba10 <__udivmoddi4+0xa0>
    bad6:	mov	r1, r5
    bad8:	mov	r0, r5
    bada:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bade:	rsb	r1, lr, #32
    bae2:	lsl.w	r3, r6, lr
    bae6:	lsl.w	r7, r7, lr
    baea:	lsr.w	r9, r0, r1
    baee:	mov.w	r8, r7, lsr #16
    baf2:	lsrs	r6, r1
    baf4:	orr.w	r9, r9, r3
    baf8:	udiv	sl, r6, r8
    bafc:	mov.w	r4, r9, lsr #16
    bb00:	mls	r6, r8, sl, r6
    bb04:	uxth.w	ip, r7
    bb08:	orr.w	r3, r4, r6, lsl #16
    bb0c:	mul.w	r2, sl, ip
    bb10:	cmp	r2, r3
    bb12:	lsl.w	r4, r0, lr
    bb16:	bls.n	bb2e <__udivmoddi4+0x1be>
    bb18:	adds	r3, r3, r7
    bb1a:	add.w	r1, sl, #4294967295
    bb1e:	bcs.w	bc30 <__udivmoddi4+0x2c0>
    bb22:	cmp	r2, r3
    bb24:	bls.w	bc30 <__udivmoddi4+0x2c0>
    bb28:	sub.w	sl, sl, #2
    bb2c:	add	r3, r7
    bb2e:	subs	r3, r3, r2
    bb30:	uxth.w	r9, r9
    bb34:	udiv	r1, r3, r8
    bb38:	mls	r3, r8, r1, r3
    bb3c:	orr.w	r3, r9, r3, lsl #16
    bb40:	mul.w	r6, r1, ip
    bb44:	cmp	r6, r3
    bb46:	bls.n	bb58 <__udivmoddi4+0x1e8>
    bb48:	adds	r3, r3, r7
    bb4a:	add.w	r2, r1, #4294967295
    bb4e:	bcs.n	bc28 <__udivmoddi4+0x2b8>
    bb50:	cmp	r6, r3
    bb52:	bls.n	bc28 <__udivmoddi4+0x2b8>
    bb54:	subs	r1, #2
    bb56:	add	r3, r7
    bb58:	subs	r3, r3, r6
    bb5a:	orr.w	r1, r1, sl, lsl #16
    bb5e:	b.n	ba7e <__udivmoddi4+0x10e>
    bb60:	rsb	lr, r1, #32
    bb64:	lsr.w	r4, r2, lr
    bb68:	lsls	r3, r1
    bb6a:	orrs	r3, r4
    bb6c:	lsr.w	r7, r0, lr
    bb70:	lsl.w	r4, r6, r1
    bb74:	mov.w	ip, r3, lsr #16
    bb78:	lsr.w	r6, r6, lr
    bb7c:	orrs	r4, r7
    bb7e:	udiv	r9, r6, ip
    bb82:	lsrs	r7, r4, #16
    bb84:	mls	r6, ip, r9, r6
    bb88:	uxth.w	r8, r3
    bb8c:	orr.w	r6, r7, r6, lsl #16
    bb90:	mul.w	r7, r9, r8
    bb94:	cmp	r7, r6
    bb96:	lsl.w	r2, r2, r1
    bb9a:	lsl.w	sl, r0, r1
    bb9e:	bls.n	bbb2 <__udivmoddi4+0x242>
    bba0:	adds	r6, r6, r3
    bba2:	add.w	r0, r9, #4294967295
    bba6:	bcs.n	bc2c <__udivmoddi4+0x2bc>
    bba8:	cmp	r7, r6
    bbaa:	bls.n	bc2c <__udivmoddi4+0x2bc>
    bbac:	sub.w	r9, r9, #2
    bbb0:	add	r6, r3
    bbb2:	subs	r6, r6, r7
    bbb4:	uxth	r0, r4
    bbb6:	udiv	r4, r6, ip
    bbba:	mls	r6, ip, r4, r6
    bbbe:	orr.w	r7, r0, r6, lsl #16
    bbc2:	mul.w	r8, r4, r8
    bbc6:	cmp	r8, r7
    bbc8:	bls.n	bbda <__udivmoddi4+0x26a>
    bbca:	adds	r7, r7, r3
    bbcc:	add.w	r0, r4, #4294967295
    bbd0:	bcs.n	bc24 <__udivmoddi4+0x2b4>
    bbd2:	cmp	r8, r7
    bbd4:	bls.n	bc24 <__udivmoddi4+0x2b4>
    bbd6:	subs	r4, #2
    bbd8:	add	r7, r3
    bbda:	orr.w	r0, r4, r9, lsl #16
    bbde:	rsb	r7, r8, r7
    bbe2:	umull	r8, r9, r0, r2
    bbe6:	cmp	r7, r9
    bbe8:	mov	r4, r8
    bbea:	mov	r6, r9
    bbec:	bcc.n	bc18 <__udivmoddi4+0x2a8>
    bbee:	beq.n	bc44 <__udivmoddi4+0x2d4>
    bbf0:	cbz	r5, bc4c <__udivmoddi4+0x2dc>
    bbf2:	subs.w	r3, sl, r4
    bbf6:	sbc.w	r7, r7, r6
    bbfa:	lsl.w	lr, r7, lr
    bbfe:	lsrs	r3, r1
    bc00:	lsrs	r7, r1
    bc02:	orr.w	r3, lr, r3
    bc06:	stmia.w	r5, {r3, r7}
    bc0a:	movs	r1, #0
    bc0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bc10:	mov	r3, r2
    bc12:	b.n	ba06 <__udivmoddi4+0x96>
    bc14:	mov	r0, r2
    bc16:	b.n	b9da <__udivmoddi4+0x6a>
    bc18:	subs.w	r4, r8, r2
    bc1c:	sbc.w	r6, r9, r3
    bc20:	subs	r0, #1
    bc22:	b.n	bbf0 <__udivmoddi4+0x280>
    bc24:	mov	r4, r0
    bc26:	b.n	bbda <__udivmoddi4+0x26a>
    bc28:	mov	r1, r2
    bc2a:	b.n	bb58 <__udivmoddi4+0x1e8>
    bc2c:	mov	r9, r0
    bc2e:	b.n	bbb2 <__udivmoddi4+0x242>
    bc30:	mov	sl, r1
    bc32:	b.n	bb2e <__udivmoddi4+0x1be>
    bc34:	subs	r3, #2
    bc36:	add	r4, r7
    bc38:	b.n	bacc <__udivmoddi4+0x15c>
    bc3a:	mov	r0, r1
    bc3c:	b.n	ba54 <__udivmoddi4+0xe4>
    bc3e:	subs	r0, #2
    bc40:	add	r6, r7
    bc42:	b.n	baa4 <__udivmoddi4+0x134>
    bc44:	cmp	sl, r8
    bc46:	bcc.n	bc18 <__udivmoddi4+0x2a8>
    bc48:	mov	r6, r7
    bc4a:	b.n	bbf0 <__udivmoddi4+0x280>
    bc4c:	mov	r1, r5
    bc4e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bc52:	nop

0000bc54 <__aeabi_idiv0>:
    bc54:	bx	lr
    bc56:	nop

0000bc58 <__cxa_atexit>:
    bc58:	mov	r3, r2
    bc5a:	mov	r2, r1
    bc5c:	mov	r1, r0
    bc5e:	movs	r0, #2
    bc60:	b.w	103a8 <__register_exitproc>

0000bc64 <__errno>:
    bc64:	ldr	r3, [pc, #4]	; (bc6c <__errno+0x8>)
    bc66:	ldr	r0, [r3, #0]
    bc68:	bx	lr
    bc6a:	nop
    bc6c:	.word	0x20013dc8

0000bc70 <__libc_init_array>:
    bc70:	push	{r4, r5, r6, lr}
    bc72:	ldr	r6, [pc, #60]	; (bcb0 <__libc_init_array+0x40>)
    bc74:	ldr	r5, [pc, #60]	; (bcb4 <__libc_init_array+0x44>)
    bc76:	subs	r6, r6, r5
    bc78:	asrs	r6, r6, #2
    bc7a:	it	ne
    bc7c:	movne	r4, #0
    bc7e:	beq.n	bc8c <__libc_init_array+0x1c>
    bc80:	adds	r4, #1
    bc82:	ldr.w	r3, [r5], #4
    bc86:	blx	r3
    bc88:	cmp	r6, r4
    bc8a:	bne.n	bc80 <__libc_init_array+0x10>
    bc8c:	ldr	r6, [pc, #40]	; (bcb8 <__libc_init_array+0x48>)
    bc8e:	ldr	r5, [pc, #44]	; (bcbc <__libc_init_array+0x4c>)
    bc90:	subs	r6, r6, r5
    bc92:	bl	13f04 <_init>
    bc96:	asrs	r6, r6, #2
    bc98:	it	ne
    bc9a:	movne	r4, #0
    bc9c:	beq.n	bcac <__libc_init_array+0x3c>
    bc9e:	adds	r4, #1
    bca0:	ldr.w	r3, [r5], #4
    bca4:	blx	r3
    bca6:	cmp	r6, r4
    bca8:	bne.n	bc9e <__libc_init_array+0x2e>
    bcaa:	pop	{r4, r5, r6, pc}
    bcac:	pop	{r4, r5, r6, pc}
    bcae:	nop
    bcb0:	.word	0x00013f10
    bcb4:	.word	0x00013f10
    bcb8:	.word	0x00013f64
    bcbc:	.word	0x00013f10

0000bcc0 <__get_current_locale>:
    bcc0:	ldr	r2, [pc, #12]	; (bcd0 <__get_current_locale+0x10>)
    bcc2:	ldr	r3, [pc, #16]	; (bcd4 <__get_current_locale+0x14>)
    bcc4:	ldr	r2, [r2, #0]
    bcc6:	ldr	r0, [r2, #52]	; 0x34
    bcc8:	cmp	r0, #0
    bcca:	it	eq
    bccc:	moveq	r0, r3
    bcce:	bx	lr
    bcd0:	.word	0x20013dc8
    bcd4:	.word	0x20013dcc

0000bcd8 <__locale_mb_cur_max>:
    bcd8:	ldr	r3, [pc, #16]	; (bcec <__locale_mb_cur_max+0x14>)
    bcda:	ldr	r2, [pc, #20]	; (bcf0 <__locale_mb_cur_max+0x18>)
    bcdc:	ldr	r3, [r3, #0]
    bcde:	ldr	r3, [r3, #52]	; 0x34
    bce0:	cmp	r3, #0
    bce2:	it	eq
    bce4:	moveq	r3, r2
    bce6:	ldrb.w	r0, [r3, #296]	; 0x128
    bcea:	bx	lr
    bcec:	.word	0x20013dc8
    bcf0:	.word	0x20013dcc

0000bcf4 <__locale_ctype_ptr_l>:
    bcf4:	ldr.w	r0, [r0, #236]	; 0xec
    bcf8:	bx	lr
    bcfa:	nop

0000bcfc <__locale_ctype_ptr>:
    bcfc:	push	{r3, lr}
    bcfe:	ldr	r3, [pc, #12]	; (bd0c <__locale_ctype_ptr+0x10>)
    bd00:	ldr	r0, [r3, #0]
    bd02:	bl	bcc0 <__get_current_locale>
    bd06:	ldr.w	r0, [r0, #236]	; 0xec
    bd0a:	pop	{r3, pc}
    bd0c:	.word	0x20013dc8

0000bd10 <malloc>:
    bd10:	ldr	r3, [pc, #8]	; (bd1c <malloc+0xc>)
    bd12:	mov	r1, r0
    bd14:	ldr	r0, [r3, #0]
    bd16:	b.w	bd30 <_malloc_r>
    bd1a:	nop
    bd1c:	.word	0x20013dc8

0000bd20 <free>:
    bd20:	ldr	r3, [pc, #8]	; (bd2c <free+0xc>)
    bd22:	mov	r1, r0
    bd24:	ldr	r0, [r3, #0]
    bd26:	b.w	11490 <_free_r>
    bd2a:	nop
    bd2c:	.word	0x20013dc8

0000bd30 <_malloc_r>:
    bd30:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bd34:	add.w	r5, r1, #11
    bd38:	cmp	r5, #22
    bd3a:	sub	sp, #12
    bd3c:	mov	r6, r0
    bd3e:	bls.w	be80 <_malloc_r+0x150>
    bd42:	bics.w	r5, r5, #7
    bd46:	bmi.w	bec8 <_malloc_r+0x198>
    bd4a:	cmp	r1, r5
    bd4c:	bhi.w	bec8 <_malloc_r+0x198>
    bd50:	bl	c538 <__malloc_lock>
    bd54:	cmp.w	r5, #504	; 0x1f8
    bd58:	bcc.w	c294 <_malloc_r+0x564>
    bd5c:	lsrs	r3, r5, #9
    bd5e:	beq.w	bed6 <_malloc_r+0x1a6>
    bd62:	cmp	r3, #4
    bd64:	bhi.w	c06e <_malloc_r+0x33e>
    bd68:	lsrs	r0, r5, #6
    bd6a:	add.w	lr, r0, #57	; 0x39
    bd6e:	mov.w	r3, lr, lsl #1
    bd72:	adds	r0, #56	; 0x38
    bd74:	ldr	r7, [pc, #784]	; (c088 <_malloc_r+0x358>)
    bd76:	add.w	r3, r7, r3, lsl #2
    bd7a:	sub.w	r1, r3, #8
    bd7e:	ldr	r4, [r3, #4]
    bd80:	cmp	r1, r4
    bd82:	bne.n	bd94 <_malloc_r+0x64>
    bd84:	b.n	bee0 <_malloc_r+0x1b0>
    bd86:	cmp	r2, #0
    bd88:	bge.w	bee4 <_malloc_r+0x1b4>
    bd8c:	ldr	r4, [r4, #12]
    bd8e:	cmp	r1, r4
    bd90:	beq.w	bee0 <_malloc_r+0x1b0>
    bd94:	ldr	r3, [r4, #4]
    bd96:	bic.w	r3, r3, #3
    bd9a:	subs	r2, r3, r5
    bd9c:	cmp	r2, #15
    bd9e:	ble.n	bd86 <_malloc_r+0x56>
    bda0:	ldr	r1, [pc, #740]	; (c088 <_malloc_r+0x358>)
    bda2:	ldr	r4, [r7, #16]
    bda4:	add.w	lr, r1, #8
    bda8:	cmp	r4, lr
    bdaa:	beq.w	c114 <_malloc_r+0x3e4>
    bdae:	ldr	r3, [r4, #4]
    bdb0:	bic.w	r3, r3, #3
    bdb4:	subs	r2, r3, r5
    bdb6:	cmp	r2, #15
    bdb8:	bgt.w	c0ee <_malloc_r+0x3be>
    bdbc:	cmp	r2, #0
    bdbe:	str.w	lr, [r1, #20]
    bdc2:	str.w	lr, [r1, #16]
    bdc6:	bge.w	bf06 <_malloc_r+0x1d6>
    bdca:	cmp.w	r3, #512	; 0x200
    bdce:	bcs.w	c0a0 <_malloc_r+0x370>
    bdd2:	lsrs	r3, r3, #3
    bdd4:	add.w	ip, r3, #1
    bdd8:	movs	r2, #1
    bdda:	asrs	r3, r3, #2
    bddc:	lsl.w	r3, r2, r3
    bde0:	ldr	r2, [r1, #4]
    bde2:	ldr.w	r8, [r1, ip, lsl #3]
    bde6:	str.w	r8, [r4, #8]
    bdea:	add.w	r9, r1, ip, lsl #3
    bdee:	orrs	r2, r3
    bdf0:	sub.w	r3, r9, #8
    bdf4:	str	r3, [r4, #12]
    bdf6:	str	r2, [r1, #4]
    bdf8:	str.w	r4, [r1, ip, lsl #3]
    bdfc:	str.w	r4, [r8, #12]
    be00:	asrs	r3, r0, #2
    be02:	movs	r4, #1
    be04:	lsls	r4, r3
    be06:	cmp	r4, r2
    be08:	bhi.w	bf20 <_malloc_r+0x1f0>
    be0c:	tst	r4, r2
    be0e:	bne.n	be1e <_malloc_r+0xee>
    be10:	bic.w	r0, r0, #3
    be14:	lsls	r4, r4, #1
    be16:	tst	r4, r2
    be18:	add.w	r0, r0, #4
    be1c:	beq.n	be14 <_malloc_r+0xe4>
    be1e:	add.w	r9, r7, r0, lsl #3
    be22:	mov	ip, r9
    be24:	mov	r8, r0
    be26:	ldr.w	r1, [ip, #12]
    be2a:	cmp	ip, r1
    be2c:	bne.n	be3e <_malloc_r+0x10e>
    be2e:	b.n	c118 <_malloc_r+0x3e8>
    be30:	cmp	r2, #0
    be32:	bge.w	c138 <_malloc_r+0x408>
    be36:	ldr	r1, [r1, #12]
    be38:	cmp	ip, r1
    be3a:	beq.w	c118 <_malloc_r+0x3e8>
    be3e:	ldr	r3, [r1, #4]
    be40:	bic.w	r3, r3, #3
    be44:	subs	r2, r3, r5
    be46:	cmp	r2, #15
    be48:	ble.n	be30 <_malloc_r+0x100>
    be4a:	mov	r4, r1
    be4c:	ldr.w	ip, [r1, #12]
    be50:	ldr.w	r8, [r4, #8]!
    be54:	adds	r3, r1, r5
    be56:	orr.w	r5, r5, #1
    be5a:	str	r5, [r1, #4]
    be5c:	orr.w	r1, r2, #1
    be60:	str.w	ip, [r8, #12]
    be64:	mov	r0, r6
    be66:	str.w	r8, [ip, #8]
    be6a:	str	r3, [r7, #20]
    be6c:	str	r3, [r7, #16]
    be6e:	str.w	lr, [r3, #12]
    be72:	str.w	lr, [r3, #8]
    be76:	str	r1, [r3, #4]
    be78:	str	r2, [r3, r2]
    be7a:	bl	c53c <__malloc_unlock>
    be7e:	b.n	bec0 <_malloc_r+0x190>
    be80:	cmp	r1, #16
    be82:	bhi.n	bec8 <_malloc_r+0x198>
    be84:	bl	c538 <__malloc_lock>
    be88:	movs	r5, #16
    be8a:	movs	r3, #6
    be8c:	movs	r0, #2
    be8e:	ldr	r7, [pc, #504]	; (c088 <_malloc_r+0x358>)
    be90:	add.w	r3, r7, r3, lsl #2
    be94:	sub.w	r2, r3, #8
    be98:	ldr	r4, [r3, #4]
    be9a:	cmp	r4, r2
    be9c:	beq.w	c12a <_malloc_r+0x3fa>
    bea0:	ldr	r3, [r4, #4]
    bea2:	ldr	r1, [r4, #12]
    bea4:	ldr	r5, [r4, #8]
    bea6:	bic.w	r3, r3, #3
    beaa:	add	r3, r4
    beac:	mov	r0, r6
    beae:	ldr	r2, [r3, #4]
    beb0:	str	r1, [r5, #12]
    beb2:	orr.w	r2, r2, #1
    beb6:	str	r5, [r1, #8]
    beb8:	str	r2, [r3, #4]
    beba:	bl	c53c <__malloc_unlock>
    bebe:	adds	r4, #8
    bec0:	mov	r0, r4
    bec2:	add	sp, #12
    bec4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bec8:	movs	r4, #0
    beca:	movs	r3, #12
    becc:	mov	r0, r4
    bece:	str	r3, [r6, #0]
    bed0:	add	sp, #12
    bed2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bed6:	movs	r3, #128	; 0x80
    bed8:	mov.w	lr, #64	; 0x40
    bedc:	movs	r0, #63	; 0x3f
    bede:	b.n	bd74 <_malloc_r+0x44>
    bee0:	mov	r0, lr
    bee2:	b.n	bda0 <_malloc_r+0x70>
    bee4:	add	r3, r4
    bee6:	ldr	r1, [r4, #12]
    bee8:	ldr	r2, [r3, #4]
    beea:	ldr	r5, [r4, #8]
    beec:	orr.w	r2, r2, #1
    bef0:	str	r1, [r5, #12]
    bef2:	mov	r0, r6
    bef4:	str	r5, [r1, #8]
    bef6:	str	r2, [r3, #4]
    bef8:	bl	c53c <__malloc_unlock>
    befc:	adds	r4, #8
    befe:	mov	r0, r4
    bf00:	add	sp, #12
    bf02:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bf06:	add	r3, r4
    bf08:	mov	r0, r6
    bf0a:	ldr	r2, [r3, #4]
    bf0c:	orr.w	r2, r2, #1
    bf10:	str	r2, [r3, #4]
    bf12:	bl	c53c <__malloc_unlock>
    bf16:	adds	r4, #8
    bf18:	mov	r0, r4
    bf1a:	add	sp, #12
    bf1c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bf20:	ldr	r4, [r7, #8]
    bf22:	ldr	r3, [r4, #4]
    bf24:	bic.w	r8, r3, #3
    bf28:	cmp	r8, r5
    bf2a:	bcc.n	bf36 <_malloc_r+0x206>
    bf2c:	rsb	r3, r5, r8
    bf30:	cmp	r3, #15
    bf32:	bgt.w	c04e <_malloc_r+0x31e>
    bf36:	ldr	r3, [pc, #340]	; (c08c <_malloc_r+0x35c>)
    bf38:	ldr.w	r9, [pc, #352]	; c09c <_malloc_r+0x36c>
    bf3c:	ldr	r2, [r3, #0]
    bf3e:	ldr.w	r3, [r9]
    bf42:	adds	r3, #1
    bf44:	add	r2, r5
    bf46:	add.w	sl, r4, r8
    bf4a:	beq.w	c20e <_malloc_r+0x4de>
    bf4e:	add.w	r2, r2, #4096	; 0x1000
    bf52:	adds	r2, #15
    bf54:	bic.w	r2, r2, #4080	; 0xff0
    bf58:	bic.w	r2, r2, #15
    bf5c:	mov	r1, r2
    bf5e:	mov	r0, r6
    bf60:	str	r2, [sp, #4]
    bf62:	bl	c920 <_sbrk_r>
    bf66:	cmp.w	r0, #4294967295
    bf6a:	mov	fp, r0
    bf6c:	ldr	r2, [sp, #4]
    bf6e:	beq.w	c222 <_malloc_r+0x4f2>
    bf72:	cmp	sl, r0
    bf74:	bhi.w	c170 <_malloc_r+0x440>
    bf78:	ldr	r3, [pc, #276]	; (c090 <_malloc_r+0x360>)
    bf7a:	ldr	r1, [r3, #0]
    bf7c:	cmp	sl, fp
    bf7e:	add	r1, r2
    bf80:	str	r1, [r3, #0]
    bf82:	beq.w	c22c <_malloc_r+0x4fc>
    bf86:	ldr.w	r0, [r9]
    bf8a:	ldr.w	lr, [pc, #272]	; c09c <_malloc_r+0x36c>
    bf8e:	adds	r0, #1
    bf90:	ittet	ne
    bf92:	rsbne	sl, sl, fp
    bf96:	addne	r1, sl
    bf98:	streq.w	fp, [lr]
    bf9c:	strne	r1, [r3, #0]
    bf9e:	ands.w	r1, fp, #7
    bfa2:	beq.w	c1d4 <_malloc_r+0x4a4>
    bfa6:	rsb	r0, r1, #8
    bfaa:	rsb	r1, r1, #4096	; 0x1000
    bfae:	add	fp, r0
    bfb0:	adds	r1, #8
    bfb2:	add	r2, fp
    bfb4:	ubfx	r2, r2, #0, #12
    bfb8:	rsb	r9, r2, r1
    bfbc:	mov	r1, r9
    bfbe:	mov	r0, r6
    bfc0:	str	r3, [sp, #4]
    bfc2:	bl	c920 <_sbrk_r>
    bfc6:	adds	r3, r0, #1
    bfc8:	ldr	r3, [sp, #4]
    bfca:	beq.w	c24c <_malloc_r+0x51c>
    bfce:	rsb	r2, fp, r0
    bfd2:	add	r2, r9
    bfd4:	orr.w	r2, r2, #1
    bfd8:	ldr	r1, [r3, #0]
    bfda:	str.w	fp, [r7, #8]
    bfde:	add	r1, r9
    bfe0:	cmp	r4, r7
    bfe2:	str.w	r2, [fp, #4]
    bfe6:	str	r1, [r3, #0]
    bfe8:	ldr.w	r9, [pc, #164]	; c090 <_malloc_r+0x360>
    bfec:	beq.n	c01c <_malloc_r+0x2ec>
    bfee:	cmp.w	r8, #15
    bff2:	bls.w	c1f0 <_malloc_r+0x4c0>
    bff6:	ldr	r2, [r4, #4]
    bff8:	sub.w	r3, r8, #12
    bffc:	bic.w	r3, r3, #7
    c000:	adds	r0, r4, r3
    c002:	and.w	r2, r2, #1
    c006:	mov.w	lr, #5
    c00a:	orrs	r2, r3
    c00c:	cmp	r3, #15
    c00e:	str	r2, [r4, #4]
    c010:	str.w	lr, [r0, #4]
    c014:	str.w	lr, [r0, #8]
    c018:	bhi.w	c254 <_malloc_r+0x524>
    c01c:	ldr	r3, [pc, #116]	; (c094 <_malloc_r+0x364>)
    c01e:	ldr	r4, [r7, #8]
    c020:	ldr	r2, [r3, #0]
    c022:	cmp	r1, r2
    c024:	it	hi
    c026:	strhi	r1, [r3, #0]
    c028:	ldr	r3, [pc, #108]	; (c098 <_malloc_r+0x368>)
    c02a:	ldr	r2, [r3, #0]
    c02c:	cmp	r1, r2
    c02e:	ldr	r2, [r4, #4]
    c030:	it	hi
    c032:	strhi	r1, [r3, #0]
    c034:	bic.w	r2, r2, #3
    c038:	cmp	r5, r2
    c03a:	sub.w	r3, r2, r5
    c03e:	bhi.n	c044 <_malloc_r+0x314>
    c040:	cmp	r3, #15
    c042:	bgt.n	c04e <_malloc_r+0x31e>
    c044:	mov	r0, r6
    c046:	bl	c53c <__malloc_unlock>
    c04a:	movs	r4, #0
    c04c:	b.n	bec0 <_malloc_r+0x190>
    c04e:	adds	r2, r4, r5
    c050:	orr.w	r3, r3, #1
    c054:	orr.w	r5, r5, #1
    c058:	str	r5, [r4, #4]
    c05a:	mov	r0, r6
    c05c:	str	r2, [r7, #8]
    c05e:	str	r3, [r2, #4]
    c060:	bl	c53c <__malloc_unlock>
    c064:	adds	r4, #8
    c066:	mov	r0, r4
    c068:	add	sp, #12
    c06a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c06e:	cmp	r3, #20
    c070:	bls.n	c156 <_malloc_r+0x426>
    c072:	cmp	r3, #84	; 0x54
    c074:	bhi.w	c1c0 <_malloc_r+0x490>
    c078:	lsrs	r0, r5, #12
    c07a:	add.w	lr, r0, #111	; 0x6f
    c07e:	mov.w	r3, lr, lsl #1
    c082:	adds	r0, #110	; 0x6e
    c084:	b.n	bd74 <_malloc_r+0x44>
    c086:	nop
    c088:	.word	0x20013f38
    c08c:	.word	0x20019d74
    c090:	.word	0x20019d78
    c094:	.word	0x20019d70
    c098:	.word	0x20019d6c
    c09c:	.word	0x20014344
    c0a0:	lsrs	r2, r3, #9
    c0a2:	cmp	r2, #4
    c0a4:	bls.n	c164 <_malloc_r+0x434>
    c0a6:	cmp	r2, #20
    c0a8:	bhi.w	c212 <_malloc_r+0x4e2>
    c0ac:	add.w	r1, r2, #92	; 0x5c
    c0b0:	lsls	r1, r1, #1
    c0b2:	adds	r2, #91	; 0x5b
    c0b4:	add.w	ip, r7, r1, lsl #2
    c0b8:	ldr.w	r1, [r7, r1, lsl #2]
    c0bc:	ldr.w	r8, [pc, #476]	; c29c <_malloc_r+0x56c>
    c0c0:	sub.w	ip, ip, #8
    c0c4:	cmp	ip, r1
    c0c6:	beq.w	c1da <_malloc_r+0x4aa>
    c0ca:	ldr	r2, [r1, #4]
    c0cc:	bic.w	r2, r2, #3
    c0d0:	cmp	r3, r2
    c0d2:	bcs.n	c0da <_malloc_r+0x3aa>
    c0d4:	ldr	r1, [r1, #8]
    c0d6:	cmp	ip, r1
    c0d8:	bne.n	c0ca <_malloc_r+0x39a>
    c0da:	ldr.w	ip, [r1, #12]
    c0de:	ldr	r2, [r7, #4]
    c0e0:	str.w	ip, [r4, #12]
    c0e4:	str	r1, [r4, #8]
    c0e6:	str.w	r4, [ip, #8]
    c0ea:	str	r4, [r1, #12]
    c0ec:	b.n	be00 <_malloc_r+0xd0>
    c0ee:	adds	r3, r4, r5
    c0f0:	orr.w	r7, r2, #1
    c0f4:	orr.w	r5, r5, #1
    c0f8:	str	r5, [r4, #4]
    c0fa:	mov	r0, r6
    c0fc:	str	r3, [r1, #20]
    c0fe:	str	r3, [r1, #16]
    c100:	str.w	lr, [r3, #12]
    c104:	str.w	lr, [r3, #8]
    c108:	str	r7, [r3, #4]
    c10a:	str	r2, [r3, r2]
    c10c:	adds	r4, #8
    c10e:	bl	c53c <__malloc_unlock>
    c112:	b.n	bec0 <_malloc_r+0x190>
    c114:	ldr	r2, [r1, #4]
    c116:	b.n	be00 <_malloc_r+0xd0>
    c118:	add.w	r8, r8, #1
    c11c:	tst.w	r8, #3
    c120:	add.w	ip, ip, #8
    c124:	bne.w	be26 <_malloc_r+0xf6>
    c128:	b.n	c18c <_malloc_r+0x45c>
    c12a:	ldr	r4, [r3, #12]
    c12c:	cmp	r3, r4
    c12e:	it	eq
    c130:	addeq	r0, #2
    c132:	beq.w	bda0 <_malloc_r+0x70>
    c136:	b.n	bea0 <_malloc_r+0x170>
    c138:	add	r3, r1
    c13a:	mov	r4, r1
    c13c:	ldr	r2, [r3, #4]
    c13e:	ldr	r1, [r1, #12]
    c140:	ldr.w	r5, [r4, #8]!
    c144:	orr.w	r2, r2, #1
    c148:	str	r2, [r3, #4]
    c14a:	mov	r0, r6
    c14c:	str	r1, [r5, #12]
    c14e:	str	r5, [r1, #8]
    c150:	bl	c53c <__malloc_unlock>
    c154:	b.n	bec0 <_malloc_r+0x190>
    c156:	add.w	lr, r3, #92	; 0x5c
    c15a:	add.w	r0, r3, #91	; 0x5b
    c15e:	mov.w	r3, lr, lsl #1
    c162:	b.n	bd74 <_malloc_r+0x44>
    c164:	lsrs	r2, r3, #6
    c166:	add.w	r1, r2, #57	; 0x39
    c16a:	lsls	r1, r1, #1
    c16c:	adds	r2, #56	; 0x38
    c16e:	b.n	c0b4 <_malloc_r+0x384>
    c170:	cmp	r4, r7
    c172:	ldr	r3, [pc, #296]	; (c29c <_malloc_r+0x56c>)
    c174:	beq.w	bf78 <_malloc_r+0x248>
    c178:	ldr	r4, [r3, #8]
    c17a:	ldr	r2, [r4, #4]
    c17c:	bic.w	r2, r2, #3
    c180:	b.n	c038 <_malloc_r+0x308>
    c182:	ldr.w	r3, [r9], #-8
    c186:	cmp	r9, r3
    c188:	bne.w	c290 <_malloc_r+0x560>
    c18c:	tst.w	r0, #3
    c190:	add.w	r0, r0, #4294967295
    c194:	bne.n	c182 <_malloc_r+0x452>
    c196:	ldr	r3, [r7, #4]
    c198:	bic.w	r3, r3, r4
    c19c:	str	r3, [r7, #4]
    c19e:	lsls	r4, r4, #1
    c1a0:	cmp	r4, r3
    c1a2:	bhi.w	bf20 <_malloc_r+0x1f0>
    c1a6:	cmp	r4, #0
    c1a8:	beq.w	bf20 <_malloc_r+0x1f0>
    c1ac:	tst	r4, r3
    c1ae:	mov	r0, r8
    c1b0:	bne.w	be1e <_malloc_r+0xee>
    c1b4:	lsls	r4, r4, #1
    c1b6:	tst	r4, r3
    c1b8:	add.w	r0, r0, #4
    c1bc:	beq.n	c1b4 <_malloc_r+0x484>
    c1be:	b.n	be1e <_malloc_r+0xee>
    c1c0:	cmp.w	r3, #340	; 0x154
    c1c4:	bhi.n	c1f8 <_malloc_r+0x4c8>
    c1c6:	lsrs	r0, r5, #15
    c1c8:	add.w	lr, r0, #120	; 0x78
    c1cc:	mov.w	r3, lr, lsl #1
    c1d0:	adds	r0, #119	; 0x77
    c1d2:	b.n	bd74 <_malloc_r+0x44>
    c1d4:	mov.w	r1, #4096	; 0x1000
    c1d8:	b.n	bfb2 <_malloc_r+0x282>
    c1da:	movs	r1, #1
    c1dc:	ldr.w	r3, [r8, #4]
    c1e0:	asrs	r2, r2, #2
    c1e2:	lsl.w	r2, r1, r2
    c1e6:	orrs	r2, r3
    c1e8:	str.w	r2, [r8, #4]
    c1ec:	mov	r1, ip
    c1ee:	b.n	c0e0 <_malloc_r+0x3b0>
    c1f0:	movs	r3, #1
    c1f2:	str.w	r3, [fp, #4]
    c1f6:	b.n	c044 <_malloc_r+0x314>
    c1f8:	movw	r2, #1364	; 0x554
    c1fc:	cmp	r3, r2
    c1fe:	bhi.n	c242 <_malloc_r+0x512>
    c200:	lsrs	r0, r5, #18
    c202:	add.w	lr, r0, #125	; 0x7d
    c206:	mov.w	r3, lr, lsl #1
    c20a:	adds	r0, #124	; 0x7c
    c20c:	b.n	bd74 <_malloc_r+0x44>
    c20e:	adds	r2, #16
    c210:	b.n	bf5c <_malloc_r+0x22c>
    c212:	cmp	r2, #84	; 0x54
    c214:	bhi.n	c264 <_malloc_r+0x534>
    c216:	lsrs	r2, r3, #12
    c218:	add.w	r1, r2, #111	; 0x6f
    c21c:	lsls	r1, r1, #1
    c21e:	adds	r2, #110	; 0x6e
    c220:	b.n	c0b4 <_malloc_r+0x384>
    c222:	ldr	r4, [r7, #8]
    c224:	ldr	r2, [r4, #4]
    c226:	bic.w	r2, r2, #3
    c22a:	b.n	c038 <_malloc_r+0x308>
    c22c:	ubfx	r0, sl, #0, #12
    c230:	cmp	r0, #0
    c232:	bne.w	bf86 <_malloc_r+0x256>
    c236:	add	r2, r8
    c238:	ldr	r3, [r7, #8]
    c23a:	orr.w	r2, r2, #1
    c23e:	str	r2, [r3, #4]
    c240:	b.n	c01c <_malloc_r+0x2ec>
    c242:	movs	r3, #254	; 0xfe
    c244:	mov.w	lr, #127	; 0x7f
    c248:	movs	r0, #126	; 0x7e
    c24a:	b.n	bd74 <_malloc_r+0x44>
    c24c:	movs	r2, #1
    c24e:	mov.w	r9, #0
    c252:	b.n	bfd8 <_malloc_r+0x2a8>
    c254:	add.w	r1, r4, #8
    c258:	mov	r0, r6
    c25a:	bl	11490 <_free_r>
    c25e:	ldr.w	r1, [r9]
    c262:	b.n	c01c <_malloc_r+0x2ec>
    c264:	cmp.w	r2, #340	; 0x154
    c268:	bhi.n	c276 <_malloc_r+0x546>
    c26a:	lsrs	r2, r3, #15
    c26c:	add.w	r1, r2, #120	; 0x78
    c270:	lsls	r1, r1, #1
    c272:	adds	r2, #119	; 0x77
    c274:	b.n	c0b4 <_malloc_r+0x384>
    c276:	movw	r1, #1364	; 0x554
    c27a:	cmp	r2, r1
    c27c:	bhi.n	c28a <_malloc_r+0x55a>
    c27e:	lsrs	r2, r3, #18
    c280:	add.w	r1, r2, #125	; 0x7d
    c284:	lsls	r1, r1, #1
    c286:	adds	r2, #124	; 0x7c
    c288:	b.n	c0b4 <_malloc_r+0x384>
    c28a:	movs	r1, #254	; 0xfe
    c28c:	movs	r2, #126	; 0x7e
    c28e:	b.n	c0b4 <_malloc_r+0x384>
    c290:	ldr	r3, [r7, #4]
    c292:	b.n	c19e <_malloc_r+0x46e>
    c294:	lsrs	r0, r5, #3
    c296:	adds	r3, r0, #1
    c298:	lsls	r3, r3, #1
    c29a:	b.n	be8e <_malloc_r+0x15e>
    c29c:	.word	0x20013f38

0000c2a0 <__ascii_mbtowc>:
    c2a0:	sub	sp, #8
    c2a2:	cbz	r1, c2b8 <__ascii_mbtowc+0x18>
    c2a4:	cbz	r2, c2be <__ascii_mbtowc+0x1e>
    c2a6:	cbz	r3, c2c4 <__ascii_mbtowc+0x24>
    c2a8:	ldrb	r3, [r2, #0]
    c2aa:	str	r3, [r1, #0]
    c2ac:	ldrb	r2, [r2, #0]
    c2ae:	adds	r0, r2, #0
    c2b0:	it	ne
    c2b2:	movne	r0, #1
    c2b4:	add	sp, #8
    c2b6:	bx	lr
    c2b8:	add	r1, sp, #4
    c2ba:	cmp	r2, #0
    c2bc:	bne.n	c2a6 <__ascii_mbtowc+0x6>
    c2be:	mov	r0, r2
    c2c0:	add	sp, #8
    c2c2:	bx	lr
    c2c4:	mvn.w	r0, #1
    c2c8:	b.n	c2b4 <__ascii_mbtowc+0x14>
    c2ca:	nop
    c2cc:			; <UNDEFINED> instruction: 0xffffffff

0000c2d0 <memchr>:
    c2d0:	and.w	r1, r1, #255	; 0xff
    c2d4:	cmp	r2, #16
    c2d6:	blt.n	c330 <memchr+0x60>
    c2d8:	tst.w	r0, #7
    c2dc:	beq.n	c2f0 <memchr+0x20>
    c2de:	ldrb.w	r3, [r0], #1
    c2e2:	subs	r2, #1
    c2e4:	cmp	r3, r1
    c2e6:	beq.n	c344 <memchr+0x74>
    c2e8:	tst.w	r0, #7
    c2ec:	cbz	r2, c340 <memchr+0x70>
    c2ee:	bne.n	c2de <memchr+0xe>
    c2f0:	push	{r4, r5, r6, r7}
    c2f2:	orr.w	r1, r1, r1, lsl #8
    c2f6:	orr.w	r1, r1, r1, lsl #16
    c2fa:	bic.w	r4, r2, #7
    c2fe:	mvns.w	r7, #0
    c302:	movs	r3, #0
    c304:	ldrd	r5, r6, [r0], #8
    c308:	subs	r4, #8
    c30a:	eor.w	r5, r5, r1
    c30e:	eor.w	r6, r6, r1
    c312:	uadd8	r5, r5, r7
    c316:	sel	r5, r3, r7
    c31a:	uadd8	r6, r6, r7
    c31e:	sel	r6, r5, r7
    c322:	cbnz	r6, c348 <memchr+0x78>
    c324:	bne.n	c304 <memchr+0x34>
    c326:	pop	{r4, r5, r6, r7}
    c328:	and.w	r1, r1, #255	; 0xff
    c32c:	and.w	r2, r2, #7
    c330:	cbz	r2, c340 <memchr+0x70>
    c332:	ldrb.w	r3, [r0], #1
    c336:	subs	r2, #1
    c338:	eor.w	r3, r3, r1
    c33c:	cbz	r3, c344 <memchr+0x74>
    c33e:	bne.n	c332 <memchr+0x62>
    c340:	movs	r0, #0
    c342:	bx	lr
    c344:	subs	r0, #1
    c346:	bx	lr
    c348:	cmp	r5, #0
    c34a:	itte	eq
    c34c:	moveq	r5, r6
    c34e:	subeq	r0, #3
    c350:	subne	r0, #7
    c352:	tst.w	r5, #1
    c356:	bne.n	c368 <memchr+0x98>
    c358:	adds	r0, #1
    c35a:	tst.w	r5, #256	; 0x100
    c35e:	ittt	eq
    c360:	addeq	r0, #1
    c362:	tsteq.w	r5, #98304	; 0x18000
    c366:	addeq	r0, #1
    c368:	pop	{r4, r5, r6, r7}
    c36a:	subs	r0, #1
    c36c:	bx	lr
    c36e:	nop

0000c370 <memcmp>:
    c370:	cmp	r2, #3
    c372:	push	{r4, r5, r6}
    c374:	bls.n	c3c4 <memcmp+0x54>
    c376:	orr.w	r3, r0, r1
    c37a:	lsls	r3, r3, #30
    c37c:	beq.n	c3a2 <memcmp+0x32>
    c37e:	ldrb	r4, [r0, #0]
    c380:	ldrb	r5, [r1, #0]
    c382:	cmp	r4, r5
    c384:	bne.n	c3cc <memcmp+0x5c>
    c386:	add	r2, r0
    c388:	adds	r3, r0, #1
    c38a:	b.n	c398 <memcmp+0x28>
    c38c:	ldrb.w	r4, [r3], #1
    c390:	ldrb.w	r5, [r1, #1]!
    c394:	cmp	r4, r5
    c396:	bne.n	c3cc <memcmp+0x5c>
    c398:	cmp	r3, r2
    c39a:	bne.n	c38c <memcmp+0x1c>
    c39c:	movs	r0, #0
    c39e:	pop	{r4, r5, r6}
    c3a0:	bx	lr
    c3a2:	mov	r4, r1
    c3a4:	mov	r3, r0
    c3a6:	ldr	r6, [r3, #0]
    c3a8:	ldr	r5, [r4, #0]
    c3aa:	cmp	r6, r5
    c3ac:	mov	r0, r3
    c3ae:	mov	r1, r4
    c3b0:	add.w	r3, r3, #4
    c3b4:	add.w	r4, r4, #4
    c3b8:	bne.n	c37e <memcmp+0xe>
    c3ba:	subs	r2, #4
    c3bc:	cmp	r2, #3
    c3be:	mov	r0, r3
    c3c0:	mov	r1, r4
    c3c2:	bhi.n	c3a6 <memcmp+0x36>
    c3c4:	cmp	r2, #0
    c3c6:	bne.n	c37e <memcmp+0xe>
    c3c8:	mov	r0, r2
    c3ca:	b.n	c39e <memcmp+0x2e>
    c3cc:	subs	r0, r4, r5
    c3ce:	pop	{r4, r5, r6}
    c3d0:	bx	lr
    c3d2:	nop

0000c3d4 <memmove>:
    c3d4:	cmp	r0, r1
    c3d6:	push	{r4, r5, r6, r7, lr}
    c3d8:	bls.n	c3f6 <memmove+0x22>
    c3da:	adds	r3, r1, r2
    c3dc:	cmp	r0, r3
    c3de:	bcs.n	c3f6 <memmove+0x22>
    c3e0:	adds	r1, r0, r2
    c3e2:	cmp	r2, #0
    c3e4:	beq.n	c48a <memmove+0xb6>
    c3e6:	subs	r2, r3, r2
    c3e8:	ldrb.w	r4, [r3, #-1]!
    c3ec:	strb.w	r4, [r1, #-1]!
    c3f0:	cmp	r3, r2
    c3f2:	bne.n	c3e8 <memmove+0x14>
    c3f4:	pop	{r4, r5, r6, r7, pc}
    c3f6:	cmp	r2, #15
    c3f8:	bls.n	c48c <memmove+0xb8>
    c3fa:	orr.w	r3, r1, r0
    c3fe:	lsls	r3, r3, #30
    c400:	bne.n	c490 <memmove+0xbc>
    c402:	add.w	r4, r0, #16
    c406:	add.w	r3, r1, #16
    c40a:	mov	r5, r2
    c40c:	ldr.w	r6, [r3, #-16]
    c410:	str.w	r6, [r4, #-16]
    c414:	ldr.w	r6, [r3, #-12]
    c418:	str.w	r6, [r4, #-12]
    c41c:	ldr.w	r6, [r3, #-8]
    c420:	str.w	r6, [r4, #-8]
    c424:	subs	r5, #16
    c426:	ldr.w	r6, [r3, #-4]
    c42a:	str.w	r6, [r4, #-4]
    c42e:	cmp	r5, #15
    c430:	add.w	r3, r3, #16
    c434:	add.w	r4, r4, #16
    c438:	bhi.n	c40c <memmove+0x38>
    c43a:	sub.w	r3, r2, #16
    c43e:	bic.w	r3, r3, #15
    c442:	and.w	lr, r2, #15
    c446:	adds	r3, #16
    c448:	cmp.w	lr, #3
    c44c:	add	r1, r3
    c44e:	add	r3, r0
    c450:	bls.n	c496 <memmove+0xc2>
    c452:	subs	r6, r3, #4
    c454:	mov	r5, r1
    c456:	mov	r4, lr
    c458:	subs	r4, #4
    c45a:	ldr.w	r7, [r5], #4
    c45e:	str.w	r7, [r6, #4]!
    c462:	cmp	r4, #3
    c464:	bhi.n	c458 <memmove+0x84>
    c466:	sub.w	r4, lr, #4
    c46a:	bic.w	r4, r4, #3
    c46e:	adds	r4, #4
    c470:	add	r3, r4
    c472:	add	r1, r4
    c474:	and.w	r2, r2, #3
    c478:	cbz	r2, c494 <memmove+0xc0>
    c47a:	subs	r3, #1
    c47c:	add	r2, r1
    c47e:	ldrb.w	r4, [r1], #1
    c482:	strb.w	r4, [r3, #1]!
    c486:	cmp	r2, r1
    c488:	bne.n	c47e <memmove+0xaa>
    c48a:	pop	{r4, r5, r6, r7, pc}
    c48c:	mov	r3, r0
    c48e:	b.n	c478 <memmove+0xa4>
    c490:	mov	r3, r0
    c492:	b.n	c47a <memmove+0xa6>
    c494:	pop	{r4, r5, r6, r7, pc}
    c496:	mov	r2, lr
    c498:	b.n	c478 <memmove+0xa4>
    c49a:	nop

0000c49c <memset>:
    c49c:	push	{r4, r5, r6}
    c49e:	lsls	r4, r0, #30
    c4a0:	beq.n	c530 <memset+0x94>
    c4a2:	subs	r4, r2, #1
    c4a4:	cmp	r2, #0
    c4a6:	beq.n	c52c <memset+0x90>
    c4a8:	uxtb	r5, r1
    c4aa:	mov	r3, r0
    c4ac:	b.n	c4b4 <memset+0x18>
    c4ae:	subs	r2, r4, #1
    c4b0:	cbz	r4, c52c <memset+0x90>
    c4b2:	mov	r4, r2
    c4b4:	strb.w	r5, [r3], #1
    c4b8:	lsls	r2, r3, #30
    c4ba:	bne.n	c4ae <memset+0x12>
    c4bc:	cmp	r4, #3
    c4be:	bls.n	c51e <memset+0x82>
    c4c0:	uxtb	r5, r1
    c4c2:	orr.w	r5, r5, r5, lsl #8
    c4c6:	cmp	r4, #15
    c4c8:	orr.w	r5, r5, r5, lsl #16
    c4cc:	bls.n	c502 <memset+0x66>
    c4ce:	add.w	r2, r3, #16
    c4d2:	mov	r6, r4
    c4d4:	subs	r6, #16
    c4d6:	cmp	r6, #15
    c4d8:	str.w	r5, [r2, #-16]
    c4dc:	str.w	r5, [r2, #-12]
    c4e0:	str.w	r5, [r2, #-8]
    c4e4:	str.w	r5, [r2, #-4]
    c4e8:	add.w	r2, r2, #16
    c4ec:	bhi.n	c4d4 <memset+0x38>
    c4ee:	sub.w	r2, r4, #16
    c4f2:	bic.w	r2, r2, #15
    c4f6:	and.w	r4, r4, #15
    c4fa:	adds	r2, #16
    c4fc:	cmp	r4, #3
    c4fe:	add	r3, r2
    c500:	bls.n	c51e <memset+0x82>
    c502:	mov	r6, r3
    c504:	mov	r2, r4
    c506:	subs	r2, #4
    c508:	cmp	r2, #3
    c50a:	str.w	r5, [r6], #4
    c50e:	bhi.n	c506 <memset+0x6a>
    c510:	subs	r2, r4, #4
    c512:	bic.w	r2, r2, #3
    c516:	adds	r2, #4
    c518:	add	r3, r2
    c51a:	and.w	r4, r4, #3
    c51e:	cbz	r4, c52c <memset+0x90>
    c520:	uxtb	r1, r1
    c522:	add	r4, r3
    c524:	strb.w	r1, [r3], #1
    c528:	cmp	r3, r4
    c52a:	bne.n	c524 <memset+0x88>
    c52c:	pop	{r4, r5, r6}
    c52e:	bx	lr
    c530:	mov	r4, r2
    c532:	mov	r3, r0
    c534:	b.n	c4bc <memset+0x20>
    c536:	nop

0000c538 <__malloc_lock>:
    c538:	bx	lr
    c53a:	nop

0000c53c <__malloc_unlock>:
    c53c:	bx	lr
    c53e:	nop

0000c540 <_realloc_r>:
    c540:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c544:	mov	r7, r2
    c546:	sub	sp, #12
    c548:	cmp	r1, #0
    c54a:	beq.w	c6d0 <_realloc_r+0x190>
    c54e:	mov	r6, r1
    c550:	mov	r9, r0
    c552:	add.w	r5, r7, #11
    c556:	bl	c538 <__malloc_lock>
    c55a:	ldr.w	lr, [r6, #-4]
    c55e:	cmp	r5, #22
    c560:	bic.w	r4, lr, #3
    c564:	sub.w	r8, r6, #8
    c568:	bhi.n	c5ec <_realloc_r+0xac>
    c56a:	movs	r2, #16
    c56c:	mov	r5, r2
    c56e:	cmp	r7, r5
    c570:	bhi.n	c5f6 <_realloc_r+0xb6>
    c572:	cmp	r4, r2
    c574:	bge.n	c662 <_realloc_r+0x122>
    c576:	ldr	r3, [pc, #804]	; (c89c <_realloc_r+0x35c>)
    c578:	ldr	r1, [r3, #8]
    c57a:	add.w	r0, r8, r4
    c57e:	cmp	r0, r1
    c580:	ldr	r1, [r0, #4]
    c582:	beq.w	c738 <_realloc_r+0x1f8>
    c586:	bic.w	r3, r1, #1
    c58a:	add	r3, r0
    c58c:	ldr	r3, [r3, #4]
    c58e:	lsls	r3, r3, #31
    c590:	bpl.n	c68e <_realloc_r+0x14e>
    c592:	tst.w	lr, #1
    c596:	beq.n	c604 <_realloc_r+0xc4>
    c598:	mov	r1, r7
    c59a:	mov	r0, r9
    c59c:	bl	bd30 <_malloc_r>
    c5a0:	mov	r7, r0
    c5a2:	cbz	r0, c5de <_realloc_r+0x9e>
    c5a4:	ldr.w	r3, [r6, #-4]
    c5a8:	bic.w	r3, r3, #1
    c5ac:	add	r3, r8
    c5ae:	sub.w	r2, r0, #8
    c5b2:	cmp	r2, r3
    c5b4:	beq.w	c840 <_realloc_r+0x300>
    c5b8:	subs	r2, r4, #4
    c5ba:	cmp	r2, #36	; 0x24
    c5bc:	bhi.w	c822 <_realloc_r+0x2e2>
    c5c0:	cmp	r2, #19
    c5c2:	bhi.w	c7ce <_realloc_r+0x28e>
    c5c6:	mov	r3, r0
    c5c8:	mov	r2, r6
    c5ca:	ldr	r1, [r2, #0]
    c5cc:	str	r1, [r3, #0]
    c5ce:	ldr	r1, [r2, #4]
    c5d0:	str	r1, [r3, #4]
    c5d2:	ldr	r2, [r2, #8]
    c5d4:	str	r2, [r3, #8]
    c5d6:	mov	r1, r6
    c5d8:	mov	r0, r9
    c5da:	bl	11490 <_free_r>
    c5de:	mov	r0, r9
    c5e0:	bl	c53c <__malloc_unlock>
    c5e4:	mov	r0, r7
    c5e6:	add	sp, #12
    c5e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c5ec:	bic.w	r5, r5, #7
    c5f0:	cmp	r5, #0
    c5f2:	mov	r2, r5
    c5f4:	bge.n	c56e <_realloc_r+0x2e>
    c5f6:	movs	r3, #12
    c5f8:	movs	r0, #0
    c5fa:	str.w	r3, [r9]
    c5fe:	add	sp, #12
    c600:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c604:	ldr.w	r3, [r6, #-8]
    c608:	rsb	sl, r3, r8
    c60c:	ldr.w	r3, [sl, #4]
    c610:	bic.w	ip, r3, #3
    c614:	add.w	r3, r4, ip
    c618:	cmp	r3, r2
    c61a:	blt.n	c598 <_realloc_r+0x58>
    c61c:	mov	r7, sl
    c61e:	ldr.w	r1, [sl, #12]
    c622:	ldr.w	r0, [r7, #8]!
    c626:	subs	r2, r4, #4
    c628:	cmp	r2, #36	; 0x24
    c62a:	str	r1, [r0, #12]
    c62c:	str	r0, [r1, #8]
    c62e:	bhi.w	c860 <_realloc_r+0x320>
    c632:	cmp	r2, #19
    c634:	bls.w	c85c <_realloc_r+0x31c>
    c638:	ldr	r1, [r6, #0]
    c63a:	str.w	r1, [sl, #8]
    c63e:	ldr	r1, [r6, #4]
    c640:	str.w	r1, [sl, #12]
    c644:	cmp	r2, #27
    c646:	bhi.w	c8a0 <_realloc_r+0x360>
    c64a:	adds	r6, #8
    c64c:	add.w	r2, sl, #16
    c650:	ldr	r1, [r6, #0]
    c652:	str	r1, [r2, #0]
    c654:	ldr	r1, [r6, #4]
    c656:	str	r1, [r2, #4]
    c658:	ldr	r1, [r6, #8]
    c65a:	str	r1, [r2, #8]
    c65c:	mov	r6, r7
    c65e:	mov	r4, r3
    c660:	mov	r8, sl
    c662:	subs	r3, r4, r5
    c664:	cmp	r3, #15
    c666:	bhi.n	c6a4 <_realloc_r+0x164>
    c668:	ldr.w	r3, [r8, #4]
    c66c:	and.w	r3, r3, #1
    c670:	orrs	r3, r4
    c672:	add	r4, r8
    c674:	str.w	r3, [r8, #4]
    c678:	ldr	r3, [r4, #4]
    c67a:	orr.w	r3, r3, #1
    c67e:	str	r3, [r4, #4]
    c680:	mov	r0, r9
    c682:	bl	c53c <__malloc_unlock>
    c686:	mov	r0, r6
    c688:	add	sp, #12
    c68a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c68e:	bic.w	r1, r1, #3
    c692:	add	r1, r4
    c694:	cmp	r1, r2
    c696:	blt.n	c6dc <_realloc_r+0x19c>
    c698:	ldr	r3, [r0, #12]
    c69a:	ldr	r2, [r0, #8]
    c69c:	mov	r4, r1
    c69e:	str	r3, [r2, #12]
    c6a0:	str	r2, [r3, #8]
    c6a2:	b.n	c662 <_realloc_r+0x122>
    c6a4:	ldr.w	r2, [r8, #4]
    c6a8:	add.w	r1, r8, r5
    c6ac:	and.w	r2, r2, #1
    c6b0:	orrs	r5, r2
    c6b2:	orr.w	r2, r3, #1
    c6b6:	add	r3, r1
    c6b8:	str.w	r5, [r8, #4]
    c6bc:	str	r2, [r1, #4]
    c6be:	ldr	r2, [r3, #4]
    c6c0:	orr.w	r2, r2, #1
    c6c4:	adds	r1, #8
    c6c6:	str	r2, [r3, #4]
    c6c8:	mov	r0, r9
    c6ca:	bl	11490 <_free_r>
    c6ce:	b.n	c680 <_realloc_r+0x140>
    c6d0:	mov	r1, r2
    c6d2:	add	sp, #12
    c6d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c6d8:	b.w	bd30 <_malloc_r>
    c6dc:	tst.w	lr, #1
    c6e0:	bne.w	c598 <_realloc_r+0x58>
    c6e4:	ldr.w	r3, [r6, #-8]
    c6e8:	rsb	sl, r3, r8
    c6ec:	ldr.w	r3, [sl, #4]
    c6f0:	bic.w	ip, r3, #3
    c6f4:	add.w	lr, r1, ip
    c6f8:	cmp	lr, r2
    c6fa:	blt.n	c614 <_realloc_r+0xd4>
    c6fc:	ldr	r3, [r0, #12]
    c6fe:	ldr	r2, [r0, #8]
    c700:	mov	r7, sl
    c702:	str	r3, [r2, #12]
    c704:	str	r2, [r3, #8]
    c706:	ldr.w	r1, [r7, #8]!
    c70a:	ldr.w	r3, [sl, #12]
    c70e:	str	r3, [r1, #12]
    c710:	subs	r2, r4, #4
    c712:	cmp	r2, #36	; 0x24
    c714:	str	r1, [r3, #8]
    c716:	bhi.w	c84c <_realloc_r+0x30c>
    c71a:	cmp	r2, #19
    c71c:	bls.n	c7e4 <_realloc_r+0x2a4>
    c71e:	ldr	r3, [r6, #0]
    c720:	str.w	r3, [sl, #8]
    c724:	ldr	r3, [r6, #4]
    c726:	str.w	r3, [sl, #12]
    c72a:	cmp	r2, #27
    c72c:	bhi.w	c870 <_realloc_r+0x330>
    c730:	adds	r6, #8
    c732:	add.w	r3, sl, #16
    c736:	b.n	c7e6 <_realloc_r+0x2a6>
    c738:	bic.w	fp, r1, #3
    c73c:	add	fp, r4
    c73e:	add.w	r0, r5, #16
    c742:	cmp	fp, r0
    c744:	bge.n	c7fa <_realloc_r+0x2ba>
    c746:	tst.w	lr, #1
    c74a:	bne.w	c598 <_realloc_r+0x58>
    c74e:	ldr.w	r1, [r6, #-8]
    c752:	rsb	sl, r1, r8
    c756:	ldr.w	r1, [sl, #4]
    c75a:	bic.w	ip, r1, #3
    c75e:	add	fp, ip
    c760:	cmp	r0, fp
    c762:	bgt.w	c614 <_realloc_r+0xd4>
    c766:	mov	r7, sl
    c768:	ldr.w	r1, [sl, #12]
    c76c:	ldr.w	r0, [r7, #8]!
    c770:	subs	r2, r4, #4
    c772:	cmp	r2, #36	; 0x24
    c774:	str	r1, [r0, #12]
    c776:	str	r0, [r1, #8]
    c778:	bhi.w	c8e4 <_realloc_r+0x3a4>
    c77c:	cmp	r2, #19
    c77e:	bls.w	c8cc <_realloc_r+0x38c>
    c782:	ldr	r1, [r6, #0]
    c784:	str.w	r1, [sl, #8]
    c788:	ldr	r1, [r6, #4]
    c78a:	str.w	r1, [sl, #12]
    c78e:	cmp	r2, #27
    c790:	bhi.w	c8f2 <_realloc_r+0x3b2>
    c794:	adds	r6, #8
    c796:	add.w	r2, sl, #16
    c79a:	ldr	r1, [r6, #0]
    c79c:	str	r1, [r2, #0]
    c79e:	ldr	r1, [r6, #4]
    c7a0:	str	r1, [r2, #4]
    c7a2:	ldr	r1, [r6, #8]
    c7a4:	str	r1, [r2, #8]
    c7a6:	add.w	r1, sl, r5
    c7aa:	rsb	r2, r5, fp
    c7ae:	orr.w	r2, r2, #1
    c7b2:	str	r1, [r3, #8]
    c7b4:	str	r2, [r1, #4]
    c7b6:	ldr.w	r3, [sl, #4]
    c7ba:	and.w	r3, r3, #1
    c7be:	orrs	r5, r3
    c7c0:	mov	r0, r9
    c7c2:	str.w	r5, [sl, #4]
    c7c6:	bl	c53c <__malloc_unlock>
    c7ca:	mov	r0, r7
    c7cc:	b.n	c688 <_realloc_r+0x148>
    c7ce:	ldr	r3, [r6, #0]
    c7d0:	str	r3, [r0, #0]
    c7d2:	ldr	r3, [r6, #4]
    c7d4:	str	r3, [r0, #4]
    c7d6:	cmp	r2, #27
    c7d8:	bhi.n	c82a <_realloc_r+0x2ea>
    c7da:	add.w	r3, r0, #8
    c7de:	add.w	r2, r6, #8
    c7e2:	b.n	c5ca <_realloc_r+0x8a>
    c7e4:	mov	r3, r7
    c7e6:	ldr	r2, [r6, #0]
    c7e8:	str	r2, [r3, #0]
    c7ea:	ldr	r2, [r6, #4]
    c7ec:	str	r2, [r3, #4]
    c7ee:	ldr	r2, [r6, #8]
    c7f0:	str	r2, [r3, #8]
    c7f2:	mov	r6, r7
    c7f4:	mov	r4, lr
    c7f6:	mov	r8, sl
    c7f8:	b.n	c662 <_realloc_r+0x122>
    c7fa:	add.w	r1, r8, r5
    c7fe:	rsb	fp, r5, fp
    c802:	orr.w	r2, fp, #1
    c806:	str	r1, [r3, #8]
    c808:	str	r2, [r1, #4]
    c80a:	ldr.w	r3, [r6, #-4]
    c80e:	and.w	r3, r3, #1
    c812:	orrs	r5, r3
    c814:	mov	r0, r9
    c816:	str.w	r5, [r6, #-4]
    c81a:	bl	c53c <__malloc_unlock>
    c81e:	mov	r0, r6
    c820:	b.n	c688 <_realloc_r+0x148>
    c822:	mov	r1, r6
    c824:	bl	c3d4 <memmove>
    c828:	b.n	c5d6 <_realloc_r+0x96>
    c82a:	ldr	r3, [r6, #8]
    c82c:	str	r3, [r0, #8]
    c82e:	ldr	r3, [r6, #12]
    c830:	str	r3, [r0, #12]
    c832:	cmp	r2, #36	; 0x24
    c834:	beq.n	c888 <_realloc_r+0x348>
    c836:	add.w	r3, r0, #16
    c83a:	add.w	r2, r6, #16
    c83e:	b.n	c5ca <_realloc_r+0x8a>
    c840:	ldr.w	r3, [r0, #-4]
    c844:	bic.w	r3, r3, #3
    c848:	add	r4, r3
    c84a:	b.n	c662 <_realloc_r+0x122>
    c84c:	mov	r1, r6
    c84e:	mov	r0, r7
    c850:	mov	r4, lr
    c852:	mov	r8, sl
    c854:	bl	c3d4 <memmove>
    c858:	mov	r6, r7
    c85a:	b.n	c662 <_realloc_r+0x122>
    c85c:	mov	r2, r7
    c85e:	b.n	c650 <_realloc_r+0x110>
    c860:	mov	r1, r6
    c862:	mov	r0, r7
    c864:	mov	r4, r3
    c866:	mov	r8, sl
    c868:	bl	c3d4 <memmove>
    c86c:	mov	r6, r7
    c86e:	b.n	c662 <_realloc_r+0x122>
    c870:	ldr	r3, [r6, #8]
    c872:	str.w	r3, [sl, #16]
    c876:	ldr	r3, [r6, #12]
    c878:	str.w	r3, [sl, #20]
    c87c:	cmp	r2, #36	; 0x24
    c87e:	beq.n	c8b8 <_realloc_r+0x378>
    c880:	adds	r6, #16
    c882:	add.w	r3, sl, #24
    c886:	b.n	c7e6 <_realloc_r+0x2a6>
    c888:	ldr	r3, [r6, #16]
    c88a:	str	r3, [r0, #16]
    c88c:	ldr	r3, [r6, #20]
    c88e:	str	r3, [r0, #20]
    c890:	add.w	r2, r6, #24
    c894:	add.w	r3, r0, #24
    c898:	b.n	c5ca <_realloc_r+0x8a>
    c89a:	nop
    c89c:	.word	0x20013f38
    c8a0:	ldr	r1, [r6, #8]
    c8a2:	str.w	r1, [sl, #16]
    c8a6:	ldr	r1, [r6, #12]
    c8a8:	str.w	r1, [sl, #20]
    c8ac:	cmp	r2, #36	; 0x24
    c8ae:	beq.n	c8d0 <_realloc_r+0x390>
    c8b0:	adds	r6, #16
    c8b2:	add.w	r2, sl, #24
    c8b6:	b.n	c650 <_realloc_r+0x110>
    c8b8:	ldr	r3, [r6, #16]
    c8ba:	str.w	r3, [sl, #24]
    c8be:	ldr	r3, [r6, #20]
    c8c0:	str.w	r3, [sl, #28]
    c8c4:	adds	r6, #24
    c8c6:	add.w	r3, sl, #32
    c8ca:	b.n	c7e6 <_realloc_r+0x2a6>
    c8cc:	mov	r2, r7
    c8ce:	b.n	c79a <_realloc_r+0x25a>
    c8d0:	ldr	r2, [r6, #16]
    c8d2:	str.w	r2, [sl, #24]
    c8d6:	ldr	r2, [r6, #20]
    c8d8:	str.w	r2, [sl, #28]
    c8dc:	adds	r6, #24
    c8de:	add.w	r2, sl, #32
    c8e2:	b.n	c650 <_realloc_r+0x110>
    c8e4:	mov	r1, r6
    c8e6:	mov	r0, r7
    c8e8:	str	r3, [sp, #4]
    c8ea:	bl	c3d4 <memmove>
    c8ee:	ldr	r3, [sp, #4]
    c8f0:	b.n	c7a6 <_realloc_r+0x266>
    c8f2:	ldr	r1, [r6, #8]
    c8f4:	str.w	r1, [sl, #16]
    c8f8:	ldr	r1, [r6, #12]
    c8fa:	str.w	r1, [sl, #20]
    c8fe:	cmp	r2, #36	; 0x24
    c900:	beq.n	c90a <_realloc_r+0x3ca>
    c902:	adds	r6, #16
    c904:	add.w	r2, sl, #24
    c908:	b.n	c79a <_realloc_r+0x25a>
    c90a:	ldr	r2, [r6, #16]
    c90c:	str.w	r2, [sl, #24]
    c910:	ldr	r2, [r6, #20]
    c912:	str.w	r2, [sl, #28]
    c916:	adds	r6, #24
    c918:	add.w	r2, sl, #32
    c91c:	b.n	c79a <_realloc_r+0x25a>
    c91e:	nop

0000c920 <_sbrk_r>:
    c920:	push	{r3, r4, r5, lr}
    c922:	ldr	r4, [pc, #28]	; (c940 <_sbrk_r+0x20>)
    c924:	movs	r3, #0
    c926:	mov	r5, r0
    c928:	mov	r0, r1
    c92a:	str	r3, [r4, #0]
    c92c:	bl	97dc <_sbrk>
    c930:	adds	r3, r0, #1
    c932:	beq.n	c936 <_sbrk_r+0x16>
    c934:	pop	{r3, r4, r5, pc}
    c936:	ldr	r3, [r4, #0]
    c938:	cmp	r3, #0
    c93a:	beq.n	c934 <_sbrk_r+0x14>
    c93c:	str	r3, [r5, #0]
    c93e:	pop	{r3, r4, r5, pc}
    c940:	.word	0x20019db4

0000c944 <sprintf>:
    c944:	push	{r1, r2, r3}
    c946:	push	{r4, r5, r6, r7, lr}
    c948:	sub	sp, #112	; 0x70
    c94a:	add	r3, sp, #132	; 0x84
    c94c:	ldr	r1, [pc, #60]	; (c98c <sprintf+0x48>)
    c94e:	ldr.w	r2, [r3], #4
    c952:	str	r3, [sp, #4]
    c954:	mov	r5, r0
    c956:	mvn.w	r4, #2147483648	; 0x80000000
    c95a:	ldr	r0, [r1, #0]
    c95c:	str	r5, [sp, #8]
    c95e:	mov.w	r7, #520	; 0x208
    c962:	movw	r6, #65535	; 0xffff
    c966:	add	r1, sp, #8
    c968:	str	r5, [sp, #24]
    c96a:	strh.w	r7, [sp, #20]
    c96e:	str	r4, [sp, #16]
    c970:	str	r4, [sp, #28]
    c972:	strh.w	r6, [sp, #22]
    c976:	bl	dd90 <_svfprintf_r>
    c97a:	ldr	r3, [sp, #8]
    c97c:	movs	r2, #0
    c97e:	strb	r2, [r3, #0]
    c980:	add	sp, #112	; 0x70
    c982:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    c986:	add	sp, #12
    c988:	bx	lr
    c98a:	nop
    c98c:	.word	0x20013dc8

0000c990 <sscanf>:
    c990:	push	{r1, r2, r3}
    c992:	push	{r4, r5, r6, r7, lr}
    c994:	sub	sp, #112	; 0x70
    c996:	add	r4, sp, #132	; 0x84
    c998:	mov.w	r2, #516	; 0x204
    c99c:	ldr.w	r6, [r4], #4
    c9a0:	strh.w	r2, [sp, #20]
    c9a4:	str	r0, [sp, #8]
    c9a6:	str	r0, [sp, #24]
    c9a8:	bl	cb80 <strlen>
    c9ac:	ldr	r3, [pc, #48]	; (c9e0 <sscanf+0x50>)
    c9ae:	str	r4, [sp, #4]
    c9b0:	mov	r5, r0
    c9b2:	mov	r2, r6
    c9b4:	ldr	r7, [pc, #44]	; (c9e4 <sscanf+0x54>)
    c9b6:	ldr	r0, [r3, #0]
    c9b8:	str	r5, [sp, #12]
    c9ba:	mov	r3, r4
    c9bc:	movw	r6, #65535	; 0xffff
    c9c0:	movs	r4, #0
    c9c2:	add	r1, sp, #8
    c9c4:	str	r5, [sp, #28]
    c9c6:	str	r7, [sp, #40]	; 0x28
    c9c8:	str	r4, [sp, #56]	; 0x38
    c9ca:	str	r4, [sp, #76]	; 0x4c
    c9cc:	strh.w	r6, [sp, #22]
    c9d0:	bl	f474 <__ssvfscanf_r>
    c9d4:	add	sp, #112	; 0x70
    c9d6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    c9da:	add	sp, #12
    c9dc:	bx	lr
    c9de:	nop
    c9e0:	.word	0x20013dc8
    c9e4:	.word	0x0000c9e9

0000c9e8 <__seofread>:
    c9e8:	movs	r0, #0
    c9ea:	bx	lr

0000c9ec <strchr>:
    c9ec:	push	{r4, r5, r6}
    c9ee:	ands.w	r4, r1, #255	; 0xff
    c9f2:	beq.n	ca5e <strchr+0x72>
    c9f4:	lsls	r5, r0, #30
    c9f6:	beq.n	ca18 <strchr+0x2c>
    c9f8:	ldrb	r3, [r0, #0]
    c9fa:	cmp	r3, #0
    c9fc:	beq.n	cab4 <strchr+0xc8>
    c9fe:	cmp	r4, r3
    ca00:	beq.n	ca5a <strchr+0x6e>
    ca02:	adds	r3, r0, #1
    ca04:	b.n	ca12 <strchr+0x26>
    ca06:	ldrb.w	r2, [r3], #1
    ca0a:	cmp	r2, #0
    ca0c:	beq.n	caae <strchr+0xc2>
    ca0e:	cmp	r4, r2
    ca10:	beq.n	ca5a <strchr+0x6e>
    ca12:	lsls	r2, r3, #30
    ca14:	mov	r0, r3
    ca16:	bne.n	ca06 <strchr+0x1a>
    ca18:	lsls	r6, r1, #8
    ca1a:	and.w	r6, r6, #65280	; 0xff00
    ca1e:	orrs	r6, r4
    ca20:	ldr	r3, [r0, #0]
    ca22:	orr.w	r6, r6, r6, lsl #16
    ca26:	b.n	ca2c <strchr+0x40>
    ca28:	ldr.w	r3, [r0, #4]!
    ca2c:	eor.w	r5, r6, r3
    ca30:	sub.w	r2, r5, #16843009	; 0x1010101
    ca34:	sub.w	r1, r3, #16843009	; 0x1010101
    ca38:	bic.w	r2, r2, r5
    ca3c:	bic.w	r3, r1, r3
    ca40:	orrs	r3, r2
    ca42:	tst.w	r3, #2155905152	; 0x80808080
    ca46:	beq.n	ca28 <strchr+0x3c>
    ca48:	ldrb	r3, [r0, #0]
    ca4a:	cbnz	r3, ca56 <strchr+0x6a>
    ca4c:	b.n	cab4 <strchr+0xc8>
    ca4e:	ldrb.w	r3, [r0, #1]!
    ca52:	cmp	r3, #0
    ca54:	beq.n	cab4 <strchr+0xc8>
    ca56:	cmp	r4, r3
    ca58:	bne.n	ca4e <strchr+0x62>
    ca5a:	pop	{r4, r5, r6}
    ca5c:	bx	lr
    ca5e:	lsls	r4, r0, #30
    ca60:	beq.n	ca7a <strchr+0x8e>
    ca62:	ldrb	r3, [r0, #0]
    ca64:	cmp	r3, #0
    ca66:	beq.n	ca5a <strchr+0x6e>
    ca68:	adds	r3, r0, #1
    ca6a:	b.n	ca74 <strchr+0x88>
    ca6c:	ldrb	r2, [r0, #0]
    ca6e:	adds	r3, #1
    ca70:	cmp	r2, #0
    ca72:	beq.n	ca5a <strchr+0x6e>
    ca74:	lsls	r1, r3, #30
    ca76:	mov	r0, r3
    ca78:	bne.n	ca6c <strchr+0x80>
    ca7a:	ldr	r2, [r0, #0]
    ca7c:	sub.w	r3, r2, #16843009	; 0x1010101
    ca80:	bic.w	r3, r3, r2
    ca84:	tst.w	r3, #2155905152	; 0x80808080
    ca88:	bne.n	ca9c <strchr+0xb0>
    ca8a:	ldr.w	r2, [r0, #4]!
    ca8e:	sub.w	r3, r2, #16843009	; 0x1010101
    ca92:	bic.w	r3, r3, r2
    ca96:	tst.w	r3, #2155905152	; 0x80808080
    ca9a:	beq.n	ca8a <strchr+0x9e>
    ca9c:	ldrb	r3, [r0, #0]
    ca9e:	cmp	r3, #0
    caa0:	beq.n	ca5a <strchr+0x6e>
    caa2:	ldrb.w	r3, [r0, #1]!
    caa6:	cmp	r3, #0
    caa8:	bne.n	caa2 <strchr+0xb6>
    caaa:	pop	{r4, r5, r6}
    caac:	bx	lr
    caae:	mov	r0, r2
    cab0:	pop	{r4, r5, r6}
    cab2:	bx	lr
    cab4:	mov	r0, r3
    cab6:	pop	{r4, r5, r6}
    cab8:	bx	lr
    caba:	nop

0000cabc <strcpy>:
    cabc:	eor.w	r2, r0, r1
    cac0:	mov	ip, r0
    cac2:	tst.w	r2, #3
    cac6:	bne.n	cb68 <strcpy+0xac>
    cac8:	tst.w	r1, #3
    cacc:	bne.n	cb34 <strcpy+0x78>
    cace:	str.w	r4, [sp, #-4]!
    cad2:	tst.w	r1, #4
    cad6:	ldr.w	r3, [r1], #4
    cada:	beq.n	caf4 <strcpy+0x38>
    cadc:	sub.w	r2, r3, #16843009	; 0x1010101
    cae0:	bics	r2, r3
    cae2:	tst.w	r2, #2155905152	; 0x80808080
    cae6:	itt	eq
    cae8:	streq.w	r3, [ip], #4
    caec:	ldreq.w	r3, [r1], #4
    caf0:	bne.n	cb20 <strcpy+0x64>
    caf2:	nop
    caf4:	ldr.w	r4, [r1], #4
    caf8:	sub.w	r2, r3, #16843009	; 0x1010101
    cafc:	bics	r2, r3
    cafe:	tst.w	r2, #2155905152	; 0x80808080
    cb02:	sub.w	r2, r4, #16843009	; 0x1010101
    cb06:	bne.n	cb20 <strcpy+0x64>
    cb08:	str.w	r3, [ip], #4
    cb0c:	bics	r2, r4
    cb0e:	tst.w	r2, #2155905152	; 0x80808080
    cb12:	itt	eq
    cb14:	ldreq.w	r3, [r1], #4
    cb18:	streq.w	r4, [ip], #4
    cb1c:	beq.n	caf4 <strcpy+0x38>
    cb1e:	mov	r3, r4
    cb20:	strb.w	r3, [ip], #1
    cb24:	tst.w	r3, #255	; 0xff
    cb28:	mov.w	r3, r3, ror #8
    cb2c:	bne.n	cb20 <strcpy+0x64>
    cb2e:	ldr.w	r4, [sp], #4
    cb32:	bx	lr
    cb34:	tst.w	r1, #1
    cb38:	beq.n	cb48 <strcpy+0x8c>
    cb3a:	ldrb.w	r2, [r1], #1
    cb3e:	strb.w	r2, [ip], #1
    cb42:	cmp	r2, #0
    cb44:	it	eq
    cb46:	bxeq	lr
    cb48:	tst.w	r1, #2
    cb4c:	beq.n	cace <strcpy+0x12>
    cb4e:	ldrh.w	r2, [r1], #2
    cb52:	tst.w	r2, #255	; 0xff
    cb56:	itet	ne
    cb58:	strhne.w	r2, [ip], #2
    cb5c:	strbeq.w	r2, [ip]
    cb60:	tstne.w	r2, #65280	; 0xff00
    cb64:	bne.n	cace <strcpy+0x12>
    cb66:	bx	lr
    cb68:	ldrb.w	r2, [r1], #1
    cb6c:	strb.w	r2, [ip], #1
    cb70:	cmp	r2, #0
    cb72:	bne.n	cb68 <strcpy+0xac>
    cb74:	bx	lr
    cb76:	nop
    cb78:			; <UNDEFINED> instruction: 0xffffffff
    cb7c:			; <UNDEFINED> instruction: 0xffffffff

0000cb80 <strlen>:
    cb80:	pld	[r0]
    cb84:	strd	r4, r5, [sp, #-8]!
    cb88:	bic.w	r1, r0, #7
    cb8c:	mvn.w	ip, #0
    cb90:	ands.w	r4, r0, #7
    cb94:	pld	[r1, #32]
    cb98:	bne.w	cc2e <strlen+0xae>
    cb9c:	mov.w	r4, #0
    cba0:	mvn.w	r0, #7
    cba4:	ldrd	r2, r3, [r1]
    cba8:	pld	[r1, #64]	; 0x40
    cbac:	add.w	r0, r0, #8
    cbb0:	uadd8	r2, r2, ip
    cbb4:	sel	r2, r4, ip
    cbb8:	uadd8	r3, r3, ip
    cbbc:	sel	r3, r2, ip
    cbc0:	cbnz	r3, cc16 <strlen+0x96>
    cbc2:	ldrd	r2, r3, [r1, #8]
    cbc6:	uadd8	r2, r2, ip
    cbca:	add.w	r0, r0, #8
    cbce:	sel	r2, r4, ip
    cbd2:	uadd8	r3, r3, ip
    cbd6:	sel	r3, r2, ip
    cbda:	cbnz	r3, cc16 <strlen+0x96>
    cbdc:	ldrd	r2, r3, [r1, #16]
    cbe0:	uadd8	r2, r2, ip
    cbe4:	add.w	r0, r0, #8
    cbe8:	sel	r2, r4, ip
    cbec:	uadd8	r3, r3, ip
    cbf0:	sel	r3, r2, ip
    cbf4:	cbnz	r3, cc16 <strlen+0x96>
    cbf6:	ldrd	r2, r3, [r1, #24]
    cbfa:	add.w	r1, r1, #32
    cbfe:	uadd8	r2, r2, ip
    cc02:	add.w	r0, r0, #8
    cc06:	sel	r2, r4, ip
    cc0a:	uadd8	r3, r3, ip
    cc0e:	sel	r3, r2, ip
    cc12:	cmp	r3, #0
    cc14:	beq.n	cba4 <strlen+0x24>
    cc16:	cmp	r2, #0
    cc18:	itt	eq
    cc1a:	addeq	r0, #4
    cc1c:	moveq	r2, r3
    cc1e:	rev	r2, r2
    cc20:	clz	r2, r2
    cc24:	ldrd	r4, r5, [sp], #8
    cc28:	add.w	r0, r0, r2, lsr #3
    cc2c:	bx	lr
    cc2e:	ldrd	r2, r3, [r1]
    cc32:	and.w	r5, r4, #3
    cc36:	rsb	r0, r4, #0
    cc3a:	mov.w	r5, r5, lsl #3
    cc3e:	tst.w	r4, #4
    cc42:	pld	[r1, #64]	; 0x40
    cc46:	lsl.w	r5, ip, r5
    cc4a:	orn	r2, r2, r5
    cc4e:	itt	ne
    cc50:	ornne	r3, r3, r5
    cc54:	movne	r2, ip
    cc56:	mov.w	r4, #0
    cc5a:	b.n	cbb0 <strlen+0x30>

0000cc5c <strncmp>:
    cc5c:	cmp	r2, #0
    cc5e:	beq.n	cce4 <strncmp+0x88>
    cc60:	orr.w	r3, r0, r1
    cc64:	ands.w	r3, r3, #3
    cc68:	push	{r4, r5, r6, r7}
    cc6a:	bne.n	ccb8 <strncmp+0x5c>
    cc6c:	cmp	r2, #3
    cc6e:	bls.n	ccb8 <strncmp+0x5c>
    cc70:	ldr	r4, [r0, #0]
    cc72:	ldr	r5, [r1, #0]
    cc74:	cmp	r4, r5
    cc76:	bne.n	ccb8 <strncmp+0x5c>
    cc78:	subs	r2, #4
    cc7a:	beq.n	cce8 <strncmp+0x8c>
    cc7c:	sub.w	r5, r4, #16843009	; 0x1010101
    cc80:	bic.w	r4, r5, r4
    cc84:	tst.w	r4, #2155905152	; 0x80808080
    cc88:	bne.n	ccee <strncmp+0x92>
    cc8a:	adds	r7, r0, #4
    cc8c:	adds	r5, r1, #4
    cc8e:	b.n	ccac <strncmp+0x50>
    cc90:	ldr.w	r3, [r7], #4
    cc94:	ldr	r6, [r1, #0]
    cc96:	sub.w	r4, r3, #16843009	; 0x1010101
    cc9a:	cmp	r3, r6
    cc9c:	bic.w	r4, r4, r3
    cca0:	bne.n	ccb8 <strncmp+0x5c>
    cca2:	subs	r2, #4
    cca4:	beq.n	cce8 <strncmp+0x8c>
    cca6:	tst.w	r4, #2155905152	; 0x80808080
    ccaa:	bne.n	ccf4 <strncmp+0x98>
    ccac:	cmp	r2, #3
    ccae:	mov	r1, r5
    ccb0:	mov	r0, r7
    ccb2:	add.w	r5, r5, #4
    ccb6:	bhi.n	cc90 <strncmp+0x34>
    ccb8:	ldrb	r3, [r0, #0]
    ccba:	ldrb	r4, [r1, #0]
    ccbc:	cmp	r4, r3
    ccbe:	add.w	r2, r2, #4294967295
    ccc2:	bne.n	ccde <strncmp+0x82>
    ccc4:	cbz	r2, cce8 <strncmp+0x8c>
    ccc6:	cbnz	r4, ccce <strncmp+0x72>
    ccc8:	b.n	ccf8 <strncmp+0x9c>
    ccca:	cbz	r2, cce8 <strncmp+0x8c>
    cccc:	cbz	r3, ccee <strncmp+0x92>
    ccce:	ldrb.w	r3, [r0, #1]!
    ccd2:	ldrb.w	r4, [r1, #1]!
    ccd6:	cmp	r3, r4
    ccd8:	add.w	r2, r2, #4294967295
    ccdc:	beq.n	ccca <strncmp+0x6e>
    ccde:	subs	r0, r3, r4
    cce0:	pop	{r4, r5, r6, r7}
    cce2:	bx	lr
    cce4:	mov	r0, r2
    cce6:	bx	lr
    cce8:	mov	r0, r2
    ccea:	pop	{r4, r5, r6, r7}
    ccec:	bx	lr
    ccee:	mov	r0, r3
    ccf0:	pop	{r4, r5, r6, r7}
    ccf2:	bx	lr
    ccf4:	movs	r0, #0
    ccf6:	b.n	cce0 <strncmp+0x84>
    ccf8:	mov	r0, r4
    ccfa:	b.n	cce0 <strncmp+0x84>

0000ccfc <sulp>:
    ccfc:	push	{r4, r5, r6, lr}
    ccfe:	mov	r4, r0
    cd00:	mov	r5, r1
    cd02:	vmov	d0, r4, r5
    cd06:	mov	r6, r2
    cd08:	bl	12460 <__ulp>
    cd0c:	vmov	r0, r1, d0
    cd10:	cbz	r6, cd32 <sulp+0x36>
    cd12:	ubfx	r3, r5, #20, #11
    cd16:	rsb	r3, r3, #107	; 0x6b
    cd1a:	cmp	r3, #0
    cd1c:	ble.n	cd32 <sulp+0x36>
    cd1e:	lsls	r3, r3, #20
    cd20:	add.w	r5, r3, #1069547520	; 0x3fc00000
    cd24:	movs	r4, #0
    cd26:	add.w	r5, r5, #3145728	; 0x300000
    cd2a:	mov	r2, r4
    cd2c:	mov	r3, r5
    cd2e:	bl	b2b0 <__aeabi_dmul>
    cd32:	pop	{r4, r5, r6, pc}
    cd34:			; <UNDEFINED> instruction: 0xffffffff

0000cd38 <_strtod_l>:
    cd38:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cd3c:	mov	r5, r3
    cd3e:	sub	sp, #132	; 0x84
    cd40:	movs	r3, #0
    cd42:	mov	fp, r0
    cd44:	mov	r0, r5
    cd46:	mov	r6, r1
    cd48:	str	r2, [sp, #24]
    cd4a:	str	r3, [sp, #112]	; 0x70
    cd4c:	bl	11de4 <__localeconv_l>
    cd50:	movs	r4, #0
    cd52:	movs	r3, #0
    cd54:	mov	sl, r0
    cd56:	ldr	r0, [r0, #0]
    cd58:	strd	r3, r4, [sp, #16]
    cd5c:	bl	cb80 <strlen>
    cd60:	str	r6, [sp, #108]	; 0x6c
    cd62:	mov	r9, r0
    cd64:	mov	r2, r6
    cd66:	mov	r4, r2
    cd68:	ldrb.w	r7, [r2], #1
    cd6c:	cmp	r7, #45	; 0x2d
    cd6e:	bhi.w	ced0 <_strtod_l+0x198>
    cd72:	tbb	[pc, r7]
    cd76:	.short	0xad17
    cd78:	.word	0xadadadad
    cd7c:	.word	0x81adadad
    cd80:	.word	0x81818181
    cd84:	.word	0xadadadad
    cd88:	.word	0xadadadad
    cd8c:	.word	0xadadadad
    cd90:	.word	0xadadadad
    cd94:	.word	0xad81adad
    cd98:	.word	0xadadadad
    cd9c:	.word	0xadadadad
    cda0:	.word	0x7ead2bad
    cda4:	ldr	r3, [sp, #24]
    cda6:	mov.w	r8, #0
    cdaa:	mov.w	r9, #0
    cdae:	cbz	r3, cdc2 <_strtod_l+0x8a>
    cdb0:	movs	r3, #0
    cdb2:	str	r3, [sp, #28]
    cdb4:	ldr	r3, [sp, #24]
    cdb6:	str	r6, [r3, #0]
    cdb8:	ldr	r3, [sp, #28]
    cdba:	cbz	r3, cdc2 <_strtod_l+0x8a>
    cdbc:	add.w	r3, r9, #2147483648	; 0x80000000
    cdc0:	mov	r9, r3
    cdc2:	vmov	d0, r8, r9
    cdc6:	add	sp, #132	; 0x84
    cdc8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cdcc:	movs	r3, #0
    cdce:	str	r3, [sp, #28]
    cdd0:	adds	r2, r4, #1
    cdd2:	str	r2, [sp, #108]	; 0x6c
    cdd4:	ldrb	r7, [r4, #1]
    cdd6:	cmp	r7, #0
    cdd8:	beq.n	cda4 <_strtod_l+0x6c>
    cdda:	cmp	r7, #48	; 0x30
    cddc:	mov	r4, r2
    cdde:	beq.n	ced8 <_strtod_l+0x1a0>
    cde0:	movs	r3, #0
    cde2:	str	r4, [sp, #32]
    cde4:	str	r3, [sp, #40]	; 0x28
    cde6:	sub.w	r3, r7, #48	; 0x30
    cdea:	cmp	r3, #9
    cdec:	bhi.w	d5fe <_strtod_l+0x8c6>
    cdf0:	mov.w	r8, #0
    cdf4:	mov	r0, r4
    cdf6:	mov	r5, r8
    cdf8:	mov	r4, r8
    cdfa:	cmp	r4, #8
    cdfc:	it	gt
    cdfe:	addgt.w	r8, r8, r8, lsl #2
    ce02:	add.w	r3, r5, r5, lsl #2
    ce06:	add.w	r0, r0, #1
    ce0a:	add.w	r3, r7, r3, lsl #1
    ce0e:	str	r0, [sp, #108]	; 0x6c
    ce10:	itt	gt
    ce12:	addgt.w	r7, r7, r8, lsl #1
    ce16:	subgt.w	r8, r7, #48	; 0x30
    ce1a:	ldrb	r7, [r0, #0]
    ce1c:	it	le
    ce1e:	suble.w	r5, r3, #48	; 0x30
    ce22:	sub.w	r3, r7, #48	; 0x30
    ce26:	cmp	r3, #9
    ce28:	add.w	r4, r4, #1
    ce2c:	bls.n	cdfa <_strtod_l+0xc2>
    ce2e:	ldr.w	r1, [sl]
    ce32:	mov	r2, r9
    ce34:	bl	cc5c <strncmp>
    ce38:	cbz	r0, ce7c <_strtod_l+0x144>
    ce3a:	movs	r0, #0
    ce3c:	mov	r3, r7
    ce3e:	mov	r9, r0
    ce40:	mov	r7, r0
    ce42:	mov	sl, r4
    ce44:	cmp	r3, #101	; 0x65
    ce46:	beq.w	cfae <_strtod_l+0x276>
    ce4a:	cmp	r3, #69	; 0x45
    ce4c:	beq.w	cfae <_strtod_l+0x276>
    ce50:	movs	r2, #0
    ce52:	cmp	r4, #0
    ce54:	bne.n	cefc <_strtod_l+0x1c4>
    ce56:	cbnz	r0, ce60 <_strtod_l+0x128>
    ce58:	ldr	r2, [sp, #40]	; 0x28
    ce5a:	cmp	r2, #0
    ce5c:	beq.w	d402 <_strtod_l+0x6ca>
    ce60:	mov.w	r8, #0
    ce64:	mov.w	r9, #0
    ce68:	ldr	r3, [sp, #24]
    ce6a:	cmp	r3, #0
    ce6c:	beq.n	cdb8 <_strtod_l+0x80>
    ce6e:	ldr	r6, [sp, #108]	; 0x6c
    ce70:	b.n	cdb4 <_strtod_l+0x7c>
    ce72:	movs	r3, #1
    ce74:	str	r3, [sp, #28]
    ce76:	b.n	cdd0 <_strtod_l+0x98>
    ce78:	str	r2, [sp, #108]	; 0x6c
    ce7a:	b.n	cd66 <_strtod_l+0x2e>
    ce7c:	ldr	r3, [sp, #108]	; 0x6c
    ce7e:	add.w	r2, r3, r9
    ce82:	str	r2, [sp, #108]	; 0x6c
    ce84:	ldrb.w	r3, [r3, r9]
    ce88:	mov	r7, r0
    ce8a:	mov	sl, r4
    ce8c:	sub.w	r2, r3, #48	; 0x30
    ce90:	cmp	r2, #9
    ce92:	bhi.w	d388 <_strtod_l+0x650>
    ce96:	adds	r1, r0, #1
    ce98:	mov	r3, r2
    ce9a:	cmp	r2, #0
    ce9c:	beq.w	dbde <_strtod_l+0xea6>
    cea0:	cmp	r1, #1
    cea2:	add	r7, r1
    cea4:	it	ne
    cea6:	addne	r0, r0, r4
    cea8:	bne.n	ceb6 <_strtod_l+0x17e>
    ceaa:	b.w	dbd6 <_strtod_l+0xe9e>
    ceae:	lsls	r5, r1, #1
    ceb0:	cmp	r4, r0
    ceb2:	beq.w	d82c <_strtod_l+0xaf4>
    ceb6:	adds	r4, #1
    ceb8:	subs	r1, r4, #1
    ceba:	cmp	r1, #8
    cebc:	add.w	r1, r5, r5, lsl #2
    cec0:	ble.n	ceae <_strtod_l+0x176>
    cec2:	cmp	r4, #16
    cec4:	itt	le
    cec6:	addle.w	r8, r8, r8, lsl #2
    ceca:	movle.w	r8, r8, lsl #1
    cece:	b.n	ceb0 <_strtod_l+0x178>
    ced0:	movs	r3, #0
    ced2:	cmp	r7, #48	; 0x30
    ced4:	str	r3, [sp, #28]
    ced6:	bne.n	cde0 <_strtod_l+0xa8>
    ced8:	ldrb	r3, [r4, #1]
    ceda:	cmp	r3, #88	; 0x58
    cedc:	beq.w	d5c6 <_strtod_l+0x88e>
    cee0:	cmp	r3, #120	; 0x78
    cee2:	beq.w	d5c6 <_strtod_l+0x88e>
    cee6:	adds	r4, #1
    cee8:	str	r4, [sp, #108]	; 0x6c
    ceea:	ldrb	r7, [r4, #0]
    ceec:	cmp	r7, #48	; 0x30
    ceee:	beq.n	cee6 <_strtod_l+0x1ae>
    cef0:	cmp	r7, #0
    cef2:	beq.n	ce60 <_strtod_l+0x128>
    cef4:	movs	r3, #1
    cef6:	str	r4, [sp, #32]
    cef8:	str	r3, [sp, #40]	; 0x28
    cefa:	b.n	cde6 <_strtod_l+0xae>
    cefc:	cmp	r4, #16
    cefe:	sub.w	r3, r2, r7
    cf02:	mov	r0, r5
    cf04:	mov	r9, r4
    cf06:	str	r3, [sp, #44]	; 0x2c
    cf08:	it	ge
    cf0a:	movge.w	r9, #16
    cf0e:	bl	b1c4 <__aeabi_ui2d>
    cf12:	cmp.w	sl, #0
    cf16:	it	eq
    cf18:	moveq	sl, r4
    cf1a:	cmp.w	r9, #9
    cf1e:	strd	r0, r1, [sp, #16]
    cf22:	ble.n	cf4c <_strtod_l+0x214>
    cf24:	ldr	r3, [pc, #292]	; (d04c <_strtod_l+0x314>)
    cf26:	add.w	r3, r3, r9, lsl #3
    cf2a:	ldrd	r2, r3, [r3, #-72]	; 0x48
    cf2e:	bl	b2b0 <__aeabi_dmul>
    cf32:	mov	r6, r0
    cf34:	mov	r0, r8
    cf36:	mov	r7, r1
    cf38:	bl	b1c4 <__aeabi_ui2d>
    cf3c:	mov	r2, r0
    cf3e:	mov	r3, r1
    cf40:	mov	r0, r6
    cf42:	mov	r1, r7
    cf44:	bl	af4c <__adddf3>
    cf48:	strd	r0, r1, [sp, #16]
    cf4c:	cmp	r4, #15
    cf4e:	bgt.w	d05c <_strtod_l+0x324>
    cf52:	ldr	r3, [sp, #44]	; 0x2c
    cf54:	cmp	r3, #0
    cf56:	beq.n	cfa8 <_strtod_l+0x270>
    cf58:	ble.w	d994 <_strtod_l+0xc5c>
    cf5c:	ldr	r3, [sp, #44]	; 0x2c
    cf5e:	cmp	r3, #22
    cf60:	bgt.w	d860 <_strtod_l+0xb28>
    cf64:	ldr	r7, [pc, #228]	; (d04c <_strtod_l+0x314>)
    cf66:	add.w	r7, r7, r3, lsl #3
    cf6a:	ldrd	r0, r1, [r7]
    cf6e:	ldrd	r2, r3, [sp, #16]
    cf72:	bl	b2b0 <__aeabi_dmul>
    cf76:	mov	r8, r0
    cf78:	mov	r9, r1
    cf7a:	b.n	ce68 <_strtod_l+0x130>
    cf7c:	add	r0, sp, #108	; 0x6c
    cf7e:	ldr	r1, [pc, #208]	; (d050 <_strtod_l+0x318>)
    cf80:	bl	11c18 <__match>
    cf84:	cmp	r0, #0
    cf86:	beq.w	cda4 <_strtod_l+0x6c>
    cf8a:	ldr	r3, [sp, #108]	; 0x6c
    cf8c:	ldr	r1, [pc, #196]	; (d054 <_strtod_l+0x31c>)
    cf8e:	subs	r3, #1
    cf90:	add	r0, sp, #108	; 0x6c
    cf92:	str	r3, [sp, #108]	; 0x6c
    cf94:	bl	11c18 <__match>
    cf98:	cbnz	r0, cfa0 <_strtod_l+0x268>
    cf9a:	ldr	r3, [sp, #108]	; 0x6c
    cf9c:	adds	r3, #1
    cf9e:	str	r3, [sp, #108]	; 0x6c
    cfa0:	ldr	r3, [pc, #180]	; (d058 <_strtod_l+0x320>)
    cfa2:	str	r3, [sp, #20]
    cfa4:	movs	r3, #0
    cfa6:	str	r3, [sp, #16]
    cfa8:	ldrd	r8, r9, [sp, #16]
    cfac:	b.n	ce68 <_strtod_l+0x130>
    cfae:	cmp	r4, #0
    cfb0:	beq.w	d348 <_strtod_l+0x610>
    cfb4:	ldr	r6, [sp, #108]	; 0x6c
    cfb6:	adds	r3, r6, #1
    cfb8:	str	r3, [sp, #108]	; 0x6c
    cfba:	ldrb	r3, [r6, #1]
    cfbc:	cmp	r3, #43	; 0x2b
    cfbe:	beq.w	d57c <_strtod_l+0x844>
    cfc2:	cmp	r3, #45	; 0x2d
    cfc4:	beq.w	d3f2 <_strtod_l+0x6ba>
    cfc8:	mov.w	ip, #0
    cfcc:	sub.w	r2, r3, #48	; 0x30
    cfd0:	cmp	r2, #9
    cfd2:	bhi.w	d576 <_strtod_l+0x83e>
    cfd6:	cmp	r3, #48	; 0x30
    cfd8:	bne.n	cfe6 <_strtod_l+0x2ae>
    cfda:	ldr	r2, [sp, #108]	; 0x6c
    cfdc:	adds	r2, #1
    cfde:	str	r2, [sp, #108]	; 0x6c
    cfe0:	ldrb	r3, [r2, #0]
    cfe2:	cmp	r3, #48	; 0x30
    cfe4:	beq.n	cfdc <_strtod_l+0x2a4>
    cfe6:	sub.w	r2, r3, #49	; 0x31
    cfea:	cmp	r2, #8
    cfec:	bhi.w	ce50 <_strtod_l+0x118>
    cff0:	ldr	r2, [sp, #108]	; 0x6c
    cff2:	str	r2, [sp, #48]	; 0x30
    cff4:	adds	r1, r2, #1
    cff6:	subs	r3, #48	; 0x30
    cff8:	str	r1, [sp, #108]	; 0x6c
    cffa:	str	r3, [sp, #44]	; 0x2c
    cffc:	ldrb	r3, [r2, #1]
    cffe:	sub.w	lr, r3, #48	; 0x30
    d002:	cmp.w	lr, #9
    d006:	bhi.n	d028 <_strtod_l+0x2f0>
    d008:	ldr	r2, [sp, #44]	; 0x2c
    d00a:	adds	r1, #1
    d00c:	str	r1, [sp, #108]	; 0x6c
    d00e:	add.w	r2, r2, r2, lsl #2
    d012:	add.w	r2, r3, r2, lsl #1
    d016:	ldrb	r3, [r1, #0]
    d018:	sub.w	lr, r3, #48	; 0x30
    d01c:	cmp.w	lr, #9
    d020:	sub.w	r2, r2, #48	; 0x30
    d024:	bls.n	d00a <_strtod_l+0x2d2>
    d026:	str	r2, [sp, #44]	; 0x2c
    d028:	ldr	r2, [sp, #48]	; 0x30
    d02a:	subs	r1, r1, r2
    d02c:	cmp	r1, #8
    d02e:	bgt.w	d84e <_strtod_l+0xb16>
    d032:	ldr	r2, [sp, #44]	; 0x2c
    d034:	movw	r1, #19999	; 0x4e1f
    d038:	cmp	r2, r1
    d03a:	it	ge
    d03c:	movge	r2, r1
    d03e:	cmp.w	ip, #0
    d042:	beq.w	ce52 <_strtod_l+0x11a>
    d046:	negs	r2, r2
    d048:	b.n	ce52 <_strtod_l+0x11a>
    d04a:	nop
    d04c:	.word	0x00013e08
    d050:	.word	0x00013b10
    d054:	.word	0x00013b14
    d058:	.word	0x7ff00000
    d05c:	ldr	r3, [sp, #44]	; 0x2c
    d05e:	rsb	r9, r9, r4
    d062:	add	r9, r3
    d064:	cmp.w	r9, #0
    d068:	ble.w	d77a <_strtod_l+0xa42>
    d06c:	ands.w	r1, r9, #15
    d070:	beq.n	d088 <_strtod_l+0x350>
    d072:	ldr	r3, [pc, #756]	; (d368 <_strtod_l+0x630>)
    d074:	add.w	r1, r3, r1, lsl #3
    d078:	ldrd	r0, r1, [r1]
    d07c:	ldrd	r2, r3, [sp, #16]
    d080:	bl	b2b0 <__aeabi_dmul>
    d084:	strd	r0, r1, [sp, #16]
    d088:	bics.w	r6, r9, #15
    d08c:	bne.w	d4b0 <_strtod_l+0x778>
    d090:	movs	r3, #0
    d092:	str	r3, [sp, #40]	; 0x28
    d094:	str	r5, [sp, #0]
    d096:	mov	r3, r4
    d098:	mov	r2, sl
    d09a:	ldr	r1, [sp, #32]
    d09c:	mov	r0, fp
    d09e:	bl	11f40 <__s2b>
    d0a2:	str	r0, [sp, #72]	; 0x48
    d0a4:	cmp	r0, #0
    d0a6:	beq.w	d6f6 <_strtod_l+0x9be>
    d0aa:	ldr	r2, [sp, #44]	; 0x2c
    d0ac:	movs	r7, #0
    d0ae:	cmp	r2, #0
    d0b0:	rsb	r3, r2, #0
    d0b4:	it	ge
    d0b6:	movge	r3, r7
    d0b8:	str	r3, [sp, #48]	; 0x30
    d0ba:	bic.w	r3, r2, r2, asr #31
    d0be:	str	r3, [sp, #44]	; 0x2c
    d0c0:	mov	sl, r7
    d0c2:	ldr	r4, [sp, #72]	; 0x48
    d0c4:	mov	r0, fp
    d0c6:	ldr	r1, [r4, #4]
    d0c8:	bl	11e60 <_Balloc>
    d0cc:	mov	r6, r0
    d0ce:	cmp	r0, #0
    d0d0:	beq.w	d588 <_strtod_l+0x850>
    d0d4:	ldr	r2, [r4, #16]
    d0d6:	vldr	d7, [sp, #16]
    d0da:	adds	r2, #2
    d0dc:	lsls	r2, r2, #2
    d0de:	add.w	r1, r4, #12
    d0e2:	adds	r0, #12
    d0e4:	vstr	d7, [sp, #32]
    d0e8:	bl	9220 <memcpy>
    d0ec:	vldr	d0, [sp, #32]
    d0f0:	add	r2, sp, #120	; 0x78
    d0f2:	add	r1, sp, #116	; 0x74
    d0f4:	mov	r0, fp
    d0f6:	bl	12584 <__d2b>
    d0fa:	str	r0, [sp, #112]	; 0x70
    d0fc:	cmp	r0, #0
    d0fe:	beq.w	d58a <_strtod_l+0x852>
    d102:	movs	r1, #1
    d104:	mov	r0, fp
    d106:	bl	12074 <__i2b>
    d10a:	mov	sl, r0
    d10c:	cmp	r0, #0
    d10e:	beq.w	d588 <_strtod_l+0x850>
    d112:	ldr	r2, [sp, #116]	; 0x74
    d114:	cmp	r2, #0
    d116:	blt.w	d380 <_strtod_l+0x648>
    d11a:	ldr	r3, [sp, #48]	; 0x30
    d11c:	ldr	r4, [sp, #44]	; 0x2c
    d11e:	adds	r5, r3, r2
    d120:	ldr	r0, [sp, #40]	; 0x28
    d122:	ldr	r3, [sp, #120]	; 0x78
    d124:	ldr	r1, [pc, #580]	; (d36c <_strtod_l+0x634>)
    d126:	subs	r2, r2, r0
    d128:	add	r2, r3
    d12a:	subs	r2, #1
    d12c:	cmp	r2, r1
    d12e:	rsb	r3, r3, #54	; 0x36
    d132:	bge.w	d312 <_strtod_l+0x5da>
    d136:	subs	r1, r1, r2
    d138:	cmp	r1, #31
    d13a:	sub.w	r3, r3, r1
    d13e:	bgt.w	d38e <_strtod_l+0x656>
    d142:	movs	r2, #1
    d144:	lsls	r2, r1
    d146:	str	r2, [sp, #56]	; 0x38
    d148:	movs	r2, #0
    d14a:	str	r2, [sp, #76]	; 0x4c
    d14c:	add.w	r9, r5, r3
    d150:	add	r4, r3
    d152:	ldr	r3, [sp, #40]	; 0x28
    d154:	cmp	r5, r9
    d156:	mov	r2, r5
    d158:	add	r4, r3
    d15a:	it	ge
    d15c:	movge	r2, r9
    d15e:	cmp	r2, r4
    d160:	it	ge
    d162:	movge	r2, r4
    d164:	cmp	r2, #0
    d166:	ble.n	d170 <_strtod_l+0x438>
    d168:	rsb	r9, r2, r9
    d16c:	subs	r4, r4, r2
    d16e:	subs	r5, r5, r2
    d170:	ldr	r3, [sp, #48]	; 0x30
    d172:	cbz	r3, d1a4 <_strtod_l+0x46c>
    d174:	mov	r1, sl
    d176:	mov	r2, r3
    d178:	mov	r0, fp
    d17a:	bl	121b8 <__pow5mult>
    d17e:	mov	sl, r0
    d180:	cmp	r0, #0
    d182:	beq.w	d588 <_strtod_l+0x850>
    d186:	mov	r1, r0
    d188:	ldr	r2, [sp, #112]	; 0x70
    d18a:	mov	r0, fp
    d18c:	bl	12088 <__multiply>
    d190:	cmp	r0, #0
    d192:	beq.w	d588 <_strtod_l+0x850>
    d196:	str	r0, [sp, #52]	; 0x34
    d198:	ldr	r1, [sp, #112]	; 0x70
    d19a:	mov	r0, fp
    d19c:	bl	11eac <_Bfree>
    d1a0:	ldr	r2, [sp, #52]	; 0x34
    d1a2:	str	r2, [sp, #112]	; 0x70
    d1a4:	cmp.w	r9, #0
    d1a8:	ble.n	d1bc <_strtod_l+0x484>
    d1aa:	mov	r2, r9
    d1ac:	ldr	r1, [sp, #112]	; 0x70
    d1ae:	mov	r0, fp
    d1b0:	bl	12258 <__lshift>
    d1b4:	str	r0, [sp, #112]	; 0x70
    d1b6:	cmp	r0, #0
    d1b8:	beq.w	d58a <_strtod_l+0x852>
    d1bc:	ldr	r3, [sp, #44]	; 0x2c
    d1be:	cbz	r3, d1d2 <_strtod_l+0x49a>
    d1c0:	mov	r1, r6
    d1c2:	ldr	r2, [sp, #44]	; 0x2c
    d1c4:	mov	r0, fp
    d1c6:	bl	121b8 <__pow5mult>
    d1ca:	mov	r6, r0
    d1cc:	cmp	r0, #0
    d1ce:	beq.w	d588 <_strtod_l+0x850>
    d1d2:	cmp	r4, #0
    d1d4:	ble.n	d1e8 <_strtod_l+0x4b0>
    d1d6:	mov	r1, r6
    d1d8:	mov	r2, r4
    d1da:	mov	r0, fp
    d1dc:	bl	12258 <__lshift>
    d1e0:	mov	r6, r0
    d1e2:	cmp	r0, #0
    d1e4:	beq.w	d588 <_strtod_l+0x850>
    d1e8:	cmp	r5, #0
    d1ea:	ble.n	d1fe <_strtod_l+0x4c6>
    d1ec:	mov	r1, sl
    d1ee:	mov	r2, r5
    d1f0:	mov	r0, fp
    d1f2:	bl	12258 <__lshift>
    d1f6:	mov	sl, r0
    d1f8:	cmp	r0, #0
    d1fa:	beq.w	d588 <_strtod_l+0x850>
    d1fe:	mov	r2, r6
    d200:	ldr	r1, [sp, #112]	; 0x70
    d202:	mov	r0, fp
    d204:	bl	1234c <__mdiff>
    d208:	mov	r7, r0
    d20a:	cmp	r0, #0
    d20c:	beq.w	d588 <_strtod_l+0x850>
    d210:	movs	r3, #0
    d212:	ldr	r2, [r0, #12]
    d214:	str	r3, [r0, #12]
    d216:	mov	r1, sl
    d218:	str	r2, [sp, #52]	; 0x34
    d21a:	bl	12308 <__mcmp>
    d21e:	cmp	r0, #0
    d220:	blt.w	da3e <_strtod_l+0xd06>
    d224:	beq.w	d9b8 <_strtod_l+0xc80>
    d228:	mov	r1, sl
    d22a:	mov	r0, r7
    d22c:	bl	12640 <__ratio>
    d230:	vmov	r4, r5, d0
    d234:	movs	r2, #0
    d236:	mov.w	r3, #1073741824	; 0x40000000
    d23a:	vmov	r0, s0
    d23e:	mov	r1, r5
    d240:	bl	b7a8 <__aeabi_dcmple>
    d244:	cmp	r0, #0
    d246:	beq.n	d31c <_strtod_l+0x5e4>
    d248:	ldr	r3, [sp, #52]	; 0x34
    d24a:	cmp	r3, #0
    d24c:	beq.w	d39e <_strtod_l+0x666>
    d250:	vldr	d7, [pc, #260]	; d358 <_strtod_l+0x620>
    d254:	ldr	r3, [sp, #20]
    d256:	ldr	r5, [pc, #280]	; (d370 <_strtod_l+0x638>)
    d258:	vstr	d7, [sp, #56]	; 0x38
    d25c:	movs	r4, #0
    d25e:	mov	r8, r3
    d260:	ldr.w	r9, [pc, #276]	; d378 <_strtod_l+0x640>
    d264:	ldr	r3, [pc, #268]	; (d374 <_strtod_l+0x63c>)
    d266:	and.w	r9, r8, r9
    d26a:	cmp	r9, r3
    d26c:	beq.w	d69c <_strtod_l+0x964>
    d270:	ldr	r3, [sp, #40]	; 0x28
    d272:	cbz	r3, d2c0 <_strtod_l+0x588>
    d274:	cmp.w	r9, #111149056	; 0x6a00000
    d278:	bhi.n	d2c0 <_strtod_l+0x588>
    d27a:	add	r3, pc, #228	; (adr r3, d360 <_strtod_l+0x628>)
    d27c:	ldrd	r2, r3, [r3]
    d280:	ldrd	r0, r1, [sp, #56]	; 0x38
    d284:	bl	b7a8 <__aeabi_dcmple>
    d288:	cbz	r0, d2b8 <_strtod_l+0x580>
    d28a:	ldrd	r0, r1, [sp, #56]	; 0x38
    d28e:	bl	b860 <__aeabi_d2uiz>
    d292:	cmp	r0, #0
    d294:	beq.w	d918 <_strtod_l+0xbe0>
    d298:	bl	b1c4 <__aeabi_ui2d>
    d29c:	strd	r0, r1, [sp, #56]	; 0x38
    d2a0:	ldr	r3, [sp, #52]	; 0x34
    d2a2:	cmp	r3, #0
    d2a4:	bne.w	d90e <_strtod_l+0xbd6>
    d2a8:	ldrd	r1, r2, [sp, #56]	; 0x38
    d2ac:	add.w	r3, r2, #2147483648	; 0x80000000
    d2b0:	str	r1, [sp, #80]	; 0x50
    d2b2:	str	r3, [sp, #84]	; 0x54
    d2b4:	ldrd	r4, r5, [sp, #80]	; 0x50
    d2b8:	add.w	r3, r5, #112197632	; 0x6b00000
    d2bc:	rsb	r5, r9, r3
    d2c0:	vldr	d0, [sp, #32]
    d2c4:	bl	12460 <__ulp>
    d2c8:	mov	r0, r4
    d2ca:	vmov	r2, r3, d0
    d2ce:	mov	r1, r5
    d2d0:	bl	b2b0 <__aeabi_dmul>
    d2d4:	ldrd	r2, r3, [sp, #32]
    d2d8:	bl	af4c <__adddf3>
    d2dc:	strd	r0, r1, [sp, #16]
    d2e0:	mov	r4, r1
    d2e2:	ldr	r3, [sp, #40]	; 0x28
    d2e4:	cbnz	r3, d2f0 <_strtod_l+0x5b8>
    d2e6:	ldr	r3, [pc, #144]	; (d378 <_strtod_l+0x640>)
    d2e8:	ands	r3, r4
    d2ea:	cmp	r9, r3
    d2ec:	beq.w	d70c <_strtod_l+0x9d4>
    d2f0:	ldr	r1, [sp, #112]	; 0x70
    d2f2:	mov	r0, fp
    d2f4:	bl	11eac <_Bfree>
    d2f8:	mov	r1, r6
    d2fa:	mov	r0, fp
    d2fc:	bl	11eac <_Bfree>
    d300:	mov	r1, sl
    d302:	mov	r0, fp
    d304:	bl	11eac <_Bfree>
    d308:	mov	r1, r7
    d30a:	mov	r0, fp
    d30c:	bl	11eac <_Bfree>
    d310:	b.n	d0c2 <_strtod_l+0x38a>
    d312:	movs	r2, #0
    d314:	str	r2, [sp, #76]	; 0x4c
    d316:	movs	r2, #1
    d318:	str	r2, [sp, #56]	; 0x38
    d31a:	b.n	d14c <_strtod_l+0x414>
    d31c:	ldr	r3, [pc, #92]	; (d37c <_strtod_l+0x644>)
    d31e:	mov	r0, r4
    d320:	mov	r1, r5
    d322:	movs	r2, #0
    d324:	bl	b2b0 <__aeabi_dmul>
    d328:	ldr	r3, [sp, #52]	; 0x34
    d32a:	strd	r0, r1, [sp, #56]	; 0x38
    d32e:	cmp	r3, #0
    d330:	bne.n	d3e8 <_strtod_l+0x6b0>
    d332:	add.w	r3, r1, #2147483648	; 0x80000000
    d336:	str	r0, [sp, #64]	; 0x40
    d338:	str	r3, [sp, #68]	; 0x44
    d33a:	ldr	r3, [sp, #20]
    d33c:	ldrd	r4, r5, [sp, #64]	; 0x40
    d340:	mov	r8, r3
    d342:	b.n	d260 <_strtod_l+0x528>
    d344:	mov.w	r9, #1
    d348:	cmp	r0, #0
    d34a:	bne.n	d3fe <_strtod_l+0x6c6>
    d34c:	ldr	r3, [sp, #40]	; 0x28
    d34e:	cmp	r3, #0
    d350:	beq.w	cda4 <_strtod_l+0x6c>
    d354:	mov	r4, r0
    d356:	b.n	cfb4 <_strtod_l+0x27c>
    d358:	.word	0x00000000
    d35c:	.word	0x3ff00000
    d360:	.word	0xffc00000
    d364:	.word	0x41dfffff
    d368:	.word	0x00013e08
    d36c:	.word	0xfffffc02
    d370:	.word	0x3ff00000
    d374:	.word	0x7fe00000
    d378:	.word	0x7ff00000
    d37c:	.word	0x3fe00000
    d380:	ldr	r3, [sp, #44]	; 0x2c
    d382:	ldr	r5, [sp, #48]	; 0x30
    d384:	subs	r4, r3, r2
    d386:	b.n	d120 <_strtod_l+0x3e8>
    d388:	mov.w	r9, #1
    d38c:	b.n	ce44 <_strtod_l+0x10c>
    d38e:	ldr	r1, [pc, #736]	; (d670 <_strtod_l+0x938>)
    d390:	subs	r1, r1, r2
    d392:	movs	r2, #1
    d394:	lsl.w	r1, r2, r1
    d398:	str	r1, [sp, #76]	; 0x4c
    d39a:	str	r2, [sp, #56]	; 0x38
    d39c:	b.n	d14c <_strtod_l+0x414>
    d39e:	ldrd	r1, r2, [sp, #16]
    d3a2:	cmp	r1, #0
    d3a4:	bne.w	d53a <_strtod_l+0x802>
    d3a8:	ubfx	r3, r2, #0, #20
    d3ac:	mov	r8, r2
    d3ae:	cmp	r3, #0
    d3b0:	bne.w	d546 <_strtod_l+0x80e>
    d3b4:	movs	r2, #0
    d3b6:	ldr	r3, [pc, #700]	; (d674 <_strtod_l+0x93c>)
    d3b8:	mov	r0, r4
    d3ba:	mov	r1, r5
    d3bc:	bl	b794 <__aeabi_dcmplt>
    d3c0:	cmp	r0, #0
    d3c2:	bne.w	dac2 <_strtod_l+0xd8a>
    d3c6:	movs	r2, #0
    d3c8:	ldr	r3, [pc, #684]	; (d678 <_strtod_l+0x940>)
    d3ca:	mov	r0, r4
    d3cc:	mov	r1, r5
    d3ce:	bl	b2b0 <__aeabi_dmul>
    d3d2:	mov	r2, r1
    d3d4:	mov	r1, r0
    d3d6:	strd	r1, r2, [sp, #56]	; 0x38
    d3da:	add.w	r3, r2, #2147483648	; 0x80000000
    d3de:	str	r0, [sp, #96]	; 0x60
    d3e0:	str	r3, [sp, #100]	; 0x64
    d3e2:	ldrd	r4, r5, [sp, #96]	; 0x60
    d3e6:	b.n	d260 <_strtod_l+0x528>
    d3e8:	vldr	d7, [sp, #56]	; 0x38
    d3ec:	vstr	d7, [sp, #64]	; 0x40
    d3f0:	b.n	d33a <_strtod_l+0x602>
    d3f2:	mov.w	ip, #1
    d3f6:	adds	r3, r6, #2
    d3f8:	str	r3, [sp, #108]	; 0x6c
    d3fa:	ldrb	r3, [r6, #2]
    d3fc:	b.n	cfcc <_strtod_l+0x294>
    d3fe:	movs	r4, #0
    d400:	b.n	cfb4 <_strtod_l+0x27c>
    d402:	cmp.w	r9, #0
    d406:	bne.w	cda4 <_strtod_l+0x6c>
    d40a:	subs	r3, #73	; 0x49
    d40c:	cmp	r3, #37	; 0x25
    d40e:	bhi.w	cda4 <_strtod_l+0x6c>
    d412:	add	r2, pc, #4	; (adr r2, d418 <_strtod_l+0x6e0>)
    d414:	ldr.w	pc, [r2, r3, lsl #2]
    d418:	.word	0x0000cf7d
    d41c:	.word	0x0000cda5
    d420:	.word	0x0000cda5
    d424:	.word	0x0000cda5
    d428:	.word	0x0000cda5
    d42c:	.word	0x0000d555
    d430:	.word	0x0000cda5
    d434:	.word	0x0000cda5
    d438:	.word	0x0000cda5
    d43c:	.word	0x0000cda5
    d440:	.word	0x0000cda5
    d444:	.word	0x0000cda5
    d448:	.word	0x0000cda5
    d44c:	.word	0x0000cda5
    d450:	.word	0x0000cda5
    d454:	.word	0x0000cda5
    d458:	.word	0x0000cda5
    d45c:	.word	0x0000cda5
    d460:	.word	0x0000cda5
    d464:	.word	0x0000cda5
    d468:	.word	0x0000cda5
    d46c:	.word	0x0000cda5
    d470:	.word	0x0000cda5
    d474:	.word	0x0000cda5
    d478:	.word	0x0000cda5
    d47c:	.word	0x0000cda5
    d480:	.word	0x0000cda5
    d484:	.word	0x0000cda5
    d488:	.word	0x0000cda5
    d48c:	.word	0x0000cda5
    d490:	.word	0x0000cda5
    d494:	.word	0x0000cda5
    d498:	.word	0x0000cf7d
    d49c:	.word	0x0000cda5
    d4a0:	.word	0x0000cda5
    d4a4:	.word	0x0000cda5
    d4a8:	.word	0x0000cda5
    d4ac:	.word	0x0000d555
    d4b0:	cmp.w	r6, #308	; 0x134
    d4b4:	bgt.w	d6f6 <_strtod_l+0x9be>
    d4b8:	asrs	r6, r6, #4
    d4ba:	cmp	r6, #1
    d4bc:	ldr.w	r9, [pc, #472]	; d698 <_strtod_l+0x960>
    d4c0:	ble.w	daf6 <_strtod_l+0xdbe>
    d4c4:	ldrd	r0, r1, [sp, #16]
    d4c8:	movs	r3, #0
    d4ca:	mov	r7, r9
    d4cc:	mov	r8, r3
    d4ce:	tst.w	r6, #1
    d4d2:	add.w	r8, r8, #1
    d4d6:	mov.w	r6, r6, asr #1
    d4da:	beq.n	d4e6 <_strtod_l+0x7ae>
    d4dc:	ldrd	r2, r3, [r7]
    d4e0:	bl	b2b0 <__aeabi_dmul>
    d4e4:	movs	r3, #1
    d4e6:	cmp	r6, #1
    d4e8:	add.w	r7, r7, #8
    d4ec:	bne.n	d4ce <_strtod_l+0x796>
    d4ee:	cmp	r3, #0
    d4f0:	bne.w	dbba <_strtod_l+0xe82>
    d4f4:	ldr	r3, [sp, #20]
    d4f6:	sub.w	r3, r3, #55574528	; 0x3500000
    d4fa:	str	r3, [sp, #20]
    d4fc:	add.w	r8, r9, r8, lsl #3
    d500:	ldrd	r2, r3, [sp, #16]
    d504:	ldrd	r0, r1, [r8]
    d508:	bl	b2b0 <__aeabi_dmul>
    d50c:	bic.w	r3, r1, #2147483648	; 0x80000000
    d510:	lsrs	r3, r3, #20
    d512:	ldr	r2, [pc, #360]	; (d67c <_strtod_l+0x944>)
    d514:	lsls	r3, r3, #20
    d516:	cmp	r3, r2
    d518:	strd	r0, r1, [sp, #16]
    d51c:	bhi.w	d6f6 <_strtod_l+0x9be>
    d520:	sub.w	r2, r2, #1048576	; 0x100000
    d524:	cmp	r3, r2
    d526:	bls.w	dab8 <_strtod_l+0xd80>
    d52a:	ldr	r3, [pc, #340]	; (d680 <_strtod_l+0x948>)
    d52c:	str	r3, [sp, #20]
    d52e:	movs	r3, #0
    d530:	str	r3, [sp, #40]	; 0x28
    d532:	mov.w	r3, #4294967295
    d536:	str	r3, [sp, #16]
    d538:	b.n	d094 <_strtod_l+0x35c>
    d53a:	ldrd	r1, r2, [sp, #16]
    d53e:	cmp	r1, #1
    d540:	beq.w	d922 <_strtod_l+0xbea>
    d544:	mov	r8, r2
    d546:	vldr	d7, [pc, #288]	; d668 <_strtod_l+0x930>
    d54a:	movs	r4, #0
    d54c:	ldr	r5, [pc, #308]	; (d684 <_strtod_l+0x94c>)
    d54e:	vstr	d7, [sp, #56]	; 0x38
    d552:	b.n	d260 <_strtod_l+0x528>
    d554:	add	r0, sp, #108	; 0x6c
    d556:	ldr	r1, [pc, #304]	; (d688 <_strtod_l+0x950>)
    d558:	bl	11c18 <__match>
    d55c:	cmp	r0, #0
    d55e:	beq.w	cda4 <_strtod_l+0x6c>
    d562:	ldr	r3, [sp, #108]	; 0x6c
    d564:	ldrb	r3, [r3, #0]
    d566:	cmp	r3, #40	; 0x28
    d568:	beq.w	db70 <_strtod_l+0xe38>
    d56c:	ldr	r3, [pc, #284]	; (d68c <_strtod_l+0x954>)
    d56e:	str	r3, [sp, #20]
    d570:	movs	r3, #0
    d572:	str	r3, [sp, #16]
    d574:	b.n	cfa8 <_strtod_l+0x270>
    d576:	str	r6, [sp, #108]	; 0x6c
    d578:	movs	r2, #0
    d57a:	b.n	ce52 <_strtod_l+0x11a>
    d57c:	mov.w	ip, #0
    d580:	b.n	d3f6 <_strtod_l+0x6be>
    d582:	adds	r3, #1
    d584:	bne.w	db56 <_strtod_l+0xe1e>
    d588:	ldr	r0, [sp, #112]	; 0x70
    d58a:	ldr	r3, [pc, #260]	; (d690 <_strtod_l+0x958>)
    d58c:	str	r3, [sp, #20]
    d58e:	movs	r2, #0
    d590:	str	r2, [sp, #16]
    d592:	ldrd	r8, r9, [sp, #16]
    d596:	movs	r3, #34	; 0x22
    d598:	str.w	r3, [fp]
    d59c:	mov	r1, r0
    d59e:	mov	r0, fp
    d5a0:	bl	11eac <_Bfree>
    d5a4:	mov	r1, r6
    d5a6:	mov	r0, fp
    d5a8:	bl	11eac <_Bfree>
    d5ac:	mov	r1, sl
    d5ae:	mov	r0, fp
    d5b0:	bl	11eac <_Bfree>
    d5b4:	ldr	r1, [sp, #72]	; 0x48
    d5b6:	mov	r0, fp
    d5b8:	bl	11eac <_Bfree>
    d5bc:	mov	r1, r7
    d5be:	mov	r0, fp
    d5c0:	bl	11eac <_Bfree>
    d5c4:	b.n	ce68 <_strtod_l+0x130>
    d5c6:	ldr	r2, [sp, #28]
    d5c8:	str	r5, [sp, #8]
    d5ca:	add	r3, sp, #112	; 0x70
    d5cc:	str	r2, [sp, #4]
    d5ce:	str	r3, [sp, #0]
    d5d0:	ldr	r2, [pc, #192]	; (d694 <_strtod_l+0x95c>)
    d5d2:	add	r3, sp, #116	; 0x74
    d5d4:	add	r1, sp, #108	; 0x6c
    d5d6:	mov	r0, fp
    d5d8:	bl	11708 <__gethex>
    d5dc:	ands.w	r6, r0, #7
    d5e0:	mov	r5, r0
    d5e2:	beq.w	ce60 <_strtod_l+0x128>
    d5e6:	cmp	r6, #6
    d5e8:	bne.w	d898 <_strtod_l+0xb60>
    d5ec:	adds	r4, #1
    d5ee:	movs	r3, #0
    d5f0:	str	r4, [sp, #108]	; 0x6c
    d5f2:	mov.w	r8, #0
    d5f6:	mov.w	r9, #0
    d5fa:	str	r3, [sp, #28]
    d5fc:	b.n	ce68 <_strtod_l+0x130>
    d5fe:	ldr.w	r1, [sl]
    d602:	mov	r0, r4
    d604:	mov	r2, r9
    d606:	bl	cc5c <strncmp>
    d60a:	cbz	r0, d620 <_strtod_l+0x8e8>
    d60c:	mov.w	sl, #0
    d610:	mov	r3, r7
    d612:	mov	r8, sl
    d614:	mov	r5, sl
    d616:	mov	r0, sl
    d618:	mov	r7, sl
    d61a:	mov	r4, sl
    d61c:	mov	r9, sl
    d61e:	b.n	ce44 <_strtod_l+0x10c>
    d620:	ldr	r3, [sp, #108]	; 0x6c
    d622:	add.w	r2, r3, r9
    d626:	str	r2, [sp, #108]	; 0x6c
    d628:	ldrb.w	r3, [r3, r9]
    d62c:	cmp	r3, #48	; 0x30
    d62e:	bne.n	d63e <_strtod_l+0x906>
    d630:	adds	r2, #1
    d632:	str	r2, [sp, #108]	; 0x6c
    d634:	ldrb	r3, [r2, #0]
    d636:	cmp	r3, #48	; 0x30
    d638:	add.w	r0, r0, #1
    d63c:	beq.n	d630 <_strtod_l+0x8f8>
    d63e:	sub.w	r2, r3, #49	; 0x31
    d642:	cmp	r2, #8
    d644:	bls.w	d940 <_strtod_l+0xc08>
    d648:	mov.w	sl, #0
    d64c:	cmp	r3, #101	; 0x65
    d64e:	mov	r8, sl
    d650:	mov	r5, sl
    d652:	mov	r7, sl
    d654:	beq.w	d344 <_strtod_l+0x60c>
    d658:	mov	r4, sl
    d65a:	mov.w	r9, #1
    d65e:	b.w	ce4a <_strtod_l+0x112>
    d662:	nop
    d664:	nop.w
    d668:	.word	0x00000000
    d66c:	.word	0x3ff00000
    d670:	.word	0xfffffbe2
    d674:	.word	0x3ff00000
    d678:	.word	0x3fe00000
    d67c:	.word	0x7ca00000
    d680:	.word	0x7fefffff
    d684:	.word	0xbff00000
    d688:	.word	0x00013b1c
    d68c:	.word	0xfff80000
    d690:	.word	0x7ff00000
    d694:	.word	0x00013afc
    d698:	.word	0x00013ed0
    d69c:	sub.w	r3, r8, #55574528	; 0x3500000
    d6a0:	str	r3, [sp, #20]
    d6a2:	vldr	d7, [sp, #16]
    d6a6:	vmov.f32	s0, s14
    d6aa:	vmov.f32	s1, s15
    d6ae:	bl	12460 <__ulp>
    d6b2:	mov	r0, r4
    d6b4:	vmov	r2, r3, d0
    d6b8:	mov	r1, r5
    d6ba:	bl	b2b0 <__aeabi_dmul>
    d6be:	ldrd	r2, r3, [sp, #16]
    d6c2:	bl	af4c <__adddf3>
    d6c6:	bic.w	r3, r1, #2147483648	; 0x80000000
    d6ca:	strd	r0, r1, [sp, #16]
    d6ce:	lsrs	r3, r3, #20
    d6d0:	ldr	r2, [pc, #684]	; (d980 <_strtod_l+0xc48>)
    d6d2:	ldrd	r0, r1, [sp, #32]
    d6d6:	lsls	r3, r3, #20
    d6d8:	cmp	r3, r2
    d6da:	strd	r0, r1, [sp, #88]	; 0x58
    d6de:	bls.w	d856 <_strtod_l+0xb1e>
    d6e2:	ldr	r3, [pc, #672]	; (d984 <_strtod_l+0xc4c>)
    d6e4:	cmp	r1, r3
    d6e6:	beq.w	daae <_strtod_l+0xd76>
    d6ea:	ldr	r3, [pc, #664]	; (d984 <_strtod_l+0xc4c>)
    d6ec:	str	r3, [sp, #20]
    d6ee:	mov.w	r3, #4294967295
    d6f2:	str	r3, [sp, #16]
    d6f4:	b.n	d2f0 <_strtod_l+0x5b8>
    d6f6:	ldr	r3, [pc, #656]	; (d988 <_strtod_l+0xc50>)
    d6f8:	str	r3, [sp, #20]
    d6fa:	movs	r2, #0
    d6fc:	movs	r3, #34	; 0x22
    d6fe:	str	r2, [sp, #16]
    d700:	ldrd	r8, r9, [sp, #16]
    d704:	str.w	r3, [fp]
    d708:	b.w	ce68 <_strtod_l+0x130>
    d70c:	ldrd	r8, r9, [sp, #56]	; 0x38
    d710:	mov	r1, r9
    d712:	mov	r0, r8
    d714:	bl	b810 <__aeabi_d2iz>
    d718:	bl	b1e4 <__aeabi_i2d>
    d71c:	mov	r3, r1
    d71e:	mov	r2, r0
    d720:	mov	r1, r9
    d722:	mov	r0, r8
    d724:	bl	af48 <__aeabi_dsub>
    d728:	ldr	r3, [sp, #52]	; 0x34
    d72a:	mov	r8, r0
    d72c:	mov	r9, r1
    d72e:	cbnz	r3, d752 <_strtod_l+0xa1a>
    d730:	ldr	r3, [sp, #16]
    d732:	cbnz	r3, d752 <_strtod_l+0xa1a>
    d734:	ubfx	r4, r4, #0, #20
    d738:	cbnz	r4, d752 <_strtod_l+0xa1a>
    d73a:	add	r3, pc, #548	; (adr r3, d960 <_strtod_l+0xc28>)
    d73c:	ldrd	r2, r3, [r3]
    d740:	bl	b794 <__aeabi_dcmplt>
    d744:	cmp	r0, #0
    d746:	beq.w	d2f0 <_strtod_l+0x5b8>
    d74a:	ldrd	r8, r9, [sp, #16]
    d74e:	ldr	r0, [sp, #112]	; 0x70
    d750:	b.n	d59c <_strtod_l+0x864>
    d752:	add	r3, pc, #532	; (adr r3, d968 <_strtod_l+0xc30>)
    d754:	ldrd	r2, r3, [r3]
    d758:	mov	r0, r8
    d75a:	mov	r1, r9
    d75c:	bl	b794 <__aeabi_dcmplt>
    d760:	cmp	r0, #0
    d762:	bne.n	d74a <_strtod_l+0xa12>
    d764:	mov	r0, r8
    d766:	mov	r1, r9
    d768:	add	r3, pc, #516	; (adr r3, d970 <_strtod_l+0xc38>)
    d76a:	ldrd	r2, r3, [r3]
    d76e:	bl	b7d0 <__aeabi_dcmpgt>
    d772:	cmp	r0, #0
    d774:	beq.w	d2f0 <_strtod_l+0x5b8>
    d778:	b.n	d74a <_strtod_l+0xa12>
    d77a:	beq.w	d090 <_strtod_l+0x358>
    d77e:	rsb	r6, r9, #0
    d782:	ands.w	r2, r6, #15
    d786:	beq.n	d79e <_strtod_l+0xa66>
    d788:	ldr	r3, [pc, #512]	; (d98c <_strtod_l+0xc54>)
    d78a:	add.w	r3, r3, r2, lsl #3
    d78e:	ldrd	r0, r1, [sp, #16]
    d792:	ldrd	r2, r3, [r3]
    d796:	bl	b504 <__aeabi_ddiv>
    d79a:	strd	r0, r1, [sp, #16]
    d79e:	asrs	r6, r6, #4
    d7a0:	beq.w	d090 <_strtod_l+0x358>
    d7a4:	cmp	r6, #31
    d7a6:	bgt.n	d81a <_strtod_l+0xae2>
    d7a8:	ands.w	r3, r6, #16
    d7ac:	beq.w	db20 <_strtod_l+0xde8>
    d7b0:	movs	r3, #106	; 0x6a
    d7b2:	cmp	r6, #0
    d7b4:	str	r3, [sp, #40]	; 0x28
    d7b6:	ble.n	d7e0 <_strtod_l+0xaa8>
    d7b8:	ldrd	r0, r1, [sp, #16]
    d7bc:	ldr	r7, [pc, #464]	; (d990 <_strtod_l+0xc58>)
    d7be:	movs	r3, #0
    d7c0:	lsls	r2, r6, #31
    d7c2:	bpl.n	d7ce <_strtod_l+0xa96>
    d7c4:	ldrd	r2, r3, [r7]
    d7c8:	bl	b2b0 <__aeabi_dmul>
    d7cc:	movs	r3, #1
    d7ce:	asrs	r6, r6, #1
    d7d0:	add.w	r7, r7, #8
    d7d4:	bne.n	d7c0 <_strtod_l+0xa88>
    d7d6:	cmp	r3, #0
    d7d8:	bne.w	dbc0 <_strtod_l+0xe88>
    d7dc:	ldr	r3, [sp, #40]	; 0x28
    d7de:	cbz	r3, d808 <_strtod_l+0xad0>
    d7e0:	ldrd	r1, r2, [sp, #16]
    d7e4:	ubfx	r3, r2, #20, #11
    d7e8:	rsb	r3, r3, #107	; 0x6b
    d7ec:	cmp	r3, #0
    d7ee:	mov	r1, r2
    d7f0:	ble.n	d808 <_strtod_l+0xad0>
    d7f2:	cmp	r3, #31
    d7f4:	ble.w	dbaa <_strtod_l+0xe72>
    d7f8:	movs	r2, #0
    d7fa:	cmp	r3, #52	; 0x34
    d7fc:	str	r2, [sp, #16]
    d7fe:	ble.w	dbc6 <_strtod_l+0xe8e>
    d802:	mov.w	r3, #57671680	; 0x3700000
    d806:	str	r3, [sp, #20]
    d808:	movs	r2, #0
    d80a:	movs	r3, #0
    d80c:	ldrd	r0, r1, [sp, #16]
    d810:	bl	b780 <__aeabi_dcmpeq>
    d814:	cmp	r0, #0
    d816:	beq.w	d094 <_strtod_l+0x35c>
    d81a:	movs	r3, #34	; 0x22
    d81c:	str.w	r3, [fp]
    d820:	mov.w	r8, #0
    d824:	mov.w	r9, #0
    d828:	b.w	ce68 <_strtod_l+0x130>
    d82c:	ldr	r1, [sp, #108]	; 0x6c
    d82e:	adds	r4, #1
    d830:	cmp	r0, #8
    d832:	ble.w	d952 <_strtod_l+0xc1a>
    d836:	cmp	r4, #16
    d838:	itt	le
    d83a:	addle.w	r8, r8, r8, lsl #2
    d83e:	addle.w	r8, r2, r8, lsl #1
    d842:	movs	r0, #0
    d844:	adds	r3, r1, #1
    d846:	str	r3, [sp, #108]	; 0x6c
    d848:	ldrb	r3, [r1, #1]
    d84a:	b.w	ce8c <_strtod_l+0x154>
    d84e:	movw	r2, #19999	; 0x4e1f
    d852:	b.w	d03e <_strtod_l+0x306>
    d856:	ldr	r3, [sp, #20]
    d858:	add.w	r4, r3, #55574528	; 0x3500000
    d85c:	str	r4, [sp, #20]
    d85e:	b.n	d2e2 <_strtod_l+0x5aa>
    d860:	ldr	r6, [sp, #44]	; 0x2c
    d862:	rsb	r3, r4, #37	; 0x25
    d866:	cmp	r6, r3
    d868:	bgt.w	d05c <_strtod_l+0x324>
    d86c:	ldr	r5, [pc, #284]	; (d98c <_strtod_l+0xc54>)
    d86e:	rsb	r4, r4, #15
    d872:	add.w	r1, r5, r4, lsl #3
    d876:	subs	r4, r6, r4
    d878:	ldrd	r2, r3, [sp, #16]
    d87c:	ldrd	r0, r1, [r1]
    d880:	add.w	r5, r5, r4, lsl #3
    d884:	bl	b2b0 <__aeabi_dmul>
    d888:	ldrd	r2, r3, [r5]
    d88c:	bl	b2b0 <__aeabi_dmul>
    d890:	mov	r8, r0
    d892:	mov	r9, r1
    d894:	b.w	ce68 <_strtod_l+0x130>
    d898:	ldr	r2, [sp, #112]	; 0x70
    d89a:	cbz	r2, d8ac <_strtod_l+0xb74>
    d89c:	movs	r1, #53	; 0x35
    d89e:	add	r0, sp, #120	; 0x78
    d8a0:	bl	126a0 <__copybits>
    d8a4:	mov	r0, fp
    d8a6:	ldr	r1, [sp, #112]	; 0x70
    d8a8:	bl	11eac <_Bfree>
    d8ac:	cmp	r6, #6
    d8ae:	bhi.n	d8c8 <_strtod_l+0xb90>
    d8b0:	tbb	[pc, r6]
    d8b4:	.word	0x1318211d
    d8b8:	.short	0x2104
    d8ba:	.byte	0x1d
    d8bb:	.byte	0x00
    d8bc:	mvn.w	r3, #2147483648	; 0x80000000
    d8c0:	str	r3, [sp, #20]
    d8c2:	mov.w	r3, #4294967295
    d8c6:	str	r3, [sp, #16]
    d8c8:	lsls	r1, r5, #28
    d8ca:	bpl.w	cfa8 <_strtod_l+0x270>
    d8ce:	ldr	r3, [sp, #20]
    d8d0:	orr.w	r3, r3, #2147483648	; 0x80000000
    d8d4:	str	r3, [sp, #20]
    d8d6:	b.w	cfa8 <_strtod_l+0x270>
    d8da:	ldr	r3, [pc, #172]	; (d988 <_strtod_l+0xc50>)
    d8dc:	str	r3, [sp, #20]
    d8de:	movs	r3, #0
    d8e0:	str	r3, [sp, #16]
    d8e2:	b.n	d8c8 <_strtod_l+0xb90>
    d8e4:	ldr	r3, [sp, #120]	; 0x78
    d8e6:	str	r3, [sp, #16]
    d8e8:	ldr	r3, [sp, #124]	; 0x7c
    d8ea:	str	r3, [sp, #20]
    d8ec:	b.n	d8c8 <_strtod_l+0xb90>
    d8ee:	movs	r3, #0
    d8f0:	str	r3, [sp, #20]
    d8f2:	str	r3, [sp, #16]
    d8f4:	b.n	d8c8 <_strtod_l+0xb90>
    d8f6:	ldr	r2, [sp, #116]	; 0x74
    d8f8:	ldr	r3, [sp, #124]	; 0x7c
    d8fa:	ldr	r1, [sp, #120]	; 0x78
    d8fc:	str	r1, [sp, #16]
    d8fe:	addw	r2, r2, #1075	; 0x433
    d902:	bic.w	r3, r3, #1048576	; 0x100000
    d906:	orr.w	r3, r3, r2, lsl #20
    d90a:	str	r3, [sp, #20]
    d90c:	b.n	d8c8 <_strtod_l+0xb90>
    d90e:	vldr	d7, [sp, #56]	; 0x38
    d912:	vstr	d7, [sp, #80]	; 0x50
    d916:	b.n	d2b4 <_strtod_l+0x57c>
    d918:	vldr	d7, [pc, #92]	; d978 <_strtod_l+0xc40>
    d91c:	vstr	d7, [sp, #56]	; 0x38
    d920:	b.n	d2a0 <_strtod_l+0x568>
    d922:	ldrd	r1, r2, [sp, #16]
    d926:	mov	r8, r2
    d928:	cmp	r2, #0
    d92a:	bne.w	d546 <_strtod_l+0x80e>
    d92e:	movs	r3, #34	; 0x22
    d930:	str.w	r3, [fp]
    d934:	ldr	r0, [sp, #112]	; 0x70
    d936:	mov.w	r8, #0
    d93a:	mov.w	r9, #0
    d93e:	b.n	d59c <_strtod_l+0x864>
    d940:	ldr	r2, [sp, #108]	; 0x6c
    d942:	str	r2, [sp, #32]
    d944:	movs	r5, #0
    d946:	subs	r3, #48	; 0x30
    d948:	adds	r7, r0, #1
    d94a:	mov	r1, r2
    d94c:	mov	sl, r5
    d94e:	mov	r8, r5
    d950:	movs	r4, #1
    d952:	add.w	r5, r5, r5, lsl #2
    d956:	add.w	r5, r3, r5, lsl #1
    d95a:	movs	r0, #0
    d95c:	b.n	d844 <_strtod_l+0xb0c>
    d95e:	nop
    d960:	.word	0x94a03595
    d964:	.word	0x3fcfffff
    d968:	.word	0x94a03595
    d96c:	.word	0x3fdfffff
    d970:	.word	0x35afe535
    d974:	.word	0x3fe00000
    d978:	.word	0x00000000
    d97c:	.word	0x3ff00000
    d980:	.word	0x7c9fffff
    d984:	.word	0x7fefffff
    d988:	.word	0x7ff00000
    d98c:	.word	0x00013e08
    d990:	.word	0x00013b38
    d994:	ldr	r1, [sp, #44]	; 0x2c
    d996:	cmn.w	r1, #22
    d99a:	blt.w	d05c <_strtod_l+0x324>
    d99e:	ldr	r2, [pc, #600]	; (dbf8 <_strtod_l+0xec0>)
    d9a0:	sub.w	r2, r2, r1, lsl #3
    d9a4:	ldrd	r2, r3, [r2]
    d9a8:	ldrd	r0, r1, [sp, #16]
    d9ac:	bl	b504 <__aeabi_ddiv>
    d9b0:	mov	r8, r0
    d9b2:	mov	r9, r1
    d9b4:	b.w	ce68 <_strtod_l+0x130>
    d9b8:	ldr	r3, [sp, #52]	; 0x34
    d9ba:	ldrd	r8, r9, [sp, #32]
    d9be:	cmp	r3, #0
    d9c0:	beq.w	dad4 <_strtod_l+0xd9c>
    d9c4:	ldrd	r4, r5, [sp, #16]
    d9c8:	ldr	r3, [pc, #560]	; (dbfc <_strtod_l+0xec4>)
    d9ca:	ubfx	r1, r5, #0, #20
    d9ce:	cmp	r1, r3
    d9d0:	mov	r2, r5
    d9d2:	beq.w	db2a <_strtod_l+0xdf2>
    d9d6:	ldr	r3, [sp, #76]	; 0x4c
    d9d8:	cmp	r3, #0
    d9da:	beq.w	daec <_strtod_l+0xdb4>
    d9de:	ldr	r2, [sp, #20]
    d9e0:	tst	r3, r2
    d9e2:	beq.n	da06 <_strtod_l+0xcce>
    d9e4:	ldr	r3, [sp, #52]	; 0x34
    d9e6:	ldr	r2, [sp, #40]	; 0x28
    d9e8:	ldrd	r0, r1, [sp, #16]
    d9ec:	cmp	r3, #0
    d9ee:	beq.w	dafc <_strtod_l+0xdc4>
    d9f2:	bl	ccfc <sulp>
    d9f6:	mov	r2, r0
    d9f8:	mov	r3, r1
    d9fa:	mov	r0, r8
    d9fc:	mov	r1, r9
    d9fe:	bl	af4c <__adddf3>
    da02:	mov	r8, r0
    da04:	mov	r9, r1
    da06:	ldr	r3, [sp, #40]	; 0x28
    da08:	cbz	r3, da3a <_strtod_l+0xd02>
    da0a:	ldr	r3, [pc, #500]	; (dc00 <_strtod_l+0xec8>)
    da0c:	str	r3, [sp, #92]	; 0x5c
    da0e:	movs	r3, #0
    da10:	str	r3, [sp, #88]	; 0x58
    da12:	ldrd	r2, r3, [sp, #88]	; 0x58
    da16:	mov	r0, r8
    da18:	mov	r1, r9
    da1a:	bl	b2b0 <__aeabi_dmul>
    da1e:	mov	r3, r0
    da20:	mov	r4, r1
    da22:	mov	r8, r0
    da24:	mov	r9, r1
    da26:	strd	r3, r4, [sp, #16]
    da2a:	cbnz	r1, da3a <_strtod_l+0xd02>
    da2c:	ldr	r3, [sp, #16]
    da2e:	cbnz	r3, da3a <_strtod_l+0xd02>
    da30:	movs	r3, #34	; 0x22
    da32:	ldr	r0, [sp, #112]	; 0x70
    da34:	str.w	r3, [fp]
    da38:	b.n	d59c <_strtod_l+0x864>
    da3a:	ldr	r0, [sp, #112]	; 0x70
    da3c:	b.n	d59c <_strtod_l+0x864>
    da3e:	ldr	r3, [sp, #52]	; 0x34
    da40:	ldrd	r8, r9, [sp, #32]
    da44:	cmp	r3, #0
    da46:	bne.n	da06 <_strtod_l+0xcce>
    da48:	ldrd	r1, r2, [sp, #16]
    da4c:	cmp	r1, #0
    da4e:	bne.n	da06 <_strtod_l+0xcce>
    da50:	ubfx	r3, r2, #0, #20
    da54:	mov	r4, r2
    da56:	cmp	r3, #0
    da58:	bne.n	da06 <_strtod_l+0xcce>
    da5a:	bic.w	r3, r2, #2147483648	; 0x80000000
    da5e:	lsrs	r3, r3, #20
    da60:	lsls	r3, r3, #20
    da62:	cmp.w	r3, #112197632	; 0x6b00000
    da66:	bls.n	da06 <_strtod_l+0xcce>
    da68:	ldr	r3, [r7, #20]
    da6a:	cbnz	r3, da72 <_strtod_l+0xd3a>
    da6c:	ldr	r3, [r7, #16]
    da6e:	cmp	r3, #1
    da70:	ble.n	da06 <_strtod_l+0xcce>
    da72:	mov	r1, r7
    da74:	movs	r2, #1
    da76:	mov	r0, fp
    da78:	bl	12258 <__lshift>
    da7c:	mov	r1, sl
    da7e:	mov	r7, r0
    da80:	bl	12308 <__mcmp>
    da84:	cmp	r0, #0
    da86:	ble.n	da06 <_strtod_l+0xcce>
    da88:	ldr	r3, [sp, #40]	; 0x28
    da8a:	cmp	r3, #0
    da8c:	bne.w	db94 <_strtod_l+0xe5c>
    da90:	ldr	r3, [pc, #368]	; (dc04 <_strtod_l+0xecc>)
    da92:	ands	r3, r4
    da94:	sub.w	r3, r3, #1048576	; 0x100000
    da98:	mvn.w	r3, r3, lsr #20
    da9c:	mvn.w	r3, r3, lsl #20
    daa0:	str	r3, [sp, #20]
    daa2:	mov.w	r3, #4294967295
    daa6:	str	r3, [sp, #16]
    daa8:	ldrd	r8, r9, [sp, #16]
    daac:	b.n	da06 <_strtod_l+0xcce>
    daae:	ldr	r3, [sp, #88]	; 0x58
    dab0:	adds	r3, #1
    dab2:	bne.w	d6ea <_strtod_l+0x9b2>
    dab6:	b.n	d588 <_strtod_l+0x850>
    dab8:	add.w	r3, r1, #55574528	; 0x3500000
    dabc:	str	r3, [sp, #20]
    dabe:	b.w	d090 <_strtod_l+0x358>
    dac2:	vldr	d7, [pc, #292]	; dbe8 <_strtod_l+0xeb0>
    dac6:	vstr	d7, [sp, #96]	; 0x60
    daca:	vldr	d7, [pc, #292]	; dbf0 <_strtod_l+0xeb8>
    dace:	vstr	d7, [sp, #56]	; 0x38
    dad2:	b.n	d3e2 <_strtod_l+0x6aa>
    dad4:	ldrd	r1, r2, [sp, #16]
    dad8:	ubfx	r3, r2, #0, #20
    dadc:	mov	r4, r2
    dade:	cmp	r3, #0
    dae0:	bne.w	d9d6 <_strtod_l+0xc9e>
    dae4:	cmp	r1, #0
    dae6:	bne.w	d9d6 <_strtod_l+0xc9e>
    daea:	b.n	da88 <_strtod_l+0xd50>
    daec:	ldr	r3, [sp, #56]	; 0x38
    daee:	ldr	r2, [sp, #16]
    daf0:	tst	r3, r2
    daf2:	beq.n	da06 <_strtod_l+0xcce>
    daf4:	b.n	d9e4 <_strtod_l+0xcac>
    daf6:	mov.w	r8, #0
    dafa:	b.n	d4f4 <_strtod_l+0x7bc>
    dafc:	bl	ccfc <sulp>
    db00:	mov	r2, r0
    db02:	mov	r3, r1
    db04:	mov	r0, r8
    db06:	mov	r1, r9
    db08:	bl	af48 <__aeabi_dsub>
    db0c:	movs	r2, #0
    db0e:	movs	r3, #0
    db10:	mov	r8, r0
    db12:	mov	r9, r1
    db14:	bl	b780 <__aeabi_dcmpeq>
    db18:	cmp	r0, #0
    db1a:	bne.w	d92e <_strtod_l+0xbf6>
    db1e:	b.n	da06 <_strtod_l+0xcce>
    db20:	cmp	r6, #0
    db22:	str	r3, [sp, #40]	; 0x28
    db24:	bgt.w	d7b8 <_strtod_l+0xa80>
    db28:	b.n	d808 <_strtod_l+0xad0>
    db2a:	ldr	r3, [sp, #40]	; 0x28
    db2c:	ldr	r1, [sp, #16]
    db2e:	cbz	r3, db6a <_strtod_l+0xe32>
    db30:	ldr	r3, [pc, #208]	; (dc04 <_strtod_l+0xecc>)
    db32:	ands	r3, r5
    db34:	cmp.w	r3, #111149056	; 0x6a00000
    db38:	bhi.n	db6a <_strtod_l+0xe32>
    db3a:	lsrs	r3, r3, #20
    db3c:	rsb	r3, r3, #107	; 0x6b
    db40:	mov.w	r0, #4294967295
    db44:	lsl.w	r3, r0, r3
    db48:	cmp	r3, r1
    db4a:	bne.w	d9d6 <_strtod_l+0xc9e>
    db4e:	ldr	r1, [pc, #184]	; (dc08 <_strtod_l+0xed0>)
    db50:	cmp	r2, r1
    db52:	beq.w	d582 <_strtod_l+0x84a>
    db56:	ldr	r3, [pc, #172]	; (dc04 <_strtod_l+0xecc>)
    db58:	ands	r3, r2
    db5a:	add.w	r3, r3, #1048576	; 0x100000
    db5e:	str	r3, [sp, #20]
    db60:	movs	r3, #0
    db62:	str	r3, [sp, #16]
    db64:	ldrd	r8, r9, [sp, #16]
    db68:	b.n	da06 <_strtod_l+0xcce>
    db6a:	mov.w	r3, #4294967295
    db6e:	b.n	db48 <_strtod_l+0xe10>
    db70:	add	r0, sp, #108	; 0x6c
    db72:	add	r2, sp, #120	; 0x78
    db74:	ldr	r1, [pc, #148]	; (dc0c <_strtod_l+0xed4>)
    db76:	bl	11c48 <__hexnan>
    db7a:	cmp	r0, #5
    db7c:	bne.w	d56c <_strtod_l+0x834>
    db80:	ldr	r3, [sp, #124]	; 0x7c
    db82:	orr.w	r3, r3, #2139095040	; 0x7f800000
    db86:	orr.w	r3, r3, #7340032	; 0x700000
    db8a:	str	r3, [sp, #20]
    db8c:	ldr	r3, [sp, #120]	; 0x78
    db8e:	str	r3, [sp, #16]
    db90:	b.w	cfa8 <_strtod_l+0x270>
    db94:	ldr	r3, [pc, #108]	; (dc04 <_strtod_l+0xecc>)
    db96:	ands	r3, r4
    db98:	cmp.w	r3, #112197632	; 0x6b00000
    db9c:	bgt.w	da94 <_strtod_l+0xd5c>
    dba0:	cmp.w	r3, #57671680	; 0x3700000
    dba4:	bgt.w	da0a <_strtod_l+0xcd2>
    dba8:	b.n	d92e <_strtod_l+0xbf6>
    dbaa:	mov.w	r2, #4294967295
    dbae:	lsl.w	r3, r2, r3
    dbb2:	ldr	r2, [sp, #16]
    dbb4:	ands	r2, r3
    dbb6:	str	r2, [sp, #16]
    dbb8:	b.n	d808 <_strtod_l+0xad0>
    dbba:	strd	r0, r1, [sp, #16]
    dbbe:	b.n	d4f4 <_strtod_l+0x7bc>
    dbc0:	strd	r0, r1, [sp, #16]
    dbc4:	b.n	d7dc <_strtod_l+0xaa4>
    dbc6:	subs	r3, #32
    dbc8:	mov.w	r2, #4294967295
    dbcc:	lsl.w	r3, r2, r3
    dbd0:	ands	r3, r1
    dbd2:	str	r3, [sp, #20]
    dbd4:	b.n	d808 <_strtod_l+0xad0>
    dbd6:	mov	r0, r4
    dbd8:	ldr	r1, [sp, #108]	; 0x6c
    dbda:	adds	r4, #1
    dbdc:	b.n	d830 <_strtod_l+0xaf8>
    dbde:	mov	r0, r1
    dbe0:	ldr	r1, [sp, #108]	; 0x6c
    dbe2:	b.n	d844 <_strtod_l+0xb0c>
    dbe4:	nop.w
    dbe8:	.word	0x00000000
    dbec:	.word	0xbfe00000
    dbf0:	.word	0x00000000
    dbf4:	.word	0x3fe00000
    dbf8:	.word	0x00013e08
    dbfc:	.word	0x000fffff
    dc00:	.word	0x39500000
    dc04:	.word	0x7ff00000
    dc08:	.word	0x7fefffff
    dc0c:	.word	0x00013b20

0000dc10 <_strtod_r>:
    dc10:	ldr	r3, [pc, #20]	; (dc28 <_strtod_r+0x18>)
    dc12:	ldr	r3, [r3, #0]
    dc14:	push	{r4}
    dc16:	ldr	r3, [r3, #52]	; 0x34
    dc18:	ldr	r4, [pc, #16]	; (dc2c <_strtod_r+0x1c>)
    dc1a:	cmp	r3, #0
    dc1c:	it	eq
    dc1e:	moveq	r3, r4
    dc20:	ldr.w	r4, [sp], #4
    dc24:	b.w	cd38 <_strtod_l>
    dc28:	.word	0x20013dc8
    dc2c:	.word	0x20013dcc

0000dc30 <_strtol_l.isra.0>:
    dc30:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dc34:	ldr.w	r9, [sp, #40]	; 0x28
    dc38:	mov	r7, r1
    dc3a:	mov	r8, r0
    dc3c:	mov	r6, r2
    dc3e:	mov	r5, r3
    dc40:	mov	fp, r1
    dc42:	b.n	dc46 <_strtol_l.isra.0+0x16>
    dc44:	mov	fp, r4
    dc46:	mov	r4, fp
    dc48:	mov	r0, r9
    dc4a:	ldrb.w	sl, [r4], #1
    dc4e:	bl	bcf4 <__locale_ctype_ptr_l>
    dc52:	add	r0, sl
    dc54:	ldrb	r1, [r0, #1]
    dc56:	and.w	r1, r1, #8
    dc5a:	and.w	ip, r1, #255	; 0xff
    dc5e:	cmp	r1, #0
    dc60:	bne.n	dc44 <_strtol_l.isra.0+0x14>
    dc62:	mov	r2, sl
    dc64:	cmp	r2, #45	; 0x2d
    dc66:	beq.n	dd2c <_strtol_l.isra.0+0xfc>
    dc68:	cmp	r2, #43	; 0x2b
    dc6a:	itt	eq
    dc6c:	ldrbeq.w	r2, [fp, #1]
    dc70:	addeq.w	r4, fp, #2
    dc74:	cmp	r5, #0
    dc76:	beq.n	dd00 <_strtol_l.isra.0+0xd0>
    dc78:	cmp	r5, #16
    dc7a:	beq.n	dd48 <_strtol_l.isra.0+0x118>
    dc7c:	mov	r9, r5
    dc7e:	cmp.w	ip, #0
    dc82:	ite	eq
    dc84:	mvneq.w	sl, #2147483648	; 0x80000000
    dc88:	movne.w	sl, #2147483648	; 0x80000000
    dc8c:	movs	r1, #0
    dc8e:	udiv	lr, sl, r9
    dc92:	mov	r0, r1
    dc94:	mls	sl, r9, lr, sl
    dc98:	b.n	dca6 <_strtol_l.isra.0+0x76>
    dc9a:	beq.n	dcf0 <_strtol_l.isra.0+0xc0>
    dc9c:	mla	r0, r9, r0, r3
    dca0:	movs	r1, #1
    dca2:	ldrb.w	r2, [r4], #1
    dca6:	sub.w	r3, r2, #48	; 0x30
    dcaa:	cmp	r3, #9
    dcac:	bls.n	dcba <_strtol_l.isra.0+0x8a>
    dcae:	sub.w	r3, r2, #65	; 0x41
    dcb2:	cmp	r3, #25
    dcb4:	bhi.n	dccc <_strtol_l.isra.0+0x9c>
    dcb6:	sub.w	r3, r2, #55	; 0x37
    dcba:	cmp	r5, r3
    dcbc:	ble.n	dcdc <_strtol_l.isra.0+0xac>
    dcbe:	adds	r2, r1, #1
    dcc0:	beq.n	dca2 <_strtol_l.isra.0+0x72>
    dcc2:	cmp	lr, r0
    dcc4:	bcs.n	dc9a <_strtol_l.isra.0+0x6a>
    dcc6:	mov.w	r1, #4294967295
    dcca:	b.n	dca2 <_strtol_l.isra.0+0x72>
    dccc:	sub.w	r3, r2, #97	; 0x61
    dcd0:	cmp	r3, #25
    dcd2:	bhi.n	dcdc <_strtol_l.isra.0+0xac>
    dcd4:	sub.w	r3, r2, #87	; 0x57
    dcd8:	cmp	r5, r3
    dcda:	bgt.n	dcbe <_strtol_l.isra.0+0x8e>
    dcdc:	adds	r3, r1, #1
    dcde:	beq.n	dd0c <_strtol_l.isra.0+0xdc>
    dce0:	cmp.w	ip, #0
    dce4:	bne.n	dd08 <_strtol_l.isra.0+0xd8>
    dce6:	cbz	r6, dcfc <_strtol_l.isra.0+0xcc>
    dce8:	cbnz	r1, dd24 <_strtol_l.isra.0+0xf4>
    dcea:	str	r7, [r6, #0]
    dcec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dcf0:	cmp	sl, r3
    dcf2:	bge.n	dc9c <_strtol_l.isra.0+0x6c>
    dcf4:	mov	r0, lr
    dcf6:	mov.w	r1, #4294967295
    dcfa:	b.n	dca2 <_strtol_l.isra.0+0x72>
    dcfc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd00:	cmp	r2, #48	; 0x30
    dd02:	beq.n	dd3a <_strtol_l.isra.0+0x10a>
    dd04:	movs	r5, #10
    dd06:	b.n	dc7c <_strtol_l.isra.0+0x4c>
    dd08:	negs	r0, r0
    dd0a:	b.n	dce6 <_strtol_l.isra.0+0xb6>
    dd0c:	cmp.w	ip, #0
    dd10:	mov.w	r3, #34	; 0x22
    dd14:	ite	eq
    dd16:	mvneq.w	r0, #2147483648	; 0x80000000
    dd1a:	movne.w	r0, #2147483648	; 0x80000000
    dd1e:	str.w	r3, [r8]
    dd22:	cbz	r6, dd62 <_strtol_l.isra.0+0x132>
    dd24:	subs	r7, r4, #1
    dd26:	str	r7, [r6, #0]
    dd28:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd2c:	add.w	r4, fp, #2
    dd30:	ldrb.w	r2, [fp, #1]
    dd34:	mov.w	ip, #1
    dd38:	b.n	dc74 <_strtol_l.isra.0+0x44>
    dd3a:	ldrb	r3, [r4, #0]
    dd3c:	and.w	r3, r3, #223	; 0xdf
    dd40:	cmp	r3, #88	; 0x58
    dd42:	beq.n	dd56 <_strtol_l.isra.0+0x126>
    dd44:	movs	r5, #8
    dd46:	b.n	dc7c <_strtol_l.isra.0+0x4c>
    dd48:	cmp	r2, #48	; 0x30
    dd4a:	bne.n	dc7c <_strtol_l.isra.0+0x4c>
    dd4c:	ldrb	r3, [r4, #0]
    dd4e:	and.w	r3, r3, #223	; 0xdf
    dd52:	cmp	r3, #88	; 0x58
    dd54:	bne.n	dc7c <_strtol_l.isra.0+0x4c>
    dd56:	mov.w	r9, #16
    dd5a:	ldrb	r2, [r4, #1]
    dd5c:	mov	r5, r9
    dd5e:	adds	r4, #2
    dd60:	b.n	dc7e <_strtol_l.isra.0+0x4e>
    dd62:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd66:	nop

0000dd68 <_strtol_r>:
    dd68:	push	{r4, r5, lr}
    dd6a:	ldr	r4, [pc, #24]	; (dd84 <_strtol_r+0x1c>)
    dd6c:	ldr	r5, [pc, #24]	; (dd88 <_strtol_r+0x20>)
    dd6e:	ldr	r4, [r4, #0]
    dd70:	ldr	r4, [r4, #52]	; 0x34
    dd72:	sub	sp, #12
    dd74:	cmp	r4, #0
    dd76:	it	eq
    dd78:	moveq	r4, r5
    dd7a:	str	r4, [sp, #0]
    dd7c:	bl	dc30 <_strtol_l.isra.0>
    dd80:	add	sp, #12
    dd82:	pop	{r4, r5, pc}
    dd84:	.word	0x20013dc8
    dd88:	.word	0x20013dcc
    dd8c:	.word	0xffffffff

0000dd90 <_svfprintf_r>:
    dd90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dd94:	sub	sp, #260	; 0x104
    dd96:	mov	r4, r1
    dd98:	str	r1, [sp, #20]
    dd9a:	mov	r5, r2
    dd9c:	str	r3, [sp, #40]	; 0x28
    dd9e:	str	r0, [sp, #24]
    dda0:	bl	11de8 <_localeconv_r>
    dda4:	ldr	r3, [r0, #0]
    dda6:	str	r3, [sp, #76]	; 0x4c
    dda8:	mov	r0, r3
    ddaa:	bl	cb80 <strlen>
    ddae:	ldrh	r3, [r4, #12]
    ddb0:	str	r0, [sp, #72]	; 0x48
    ddb2:	lsls	r6, r3, #24
    ddb4:	bpl.n	ddbe <_svfprintf_r+0x2e>
    ddb6:	ldr	r3, [r4, #16]
    ddb8:	cmp	r3, #0
    ddba:	beq.w	f020 <_svfprintf_r+0x1290>
    ddbe:	vldr	d7, [pc, #664]	; e058 <_svfprintf_r+0x2c8>
    ddc2:	movs	r3, #0
    ddc4:	vstr	d7, [sp, #64]	; 0x40
    ddc8:	str	r3, [sp, #56]	; 0x38
    ddca:	str	r3, [sp, #148]	; 0x94
    ddcc:	str	r3, [sp, #144]	; 0x90
    ddce:	str	r3, [sp, #84]	; 0x54
    ddd0:	str	r3, [sp, #28]
    ddd2:	ldr.w	sl, [pc, #656]	; e064 <_svfprintf_r+0x2d4>
    ddd6:	add	r3, sp, #192	; 0xc0
    ddd8:	str	r3, [sp, #140]	; 0x8c
    ddda:	mov	r9, r3
    dddc:	mov	r8, r5
    ddde:	ldrb.w	r3, [r8]
    dde2:	mov	r4, r8
    dde4:	cbz	r3, de22 <_svfprintf_r+0x92>
    dde6:	cmp	r3, #37	; 0x25
    dde8:	bne.n	ddf0 <_svfprintf_r+0x60>
    ddea:	b.n	de22 <_svfprintf_r+0x92>
    ddec:	cmp	r3, #37	; 0x25
    ddee:	beq.n	ddf8 <_svfprintf_r+0x68>
    ddf0:	ldrb.w	r3, [r4, #1]!
    ddf4:	cmp	r3, #0
    ddf6:	bne.n	ddec <_svfprintf_r+0x5c>
    ddf8:	rsb	r5, r8, r4
    ddfc:	cbz	r5, de22 <_svfprintf_r+0x92>
    ddfe:	ldr	r3, [sp, #144]	; 0x90
    de00:	ldr	r2, [sp, #148]	; 0x94
    de02:	str.w	r8, [r9]
    de06:	adds	r3, #1
    de08:	add	r2, r5
    de0a:	cmp	r3, #7
    de0c:	str.w	r5, [r9, #4]
    de10:	str	r2, [sp, #148]	; 0x94
    de12:	str	r3, [sp, #144]	; 0x90
    de14:	bgt.w	df64 <_svfprintf_r+0x1d4>
    de18:	add.w	r9, r9, #8
    de1c:	ldr	r3, [sp, #28]
    de1e:	add	r3, r5
    de20:	str	r3, [sp, #28]
    de22:	ldrb	r3, [r4, #0]
    de24:	cmp	r3, #0
    de26:	beq.w	df76 <_svfprintf_r+0x1e6>
    de2a:	movs	r3, #0
    de2c:	mov	r2, r3
    de2e:	strb.w	r3, [sp, #111]	; 0x6f
    de32:	mov	r1, r3
    de34:	str	r3, [sp, #32]
    de36:	str	r3, [sp, #12]
    de38:	mov.w	fp, #4294967295
    de3c:	ldrb	r3, [r4, #1]
    de3e:	add.w	r8, r4, #1
    de42:	mov	r5, fp
    de44:	add.w	r8, r8, #1
    de48:	sub.w	r0, r3, #32
    de4c:	cmp	r0, #88	; 0x58
    de4e:	bhi.w	e6ba <_svfprintf_r+0x92a>
    de52:	tbh	[pc, r0, lsl #1]
    de56:	.short	0x03a0
    de58:	.word	0x04320432
    de5c:	.word	0x043203a8
    de60:	.word	0x04320432
    de64:	.word	0x04320432
    de68:	.word	0x03af0432
    de6c:	.word	0x043203bd
    de70:	.word	0x00e2005d
    de74:	.word	0x01090432
    de78:	.word	0x01100110
    de7c:	.word	0x01100110
    de80:	.word	0x01100110
    de84:	.word	0x01100110
    de88:	.word	0x04320110
    de8c:	.word	0x04320432
    de90:	.word	0x04320432
    de94:	.word	0x04320432
    de98:	.word	0x04320432
    de9c:	.word	0x01200432
    dea0:	.word	0x04320286
    dea4:	.word	0x04320286
    dea8:	.word	0x04320432
    deac:	.word	0x02d40432
    deb0:	.word	0x04320432
    deb4:	.word	0x043202e5
    deb8:	.word	0x04320432
    debc:	.word	0x04320432
    dec0:	.word	0x0432030f
    dec4:	.word	0x033d0432
    dec8:	.word	0x04320432
    decc:	.word	0x04320432
    ded0:	.word	0x04320432
    ded4:	.word	0x04320432
    ded8:	.word	0x04320432
    dedc:	.word	0x0391037e
    dee0:	.word	0x02860286
    dee4:	.word	0x03990286
    dee8:	.word	0x04320391
    deec:	.word	0x04070432
    def0:	.word	0x04120432
    def4:	.word	0x006400a3
    def8:	.word	0x043203c2
    defc:	.word	0x043203c9
    df00:	.word	0x043203ea
    df04:	.word	0x03f20432
    df08:	ldr	r0, [sp, #32]
    df0a:	str	r3, [sp, #40]	; 0x28
    df0c:	negs	r0, r0
    df0e:	str	r0, [sp, #32]
    df10:	ldr	r3, [sp, #12]
    df12:	orr.w	r3, r3, #4
    df16:	str	r3, [sp, #12]
    df18:	ldrb.w	r3, [r8]
    df1c:	b.n	de44 <_svfprintf_r+0xb4>
    df1e:	ldr	r0, [sp, #40]	; 0x28
    df20:	mov	fp, r5
    df22:	movs	r1, #0
    df24:	ldr	r4, [r0, #0]
    df26:	strb.w	r1, [sp, #111]	; 0x6f
    df2a:	adds	r7, r0, #4
    df2c:	ldr	r0, [sp, #12]
    df2e:	movs	r3, #48	; 0x30
    df30:	movs	r2, #120	; 0x78
    df32:	cmp	fp, r1
    df34:	strb.w	r3, [sp, #112]	; 0x70
    df38:	mov.w	r5, #0
    df3c:	strb.w	r2, [sp, #113]	; 0x71
    df40:	orr.w	r3, r0, #2
    df44:	blt.w	e6f4 <_svfprintf_r+0x964>
    df48:	bic.w	r3, r0, #128	; 0x80
    df4c:	orr.w	r3, r3, #2
    df50:	str	r3, [sp, #12]
    df52:	orrs.w	r3, r4, r5
    df56:	str	r7, [sp, #40]	; 0x28
    df58:	beq.w	e6a0 <_svfprintf_r+0x910>
    df5c:	mov	r7, r1
    df5e:	str	r2, [sp, #52]	; 0x34
    df60:	ldr	r0, [pc, #252]	; (e060 <_svfprintf_r+0x2d0>)
    df62:	b.n	e532 <_svfprintf_r+0x7a2>
    df64:	add	r2, sp, #140	; 0x8c
    df66:	ldr	r1, [sp, #20]
    df68:	ldr	r0, [sp, #24]
    df6a:	bl	12d28 <__ssprint_r>
    df6e:	cbnz	r0, df84 <_svfprintf_r+0x1f4>
    df70:	add.w	r9, sp, #192	; 0xc0
    df74:	b.n	de1c <_svfprintf_r+0x8c>
    df76:	ldr	r3, [sp, #148]	; 0x94
    df78:	cbz	r3, df84 <_svfprintf_r+0x1f4>
    df7a:	ldr	r0, [sp, #24]
    df7c:	ldr	r1, [sp, #20]
    df7e:	add	r2, sp, #140	; 0x8c
    df80:	bl	12d28 <__ssprint_r>
    df84:	ldr	r3, [sp, #20]
    df86:	ldrh	r3, [r3, #12]
    df88:	tst.w	r3, #64	; 0x40
    df8c:	ldr	r3, [sp, #28]
    df8e:	it	ne
    df90:	movne.w	r3, #4294967295
    df94:	mov	r0, r3
    df96:	add	sp, #260	; 0x104
    df98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    df9c:	str	r3, [sp, #52]	; 0x34
    df9e:	mov	fp, r5
    dfa0:	cmp	r2, #0
    dfa2:	bne.w	f40c <_svfprintf_r+0x167c>
    dfa6:	ldr	r2, [sp, #12]
    dfa8:	ands.w	r3, r2, #32
    dfac:	beq.w	e43c <_svfprintf_r+0x6ac>
    dfb0:	ldr	r7, [sp, #40]	; 0x28
    dfb2:	adds	r7, #7
    dfb4:	bic.w	r3, r7, #7
    dfb8:	movs	r7, #0
    dfba:	add.w	r1, r3, #8
    dfbe:	cmp	fp, r7
    dfc0:	str	r1, [sp, #40]	; 0x28
    dfc2:	ldrd	r4, r5, [r3]
    dfc6:	strb.w	r7, [sp, #111]	; 0x6f
    dfca:	blt.w	ee92 <_svfprintf_r+0x1102>
    dfce:	bic.w	r3, r2, #128	; 0x80
    dfd2:	str	r3, [sp, #12]
    dfd4:	orrs.w	r3, r4, r5
    dfd8:	beq.w	e6e4 <_svfprintf_r+0x954>
    dfdc:	add	r6, sp, #192	; 0xc0
    dfde:	lsrs	r2, r4, #3
    dfe0:	orr.w	r2, r2, r5, lsl #29
    dfe4:	lsrs	r1, r5, #3
    dfe6:	and.w	r3, r4, #7
    dfea:	mov	r5, r1
    dfec:	mov	r4, r2
    dfee:	adds	r3, #48	; 0x30
    dff0:	orrs.w	r2, r4, r5
    dff4:	strb.w	r3, [r6, #-1]!
    dff8:	bne.n	dfde <_svfprintf_r+0x24e>
    dffa:	ldr	r2, [sp, #12]
    dffc:	lsls	r1, r2, #31
    dffe:	bpl.w	e120 <_svfprintf_r+0x390>
    e002:	cmp	r3, #48	; 0x30
    e004:	beq.w	e120 <_svfprintf_r+0x390>
    e008:	movs	r2, #48	; 0x30
    e00a:	subs	r3, r6, #1
    e00c:	strb.w	r2, [r6, #-1]
    e010:	add	r2, sp, #192	; 0xc0
    e012:	subs	r2, r2, r3
    e014:	str	r2, [sp, #36]	; 0x24
    e016:	mov	r6, r3
    e018:	b.n	e126 <_svfprintf_r+0x396>
    e01a:	ldrb.w	r3, [r8]
    e01e:	cmp	r3, #42	; 0x2a
    e020:	add.w	r4, r8, #1
    e024:	beq.w	f3f0 <_svfprintf_r+0x1660>
    e028:	sub.w	r0, r3, #48	; 0x30
    e02c:	cmp	r0, #9
    e02e:	it	ls
    e030:	movls	r5, #0
    e032:	bhi.w	f342 <_svfprintf_r+0x15b2>
    e036:	ldrb.w	r3, [r4], #1
    e03a:	add.w	r5, r5, r5, lsl #2
    e03e:	add.w	r5, r0, r5, lsl #1
    e042:	sub.w	r0, r3, #48	; 0x30
    e046:	cmp	r0, #9
    e048:	bls.n	e036 <_svfprintf_r+0x2a6>
    e04a:	orr.w	r5, r5, r5, asr #31
    e04e:	mov	r8, r4
    e050:	b.n	de48 <_svfprintf_r+0xb8>
    e052:	nop
    e054:	nop.w
	...
    e060:	.word	0x00013b94
    e064:	.word	0x00013b60
    e068:	ldr	r3, [sp, #12]
    e06a:	orr.w	r3, r3, #128	; 0x80
    e06e:	str	r3, [sp, #12]
    e070:	ldrb.w	r3, [r8]
    e074:	b.n	de44 <_svfprintf_r+0xb4>
    e076:	sub.w	r0, r3, #48	; 0x30
    e07a:	movs	r3, #0
    e07c:	mov	r4, r3
    e07e:	ldrb.w	r3, [r8], #1
    e082:	add.w	r4, r4, r4, lsl #2
    e086:	add.w	r4, r0, r4, lsl #1
    e08a:	sub.w	r0, r3, #48	; 0x30
    e08e:	cmp	r0, #9
    e090:	bls.n	e07e <_svfprintf_r+0x2ee>
    e092:	str	r4, [sp, #32]
    e094:	b.n	de48 <_svfprintf_r+0xb8>
    e096:	str	r3, [sp, #52]	; 0x34
    e098:	mov	fp, r5
    e09a:	cmp	r2, #0
    e09c:	bne.w	f428 <_svfprintf_r+0x1698>
    e0a0:	ldr	r3, [sp, #12]
    e0a2:	orr.w	r3, r3, #16
    e0a6:	str	r3, [sp, #12]
    e0a8:	ldr	r3, [sp, #12]
    e0aa:	lsls	r4, r3, #26
    e0ac:	bpl.w	eb1e <_svfprintf_r+0xd8e>
    e0b0:	ldr	r7, [sp, #40]	; 0x28
    e0b2:	adds	r7, #7
    e0b4:	bic.w	r7, r7, #7
    e0b8:	ldrd	r2, r3, [r7]
    e0bc:	add.w	r1, r7, #8
    e0c0:	str	r1, [sp, #40]	; 0x28
    e0c2:	mov	r4, r2
    e0c4:	mov	r5, r3
    e0c6:	cmp	r2, #0
    e0c8:	sbcs.w	r3, r3, #0
    e0cc:	blt.w	eb94 <_svfprintf_r+0xe04>
    e0d0:	cmp.w	fp, #0
    e0d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    e0d8:	blt.w	eb5a <_svfprintf_r+0xdca>
    e0dc:	ldr	r3, [sp, #12]
    e0de:	bic.w	r3, r3, #128	; 0x80
    e0e2:	str	r3, [sp, #12]
    e0e4:	orrs.w	r3, r4, r5
    e0e8:	beq.w	e4bc <_svfprintf_r+0x72c>
    e0ec:	cmp	r5, #0
    e0ee:	it	eq
    e0f0:	cmpeq	r4, #10
    e0f2:	bcc.w	e4c6 <_svfprintf_r+0x736>
    e0f6:	add	r6, sp, #192	; 0xc0
    e0f8:	mov	r0, r4
    e0fa:	mov	r1, r5
    e0fc:	movs	r2, #10
    e0fe:	movs	r3, #0
    e100:	bl	b940 <__aeabi_uldivmod>
    e104:	adds	r2, #48	; 0x30
    e106:	strb.w	r2, [r6, #-1]!
    e10a:	mov	r0, r4
    e10c:	mov	r1, r5
    e10e:	movs	r3, #0
    e110:	movs	r2, #10
    e112:	bl	b940 <__aeabi_uldivmod>
    e116:	mov	r4, r0
    e118:	mov	r5, r1
    e11a:	orrs.w	r3, r4, r5
    e11e:	bne.n	e0f8 <_svfprintf_r+0x368>
    e120:	add	r3, sp, #192	; 0xc0
    e122:	subs	r3, r3, r6
    e124:	str	r3, [sp, #36]	; 0x24
    e126:	ldr	r3, [sp, #36]	; 0x24
    e128:	cmp	r3, fp
    e12a:	it	lt
    e12c:	movlt	r3, fp
    e12e:	str	r3, [sp, #16]
    e130:	movs	r3, #0
    e132:	str	r3, [sp, #60]	; 0x3c
    e134:	cbz	r7, e13c <_svfprintf_r+0x3ac>
    e136:	ldr	r3, [sp, #16]
    e138:	adds	r3, #1
    e13a:	str	r3, [sp, #16]
    e13c:	ldr	r3, [sp, #12]
    e13e:	ands.w	r3, r3, #2
    e142:	str	r3, [sp, #44]	; 0x2c
    e144:	beq.n	e14c <_svfprintf_r+0x3bc>
    e146:	ldr	r3, [sp, #16]
    e148:	adds	r3, #2
    e14a:	str	r3, [sp, #16]
    e14c:	ldr	r3, [sp, #12]
    e14e:	ands.w	r3, r3, #132	; 0x84
    e152:	str	r3, [sp, #48]	; 0x30
    e154:	bne.w	e70e <_svfprintf_r+0x97e>
    e158:	ldr	r3, [sp, #32]
    e15a:	ldr	r2, [sp, #16]
    e15c:	subs	r5, r3, r2
    e15e:	cmp	r5, #0
    e160:	ble.w	e70e <_svfprintf_r+0x97e>
    e164:	cmp	r5, #16
    e166:	ldr	r1, [sp, #148]	; 0x94
    e168:	ldr	r2, [sp, #144]	; 0x90
    e16a:	ldr	r7, [pc, #672]	; (e40c <_svfprintf_r+0x67c>)
    e16c:	ble.n	e1be <_svfprintf_r+0x42e>
    e16e:	str	r6, [sp, #80]	; 0x50
    e170:	mov	r0, r9
    e172:	movs	r4, #16
    e174:	mov	r9, r7
    e176:	ldr	r6, [sp, #20]
    e178:	mov	r7, r5
    e17a:	ldr	r5, [sp, #24]
    e17c:	b.n	e188 <_svfprintf_r+0x3f8>
    e17e:	subs	r7, #16
    e180:	cmp	r7, #16
    e182:	add.w	r0, r0, #8
    e186:	ble.n	e1b6 <_svfprintf_r+0x426>
    e188:	adds	r2, #1
    e18a:	ldr	r3, [pc, #640]	; (e40c <_svfprintf_r+0x67c>)
    e18c:	str	r2, [sp, #144]	; 0x90
    e18e:	adds	r1, #16
    e190:	cmp	r2, #7
    e192:	str	r1, [sp, #148]	; 0x94
    e194:	stmia.w	r0, {r3, r4}
    e198:	ble.n	e17e <_svfprintf_r+0x3ee>
    e19a:	add	r2, sp, #140	; 0x8c
    e19c:	mov	r1, r6
    e19e:	mov	r0, r5
    e1a0:	bl	12d28 <__ssprint_r>
    e1a4:	cmp	r0, #0
    e1a6:	bne.w	df84 <_svfprintf_r+0x1f4>
    e1aa:	subs	r7, #16
    e1ac:	cmp	r7, #16
    e1ae:	ldr	r1, [sp, #148]	; 0x94
    e1b0:	ldr	r2, [sp, #144]	; 0x90
    e1b2:	add	r0, sp, #192	; 0xc0
    e1b4:	bgt.n	e188 <_svfprintf_r+0x3f8>
    e1b6:	ldr	r6, [sp, #80]	; 0x50
    e1b8:	mov	r5, r7
    e1ba:	mov	r7, r9
    e1bc:	mov	r9, r0
    e1be:	adds	r2, #1
    e1c0:	adds	r4, r5, r1
    e1c2:	cmp	r2, #7
    e1c4:	str	r4, [sp, #148]	; 0x94
    e1c6:	str	r2, [sp, #144]	; 0x90
    e1c8:	str.w	r7, [r9]
    e1cc:	str.w	r5, [r9, #4]
    e1d0:	bgt.w	ea2e <_svfprintf_r+0xc9e>
    e1d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    e1d8:	add.w	r9, r9, #8
    e1dc:	cbz	r7, e1fc <_svfprintf_r+0x46c>
    e1de:	ldr	r3, [sp, #144]	; 0x90
    e1e0:	adds	r3, #1
    e1e2:	adds	r4, #1
    e1e4:	add.w	r1, sp, #111	; 0x6f
    e1e8:	movs	r2, #1
    e1ea:	cmp	r3, #7
    e1ec:	str	r4, [sp, #148]	; 0x94
    e1ee:	str	r3, [sp, #144]	; 0x90
    e1f0:	stmia.w	r9, {r1, r2}
    e1f4:	bgt.w	e942 <_svfprintf_r+0xbb2>
    e1f8:	add.w	r9, r9, #8
    e1fc:	ldr	r3, [sp, #44]	; 0x2c
    e1fe:	cbz	r3, e21c <_svfprintf_r+0x48c>
    e200:	ldr	r3, [sp, #144]	; 0x90
    e202:	adds	r3, #1
    e204:	adds	r4, #2
    e206:	add	r1, sp, #112	; 0x70
    e208:	movs	r2, #2
    e20a:	cmp	r3, #7
    e20c:	str	r4, [sp, #148]	; 0x94
    e20e:	str	r3, [sp, #144]	; 0x90
    e210:	stmia.w	r9, {r1, r2}
    e214:	bgt.w	e95a <_svfprintf_r+0xbca>
    e218:	add.w	r9, r9, #8
    e21c:	ldr	r3, [sp, #48]	; 0x30
    e21e:	cmp	r3, #128	; 0x80
    e220:	beq.w	e7e6 <_svfprintf_r+0xa56>
    e224:	ldr	r3, [sp, #36]	; 0x24
    e226:	rsb	r7, r3, fp
    e22a:	cmp	r7, #0
    e22c:	ble.n	e296 <_svfprintf_r+0x506>
    e22e:	ldr	r2, [pc, #480]	; (e410 <_svfprintf_r+0x680>)
    e230:	ldr	r3, [sp, #144]	; 0x90
    e232:	str	r2, [sp, #44]	; 0x2c
    e234:	cmp	r7, #16
    e236:	ble.n	e27e <_svfprintf_r+0x4ee>
    e238:	mov	r2, r4
    e23a:	mov.w	fp, #16
    e23e:	ldr	r5, [sp, #24]
    e240:	ldr	r4, [sp, #20]
    e242:	b.n	e24e <_svfprintf_r+0x4be>
    e244:	subs	r7, #16
    e246:	cmp	r7, #16
    e248:	add.w	r9, r9, #8
    e24c:	ble.n	e27c <_svfprintf_r+0x4ec>
    e24e:	adds	r3, #1
    e250:	adds	r2, #16
    e252:	cmp	r3, #7
    e254:	str	r2, [sp, #148]	; 0x94
    e256:	str	r3, [sp, #144]	; 0x90
    e258:	stmia.w	r9, {sl, fp}
    e25c:	ble.n	e244 <_svfprintf_r+0x4b4>
    e25e:	add	r2, sp, #140	; 0x8c
    e260:	mov	r1, r4
    e262:	mov	r0, r5
    e264:	bl	12d28 <__ssprint_r>
    e268:	cmp	r0, #0
    e26a:	bne.w	df84 <_svfprintf_r+0x1f4>
    e26e:	subs	r7, #16
    e270:	cmp	r7, #16
    e272:	ldr	r2, [sp, #148]	; 0x94
    e274:	ldr	r3, [sp, #144]	; 0x90
    e276:	add.w	r9, sp, #192	; 0xc0
    e27a:	bgt.n	e24e <_svfprintf_r+0x4be>
    e27c:	mov	r4, r2
    e27e:	adds	r3, #1
    e280:	ldr	r2, [sp, #44]	; 0x2c
    e282:	str	r3, [sp, #144]	; 0x90
    e284:	add	r4, r7
    e286:	cmp	r3, #7
    e288:	str	r4, [sp, #148]	; 0x94
    e28a:	stmia.w	r9, {r2, r7}
    e28e:	bgt.w	e92a <_svfprintf_r+0xb9a>
    e292:	add.w	r9, r9, #8
    e296:	ldr	r3, [sp, #12]
    e298:	lsls	r2, r3, #23
    e29a:	bmi.w	e712 <_svfprintf_r+0x982>
    e29e:	ldr	r3, [sp, #144]	; 0x90
    e2a0:	ldr	r1, [sp, #36]	; 0x24
    e2a2:	str.w	r6, [r9]
    e2a6:	adds	r3, #1
    e2a8:	add	r4, r1
    e2aa:	cmp	r3, #7
    e2ac:	str	r4, [sp, #148]	; 0x94
    e2ae:	str.w	r1, [r9, #4]
    e2b2:	str	r3, [sp, #144]	; 0x90
    e2b4:	bgt.w	e8fe <_svfprintf_r+0xb6e>
    e2b8:	add.w	r9, r9, #8
    e2bc:	ldr	r3, [sp, #12]
    e2be:	lsls	r1, r3, #29
    e2c0:	bpl.n	e342 <_svfprintf_r+0x5b2>
    e2c2:	ldr	r3, [sp, #32]
    e2c4:	ldr	r2, [sp, #16]
    e2c6:	subs	r5, r3, r2
    e2c8:	cmp	r5, #0
    e2ca:	ble.n	e342 <_svfprintf_r+0x5b2>
    e2cc:	cmp	r5, #16
    e2ce:	ldr	r3, [sp, #144]	; 0x90
    e2d0:	ldr	r7, [pc, #312]	; (e40c <_svfprintf_r+0x67c>)
    e2d2:	ble.n	e31c <_svfprintf_r+0x58c>
    e2d4:	mov	r2, r4
    e2d6:	movs	r6, #16
    e2d8:	ldr.w	fp, [sp, #24]
    e2dc:	ldr	r4, [sp, #20]
    e2de:	b.n	e2ea <_svfprintf_r+0x55a>
    e2e0:	subs	r5, #16
    e2e2:	cmp	r5, #16
    e2e4:	add.w	r9, r9, #8
    e2e8:	ble.n	e31a <_svfprintf_r+0x58a>
    e2ea:	adds	r3, #1
    e2ec:	ldr	r1, [pc, #284]	; (e40c <_svfprintf_r+0x67c>)
    e2ee:	str	r3, [sp, #144]	; 0x90
    e2f0:	adds	r2, #16
    e2f2:	cmp	r3, #7
    e2f4:	str	r2, [sp, #148]	; 0x94
    e2f6:	stmia.w	r9, {r1, r6}
    e2fa:	ble.n	e2e0 <_svfprintf_r+0x550>
    e2fc:	add	r2, sp, #140	; 0x8c
    e2fe:	mov	r1, r4
    e300:	mov	r0, fp
    e302:	bl	12d28 <__ssprint_r>
    e306:	cmp	r0, #0
    e308:	bne.w	df84 <_svfprintf_r+0x1f4>
    e30c:	subs	r5, #16
    e30e:	cmp	r5, #16
    e310:	ldr	r2, [sp, #148]	; 0x94
    e312:	ldr	r3, [sp, #144]	; 0x90
    e314:	add.w	r9, sp, #192	; 0xc0
    e318:	bgt.n	e2ea <_svfprintf_r+0x55a>
    e31a:	mov	r4, r2
    e31c:	adds	r3, #1
    e31e:	add	r4, r5
    e320:	cmp	r3, #7
    e322:	str	r4, [sp, #148]	; 0x94
    e324:	str	r3, [sp, #144]	; 0x90
    e326:	str.w	r7, [r9]
    e32a:	str.w	r5, [r9, #4]
    e32e:	ble.n	e342 <_svfprintf_r+0x5b2>
    e330:	add	r2, sp, #140	; 0x8c
    e332:	ldr	r1, [sp, #20]
    e334:	ldr	r0, [sp, #24]
    e336:	bl	12d28 <__ssprint_r>
    e33a:	cmp	r0, #0
    e33c:	bne.w	df84 <_svfprintf_r+0x1f4>
    e340:	ldr	r4, [sp, #148]	; 0x94
    e342:	ldr	r3, [sp, #28]
    e344:	ldr	r2, [sp, #32]
    e346:	ldr	r1, [sp, #16]
    e348:	cmp	r2, r1
    e34a:	ite	ge
    e34c:	addge	r3, r3, r2
    e34e:	addlt	r3, r3, r1
    e350:	str	r3, [sp, #28]
    e352:	cmp	r4, #0
    e354:	bne.w	e916 <_svfprintf_r+0xb86>
    e358:	movs	r3, #0
    e35a:	str	r3, [sp, #144]	; 0x90
    e35c:	add.w	r9, sp, #192	; 0xc0
    e360:	b.n	ddde <_svfprintf_r+0x4e>
    e362:	str	r3, [sp, #52]	; 0x34
    e364:	mov	fp, r5
    e366:	cmp	r2, #0
    e368:	bne.w	f430 <_svfprintf_r+0x16a0>
    e36c:	ldr	r3, [sp, #12]
    e36e:	ldr	r7, [sp, #40]	; 0x28
    e370:	lsls	r2, r3, #28
    e372:	add.w	r7, r7, #7
    e376:	bpl.w	ee62 <_svfprintf_r+0x10d2>
    e37a:	bic.w	r3, r7, #7
    e37e:	vldr	d7, [r3]
    e382:	vstr	d7, [sp, #64]	; 0x40
    e386:	add.w	r2, r3, #8
    e38a:	str	r2, [sp, #40]	; 0x28
    e38c:	ldrd	r1, r2, [sp, #64]	; 0x40
    e390:	bic.w	r3, r2, #2147483648	; 0x80000000
    e394:	str	r1, [sp, #88]	; 0x58
    e396:	str	r3, [sp, #92]	; 0x5c
    e398:	ldrd	r4, r5, [sp, #88]	; 0x58
    e39c:	mov.w	r2, #4294967295
    e3a0:	mov	r0, r4
    e3a2:	mov	r1, r5
    e3a4:	ldr	r3, [pc, #108]	; (e414 <_svfprintf_r+0x684>)
    e3a6:	bl	b7e4 <__aeabi_dcmpun>
    e3aa:	cmp	r0, #0
    e3ac:	bne.w	ed64 <_svfprintf_r+0xfd4>
    e3b0:	mov.w	r2, #4294967295
    e3b4:	ldr	r3, [pc, #92]	; (e414 <_svfprintf_r+0x684>)
    e3b6:	mov	r0, r4
    e3b8:	mov	r1, r5
    e3ba:	bl	b7a8 <__aeabi_dcmple>
    e3be:	cmp	r0, #0
    e3c0:	bne.w	ed64 <_svfprintf_r+0xfd4>
    e3c4:	movs	r2, #0
    e3c6:	movs	r3, #0
    e3c8:	ldrd	r0, r1, [sp, #64]	; 0x40
    e3cc:	bl	b794 <__aeabi_dcmplt>
    e3d0:	cmp	r0, #0
    e3d2:	bne.w	f27a <_svfprintf_r+0x14ea>
    e3d6:	ldrb.w	r7, [sp, #111]	; 0x6f
    e3da:	ldr	r6, [pc, #60]	; (e418 <_svfprintf_r+0x688>)
    e3dc:	ldr	r3, [pc, #60]	; (e41c <_svfprintf_r+0x68c>)
    e3de:	ldr	r1, [sp, #12]
    e3e0:	bic.w	r1, r1, #128	; 0x80
    e3e4:	str	r1, [sp, #12]
    e3e6:	ldr	r1, [sp, #52]	; 0x34
    e3e8:	movs	r2, #3
    e3ea:	mov.w	fp, #0
    e3ee:	str	r2, [sp, #16]
    e3f0:	cmp	r1, #71	; 0x47
    e3f2:	it	le
    e3f4:	movle	r6, r3
    e3f6:	str	r2, [sp, #36]	; 0x24
    e3f8:	str.w	fp, [sp, #60]	; 0x3c
    e3fc:	b.n	e134 <_svfprintf_r+0x3a4>
    e3fe:	ldr	r3, [sp, #12]
    e400:	orr.w	r3, r3, #8
    e404:	str	r3, [sp, #12]
    e406:	ldrb.w	r3, [r8]
    e40a:	b.n	de44 <_svfprintf_r+0xb4>
    e40c:	.word	0x00013bb4
    e410:	.word	0x00013b60
    e414:	.word	0x7fefffff
    e418:	.word	0x00013b74
    e41c:	.word	0x00013b70
    e420:	str	r3, [sp, #52]	; 0x34
    e422:	mov	fp, r5
    e424:	cmp	r2, #0
    e426:	bne.w	f448 <_svfprintf_r+0x16b8>
    e42a:	ldr	r3, [sp, #12]
    e42c:	orr.w	r3, r3, #16
    e430:	str	r3, [sp, #12]
    e432:	ldr	r2, [sp, #12]
    e434:	ands.w	r3, r2, #32
    e438:	bne.w	dfb0 <_svfprintf_r+0x220>
    e43c:	ldr	r1, [sp, #12]
    e43e:	ands.w	r2, r1, #16
    e442:	beq.w	ecfc <_svfprintf_r+0xf6c>
    e446:	ldr	r0, [sp, #40]	; 0x28
    e448:	strb.w	r3, [sp, #111]	; 0x6f
    e44c:	cmp.w	fp, #0
    e450:	ldr	r4, [r0, #0]
    e452:	add.w	r7, r0, #4
    e456:	mov.w	r5, #0
    e45a:	blt.w	ee90 <_svfprintf_r+0x1100>
    e45e:	mov	r2, r1
    e460:	bic.w	r2, r2, #128	; 0x80
    e464:	str	r2, [sp, #12]
    e466:	orrs.w	r2, r4, r5
    e46a:	str	r7, [sp, #40]	; 0x28
    e46c:	beq.w	e6e4 <_svfprintf_r+0x954>
    e470:	mov	r7, r3
    e472:	b.n	dfdc <_svfprintf_r+0x24c>
    e474:	str	r3, [sp, #52]	; 0x34
    e476:	mov	fp, r5
    e478:	cmp	r2, #0
    e47a:	bne.w	f440 <_svfprintf_r+0x16b0>
    e47e:	ldr	r3, [sp, #12]
    e480:	orr.w	r3, r3, #16
    e484:	str	r3, [sp, #12]
    e486:	ldr	r2, [sp, #12]
    e488:	ands.w	r3, r2, #32
    e48c:	beq.w	eae8 <_svfprintf_r+0xd58>
    e490:	ldr	r7, [sp, #40]	; 0x28
    e492:	adds	r7, #7
    e494:	bic.w	r3, r7, #7
    e498:	movs	r7, #0
    e49a:	add.w	r1, r3, #8
    e49e:	cmp	fp, r7
    e4a0:	str	r1, [sp, #40]	; 0x28
    e4a2:	ldrd	r4, r5, [r3]
    e4a6:	strb.w	r7, [sp, #111]	; 0x6f
    e4aa:	blt.w	eb5a <_svfprintf_r+0xdca>
    e4ae:	bic.w	r3, r2, #128	; 0x80
    e4b2:	str	r3, [sp, #12]
    e4b4:	orrs.w	r3, r4, r5
    e4b8:	bne.w	e0ec <_svfprintf_r+0x35c>
    e4bc:	cmp.w	fp, #0
    e4c0:	beq.w	e6ae <_svfprintf_r+0x91e>
    e4c4:	movs	r4, #0
    e4c6:	add	r6, sp, #256	; 0x100
    e4c8:	adds	r4, #48	; 0x30
    e4ca:	strb.w	r4, [r6, #-65]!
    e4ce:	b.n	e120 <_svfprintf_r+0x390>
    e4d0:	str	r3, [sp, #52]	; 0x34
    e4d2:	mov	fp, r5
    e4d4:	cmp	r2, #0
    e4d6:	bne.w	f438 <_svfprintf_r+0x16a8>
    e4da:	ldr	r3, [sp, #12]
    e4dc:	ldr	r0, [pc, #700]	; (e79c <_svfprintf_r+0xa0c>)
    e4de:	lsls	r5, r3, #26
    e4e0:	bpl.w	e64e <_svfprintf_r+0x8be>
    e4e4:	ldr	r7, [sp, #40]	; 0x28
    e4e6:	adds	r7, #7
    e4e8:	bic.w	r3, r7, #7
    e4ec:	ldrd	r4, r5, [r3]
    e4f0:	add.w	r2, r3, #8
    e4f4:	str	r2, [sp, #40]	; 0x28
    e4f6:	ldr	r2, [sp, #12]
    e4f8:	ands.w	r7, r2, #1
    e4fc:	beq.w	e972 <_svfprintf_r+0xbe2>
    e500:	orrs.w	r3, r4, r5
    e504:	beq.w	ef0c <_svfprintf_r+0x117c>
    e508:	ldrb.w	r2, [sp, #52]	; 0x34
    e50c:	strb.w	r2, [sp, #113]	; 0x71
    e510:	movs	r7, #0
    e512:	ldr	r2, [sp, #12]
    e514:	strb.w	r7, [sp, #111]	; 0x6f
    e518:	movs	r3, #48	; 0x30
    e51a:	cmp	fp, r7
    e51c:	strb.w	r3, [sp, #112]	; 0x70
    e520:	orr.w	r3, r2, #2
    e524:	blt.w	f284 <_svfprintf_r+0x14f4>
    e528:	bic.w	r3, r2, #128	; 0x80
    e52c:	orr.w	r3, r3, #2
    e530:	str	r3, [sp, #12]
    e532:	add	r6, sp, #192	; 0xc0
    e534:	lsrs	r3, r4, #4
    e536:	and.w	r1, r4, #15
    e53a:	orr.w	r3, r3, r5, lsl #28
    e53e:	lsrs	r2, r5, #4
    e540:	mov	r4, r3
    e542:	mov	r5, r2
    e544:	ldrb	r3, [r0, r1]
    e546:	strb.w	r3, [r6, #-1]!
    e54a:	orrs.w	r3, r4, r5
    e54e:	bne.n	e534 <_svfprintf_r+0x7a4>
    e550:	b.n	e120 <_svfprintf_r+0x390>
    e552:	ldr	r1, [sp, #40]	; 0x28
    e554:	str	r3, [sp, #52]	; 0x34
    e556:	ldr	r2, [r1, #0]
    e558:	strb.w	r2, [sp, #152]	; 0x98
    e55c:	movs	r3, #0
    e55e:	mov	r2, r1
    e560:	mov	r7, r3
    e562:	strb.w	r3, [sp, #111]	; 0x6f
    e566:	adds	r2, #4
    e568:	movs	r3, #1
    e56a:	str	r3, [sp, #16]
    e56c:	mov	fp, r7
    e56e:	str	r7, [sp, #60]	; 0x3c
    e570:	str	r2, [sp, #40]	; 0x28
    e572:	str	r3, [sp, #36]	; 0x24
    e574:	add	r6, sp, #152	; 0x98
    e576:	b.n	e13c <_svfprintf_r+0x3ac>
    e578:	str	r3, [sp, #52]	; 0x34
    e57a:	mov	fp, r5
    e57c:	cmp	r2, #0
    e57e:	beq.w	e0a8 <_svfprintf_r+0x318>
    e582:	strb.w	r1, [sp, #111]	; 0x6f
    e586:	b.n	e0a8 <_svfprintf_r+0x318>
    e588:	ldr	r3, [sp, #12]
    e58a:	orr.w	r3, r3, #64	; 0x40
    e58e:	str	r3, [sp, #12]
    e590:	ldrb.w	r3, [r8]
    e594:	b.n	de44 <_svfprintf_r+0xb4>
    e596:	ldrb.w	r3, [r8]
    e59a:	cmp	r1, #0
    e59c:	bne.w	de44 <_svfprintf_r+0xb4>
    e5a0:	movs	r2, #1
    e5a2:	movs	r1, #32
    e5a4:	b.n	de44 <_svfprintf_r+0xb4>
    e5a6:	ldr	r3, [sp, #12]
    e5a8:	orr.w	r3, r3, #1
    e5ac:	str	r3, [sp, #12]
    e5ae:	ldrb.w	r3, [r8]
    e5b2:	b.n	de44 <_svfprintf_r+0xb4>
    e5b4:	ldr	r4, [sp, #40]	; 0x28
    e5b6:	ldr	r3, [r4, #0]
    e5b8:	str	r3, [sp, #32]
    e5ba:	mov	r0, r3
    e5bc:	cmp	r0, #0
    e5be:	mov	r3, r4
    e5c0:	add.w	r3, r3, #4
    e5c4:	blt.w	df08 <_svfprintf_r+0x178>
    e5c8:	str	r3, [sp, #40]	; 0x28
    e5ca:	ldrb.w	r3, [r8]
    e5ce:	b.n	de44 <_svfprintf_r+0xb4>
    e5d0:	ldrb.w	r3, [r8]
    e5d4:	movs	r2, #1
    e5d6:	movs	r1, #43	; 0x2b
    e5d8:	b.n	de44 <_svfprintf_r+0xb4>
    e5da:	ldr	r3, [sp, #12]
    e5dc:	orr.w	r3, r3, #32
    e5e0:	str	r3, [sp, #12]
    e5e2:	ldrb.w	r3, [r8]
    e5e6:	b.n	de44 <_svfprintf_r+0xb4>
    e5e8:	ldr	r2, [sp, #40]	; 0x28
    e5ea:	str	r3, [sp, #52]	; 0x34
    e5ec:	ldr	r6, [r2, #0]
    e5ee:	movs	r4, #0
    e5f0:	strb.w	r4, [sp, #111]	; 0x6f
    e5f4:	adds	r7, r2, #4
    e5f6:	cmp	r6, #0
    e5f8:	beq.w	f234 <_svfprintf_r+0x14a4>
    e5fc:	cmp	r5, #0
    e5fe:	blt.w	f0c4 <_svfprintf_r+0x1334>
    e602:	mov	r2, r5
    e604:	mov	r1, r4
    e606:	mov	r0, r6
    e608:	bl	c2d0 <memchr>
    e60c:	cmp	r0, #0
    e60e:	beq.w	f2d8 <_svfprintf_r+0x1548>
    e612:	subs	r3, r0, r6
    e614:	str	r3, [sp, #36]	; 0x24
    e616:	mov	fp, r4
    e618:	bic.w	r3, r3, r3, asr #31
    e61c:	str	r7, [sp, #40]	; 0x28
    e61e:	str	r3, [sp, #16]
    e620:	str.w	fp, [sp, #60]	; 0x3c
    e624:	ldrb.w	r7, [sp, #111]	; 0x6f
    e628:	b.n	e134 <_svfprintf_r+0x3a4>
    e62a:	str	r3, [sp, #52]	; 0x34
    e62c:	mov	fp, r5
    e62e:	cmp	r2, #0
    e630:	beq.w	e486 <_svfprintf_r+0x6f6>
    e634:	strb.w	r1, [sp, #111]	; 0x6f
    e638:	b.n	e486 <_svfprintf_r+0x6f6>
    e63a:	str	r3, [sp, #52]	; 0x34
    e63c:	mov	fp, r5
    e63e:	cmp	r2, #0
    e640:	bne.w	f460 <_svfprintf_r+0x16d0>
    e644:	ldr	r3, [sp, #12]
    e646:	ldr	r0, [pc, #344]	; (e7a0 <_svfprintf_r+0xa10>)
    e648:	lsls	r5, r3, #26
    e64a:	bmi.w	e4e4 <_svfprintf_r+0x754>
    e64e:	ldr	r3, [sp, #12]
    e650:	lsls	r4, r3, #27
    e652:	bpl.w	eed2 <_svfprintf_r+0x1142>
    e656:	ldr	r2, [sp, #40]	; 0x28
    e658:	mov	r3, r2
    e65a:	adds	r3, #4
    e65c:	ldr	r4, [r2, #0]
    e65e:	str	r3, [sp, #40]	; 0x28
    e660:	movs	r5, #0
    e662:	b.n	e4f6 <_svfprintf_r+0x766>
    e664:	ldrb.w	r3, [r8]
    e668:	cmp	r3, #108	; 0x6c
    e66a:	beq.w	eff2 <_svfprintf_r+0x1262>
    e66e:	ldr	r0, [sp, #12]
    e670:	orr.w	r0, r0, #16
    e674:	str	r0, [sp, #12]
    e676:	b.w	de44 <_svfprintf_r+0xb4>
    e67a:	cmp	r2, #0
    e67c:	bne.w	f458 <_svfprintf_r+0x16c8>
    e680:	ldr	r3, [sp, #12]
    e682:	lsls	r3, r3, #26
    e684:	bpl.w	ed36 <_svfprintf_r+0xfa6>
    e688:	ldr	r2, [sp, #40]	; 0x28
    e68a:	ldr	r1, [sp, #28]
    e68c:	ldr	r3, [r2, #0]
    e68e:	asrs	r5, r1, #31
    e690:	mov	r0, r1
    e692:	adds	r2, #4
    e694:	mov	r1, r5
    e696:	str	r2, [sp, #40]	; 0x28
    e698:	strd	r0, r1, [r3]
    e69c:	b.w	ddde <_svfprintf_r+0x4e>
    e6a0:	ldr	r0, [pc, #252]	; (e7a0 <_svfprintf_r+0xa10>)
    e6a2:	str	r2, [sp, #52]	; 0x34
    e6a4:	cmp.w	fp, #0
    e6a8:	bne.w	e994 <_svfprintf_r+0xc04>
    e6ac:	mov	r7, fp
    e6ae:	mov.w	fp, #0
    e6b2:	str.w	fp, [sp, #36]	; 0x24
    e6b6:	add	r6, sp, #192	; 0xc0
    e6b8:	b.n	e126 <_svfprintf_r+0x396>
    e6ba:	str	r3, [sp, #52]	; 0x34
    e6bc:	cmp	r2, #0
    e6be:	bne.w	f450 <_svfprintf_r+0x16c0>
    e6c2:	ldr	r2, [sp, #52]	; 0x34
    e6c4:	cmp	r2, #0
    e6c6:	beq.w	df76 <_svfprintf_r+0x1e6>
    e6ca:	movs	r3, #0
    e6cc:	movs	r1, #1
    e6ce:	mov	r7, r3
    e6d0:	str	r1, [sp, #16]
    e6d2:	strb.w	r2, [sp, #152]	; 0x98
    e6d6:	strb.w	r3, [sp, #111]	; 0x6f
    e6da:	mov	fp, r3
    e6dc:	str	r3, [sp, #60]	; 0x3c
    e6de:	str	r1, [sp, #36]	; 0x24
    e6e0:	add	r6, sp, #152	; 0x98
    e6e2:	b.n	e13c <_svfprintf_r+0x3ac>
    e6e4:	cmp.w	fp, #0
    e6e8:	beq.w	f308 <_svfprintf_r+0x1578>
    e6ec:	movs	r7, #0
    e6ee:	movs	r4, #0
    e6f0:	movs	r5, #0
    e6f2:	b.n	dfdc <_svfprintf_r+0x24c>
    e6f4:	ldr	r0, [pc, #168]	; (e7a0 <_svfprintf_r+0xa10>)
    e6f6:	str	r3, [sp, #12]
    e6f8:	str	r2, [sp, #52]	; 0x34
    e6fa:	orrs.w	r3, r4, r5
    e6fe:	str	r7, [sp, #40]	; 0x28
    e700:	mov.w	r7, #0
    e704:	bne.w	e532 <_svfprintf_r+0x7a2>
    e708:	movs	r4, #0
    e70a:	movs	r5, #0
    e70c:	b.n	e532 <_svfprintf_r+0x7a2>
    e70e:	ldr	r4, [sp, #148]	; 0x94
    e710:	b.n	e1dc <_svfprintf_r+0x44c>
    e712:	ldr	r3, [sp, #52]	; 0x34
    e714:	cmp	r3, #101	; 0x65
    e716:	ble.w	e86e <_svfprintf_r+0xade>
    e71a:	movs	r2, #0
    e71c:	movs	r3, #0
    e71e:	ldrd	r0, r1, [sp, #64]	; 0x40
    e722:	bl	b780 <__aeabi_dcmpeq>
    e726:	cmp	r0, #0
    e728:	beq.w	e998 <_svfprintf_r+0xc08>
    e72c:	ldr	r3, [sp, #144]	; 0x90
    e72e:	ldr	r2, [pc, #116]	; (e7a4 <_svfprintf_r+0xa14>)
    e730:	str.w	r2, [r9]
    e734:	adds	r3, #1
    e736:	adds	r4, #1
    e738:	movs	r2, #1
    e73a:	cmp	r3, #7
    e73c:	str	r4, [sp, #148]	; 0x94
    e73e:	str	r3, [sp, #144]	; 0x90
    e740:	str.w	r2, [r9, #4]
    e744:	bgt.w	ef24 <_svfprintf_r+0x1194>
    e748:	add.w	r9, r9, #8
    e74c:	ldr	r3, [sp, #116]	; 0x74
    e74e:	ldr	r2, [sp, #56]	; 0x38
    e750:	cmp	r3, r2
    e752:	blt.n	e75c <_svfprintf_r+0x9cc>
    e754:	ldr	r3, [sp, #12]
    e756:	lsls	r3, r3, #31
    e758:	bpl.w	e2bc <_svfprintf_r+0x52c>
    e75c:	ldr	r3, [sp, #144]	; 0x90
    e75e:	ldr	r1, [sp, #72]	; 0x48
    e760:	ldr	r2, [sp, #76]	; 0x4c
    e762:	str.w	r2, [r9]
    e766:	adds	r3, #1
    e768:	add	r4, r1
    e76a:	cmp	r3, #7
    e76c:	str	r4, [sp, #148]	; 0x94
    e76e:	str.w	r1, [r9, #4]
    e772:	str	r3, [sp, #144]	; 0x90
    e774:	bgt.w	f006 <_svfprintf_r+0x1276>
    e778:	add.w	r9, r9, #8
    e77c:	ldr	r3, [sp, #56]	; 0x38
    e77e:	subs	r5, r3, #1
    e780:	cmp	r5, #0
    e782:	ble.w	e2bc <_svfprintf_r+0x52c>
    e786:	ldr	r2, [pc, #32]	; (e7a8 <_svfprintf_r+0xa18>)
    e788:	ldr	r3, [sp, #144]	; 0x90
    e78a:	str	r2, [sp, #44]	; 0x2c
    e78c:	cmp	r5, #16
    e78e:	ble.w	eb64 <_svfprintf_r+0xdd4>
    e792:	movs	r6, #16
    e794:	ldr	r7, [sp, #24]
    e796:	ldr.w	fp, [sp, #20]
    e79a:	b.n	e7b8 <_svfprintf_r+0xa28>
    e79c:	.word	0x00013b80
    e7a0:	.word	0x00013b94
    e7a4:	.word	0x00013bb0
    e7a8:	.word	0x00013b60
    e7ac:	add.w	r9, r9, #8
    e7b0:	subs	r5, #16
    e7b2:	cmp	r5, #16
    e7b4:	ble.w	eb64 <_svfprintf_r+0xdd4>
    e7b8:	adds	r3, #1
    e7ba:	adds	r4, #16
    e7bc:	cmp	r3, #7
    e7be:	str	r4, [sp, #148]	; 0x94
    e7c0:	str	r3, [sp, #144]	; 0x90
    e7c2:	str.w	sl, [r9]
    e7c6:	str.w	r6, [r9, #4]
    e7ca:	ble.n	e7ac <_svfprintf_r+0xa1c>
    e7cc:	add	r2, sp, #140	; 0x8c
    e7ce:	mov	r1, fp
    e7d0:	mov	r0, r7
    e7d2:	bl	12d28 <__ssprint_r>
    e7d6:	cmp	r0, #0
    e7d8:	bne.w	df84 <_svfprintf_r+0x1f4>
    e7dc:	ldr	r4, [sp, #148]	; 0x94
    e7de:	ldr	r3, [sp, #144]	; 0x90
    e7e0:	add.w	r9, sp, #192	; 0xc0
    e7e4:	b.n	e7b0 <_svfprintf_r+0xa20>
    e7e6:	ldr	r3, [sp, #32]
    e7e8:	ldr	r2, [sp, #16]
    e7ea:	subs	r7, r3, r2
    e7ec:	cmp	r7, #0
    e7ee:	ble.w	e224 <_svfprintf_r+0x494>
    e7f2:	ldr	r2, [pc, #752]	; (eae4 <_svfprintf_r+0xd54>)
    e7f4:	ldr	r3, [sp, #144]	; 0x90
    e7f6:	str	r2, [sp, #44]	; 0x2c
    e7f8:	cmp	r7, #16
    e7fa:	ble.n	e854 <_svfprintf_r+0xac4>
    e7fc:	mov	r2, r9
    e7fe:	mov	r1, r4
    e800:	mov	r9, r7
    e802:	movs	r5, #16
    e804:	mov	r7, r6
    e806:	ldr	r4, [sp, #24]
    e808:	ldr	r6, [sp, #20]
    e80a:	b.n	e81a <_svfprintf_r+0xa8a>
    e80c:	sub.w	r9, r9, #16
    e810:	cmp.w	r9, #16
    e814:	add.w	r2, r2, #8
    e818:	ble.n	e84c <_svfprintf_r+0xabc>
    e81a:	adds	r3, #1
    e81c:	adds	r1, #16
    e81e:	cmp	r3, #7
    e820:	str	r1, [sp, #148]	; 0x94
    e822:	str	r3, [sp, #144]	; 0x90
    e824:	str.w	sl, [r2]
    e828:	str	r5, [r2, #4]
    e82a:	ble.n	e80c <_svfprintf_r+0xa7c>
    e82c:	add	r2, sp, #140	; 0x8c
    e82e:	mov	r1, r6
    e830:	mov	r0, r4
    e832:	bl	12d28 <__ssprint_r>
    e836:	cmp	r0, #0
    e838:	bne.w	df84 <_svfprintf_r+0x1f4>
    e83c:	sub.w	r9, r9, #16
    e840:	cmp.w	r9, #16
    e844:	ldr	r1, [sp, #148]	; 0x94
    e846:	ldr	r3, [sp, #144]	; 0x90
    e848:	add	r2, sp, #192	; 0xc0
    e84a:	bgt.n	e81a <_svfprintf_r+0xa8a>
    e84c:	mov	r6, r7
    e84e:	mov	r4, r1
    e850:	mov	r7, r9
    e852:	mov	r9, r2
    e854:	adds	r3, #1
    e856:	ldr	r2, [sp, #44]	; 0x2c
    e858:	str	r3, [sp, #144]	; 0x90
    e85a:	add	r4, r7
    e85c:	cmp	r3, #7
    e85e:	str	r4, [sp, #148]	; 0x94
    e860:	stmia.w	r9, {r2, r7}
    e864:	bgt.w	ece2 <_svfprintf_r+0xf52>
    e868:	add.w	r9, r9, #8
    e86c:	b.n	e224 <_svfprintf_r+0x494>
    e86e:	ldr	r3, [sp, #56]	; 0x38
    e870:	ldr	r5, [sp, #144]	; 0x90
    e872:	cmp	r3, #1
    e874:	ble.w	ec8c <_svfprintf_r+0xefc>
    e878:	adds	r5, #1
    e87a:	adds	r4, #1
    e87c:	movs	r3, #1
    e87e:	cmp	r5, #7
    e880:	str	r4, [sp, #148]	; 0x94
    e882:	str	r5, [sp, #144]	; 0x90
    e884:	str.w	r6, [r9]
    e888:	str.w	r3, [r9, #4]
    e88c:	bgt.w	ecae <_svfprintf_r+0xf1e>
    e890:	add.w	r9, r9, #8
    e894:	ldr	r2, [sp, #72]	; 0x48
    e896:	ldr	r3, [sp, #76]	; 0x4c
    e898:	str.w	r3, [r9]
    e89c:	adds	r5, #1
    e89e:	add	r4, r2
    e8a0:	cmp	r5, #7
    e8a2:	str	r4, [sp, #148]	; 0x94
    e8a4:	str	r5, [sp, #144]	; 0x90
    e8a6:	str.w	r2, [r9, #4]
    e8aa:	bgt.w	ecc8 <_svfprintf_r+0xf38>
    e8ae:	add.w	r9, r9, #8
    e8b2:	movs	r3, #0
    e8b4:	movs	r2, #0
    e8b6:	ldrd	r0, r1, [sp, #64]	; 0x40
    e8ba:	bl	b780 <__aeabi_dcmpeq>
    e8be:	ldr	r3, [sp, #56]	; 0x38
    e8c0:	cmp	r0, #0
    e8c2:	bne.w	ea4c <_svfprintf_r+0xcbc>
    e8c6:	subs	r3, #1
    e8c8:	adds	r5, #1
    e8ca:	adds	r6, #1
    e8cc:	add	r4, r3
    e8ce:	cmp	r5, #7
    e8d0:	str	r5, [sp, #144]	; 0x90
    e8d2:	str	r4, [sp, #148]	; 0x94
    e8d4:	str.w	r6, [r9]
    e8d8:	str.w	r3, [r9, #4]
    e8dc:	bgt.w	eaca <_svfprintf_r+0xd3a>
    e8e0:	add.w	r9, r9, #8
    e8e4:	ldr	r2, [sp, #84]	; 0x54
    e8e6:	str.w	r2, [r9, #4]
    e8ea:	adds	r5, #1
    e8ec:	add	r4, r2
    e8ee:	add	r3, sp, #124	; 0x7c
    e8f0:	cmp	r5, #7
    e8f2:	str	r4, [sp, #148]	; 0x94
    e8f4:	str	r5, [sp, #144]	; 0x90
    e8f6:	str.w	r3, [r9]
    e8fa:	ble.w	e2b8 <_svfprintf_r+0x528>
    e8fe:	add	r2, sp, #140	; 0x8c
    e900:	ldr	r1, [sp, #20]
    e902:	ldr	r0, [sp, #24]
    e904:	bl	12d28 <__ssprint_r>
    e908:	cmp	r0, #0
    e90a:	bne.w	df84 <_svfprintf_r+0x1f4>
    e90e:	ldr	r4, [sp, #148]	; 0x94
    e910:	add.w	r9, sp, #192	; 0xc0
    e914:	b.n	e2bc <_svfprintf_r+0x52c>
    e916:	add	r2, sp, #140	; 0x8c
    e918:	ldr	r1, [sp, #20]
    e91a:	ldr	r0, [sp, #24]
    e91c:	bl	12d28 <__ssprint_r>
    e920:	cmp	r0, #0
    e922:	beq.w	e358 <_svfprintf_r+0x5c8>
    e926:	b.w	df84 <_svfprintf_r+0x1f4>
    e92a:	add	r2, sp, #140	; 0x8c
    e92c:	ldr	r1, [sp, #20]
    e92e:	ldr	r0, [sp, #24]
    e930:	bl	12d28 <__ssprint_r>
    e934:	cmp	r0, #0
    e936:	bne.w	df84 <_svfprintf_r+0x1f4>
    e93a:	ldr	r4, [sp, #148]	; 0x94
    e93c:	add.w	r9, sp, #192	; 0xc0
    e940:	b.n	e296 <_svfprintf_r+0x506>
    e942:	add	r2, sp, #140	; 0x8c
    e944:	ldr	r1, [sp, #20]
    e946:	ldr	r0, [sp, #24]
    e948:	bl	12d28 <__ssprint_r>
    e94c:	cmp	r0, #0
    e94e:	bne.w	df84 <_svfprintf_r+0x1f4>
    e952:	ldr	r4, [sp, #148]	; 0x94
    e954:	add.w	r9, sp, #192	; 0xc0
    e958:	b.n	e1fc <_svfprintf_r+0x46c>
    e95a:	add	r2, sp, #140	; 0x8c
    e95c:	ldr	r1, [sp, #20]
    e95e:	ldr	r0, [sp, #24]
    e960:	bl	12d28 <__ssprint_r>
    e964:	cmp	r0, #0
    e966:	bne.w	df84 <_svfprintf_r+0x1f4>
    e96a:	ldr	r4, [sp, #148]	; 0x94
    e96c:	add.w	r9, sp, #192	; 0xc0
    e970:	b.n	e21c <_svfprintf_r+0x48c>
    e972:	cmp.w	fp, #0
    e976:	strb.w	r7, [sp, #111]	; 0x6f
    e97a:	blt.w	ef3c <_svfprintf_r+0x11ac>
    e97e:	bic.w	r3, r2, #128	; 0x80
    e982:	str	r3, [sp, #12]
    e984:	orrs.w	r3, r4, r5
    e988:	bne.w	e532 <_svfprintf_r+0x7a2>
    e98c:	cmp.w	fp, #0
    e990:	beq.w	e6ac <_svfprintf_r+0x91c>
    e994:	movs	r7, #0
    e996:	b.n	e708 <_svfprintf_r+0x978>
    e998:	ldr	r5, [sp, #116]	; 0x74
    e99a:	cmp	r5, #0
    e99c:	ble.w	ef42 <_svfprintf_r+0x11b2>
    e9a0:	ldr	r3, [sp, #60]	; 0x3c
    e9a2:	ldr	r2, [sp, #56]	; 0x38
    e9a4:	cmp	r3, r2
    e9a6:	it	ge
    e9a8:	movge	r3, r2
    e9aa:	cmp	r3, #0
    e9ac:	mov	r5, r3
    e9ae:	ble.n	e9cc <_svfprintf_r+0xc3c>
    e9b0:	ldr	r3, [sp, #144]	; 0x90
    e9b2:	str.w	r6, [r9]
    e9b6:	adds	r3, #1
    e9b8:	add	r4, r5
    e9ba:	cmp	r3, #7
    e9bc:	str	r4, [sp, #148]	; 0x94
    e9be:	str.w	r5, [r9, #4]
    e9c2:	str	r3, [sp, #144]	; 0x90
    e9c4:	bgt.w	f11a <_svfprintf_r+0x138a>
    e9c8:	add.w	r9, r9, #8
    e9cc:	ldr	r3, [sp, #60]	; 0x3c
    e9ce:	cmp	r5, #0
    e9d0:	it	ge
    e9d2:	subge	r3, r3, r5
    e9d4:	cmp	r3, #0
    e9d6:	mov	r5, r3
    e9d8:	ble.w	ebcc <_svfprintf_r+0xe3c>
    e9dc:	ldr	r2, [pc, #260]	; (eae4 <_svfprintf_r+0xd54>)
    e9de:	ldr	r3, [sp, #144]	; 0x90
    e9e0:	str	r2, [sp, #44]	; 0x2c
    e9e2:	cmp	r5, #16
    e9e4:	ble.w	eeee <_svfprintf_r+0x115e>
    e9e8:	mov	r2, r4
    e9ea:	movs	r7, #16
    e9ec:	ldr.w	fp, [sp, #24]
    e9f0:	ldr	r4, [sp, #20]
    e9f2:	b.n	ea00 <_svfprintf_r+0xc70>
    e9f4:	add.w	r9, r9, #8
    e9f8:	subs	r5, #16
    e9fa:	cmp	r5, #16
    e9fc:	ble.w	eeec <_svfprintf_r+0x115c>
    ea00:	adds	r3, #1
    ea02:	adds	r2, #16
    ea04:	cmp	r3, #7
    ea06:	str	r2, [sp, #148]	; 0x94
    ea08:	str	r3, [sp, #144]	; 0x90
    ea0a:	str.w	sl, [r9]
    ea0e:	str.w	r7, [r9, #4]
    ea12:	ble.n	e9f4 <_svfprintf_r+0xc64>
    ea14:	add	r2, sp, #140	; 0x8c
    ea16:	mov	r1, r4
    ea18:	mov	r0, fp
    ea1a:	bl	12d28 <__ssprint_r>
    ea1e:	cmp	r0, #0
    ea20:	bne.w	df84 <_svfprintf_r+0x1f4>
    ea24:	ldr	r2, [sp, #148]	; 0x94
    ea26:	ldr	r3, [sp, #144]	; 0x90
    ea28:	add.w	r9, sp, #192	; 0xc0
    ea2c:	b.n	e9f8 <_svfprintf_r+0xc68>
    ea2e:	add	r2, sp, #140	; 0x8c
    ea30:	ldr	r1, [sp, #20]
    ea32:	ldr	r0, [sp, #24]
    ea34:	bl	12d28 <__ssprint_r>
    ea38:	cmp	r0, #0
    ea3a:	bne.w	df84 <_svfprintf_r+0x1f4>
    ea3e:	ldrb.w	r7, [sp, #111]	; 0x6f
    ea42:	ldr	r4, [sp, #148]	; 0x94
    ea44:	add.w	r9, sp, #192	; 0xc0
    ea48:	b.w	e1dc <_svfprintf_r+0x44c>
    ea4c:	subs	r6, r3, #1
    ea4e:	cmp	r6, #0
    ea50:	ble.w	e8e4 <_svfprintf_r+0xb54>
    ea54:	ldr	r3, [pc, #140]	; (eae4 <_svfprintf_r+0xd54>)
    ea56:	str	r3, [sp, #44]	; 0x2c
    ea58:	cmp	r6, #16
    ea5a:	ble.n	eab6 <_svfprintf_r+0xd26>
    ea5c:	str.w	r8, [sp, #36]	; 0x24
    ea60:	movs	r7, #16
    ea62:	mov	r8, r6
    ea64:	ldr.w	fp, [sp, #24]
    ea68:	ldr	r6, [sp, #20]
    ea6a:	b.n	ea7a <_svfprintf_r+0xcea>
    ea6c:	sub.w	r8, r8, #16
    ea70:	cmp.w	r8, #16
    ea74:	add.w	r9, r9, #8
    ea78:	ble.n	eab0 <_svfprintf_r+0xd20>
    ea7a:	adds	r5, #1
    ea7c:	adds	r4, #16
    ea7e:	cmp	r5, #7
    ea80:	str	r4, [sp, #148]	; 0x94
    ea82:	str	r5, [sp, #144]	; 0x90
    ea84:	str.w	sl, [r9]
    ea88:	str.w	r7, [r9, #4]
    ea8c:	ble.n	ea6c <_svfprintf_r+0xcdc>
    ea8e:	add	r2, sp, #140	; 0x8c
    ea90:	mov	r1, r6
    ea92:	mov	r0, fp
    ea94:	bl	12d28 <__ssprint_r>
    ea98:	cmp	r0, #0
    ea9a:	bne.w	df84 <_svfprintf_r+0x1f4>
    ea9e:	sub.w	r8, r8, #16
    eaa2:	cmp.w	r8, #16
    eaa6:	ldr	r4, [sp, #148]	; 0x94
    eaa8:	ldr	r5, [sp, #144]	; 0x90
    eaaa:	add.w	r9, sp, #192	; 0xc0
    eaae:	bgt.n	ea7a <_svfprintf_r+0xcea>
    eab0:	mov	r6, r8
    eab2:	ldr.w	r8, [sp, #36]	; 0x24
    eab6:	ldr	r3, [sp, #44]	; 0x2c
    eab8:	adds	r5, #1
    eaba:	add	r4, r6
    eabc:	cmp	r5, #7
    eabe:	str	r4, [sp, #148]	; 0x94
    eac0:	str	r5, [sp, #144]	; 0x90
    eac2:	stmia.w	r9, {r3, r6}
    eac6:	ble.w	e8e0 <_svfprintf_r+0xb50>
    eaca:	add	r2, sp, #140	; 0x8c
    eacc:	ldr	r1, [sp, #20]
    eace:	ldr	r0, [sp, #24]
    ead0:	bl	12d28 <__ssprint_r>
    ead4:	cmp	r0, #0
    ead6:	bne.w	df84 <_svfprintf_r+0x1f4>
    eada:	ldr	r4, [sp, #148]	; 0x94
    eadc:	ldr	r5, [sp, #144]	; 0x90
    eade:	add.w	r9, sp, #192	; 0xc0
    eae2:	b.n	e8e4 <_svfprintf_r+0xb54>
    eae4:	.word	0x00013b60
    eae8:	ldr	r1, [sp, #12]
    eaea:	ands.w	r2, r1, #16
    eaee:	beq.w	ee98 <_svfprintf_r+0x1108>
    eaf2:	ldr	r0, [sp, #40]	; 0x28
    eaf4:	strb.w	r3, [sp, #111]	; 0x6f
    eaf8:	cmp.w	fp, #0
    eafc:	ldr	r4, [r0, #0]
    eafe:	add.w	r7, r0, #4
    eb02:	mov.w	r5, #0
    eb06:	blt.n	eb56 <_svfprintf_r+0xdc6>
    eb08:	mov	r2, r1
    eb0a:	bic.w	r2, r2, #128	; 0x80
    eb0e:	str	r2, [sp, #12]
    eb10:	orrs.w	r2, r4, r5
    eb14:	str	r7, [sp, #40]	; 0x28
    eb16:	mov	r7, r3
    eb18:	bne.w	e0ec <_svfprintf_r+0x35c>
    eb1c:	b.n	e4bc <_svfprintf_r+0x72c>
    eb1e:	ldr	r3, [sp, #12]
    eb20:	lsls	r0, r3, #27
    eb22:	bmi.n	eb7a <_svfprintf_r+0xdea>
    eb24:	ldr	r3, [sp, #12]
    eb26:	lsls	r1, r3, #25
    eb28:	bpl.n	eb7a <_svfprintf_r+0xdea>
    eb2a:	ldr	r1, [sp, #40]	; 0x28
    eb2c:	ldrsh.w	r4, [r1]
    eb30:	adds	r1, #4
    eb32:	asrs	r5, r4, #31
    eb34:	mov	r2, r4
    eb36:	mov	r3, r5
    eb38:	str	r1, [sp, #40]	; 0x28
    eb3a:	b.w	e0c6 <_svfprintf_r+0x336>
    eb3e:	ldr	r1, [sp, #40]	; 0x28
    eb40:	strb.w	r3, [sp, #111]	; 0x6f
    eb44:	cmp.w	fp, #0
    eb48:	ldr	r4, [r1, #0]
    eb4a:	add.w	r7, r1, #4
    eb4e:	mov.w	r5, #0
    eb52:	bge.w	efee <_svfprintf_r+0x125e>
    eb56:	str	r7, [sp, #40]	; 0x28
    eb58:	mov	r7, r3
    eb5a:	orrs.w	r3, r4, r5
    eb5e:	bne.w	e0ec <_svfprintf_r+0x35c>
    eb62:	b.n	e4c6 <_svfprintf_r+0x736>
    eb64:	adds	r3, #1
    eb66:	ldr	r2, [sp, #44]	; 0x2c
    eb68:	str	r3, [sp, #144]	; 0x90
    eb6a:	add	r4, r5
    eb6c:	cmp	r3, #7
    eb6e:	str	r4, [sp, #148]	; 0x94
    eb70:	stmia.w	r9, {r2, r5}
    eb74:	ble.w	e2b8 <_svfprintf_r+0x528>
    eb78:	b.n	e8fe <_svfprintf_r+0xb6e>
    eb7a:	ldr	r2, [sp, #40]	; 0x28
    eb7c:	ldr	r4, [r2, #0]
    eb7e:	mov	r3, r2
    eb80:	adds	r3, #4
    eb82:	asrs	r5, r4, #31
    eb84:	mov	r2, r4
    eb86:	str	r3, [sp, #40]	; 0x28
    eb88:	cmp	r2, #0
    eb8a:	mov	r3, r5
    eb8c:	sbcs.w	r3, r3, #0
    eb90:	bge.w	e0d0 <_svfprintf_r+0x340>
    eb94:	negs	r4, r4
    eb96:	mov.w	r7, #45	; 0x2d
    eb9a:	sbc.w	r5, r5, r5, lsl #1
    eb9e:	cmp.w	fp, #0
    eba2:	strb.w	r7, [sp, #111]	; 0x6f
    eba6:	blt.w	e0ec <_svfprintf_r+0x35c>
    ebaa:	ldr	r3, [sp, #12]
    ebac:	bic.w	r3, r3, #128	; 0x80
    ebb0:	str	r3, [sp, #12]
    ebb2:	b.w	e0ec <_svfprintf_r+0x35c>
    ebb6:	add	r2, sp, #140	; 0x8c
    ebb8:	ldr	r1, [sp, #20]
    ebba:	ldr	r0, [sp, #24]
    ebbc:	bl	12d28 <__ssprint_r>
    ebc0:	cmp	r0, #0
    ebc2:	bne.w	df84 <_svfprintf_r+0x1f4>
    ebc6:	ldr	r4, [sp, #148]	; 0x94
    ebc8:	add.w	r9, sp, #192	; 0xc0
    ebcc:	ldr	r2, [sp, #60]	; 0x3c
    ebce:	ldr	r3, [sp, #116]	; 0x74
    ebd0:	add	r2, r6
    ebd2:	mov	r7, r2
    ebd4:	ldr	r2, [sp, #56]	; 0x38
    ebd6:	cmp	r3, r2
    ebd8:	blt.n	ec6a <_svfprintf_r+0xeda>
    ebda:	ldr	r2, [sp, #12]
    ebdc:	lsls	r5, r2, #31
    ebde:	bmi.n	ec6a <_svfprintf_r+0xeda>
    ebe0:	ldr	r1, [sp, #56]	; 0x38
    ebe2:	add	r6, r1
    ebe4:	subs	r5, r6, r7
    ebe6:	subs	r3, r1, r3
    ebe8:	cmp	r5, r3
    ebea:	it	ge
    ebec:	movge	r5, r3
    ebee:	cmp	r5, #0
    ebf0:	mov	r6, r5
    ebf2:	ble.n	ec10 <_svfprintf_r+0xe80>
    ebf4:	ldr	r2, [sp, #144]	; 0x90
    ebf6:	str.w	r7, [r9]
    ebfa:	adds	r2, #1
    ebfc:	add	r4, r5
    ebfe:	cmp	r2, #7
    ec00:	str	r4, [sp, #148]	; 0x94
    ec02:	str.w	r5, [r9, #4]
    ec06:	str	r2, [sp, #144]	; 0x90
    ec08:	bgt.w	f208 <_svfprintf_r+0x1478>
    ec0c:	add.w	r9, r9, #8
    ec10:	cmp	r6, #0
    ec12:	ite	ge
    ec14:	subge	r5, r3, r6
    ec16:	movlt	r5, r3
    ec18:	cmp	r5, #0
    ec1a:	ble.w	e2bc <_svfprintf_r+0x52c>
    ec1e:	ldr	r2, [pc, #744]	; (ef08 <_svfprintf_r+0x1178>)
    ec20:	ldr	r3, [sp, #144]	; 0x90
    ec22:	str	r2, [sp, #44]	; 0x2c
    ec24:	cmp	r5, #16
    ec26:	ble.n	eb64 <_svfprintf_r+0xdd4>
    ec28:	movs	r6, #16
    ec2a:	ldr	r7, [sp, #24]
    ec2c:	ldr.w	fp, [sp, #20]
    ec30:	b.n	ec3c <_svfprintf_r+0xeac>
    ec32:	add.w	r9, r9, #8
    ec36:	subs	r5, #16
    ec38:	cmp	r5, #16
    ec3a:	ble.n	eb64 <_svfprintf_r+0xdd4>
    ec3c:	adds	r3, #1
    ec3e:	adds	r4, #16
    ec40:	cmp	r3, #7
    ec42:	str	r4, [sp, #148]	; 0x94
    ec44:	str	r3, [sp, #144]	; 0x90
    ec46:	str.w	sl, [r9]
    ec4a:	str.w	r6, [r9, #4]
    ec4e:	ble.n	ec32 <_svfprintf_r+0xea2>
    ec50:	add	r2, sp, #140	; 0x8c
    ec52:	mov	r1, fp
    ec54:	mov	r0, r7
    ec56:	bl	12d28 <__ssprint_r>
    ec5a:	cmp	r0, #0
    ec5c:	bne.w	df84 <_svfprintf_r+0x1f4>
    ec60:	ldr	r4, [sp, #148]	; 0x94
    ec62:	ldr	r3, [sp, #144]	; 0x90
    ec64:	add.w	r9, sp, #192	; 0xc0
    ec68:	b.n	ec36 <_svfprintf_r+0xea6>
    ec6a:	ldr	r2, [sp, #144]	; 0x90
    ec6c:	ldr	r0, [sp, #72]	; 0x48
    ec6e:	ldr	r1, [sp, #76]	; 0x4c
    ec70:	str.w	r1, [r9]
    ec74:	adds	r2, #1
    ec76:	add	r4, r0
    ec78:	cmp	r2, #7
    ec7a:	str	r4, [sp, #148]	; 0x94
    ec7c:	str.w	r0, [r9, #4]
    ec80:	str	r2, [sp, #144]	; 0x90
    ec82:	bgt.w	f1ee <_svfprintf_r+0x145e>
    ec86:	add.w	r9, r9, #8
    ec8a:	b.n	ebe0 <_svfprintf_r+0xe50>
    ec8c:	ldr	r3, [sp, #12]
    ec8e:	lsls	r0, r3, #31
    ec90:	bmi.w	e878 <_svfprintf_r+0xae8>
    ec94:	adds	r5, #1
    ec96:	adds	r4, #1
    ec98:	movs	r3, #1
    ec9a:	cmp	r5, #7
    ec9c:	str	r4, [sp, #148]	; 0x94
    ec9e:	str	r5, [sp, #144]	; 0x90
    eca0:	str.w	r6, [r9]
    eca4:	str.w	r3, [r9, #4]
    eca8:	ble.w	e8e0 <_svfprintf_r+0xb50>
    ecac:	b.n	eaca <_svfprintf_r+0xd3a>
    ecae:	add	r2, sp, #140	; 0x8c
    ecb0:	ldr	r1, [sp, #20]
    ecb2:	ldr	r0, [sp, #24]
    ecb4:	bl	12d28 <__ssprint_r>
    ecb8:	cmp	r0, #0
    ecba:	bne.w	df84 <_svfprintf_r+0x1f4>
    ecbe:	ldr	r4, [sp, #148]	; 0x94
    ecc0:	ldr	r5, [sp, #144]	; 0x90
    ecc2:	add.w	r9, sp, #192	; 0xc0
    ecc6:	b.n	e894 <_svfprintf_r+0xb04>
    ecc8:	add	r2, sp, #140	; 0x8c
    ecca:	ldr	r1, [sp, #20]
    eccc:	ldr	r0, [sp, #24]
    ecce:	bl	12d28 <__ssprint_r>
    ecd2:	cmp	r0, #0
    ecd4:	bne.w	df84 <_svfprintf_r+0x1f4>
    ecd8:	ldr	r4, [sp, #148]	; 0x94
    ecda:	ldr	r5, [sp, #144]	; 0x90
    ecdc:	add.w	r9, sp, #192	; 0xc0
    ece0:	b.n	e8b2 <_svfprintf_r+0xb22>
    ece2:	add	r2, sp, #140	; 0x8c
    ece4:	ldr	r1, [sp, #20]
    ece6:	ldr	r0, [sp, #24]
    ece8:	bl	12d28 <__ssprint_r>
    ecec:	cmp	r0, #0
    ecee:	bne.w	df84 <_svfprintf_r+0x1f4>
    ecf2:	ldr	r4, [sp, #148]	; 0x94
    ecf4:	add.w	r9, sp, #192	; 0xc0
    ecf8:	b.w	e224 <_svfprintf_r+0x494>
    ecfc:	ldr	r1, [sp, #12]
    ecfe:	ands.w	r3, r1, #64	; 0x40
    ed02:	beq.w	ee78 <_svfprintf_r+0x10e8>
    ed06:	ldr	r0, [sp, #40]	; 0x28
    ed08:	strb.w	r2, [sp, #111]	; 0x6f
    ed0c:	mov	r3, r0
    ed0e:	cmp.w	fp, #0
    ed12:	add.w	r3, r3, #4
    ed16:	ldrh	r4, [r0, #0]
    ed18:	mov.w	r5, #0
    ed1c:	blt.w	f0a0 <_svfprintf_r+0x1310>
    ed20:	bic.w	r1, r1, #128	; 0x80
    ed24:	str	r1, [sp, #12]
    ed26:	orrs.w	r1, r4, r5
    ed2a:	str	r3, [sp, #40]	; 0x28
    ed2c:	beq.w	e6e4 <_svfprintf_r+0x954>
    ed30:	mov	r7, r2
    ed32:	b.w	dfdc <_svfprintf_r+0x24c>
    ed36:	ldr	r3, [sp, #12]
    ed38:	lsls	r7, r3, #27
    ed3a:	bmi.n	ed54 <_svfprintf_r+0xfc4>
    ed3c:	ldr	r3, [sp, #12]
    ed3e:	lsls	r6, r3, #25
    ed40:	bpl.n	ed54 <_svfprintf_r+0xfc4>
    ed42:	ldr	r2, [sp, #40]	; 0x28
    ed44:	ldr	r3, [r2, #0]
    ed46:	adds	r2, #4
    ed48:	str	r2, [sp, #40]	; 0x28
    ed4a:	ldrh.w	r2, [sp, #28]
    ed4e:	strh	r2, [r3, #0]
    ed50:	b.w	ddde <_svfprintf_r+0x4e>
    ed54:	ldr	r2, [sp, #40]	; 0x28
    ed56:	ldr	r3, [r2, #0]
    ed58:	adds	r2, #4
    ed5a:	str	r2, [sp, #40]	; 0x28
    ed5c:	ldr	r2, [sp, #28]
    ed5e:	str	r2, [r3, #0]
    ed60:	b.w	ddde <_svfprintf_r+0x4e>
    ed64:	ldrd	r0, r1, [sp, #64]	; 0x40
    ed68:	mov	r2, r0
    ed6a:	mov	r3, r1
    ed6c:	bl	b7e4 <__aeabi_dcmpun>
    ed70:	cmp	r0, #0
    ed72:	bne.w	f370 <_svfprintf_r+0x15e0>
    ed76:	ldr	r3, [sp, #52]	; 0x34
    ed78:	cmp.w	fp, #4294967295
    ed7c:	bic.w	r7, r3, #32
    ed80:	beq.w	f252 <_svfprintf_r+0x14c2>
    ed84:	cmp	r7, #71	; 0x47
    ed86:	beq.w	f08e <_svfprintf_r+0x12fe>
    ed8a:	ldr	r3, [sp, #68]	; 0x44
    ed8c:	ldr	r2, [sp, #12]
    ed8e:	cmp	r3, #0
    ed90:	orr.w	r2, r2, #256	; 0x100
    ed94:	str	r2, [sp, #44]	; 0x2c
    ed96:	blt.w	f28a <_svfprintf_r+0x14fa>
    ed9a:	vldr	d7, [sp, #64]	; 0x40
    ed9e:	vstr	d7, [sp, #96]	; 0x60
    eda2:	movs	r3, #0
    eda4:	str	r3, [sp, #16]
    eda6:	ldr	r3, [sp, #52]	; 0x34
    eda8:	cmp	r3, #102	; 0x66
    edaa:	beq.w	f258 <_svfprintf_r+0x14c8>
    edae:	cmp	r3, #70	; 0x46
    edb0:	beq.w	f03e <_svfprintf_r+0x12ae>
    edb4:	cmp	r7, #69	; 0x45
    edb6:	ite	eq
    edb8:	addeq.w	r5, fp, #1
    edbc:	movne	r5, fp
    edbe:	add	r2, sp, #132	; 0x84
    edc0:	add	r3, sp, #120	; 0x78
    edc2:	str	r2, [sp, #4]
    edc4:	str	r3, [sp, #0]
    edc6:	mov	r2, r5
    edc8:	add	r3, sp, #116	; 0x74
    edca:	movs	r1, #2
    edcc:	vldr	d0, [sp, #96]	; 0x60
    edd0:	ldr	r0, [sp, #24]
    edd2:	bl	10598 <_dtoa_r>
    edd6:	ldr	r3, [sp, #52]	; 0x34
    edd8:	cmp	r3, #103	; 0x67
    edda:	mov	r6, r0
    eddc:	bne.w	f2b6 <_svfprintf_r+0x1526>
    ede0:	ldr	r3, [sp, #12]
    ede2:	lsls	r2, r3, #31
    ede4:	bpl.w	f35a <_svfprintf_r+0x15ca>
    ede8:	adds	r4, r6, r5
    edea:	movs	r2, #0
    edec:	movs	r3, #0
    edee:	ldrd	r0, r1, [sp, #96]	; 0x60
    edf2:	bl	b780 <__aeabi_dcmpeq>
    edf6:	cmp	r0, #0
    edf8:	bne.w	f116 <_svfprintf_r+0x1386>
    edfc:	ldr	r3, [sp, #132]	; 0x84
    edfe:	cmp	r4, r3
    ee00:	bls.n	ee10 <_svfprintf_r+0x1080>
    ee02:	movs	r1, #48	; 0x30
    ee04:	adds	r2, r3, #1
    ee06:	str	r2, [sp, #132]	; 0x84
    ee08:	strb	r1, [r3, #0]
    ee0a:	ldr	r3, [sp, #132]	; 0x84
    ee0c:	cmp	r4, r3
    ee0e:	bhi.n	ee04 <_svfprintf_r+0x1074>
    ee10:	subs	r3, r3, r6
    ee12:	cmp	r7, #71	; 0x47
    ee14:	str	r3, [sp, #56]	; 0x38
    ee16:	beq.w	f108 <_svfprintf_r+0x1378>
    ee1a:	ldr	r3, [sp, #52]	; 0x34
    ee1c:	cmp	r3, #101	; 0x65
    ee1e:	ble.w	f2d4 <_svfprintf_r+0x1544>
    ee22:	ldr	r3, [sp, #52]	; 0x34
    ee24:	cmp	r3, #102	; 0x66
    ee26:	ldr	r3, [sp, #116]	; 0x74
    ee28:	str	r3, [sp, #60]	; 0x3c
    ee2a:	beq.w	f2ee <_svfprintf_r+0x155e>
    ee2e:	ldr	r2, [sp, #60]	; 0x3c
    ee30:	ldr	r1, [sp, #56]	; 0x38
    ee32:	cmp	r2, r1
    ee34:	blt.w	f29c <_svfprintf_r+0x150c>
    ee38:	ldr	r3, [sp, #12]
    ee3a:	lsls	r1, r3, #31
    ee3c:	bmi.w	f35e <_svfprintf_r+0x15ce>
    ee40:	bic.w	r3, r2, r2, asr #31
    ee44:	str	r2, [sp, #36]	; 0x24
    ee46:	movs	r2, #103	; 0x67
    ee48:	str	r2, [sp, #52]	; 0x34
    ee4a:	ldr	r2, [sp, #16]
    ee4c:	cmp	r2, #0
    ee4e:	bne.w	f0b0 <_svfprintf_r+0x1320>
    ee52:	str	r3, [sp, #16]
    ee54:	ldr	r3, [sp, #44]	; 0x2c
    ee56:	str	r3, [sp, #12]
    ee58:	mov	fp, r2
    ee5a:	ldrb.w	r7, [sp, #111]	; 0x6f
    ee5e:	b.w	e134 <_svfprintf_r+0x3a4>
    ee62:	bic.w	r7, r7, #7
    ee66:	vldr	d7, [r7]
    ee6a:	add.w	r3, r7, #8
    ee6e:	vstr	d7, [sp, #64]	; 0x40
    ee72:	str	r3, [sp, #40]	; 0x28
    ee74:	b.w	e38c <_svfprintf_r+0x5fc>
    ee78:	ldr	r1, [sp, #40]	; 0x28
    ee7a:	strb.w	r3, [sp, #111]	; 0x6f
    ee7e:	cmp.w	fp, #0
    ee82:	ldr	r4, [r1, #0]
    ee84:	add.w	r7, r1, #4
    ee88:	mov.w	r5, #0
    ee8c:	bge.w	efe8 <_svfprintf_r+0x1258>
    ee90:	str	r7, [sp, #40]	; 0x28
    ee92:	movs	r7, #0
    ee94:	b.w	dfdc <_svfprintf_r+0x24c>
    ee98:	ldr	r1, [sp, #12]
    ee9a:	ands.w	r3, r1, #64	; 0x40
    ee9e:	beq.w	eb3e <_svfprintf_r+0xdae>
    eea2:	ldr	r0, [sp, #40]	; 0x28
    eea4:	strb.w	r2, [sp, #111]	; 0x6f
    eea8:	mov	r3, r0
    eeaa:	cmp.w	fp, #0
    eeae:	add.w	r3, r3, #4
    eeb2:	ldrh	r4, [r0, #0]
    eeb4:	mov.w	r5, #0
    eeb8:	blt.w	f09a <_svfprintf_r+0x130a>
    eebc:	bic.w	r1, r1, #128	; 0x80
    eec0:	str	r1, [sp, #12]
    eec2:	orrs.w	r1, r4, r5
    eec6:	str	r3, [sp, #40]	; 0x28
    eec8:	mov	r7, r2
    eeca:	bne.w	e0ec <_svfprintf_r+0x35c>
    eece:	b.w	e4bc <_svfprintf_r+0x72c>
    eed2:	ldr	r3, [sp, #12]
    eed4:	ldr	r2, [sp, #40]	; 0x28
    eed6:	tst.w	r3, #64	; 0x40
    eeda:	mov	r3, r2
    eedc:	beq.w	f0a4 <_svfprintf_r+0x1314>
    eee0:	adds	r3, #4
    eee2:	ldrh	r4, [r2, #0]
    eee4:	str	r3, [sp, #40]	; 0x28
    eee6:	movs	r5, #0
    eee8:	b.w	e4f6 <_svfprintf_r+0x766>
    eeec:	mov	r4, r2
    eeee:	adds	r3, #1
    eef0:	ldr	r2, [sp, #44]	; 0x2c
    eef2:	str	r3, [sp, #144]	; 0x90
    eef4:	add	r4, r5
    eef6:	cmp	r3, #7
    eef8:	str	r4, [sp, #148]	; 0x94
    eefa:	stmia.w	r9, {r2, r5}
    eefe:	bgt.w	ebb6 <_svfprintf_r+0xe26>
    ef02:	add.w	r9, r9, #8
    ef06:	b.n	ebcc <_svfprintf_r+0xe3c>
    ef08:	.word	0x00013b60
    ef0c:	movs	r7, #0
    ef0e:	cmp	fp, r7
    ef10:	strb.w	r7, [sp, #111]	; 0x6f
    ef14:	blt.w	e708 <_svfprintf_r+0x978>
    ef18:	ldr	r3, [sp, #12]
    ef1a:	bic.w	r3, r3, #128	; 0x80
    ef1e:	str	r3, [sp, #12]
    ef20:	b.w	e6a4 <_svfprintf_r+0x914>
    ef24:	add	r2, sp, #140	; 0x8c
    ef26:	ldr	r1, [sp, #20]
    ef28:	ldr	r0, [sp, #24]
    ef2a:	bl	12d28 <__ssprint_r>
    ef2e:	cmp	r0, #0
    ef30:	bne.w	df84 <_svfprintf_r+0x1f4>
    ef34:	ldr	r4, [sp, #148]	; 0x94
    ef36:	add.w	r9, sp, #192	; 0xc0
    ef3a:	b.n	e74c <_svfprintf_r+0x9bc>
    ef3c:	ldr	r7, [sp, #40]	; 0x28
    ef3e:	b.w	e6fa <_svfprintf_r+0x96a>
    ef42:	ldr	r3, [sp, #144]	; 0x90
    ef44:	ldr	r2, [pc, #736]	; (f228 <_svfprintf_r+0x1498>)
    ef46:	str.w	r2, [r9]
    ef4a:	adds	r3, #1
    ef4c:	adds	r4, #1
    ef4e:	movs	r2, #1
    ef50:	cmp	r3, #7
    ef52:	str	r4, [sp, #148]	; 0x94
    ef54:	str	r3, [sp, #144]	; 0x90
    ef56:	str.w	r2, [r9, #4]
    ef5a:	bgt.w	f074 <_svfprintf_r+0x12e4>
    ef5e:	add.w	r9, r9, #8
    ef62:	cbnz	r5, ef70 <_svfprintf_r+0x11e0>
    ef64:	ldr	r3, [sp, #56]	; 0x38
    ef66:	cbnz	r3, ef70 <_svfprintf_r+0x11e0>
    ef68:	ldr	r3, [sp, #12]
    ef6a:	lsls	r7, r3, #31
    ef6c:	bpl.w	e2bc <_svfprintf_r+0x52c>
    ef70:	ldr	r3, [sp, #144]	; 0x90
    ef72:	ldr	r1, [sp, #72]	; 0x48
    ef74:	ldr	r2, [sp, #76]	; 0x4c
    ef76:	str.w	r2, [r9]
    ef7a:	adds	r3, #1
    ef7c:	add	r4, r1
    ef7e:	cmp	r3, #7
    ef80:	str	r4, [sp, #148]	; 0x94
    ef82:	str.w	r1, [r9, #4]
    ef86:	str	r3, [sp, #144]	; 0x90
    ef88:	bgt.w	f326 <_svfprintf_r+0x1596>
    ef8c:	add.w	r9, r9, #8
    ef90:	negs	r5, r5
    ef92:	cmp	r5, #0
    ef94:	ble.w	f0ec <_svfprintf_r+0x135c>
    ef98:	ldr	r2, [pc, #656]	; (f22c <_svfprintf_r+0x149c>)
    ef9a:	str	r2, [sp, #44]	; 0x2c
    ef9c:	cmp	r5, #16
    ef9e:	ble.w	f134 <_svfprintf_r+0x13a4>
    efa2:	mov	r2, r4
    efa4:	movs	r7, #16
    efa6:	ldr.w	fp, [sp, #24]
    efaa:	ldr	r4, [sp, #20]
    efac:	b.n	efba <_svfprintf_r+0x122a>
    efae:	add.w	r9, r9, #8
    efb2:	subs	r5, #16
    efb4:	cmp	r5, #16
    efb6:	ble.w	f132 <_svfprintf_r+0x13a2>
    efba:	adds	r3, #1
    efbc:	adds	r2, #16
    efbe:	cmp	r3, #7
    efc0:	str	r2, [sp, #148]	; 0x94
    efc2:	str	r3, [sp, #144]	; 0x90
    efc4:	str.w	sl, [r9]
    efc8:	str.w	r7, [r9, #4]
    efcc:	ble.n	efae <_svfprintf_r+0x121e>
    efce:	add	r2, sp, #140	; 0x8c
    efd0:	mov	r1, r4
    efd2:	mov	r0, fp
    efd4:	bl	12d28 <__ssprint_r>
    efd8:	cmp	r0, #0
    efda:	bne.w	df84 <_svfprintf_r+0x1f4>
    efde:	ldr	r2, [sp, #148]	; 0x94
    efe0:	ldr	r3, [sp, #144]	; 0x90
    efe2:	add.w	r9, sp, #192	; 0xc0
    efe6:	b.n	efb2 <_svfprintf_r+0x1222>
    efe8:	ldr	r2, [sp, #12]
    efea:	b.w	e460 <_svfprintf_r+0x6d0>
    efee:	ldr	r2, [sp, #12]
    eff0:	b.n	eb0a <_svfprintf_r+0xd7a>
    eff2:	ldr	r3, [sp, #12]
    eff4:	orr.w	r3, r3, #32
    eff8:	str	r3, [sp, #12]
    effa:	add.w	r8, r8, #1
    effe:	ldrb.w	r3, [r8]
    f002:	b.w	de44 <_svfprintf_r+0xb4>
    f006:	add	r2, sp, #140	; 0x8c
    f008:	ldr	r1, [sp, #20]
    f00a:	ldr	r0, [sp, #24]
    f00c:	bl	12d28 <__ssprint_r>
    f010:	cmp	r0, #0
    f012:	bne.w	df84 <_svfprintf_r+0x1f4>
    f016:	ldr	r4, [sp, #148]	; 0x94
    f018:	add.w	r9, sp, #192	; 0xc0
    f01c:	b.w	e77c <_svfprintf_r+0x9ec>
    f020:	movs	r1, #64	; 0x40
    f022:	ldr	r0, [sp, #24]
    f024:	bl	bd30 <_malloc_r>
    f028:	ldr	r2, [sp, #20]
    f02a:	str	r0, [r2, #0]
    f02c:	str	r0, [r2, #16]
    f02e:	cmp	r0, #0
    f030:	beq.w	f41a <_svfprintf_r+0x168a>
    f034:	ldr	r2, [sp, #20]
    f036:	movs	r3, #64	; 0x40
    f038:	str	r3, [r2, #20]
    f03a:	b.w	ddbe <_svfprintf_r+0x2e>
    f03e:	add	r2, sp, #132	; 0x84
    f040:	add	r3, sp, #120	; 0x78
    f042:	str	r2, [sp, #4]
    f044:	str	r3, [sp, #0]
    f046:	mov	r2, fp
    f048:	add	r3, sp, #116	; 0x74
    f04a:	movs	r1, #3
    f04c:	vldr	d0, [sp, #96]	; 0x60
    f050:	ldr	r0, [sp, #24]
    f052:	bl	10598 <_dtoa_r>
    f056:	mov	r5, fp
    f058:	mov	r6, r0
    f05a:	ldr	r3, [sp, #52]	; 0x34
    f05c:	cmp	r3, #70	; 0x46
    f05e:	add.w	r4, r6, r5
    f062:	bne.w	edea <_svfprintf_r+0x105a>
    f066:	ldrb	r3, [r6, #0]
    f068:	cmp	r3, #48	; 0x30
    f06a:	beq.w	f37c <_svfprintf_r+0x15ec>
    f06e:	ldr	r5, [sp, #116]	; 0x74
    f070:	add	r4, r5
    f072:	b.n	edea <_svfprintf_r+0x105a>
    f074:	add	r2, sp, #140	; 0x8c
    f076:	ldr	r1, [sp, #20]
    f078:	ldr	r0, [sp, #24]
    f07a:	bl	12d28 <__ssprint_r>
    f07e:	cmp	r0, #0
    f080:	bne.w	df84 <_svfprintf_r+0x1f4>
    f084:	ldr	r5, [sp, #116]	; 0x74
    f086:	ldr	r4, [sp, #148]	; 0x94
    f088:	add.w	r9, sp, #192	; 0xc0
    f08c:	b.n	ef62 <_svfprintf_r+0x11d2>
    f08e:	cmp.w	fp, #0
    f092:	it	eq
    f094:	moveq.w	fp, #1
    f098:	b.n	ed8a <_svfprintf_r+0xffa>
    f09a:	str	r3, [sp, #40]	; 0x28
    f09c:	mov	r7, r2
    f09e:	b.n	eb5a <_svfprintf_r+0xdca>
    f0a0:	str	r3, [sp, #40]	; 0x28
    f0a2:	b.n	ee92 <_svfprintf_r+0x1102>
    f0a4:	adds	r3, #4
    f0a6:	ldr	r4, [r2, #0]
    f0a8:	str	r3, [sp, #40]	; 0x28
    f0aa:	movs	r5, #0
    f0ac:	b.w	e4f6 <_svfprintf_r+0x766>
    f0b0:	movs	r7, #45	; 0x2d
    f0b2:	str	r3, [sp, #16]
    f0b4:	ldr	r3, [sp, #44]	; 0x2c
    f0b6:	str	r3, [sp, #12]
    f0b8:	strb.w	r7, [sp, #111]	; 0x6f
    f0bc:	mov.w	fp, #0
    f0c0:	b.w	e136 <_svfprintf_r+0x3a6>
    f0c4:	mov	r0, r6
    f0c6:	bl	cb80 <strlen>
    f0ca:	mov	fp, r4
    f0cc:	mov	r3, r0
    f0ce:	str	r0, [sp, #36]	; 0x24
    f0d0:	b.w	e618 <_svfprintf_r+0x888>
    f0d4:	add	r2, sp, #140	; 0x8c
    f0d6:	ldr	r1, [sp, #20]
    f0d8:	ldr	r0, [sp, #24]
    f0da:	bl	12d28 <__ssprint_r>
    f0de:	cmp	r0, #0
    f0e0:	bne.w	df84 <_svfprintf_r+0x1f4>
    f0e4:	ldr	r4, [sp, #148]	; 0x94
    f0e6:	ldr	r3, [sp, #144]	; 0x90
    f0e8:	add.w	r9, sp, #192	; 0xc0
    f0ec:	ldr	r1, [sp, #56]	; 0x38
    f0ee:	str.w	r6, [r9]
    f0f2:	adds	r3, #1
    f0f4:	add	r4, r1
    f0f6:	cmp	r3, #7
    f0f8:	str	r4, [sp, #148]	; 0x94
    f0fa:	str	r3, [sp, #144]	; 0x90
    f0fc:	str.w	r1, [r9, #4]
    f100:	ble.w	e2b8 <_svfprintf_r+0x528>
    f104:	b.w	e8fe <_svfprintf_r+0xb6e>
    f108:	ldr	r3, [sp, #116]	; 0x74
    f10a:	adds	r5, r3, #3
    f10c:	blt.n	f14c <_svfprintf_r+0x13bc>
    f10e:	cmp	fp, r3
    f110:	blt.n	f14c <_svfprintf_r+0x13bc>
    f112:	str	r3, [sp, #60]	; 0x3c
    f114:	b.n	ee2e <_svfprintf_r+0x109e>
    f116:	mov	r3, r4
    f118:	b.n	ee10 <_svfprintf_r+0x1080>
    f11a:	add	r2, sp, #140	; 0x8c
    f11c:	ldr	r1, [sp, #20]
    f11e:	ldr	r0, [sp, #24]
    f120:	bl	12d28 <__ssprint_r>
    f124:	cmp	r0, #0
    f126:	bne.w	df84 <_svfprintf_r+0x1f4>
    f12a:	ldr	r4, [sp, #148]	; 0x94
    f12c:	add.w	r9, sp, #192	; 0xc0
    f130:	b.n	e9cc <_svfprintf_r+0xc3c>
    f132:	mov	r4, r2
    f134:	adds	r3, #1
    f136:	ldr	r2, [sp, #44]	; 0x2c
    f138:	str	r3, [sp, #144]	; 0x90
    f13a:	add	r4, r5
    f13c:	cmp	r3, #7
    f13e:	str	r4, [sp, #148]	; 0x94
    f140:	stmia.w	r9, {r2, r5}
    f144:	bgt.n	f0d4 <_svfprintf_r+0x1344>
    f146:	add.w	r9, r9, #8
    f14a:	b.n	f0ec <_svfprintf_r+0x135c>
    f14c:	ldr	r2, [sp, #52]	; 0x34
    f14e:	subs	r2, #2
    f150:	str	r2, [sp, #52]	; 0x34
    f152:	subs	r3, #1
    f154:	cmp	r3, #0
    f156:	ldrb.w	r2, [sp, #52]	; 0x34
    f15a:	str	r3, [sp, #116]	; 0x74
    f15c:	it	lt
    f15e:	neglt	r3, r3
    f160:	strb.w	r2, [sp, #124]	; 0x7c
    f164:	ite	lt
    f166:	movlt	r2, #45	; 0x2d
    f168:	movge	r2, #43	; 0x2b
    f16a:	cmp	r3, #9
    f16c:	strb.w	r2, [sp, #125]	; 0x7d
    f170:	ble.w	f34a <_svfprintf_r+0x15ba>
    f174:	add.w	r0, sp, #139	; 0x8b
    f178:	mov	r4, r0
    f17a:	ldr	r2, [pc, #180]	; (f230 <_svfprintf_r+0x14a0>)
    f17c:	smull	r2, r1, r2, r3
    f180:	asrs	r2, r3, #31
    f182:	rsb	r2, r2, r1, asr #2
    f186:	add.w	r1, r2, r2, lsl #2
    f18a:	sub.w	r3, r3, r1, lsl #1
    f18e:	add.w	r1, r3, #48	; 0x30
    f192:	cmp	r2, #9
    f194:	mov	r3, r2
    f196:	strb.w	r1, [r4, #-1]!
    f19a:	bgt.n	f17a <_svfprintf_r+0x13ea>
    f19c:	mov	r1, r4
    f19e:	adds	r3, #48	; 0x30
    f1a0:	uxtb	r2, r3
    f1a2:	strb.w	r2, [r1, #-1]!
    f1a6:	cmp	r0, r1
    f1a8:	bls.w	f414 <_svfprintf_r+0x1684>
    f1ac:	add.w	r1, sp, #126	; 0x7e
    f1b0:	mov	r3, r4
    f1b2:	b.n	f1b8 <_svfprintf_r+0x1428>
    f1b4:	ldrb.w	r2, [r3], #1
    f1b8:	strb.w	r2, [r1], #1
    f1bc:	cmp	r0, r3
    f1be:	bne.n	f1b4 <_svfprintf_r+0x1424>
    f1c0:	adds	r3, r0, #1
    f1c2:	subs	r3, r3, r4
    f1c4:	add.w	r2, sp, #126	; 0x7e
    f1c8:	add	r3, r2
    f1ca:	add	r2, sp, #124	; 0x7c
    f1cc:	subs	r3, r3, r2
    f1ce:	ldr	r2, [sp, #56]	; 0x38
    f1d0:	str	r3, [sp, #84]	; 0x54
    f1d2:	cmp	r2, #1
    f1d4:	add	r3, r2
    f1d6:	str	r3, [sp, #36]	; 0x24
    f1d8:	ble.w	f3aa <_svfprintf_r+0x161a>
    f1dc:	ldr	r3, [sp, #36]	; 0x24
    f1de:	ldr	r2, [sp, #72]	; 0x48
    f1e0:	add	r3, r2
    f1e2:	movs	r2, #0
    f1e4:	str	r3, [sp, #36]	; 0x24
    f1e6:	str	r2, [sp, #60]	; 0x3c
    f1e8:	bic.w	r3, r3, r3, asr #31
    f1ec:	b.n	ee4a <_svfprintf_r+0x10ba>
    f1ee:	add	r2, sp, #140	; 0x8c
    f1f0:	ldr	r1, [sp, #20]
    f1f2:	ldr	r0, [sp, #24]
    f1f4:	bl	12d28 <__ssprint_r>
    f1f8:	cmp	r0, #0
    f1fa:	bne.w	df84 <_svfprintf_r+0x1f4>
    f1fe:	ldr	r3, [sp, #116]	; 0x74
    f200:	ldr	r4, [sp, #148]	; 0x94
    f202:	add.w	r9, sp, #192	; 0xc0
    f206:	b.n	ebe0 <_svfprintf_r+0xe50>
    f208:	add	r2, sp, #140	; 0x8c
    f20a:	ldr	r1, [sp, #20]
    f20c:	ldr	r0, [sp, #24]
    f20e:	bl	12d28 <__ssprint_r>
    f212:	cmp	r0, #0
    f214:	bne.w	df84 <_svfprintf_r+0x1f4>
    f218:	ldr	r3, [sp, #116]	; 0x74
    f21a:	ldr	r2, [sp, #56]	; 0x38
    f21c:	ldr	r4, [sp, #148]	; 0x94
    f21e:	subs	r3, r2, r3
    f220:	add.w	r9, sp, #192	; 0xc0
    f224:	b.n	ec10 <_svfprintf_r+0xe80>
    f226:	nop
    f228:	.word	0x00013bb0
    f22c:	.word	0x00013b60
    f230:	.word	0x66666667
    f234:	cmp	r5, #6
    f236:	mov	r3, r5
    f238:	it	cs
    f23a:	movcs	r3, #6
    f23c:	str	r3, [sp, #36]	; 0x24
    f23e:	bic.w	r3, r3, r3, asr #31
    f242:	mov	fp, r6
    f244:	str	r7, [sp, #40]	; 0x28
    f246:	str	r6, [sp, #60]	; 0x3c
    f248:	mov	r7, r6
    f24a:	str	r3, [sp, #16]
    f24c:	ldr	r6, [pc, #536]	; (f468 <_svfprintf_r+0x16d8>)
    f24e:	b.w	e134 <_svfprintf_r+0x3a4>
    f252:	mov.w	fp, #6
    f256:	b.n	ed8a <_svfprintf_r+0xffa>
    f258:	add	r2, sp, #132	; 0x84
    f25a:	add	r3, sp, #120	; 0x78
    f25c:	str	r2, [sp, #4]
    f25e:	str	r3, [sp, #0]
    f260:	mov	r2, fp
    f262:	add	r3, sp, #116	; 0x74
    f264:	movs	r1, #3
    f266:	vldr	d0, [sp, #96]	; 0x60
    f26a:	ldr	r0, [sp, #24]
    f26c:	bl	10598 <_dtoa_r>
    f270:	mov	r5, fp
    f272:	mov	r6, r0
    f274:	add.w	r4, r0, fp
    f278:	b.n	f066 <_svfprintf_r+0x12d6>
    f27a:	movs	r7, #45	; 0x2d
    f27c:	strb.w	r7, [sp, #111]	; 0x6f
    f280:	b.w	e3da <_svfprintf_r+0x64a>
    f284:	str	r3, [sp, #12]
    f286:	b.w	e532 <_svfprintf_r+0x7a2>
    f28a:	ldrd	r1, r2, [sp, #64]	; 0x40
    f28e:	add.w	r3, r2, #2147483648	; 0x80000000
    f292:	str	r3, [sp, #100]	; 0x64
    f294:	movs	r3, #45	; 0x2d
    f296:	str	r1, [sp, #96]	; 0x60
    f298:	str	r3, [sp, #16]
    f29a:	b.n	eda6 <_svfprintf_r+0x1016>
    f29c:	ldr	r2, [sp, #72]	; 0x48
    f29e:	ldr	r3, [sp, #56]	; 0x38
    f2a0:	add	r3, r2
    f2a2:	ldr	r2, [sp, #60]	; 0x3c
    f2a4:	str	r3, [sp, #36]	; 0x24
    f2a6:	cmp	r2, #0
    f2a8:	ble.w	f3be <_svfprintf_r+0x162e>
    f2ac:	movs	r2, #103	; 0x67
    f2ae:	bic.w	r3, r3, r3, asr #31
    f2b2:	str	r2, [sp, #52]	; 0x34
    f2b4:	b.n	ee4a <_svfprintf_r+0x10ba>
    f2b6:	ldr	r3, [sp, #52]	; 0x34
    f2b8:	cmp	r3, #71	; 0x47
    f2ba:	bne.w	ede8 <_svfprintf_r+0x1058>
    f2be:	ldr	r3, [sp, #12]
    f2c0:	lsls	r3, r3, #31
    f2c2:	bmi.w	f05a <_svfprintf_r+0x12ca>
    f2c6:	ldr	r3, [sp, #132]	; 0x84
    f2c8:	cmp	r7, #71	; 0x47
    f2ca:	sub.w	r3, r3, r6
    f2ce:	str	r3, [sp, #56]	; 0x38
    f2d0:	beq.w	f108 <_svfprintf_r+0x1378>
    f2d4:	ldr	r3, [sp, #116]	; 0x74
    f2d6:	b.n	f152 <_svfprintf_r+0x13c2>
    f2d8:	bic.w	r3, r5, r5, asr #31
    f2dc:	str	r7, [sp, #40]	; 0x28
    f2de:	str	r3, [sp, #16]
    f2e0:	str	r5, [sp, #36]	; 0x24
    f2e2:	mov	fp, r0
    f2e4:	str	r0, [sp, #60]	; 0x3c
    f2e6:	ldrb.w	r7, [sp, #111]	; 0x6f
    f2ea:	b.w	e134 <_svfprintf_r+0x3a4>
    f2ee:	cmp	r3, #0
    f2f0:	ble.n	f3ce <_svfprintf_r+0x163e>
    f2f2:	cmp.w	fp, #0
    f2f6:	bne.n	f398 <_svfprintf_r+0x1608>
    f2f8:	ldr	r2, [sp, #12]
    f2fa:	lsls	r4, r2, #31
    f2fc:	bmi.n	f398 <_svfprintf_r+0x1608>
    f2fe:	mov	r2, r3
    f300:	str	r2, [sp, #36]	; 0x24
    f302:	bic.w	r3, r3, r3, asr #31
    f306:	b.n	ee4a <_svfprintf_r+0x10ba>
    f308:	ldr	r3, [sp, #12]
    f30a:	lsls	r3, r3, #31
    f30c:	mov	r7, fp
    f30e:	bpl.n	f31c <_svfprintf_r+0x158c>
    f310:	add	r6, sp, #256	; 0x100
    f312:	movs	r3, #48	; 0x30
    f314:	strb.w	r3, [r6, #-65]!
    f318:	b.w	e120 <_svfprintf_r+0x390>
    f31c:	str.w	fp, [sp, #36]	; 0x24
    f320:	add	r6, sp, #192	; 0xc0
    f322:	b.w	e126 <_svfprintf_r+0x396>
    f326:	add	r2, sp, #140	; 0x8c
    f328:	ldr	r1, [sp, #20]
    f32a:	ldr	r0, [sp, #24]
    f32c:	bl	12d28 <__ssprint_r>
    f330:	cmp	r0, #0
    f332:	bne.w	df84 <_svfprintf_r+0x1f4>
    f336:	ldr	r5, [sp, #116]	; 0x74
    f338:	ldr	r4, [sp, #148]	; 0x94
    f33a:	ldr	r3, [sp, #144]	; 0x90
    f33c:	add.w	r9, sp, #192	; 0xc0
    f340:	b.n	ef90 <_svfprintf_r+0x1200>
    f342:	mov	r8, r4
    f344:	movs	r5, #0
    f346:	b.w	de48 <_svfprintf_r+0xb8>
    f34a:	adds	r3, #48	; 0x30
    f34c:	movs	r2, #48	; 0x30
    f34e:	strb.w	r3, [sp, #127]	; 0x7f
    f352:	strb.w	r2, [sp, #126]	; 0x7e
    f356:	add	r3, sp, #128	; 0x80
    f358:	b.n	f1ca <_svfprintf_r+0x143a>
    f35a:	ldr	r3, [sp, #132]	; 0x84
    f35c:	b.n	ee10 <_svfprintf_r+0x1080>
    f35e:	ldr	r2, [sp, #72]	; 0x48
    f360:	ldr	r3, [sp, #60]	; 0x3c
    f362:	add	r3, r2
    f364:	movs	r2, #103	; 0x67
    f366:	str	r3, [sp, #36]	; 0x24
    f368:	str	r2, [sp, #52]	; 0x34
    f36a:	bic.w	r3, r3, r3, asr #31
    f36e:	b.n	ee4a <_svfprintf_r+0x10ba>
    f370:	ldr	r6, [pc, #248]	; (f46c <_svfprintf_r+0x16dc>)
    f372:	ldr	r3, [pc, #252]	; (f470 <_svfprintf_r+0x16e0>)
    f374:	ldrb.w	r7, [sp, #111]	; 0x6f
    f378:	b.w	e3de <_svfprintf_r+0x64e>
    f37c:	movs	r2, #0
    f37e:	movs	r3, #0
    f380:	ldrd	r0, r1, [sp, #96]	; 0x60
    f384:	bl	b780 <__aeabi_dcmpeq>
    f388:	cmp	r0, #0
    f38a:	bne.w	f06e <_svfprintf_r+0x12de>
    f38e:	rsb	r5, r5, #1
    f392:	str	r5, [sp, #116]	; 0x74
    f394:	add	r4, r5
    f396:	b.n	edea <_svfprintf_r+0x105a>
    f398:	ldr	r3, [sp, #60]	; 0x3c
    f39a:	ldr	r2, [sp, #72]	; 0x48
    f39c:	adds	r5, r3, r2
    f39e:	add.w	r3, r5, fp
    f3a2:	str	r3, [sp, #36]	; 0x24
    f3a4:	bic.w	r3, r3, r3, asr #31
    f3a8:	b.n	ee4a <_svfprintf_r+0x10ba>
    f3aa:	ldr	r3, [sp, #12]
    f3ac:	ands.w	r3, r3, #1
    f3b0:	bne.w	f1dc <_svfprintf_r+0x144c>
    f3b4:	str	r3, [sp, #60]	; 0x3c
    f3b6:	ldr	r3, [sp, #36]	; 0x24
    f3b8:	bic.w	r3, r3, r3, asr #31
    f3bc:	b.n	ee4a <_svfprintf_r+0x10ba>
    f3be:	ldr	r3, [sp, #60]	; 0x3c
    f3c0:	ldr	r2, [sp, #36]	; 0x24
    f3c2:	rsb	r3, r3, #1
    f3c6:	add	r2, r3
    f3c8:	mov	r3, r2
    f3ca:	str	r2, [sp, #36]	; 0x24
    f3cc:	b.n	f2ac <_svfprintf_r+0x151c>
    f3ce:	cmp.w	fp, #0
    f3d2:	bne.n	f3da <_svfprintf_r+0x164a>
    f3d4:	ldr	r3, [sp, #12]
    f3d6:	lsls	r0, r3, #31
    f3d8:	bpl.n	f3ea <_svfprintf_r+0x165a>
    f3da:	ldr	r3, [sp, #72]	; 0x48
    f3dc:	adds	r5, r3, #1
    f3de:	add.w	r3, r5, fp
    f3e2:	str	r3, [sp, #36]	; 0x24
    f3e4:	bic.w	r3, r3, r3, asr #31
    f3e8:	b.n	ee4a <_svfprintf_r+0x10ba>
    f3ea:	movs	r3, #1
    f3ec:	str	r3, [sp, #36]	; 0x24
    f3ee:	b.n	ee4a <_svfprintf_r+0x10ba>
    f3f0:	ldr	r0, [sp, #40]	; 0x28
    f3f2:	ldrb.w	r3, [r8, #1]
    f3f6:	ldr	r5, [r0, #0]
    f3f8:	adds	r0, #4
    f3fa:	cmp	r5, #0
    f3fc:	str	r0, [sp, #40]	; 0x28
    f3fe:	mov	r8, r4
    f400:	bge.w	de44 <_svfprintf_r+0xb4>
    f404:	mov.w	r5, #4294967295
    f408:	b.w	de44 <_svfprintf_r+0xb4>
    f40c:	strb.w	r1, [sp, #111]	; 0x6f
    f410:	b.w	dfa6 <_svfprintf_r+0x216>
    f414:	add.w	r3, sp, #126	; 0x7e
    f418:	b.n	f1ca <_svfprintf_r+0x143a>
    f41a:	ldr	r2, [sp, #24]
    f41c:	movs	r3, #12
    f41e:	str	r3, [r2, #0]
    f420:	mov.w	r0, #4294967295
    f424:	b.w	df96 <_svfprintf_r+0x206>
    f428:	strb.w	r1, [sp, #111]	; 0x6f
    f42c:	b.w	e0a0 <_svfprintf_r+0x310>
    f430:	strb.w	r1, [sp, #111]	; 0x6f
    f434:	b.w	e36c <_svfprintf_r+0x5dc>
    f438:	strb.w	r1, [sp, #111]	; 0x6f
    f43c:	b.w	e4da <_svfprintf_r+0x74a>
    f440:	strb.w	r1, [sp, #111]	; 0x6f
    f444:	b.w	e47e <_svfprintf_r+0x6ee>
    f448:	strb.w	r1, [sp, #111]	; 0x6f
    f44c:	b.w	e42a <_svfprintf_r+0x69a>
    f450:	strb.w	r1, [sp, #111]	; 0x6f
    f454:	b.w	e6c2 <_svfprintf_r+0x932>
    f458:	strb.w	r1, [sp, #111]	; 0x6f
    f45c:	b.w	e680 <_svfprintf_r+0x8f0>
    f460:	strb.w	r1, [sp, #111]	; 0x6f
    f464:	b.w	e644 <_svfprintf_r+0x8b4>
    f468:	.word	0x00013ba8
    f46c:	.word	0x00013b7c
    f470:	.word	0x00013b78

0000f474 <__ssvfscanf_r>:
    f474:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f478:	mov	fp, r1
    f47a:	ldrsh.w	r1, [r1, #12]
    f47e:	sub.w	sp, sp, #692	; 0x2b4
    f482:	mov	sl, r0
    f484:	lsls	r0, r1, #18
    f486:	mov	r4, r2
    f488:	str	r3, [sp, #20]
    f48a:	bmi.n	f4a0 <__ssvfscanf_r+0x2c>
    f48c:	ldr.w	r3, [fp, #100]	; 0x64
    f490:	orr.w	r1, r1, #8192	; 0x2000
    f494:	bic.w	r3, r3, #8192	; 0x2000
    f498:	strh.w	r1, [fp, #12]
    f49c:	str.w	r3, [fp, #100]	; 0x64
    f4a0:	mov	r6, r4
    f4a2:	movs	r3, #0
    f4a4:	str	r3, [sp, #28]
    f4a6:	str	r3, [sp, #16]
    f4a8:	mov	r7, r3
    f4aa:	str	r3, [sp, #24]
    f4ac:	ldrb.w	r3, [r6], #1
    f4b0:	str	r3, [sp, #68]	; 0x44
    f4b2:	cbz	r3, f510 <__ssvfscanf_r+0x9c>
    f4b4:	bl	bcfc <__locale_ctype_ptr>
    f4b8:	ldr	r2, [sp, #68]	; 0x44
    f4ba:	add	r0, r2
    f4bc:	ldrb	r3, [r0, #1]
    f4be:	and.w	r3, r3, #8
    f4c2:	and.w	r5, r3, #255	; 0xff
    f4c6:	cbz	r3, f51a <__ssvfscanf_r+0xa6>
    f4c8:	ldr.w	r3, [fp, #4]
    f4cc:	b.n	f4f2 <__ssvfscanf_r+0x7e>
    f4ce:	bl	bcfc <__locale_ctype_ptr>
    f4d2:	ldr.w	r3, [fp]
    f4d6:	ldrb	r2, [r3, #0]
    f4d8:	add	r0, r2
    f4da:	adds	r3, #1
    f4dc:	ldrb	r2, [r0, #1]
    f4de:	lsls	r1, r2, #28
    f4e0:	bpl.n	f502 <__ssvfscanf_r+0x8e>
    f4e2:	ldr.w	r2, [fp, #4]
    f4e6:	str.w	r3, [fp]
    f4ea:	subs	r3, r2, #1
    f4ec:	adds	r7, #1
    f4ee:	str.w	r3, [fp, #4]
    f4f2:	cmp	r3, #0
    f4f4:	bgt.n	f4ce <__ssvfscanf_r+0x5a>
    f4f6:	mov	r1, fp
    f4f8:	mov	r0, sl
    f4fa:	bl	12eac <__ssrefill_r>
    f4fe:	cmp	r0, #0
    f500:	beq.n	f4ce <__ssvfscanf_r+0x5a>
    f502:	mov	r4, r6
    f504:	mov	r6, r4
    f506:	ldrb.w	r3, [r6], #1
    f50a:	str	r3, [sp, #68]	; 0x44
    f50c:	cmp	r3, #0
    f50e:	bne.n	f4b4 <__ssvfscanf_r+0x40>
    f510:	ldr	r0, [sp, #24]
    f512:	add.w	sp, sp, #692	; 0x2b4
    f516:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f51a:	cmp	r2, #37	; 0x25
    f51c:	bne.w	f628 <__ssvfscanf_r+0x1b4>
    f520:	ldrb.w	r8, [r4, #1]
    f524:	mov	r4, r5
    f526:	adds	r3, r6, #1
    f528:	cmp.w	r8, #120	; 0x78
    f52c:	bhi.w	f9b6 <__ssvfscanf_r+0x542>
    f530:	tbh	[pc, r8, lsl #1]
    f534:	.word	0x02410092
    f538:	.word	0x02410241
    f53c:	.word	0x02410241
    f540:	.word	0x02410241
    f544:	.word	0x02410241
    f548:	.word	0x02410241
    f54c:	.word	0x02410241
    f550:	.word	0x02410241
    f554:	.word	0x02410241
    f558:	.word	0x02410241
    f55c:	.word	0x02410241
    f560:	.word	0x02410241
    f564:	.word	0x02410241
    f568:	.word	0x02410241
    f56c:	.word	0x02410241
    f570:	.word	0x02410241
    f574:	.word	0x02410241
    f578:	.word	0x02410241
    f57c:	.word	0x00790241
    f580:	.word	0x02410241
    f584:	.word	0x02410241
    f588:	.word	0x024101d8
    f58c:	.word	0x02410241
    f590:	.word	0x02410241
    f594:	.word	0x01cf01cf
    f598:	.word	0x01cf01cf
    f59c:	.word	0x01cf01cf
    f5a0:	.word	0x01cf01cf
    f5a4:	.word	0x01cf01cf
    f5a8:	.word	0x02410241
    f5ac:	.word	0x02410241
    f5b0:	.word	0x02410241
    f5b4:	.word	0x02410241
    f5b8:	.word	0x02410241
    f5bc:	.word	0x01b901c1
    f5c0:	.word	0x01b90241
    f5c4:	.word	0x02410241
    f5c8:	.word	0x02410241
    f5cc:	.word	0x024101b3
    f5d0:	.word	0x01a30241
    f5d4:	.word	0x02410241
    f5d8:	.word	0x02410241
    f5dc:	.word	0x02410241
    f5e0:	.word	0x02410241
    f5e4:	.word	0x02410193
    f5e8:	.word	0x01510241
    f5ec:	.word	0x02410241
    f5f0:	.word	0x02410241
    f5f4:	.word	0x02410241
    f5f8:	.word	0x01220241
    f5fc:	.word	0x01b90188
    f600:	.word	0x01b901b9
    f604:	.word	0x0098011c
    f608:	.word	0x02410241
    f60c:	.word	0x024100d5
    f610:	.word	0x0101010d
    f614:	.word	0x024100f3
    f618:	.word	0x00eb0241
    f61c:	.word	0x00df0241
    f620:	.word	0x02410241
    f624:	.short	0x0193
    f626:	mov	r6, r3
    f628:	ldr.w	r3, [fp, #4]
    f62c:	cmp	r3, #0
    f62e:	ble.w	fad8 <__ssvfscanf_r+0x664>
    f632:	ldr.w	r3, [fp]
    f636:	ldrb.w	r2, [r6, #-1]
    f63a:	ldrb	r1, [r3, #0]
    f63c:	cmp	r1, r2
    f63e:	bne.w	f510 <__ssvfscanf_r+0x9c>
    f642:	ldr.w	r2, [fp, #4]
    f646:	adds	r3, #1
    f648:	subs	r2, #1
    f64a:	str.w	r3, [fp]
    f64e:	adds	r7, #1
    f650:	str.w	r2, [fp, #4]
    f654:	mov	r4, r6
    f656:	b.n	f504 <__ssvfscanf_r+0x90>
    f658:	mov.w	r0, #4294967295
    f65c:	add.w	sp, sp, #692	; 0x2b4
    f660:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f664:	str	r3, [sp, #12]
    f666:	ldr.w	r3, [fp, #4]
    f66a:	cmp	r3, #0
    f66c:	ble.w	fb36 <__ssvfscanf_r+0x6c2>
    f670:	ldr	r3, [pc, #736]	; (f954 <__ssvfscanf_r+0x4e0>)
    f672:	str	r3, [sp, #28]
    f674:	movs	r3, #0
    f676:	str	r3, [sp, #16]
    f678:	movs	r6, #3
    f67a:	b.n	f680 <__ssvfscanf_r+0x20c>
    f67c:	str.w	lr, [fp]
    f680:	bl	bcfc <__locale_ctype_ptr>
    f684:	ldr.w	r2, [fp]
    f688:	ldrb	r1, [r2, #0]
    f68a:	add	r0, r1
    f68c:	add.w	lr, r2, #1
    f690:	ldrb	r3, [r0, #1]
    f692:	and.w	r3, r3, #8
    f696:	and.w	r8, r3, #255	; 0xff
    f69a:	cmp	r3, #0
    f69c:	beq.w	fb9e <__ssvfscanf_r+0x72a>
    f6a0:	ldr.w	r3, [fp, #4]
    f6a4:	subs	r3, #1
    f6a6:	cmp	r3, #0
    f6a8:	add.w	r7, r7, #1
    f6ac:	str.w	r3, [fp, #4]
    f6b0:	bgt.n	f67c <__ssvfscanf_r+0x208>
    f6b2:	mov	r1, fp
    f6b4:	mov	r0, sl
    f6b6:	bl	12eac <__ssrefill_r>
    f6ba:	cmp	r0, #0
    f6bc:	beq.n	f680 <__ssvfscanf_r+0x20c>
    f6be:	ldr	r2, [sp, #24]
    f6c0:	cmp	r2, #0
    f6c2:	beq.n	f658 <__ssvfscanf_r+0x1e4>
    f6c4:	ldrh.w	r3, [fp, #12]
    f6c8:	tst.w	r3, #64	; 0x40
    f6cc:	mov	r3, r2
    f6ce:	it	ne
    f6d0:	movne.w	r3, #4294967295
    f6d4:	mov	r0, r3
    f6d6:	add.w	sp, sp, #692	; 0x2b4
    f6da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f6de:	ldrb.w	r8, [r6, #1]
    f6e2:	cmp.w	r8, #108	; 0x6c
    f6e6:	beq.w	faee <__ssvfscanf_r+0x67a>
    f6ea:	orr.w	r5, r5, #1
    f6ee:	mov	r6, r3
    f6f0:	b.n	f526 <__ssvfscanf_r+0xb2>
    f6f2:	str	r3, [sp, #12]
    f6f4:	ldr.w	r3, [fp, #4]
    f6f8:	cmp	r3, #0
    f6fa:	ble.w	fb8e <__ssvfscanf_r+0x71a>
    f6fe:	ldr	r3, [pc, #600]	; (f958 <__ssvfscanf_r+0x4e4>)
    f700:	str	r3, [sp, #28]
    f702:	movs	r3, #10
    f704:	str	r3, [sp, #16]
    f706:	movs	r6, #3
    f708:	b.n	f680 <__ssvfscanf_r+0x20c>
    f70a:	str	r3, [sp, #12]
    f70c:	ldr.w	r3, [fp, #4]
    f710:	cmp	r3, #0
    f712:	ble.w	fb7e <__ssvfscanf_r+0x70a>
    f716:	movs	r6, #2
    f718:	b.n	f680 <__ssvfscanf_r+0x20c>
    f71a:	str	r3, [sp, #12]
    f71c:	ldr.w	r3, [fp, #4]
    f720:	cmp	r3, #0
    f722:	orr.w	r5, r5, #544	; 0x220
    f726:	ble.w	f86a <__ssvfscanf_r+0x3f6>
    f72a:	ldr	r3, [pc, #556]	; (f958 <__ssvfscanf_r+0x4e4>)
    f72c:	str	r3, [sp, #28]
    f72e:	movs	r3, #16
    f730:	str	r3, [sp, #16]
    f732:	movs	r6, #3
    f734:	b.n	f680 <__ssvfscanf_r+0x20c>
    f736:	str	r3, [sp, #12]
    f738:	ldr.w	r3, [fp, #4]
    f73c:	cmp	r3, #0
    f73e:	ble.w	f88a <__ssvfscanf_r+0x416>
    f742:	ldr	r3, [pc, #532]	; (f958 <__ssvfscanf_r+0x4e4>)
    f744:	str	r3, [sp, #28]
    f746:	movs	r3, #8
    f748:	str	r3, [sp, #16]
    f74a:	movs	r6, #3
    f74c:	b.n	f680 <__ssvfscanf_r+0x20c>
    f74e:	lsls	r2, r5, #27
    f750:	mov	r6, r3
    f752:	str	r3, [sp, #12]
    f754:	bmi.w	f93c <__ssvfscanf_r+0x4c8>
    f758:	lsls	r3, r5, #29
    f75a:	bpl.w	fb06 <__ssvfscanf_r+0x692>
    f75e:	ldr	r1, [sp, #20]
    f760:	ldr	r3, [r1, #0]
    f762:	strh	r7, [r3, #0]
    f764:	adds	r3, r1, #4
    f766:	str	r3, [sp, #20]
    f768:	mov	r4, r6
    f76a:	b.n	f504 <__ssvfscanf_r+0x90>
    f76c:	ldrb.w	r8, [r6, #1]
    f770:	orr.w	r5, r5, #4
    f774:	mov	r6, r3
    f776:	b.n	f526 <__ssvfscanf_r+0xb2>
    f778:	str	r3, [sp, #12]
    f77a:	ldr.w	r3, [fp, #4]
    f77e:	cmp	r3, #0
    f780:	ble.w	fb5e <__ssvfscanf_r+0x6ea>
    f784:	cmp	r4, #0
    f786:	it	eq
    f788:	moveq	r4, #1
    f78a:	ands.w	r3, r5, #1
    f78e:	bne.w	f9d6 <__ssvfscanf_r+0x562>
    f792:	lsls	r2, r5, #27
    f794:	bpl.w	faae <__ssvfscanf_r+0x63a>
    f798:	mov	r5, r3
    f79a:	b.n	f7b0 <__ssvfscanf_r+0x33c>
    f79c:	add	r3, r2
    f79e:	str.w	r3, [fp]
    f7a2:	add	r5, r2
    f7a4:	subs	r4, r4, r2
    f7a6:	bl	12eac <__ssrefill_r>
    f7aa:	cmp	r0, #0
    f7ac:	bne.w	faa6 <__ssvfscanf_r+0x632>
    f7b0:	ldr.w	r2, [fp, #4]
    f7b4:	ldr.w	r3, [fp]
    f7b8:	cmp	r2, r4
    f7ba:	mov	r1, fp
    f7bc:	mov	r0, sl
    f7be:	blt.n	f79c <__ssvfscanf_r+0x328>
    f7c0:	subs	r2, r2, r4
    f7c2:	add	r3, r4
    f7c4:	str.w	r2, [fp, #4]
    f7c8:	add	r5, r4
    f7ca:	str.w	r3, [fp]
    f7ce:	ldr	r6, [sp, #12]
    f7d0:	add	r7, r5
    f7d2:	mov	r4, r6
    f7d4:	b.n	f504 <__ssvfscanf_r+0x90>
    f7d6:	add.w	r9, sp, #80	; 0x50
    f7da:	mov	r1, r3
    f7dc:	mov	r0, r9
    f7de:	bl	12748 <__sccl>
    f7e2:	ldr.w	r3, [fp, #4]
    f7e6:	cmp	r3, #0
    f7e8:	mov	r6, r0
    f7ea:	ble.w	fb4e <__ssvfscanf_r+0x6da>
    f7ee:	cmp	r4, #0
    f7f0:	ldr.w	r2, [fp]
    f7f4:	it	eq
    f7f6:	moveq.w	r4, #4294967295
    f7fa:	lsls	r3, r5, #27
    f7fc:	ldrb	r1, [r2, #0]
    f7fe:	bpl.w	f942 <__ssvfscanf_r+0x4ce>
    f802:	mov	r8, r4
    f804:	movs	r5, #0
    f806:	b.n	f80a <__ssvfscanf_r+0x396>
    f808:	ldrb	r1, [r2, #0]
    f80a:	ldrb.w	r3, [r9, r1]
    f80e:	adds	r2, #1
    f810:	cmp	r3, #0
    f812:	beq.w	fa9c <__ssvfscanf_r+0x628>
    f816:	ldr.w	r3, [fp, #4]
    f81a:	str.w	r2, [fp]
    f81e:	adds	r5, #1
    f820:	subs	r3, #1
    f822:	cmp	r5, r4
    f824:	str.w	r3, [fp, #4]
    f828:	beq.w	fa96 <__ssvfscanf_r+0x622>
    f82c:	cmp	r3, #0
    f82e:	bgt.n	f808 <__ssvfscanf_r+0x394>
    f830:	mov	r1, fp
    f832:	mov	r0, sl
    f834:	bl	12eac <__ssrefill_r>
    f838:	cmp	r0, #0
    f83a:	bne.w	fa94 <__ssvfscanf_r+0x620>
    f83e:	ldr.w	r2, [fp]
    f842:	b.n	f808 <__ssvfscanf_r+0x394>
    f844:	str	r3, [sp, #12]
    f846:	ldr.w	r3, [fp, #4]
    f84a:	cmp	r3, #0
    f84c:	ble.n	f8c4 <__ssvfscanf_r+0x450>
    f84e:	ldr	r3, [pc, #260]	; (f954 <__ssvfscanf_r+0x4e0>)
    f850:	str	r3, [sp, #28]
    f852:	movs	r3, #10
    f854:	str	r3, [sp, #16]
    f856:	movs	r6, #3
    f858:	b.n	f680 <__ssvfscanf_r+0x20c>
    f85a:	str	r3, [sp, #12]
    f85c:	ldr.w	r3, [fp, #4]
    f860:	cmp	r3, #0
    f862:	orr.w	r5, r5, #512	; 0x200
    f866:	bgt.w	f72a <__ssvfscanf_r+0x2b6>
    f86a:	mov	r1, fp
    f86c:	mov	r0, sl
    f86e:	bl	12eac <__ssrefill_r>
    f872:	cmp	r0, #0
    f874:	beq.w	f72a <__ssvfscanf_r+0x2b6>
    f878:	b.n	f6be <__ssvfscanf_r+0x24a>
    f87a:	str	r3, [sp, #12]
    f87c:	ldr.w	r3, [fp, #4]
    f880:	cmp	r3, #0
    f882:	orr.w	r5, r5, #1
    f886:	bgt.w	f742 <__ssvfscanf_r+0x2ce>
    f88a:	mov	r1, fp
    f88c:	mov	r0, sl
    f88e:	bl	12eac <__ssrefill_r>
    f892:	cmp	r0, #0
    f894:	beq.w	f742 <__ssvfscanf_r+0x2ce>
    f898:	b.n	f6be <__ssvfscanf_r+0x24a>
    f89a:	ldrb.w	r8, [r6, #1]
    f89e:	orr.w	r5, r5, #2
    f8a2:	mov	r6, r3
    f8a4:	b.n	f526 <__ssvfscanf_r+0xb2>
    f8a6:	str	r3, [sp, #12]
    f8a8:	ldr.w	r3, [fp, #4]
    f8ac:	cmp	r3, #0
    f8ae:	ble.w	fb6e <__ssvfscanf_r+0x6fa>
    f8b2:	movs	r6, #4
    f8b4:	b.n	f680 <__ssvfscanf_r+0x20c>
    f8b6:	str	r3, [sp, #12]
    f8b8:	ldr.w	r3, [fp, #4]
    f8bc:	cmp	r3, #0
    f8be:	orr.w	r5, r5, #1
    f8c2:	bgt.n	f84e <__ssvfscanf_r+0x3da>
    f8c4:	mov	r1, fp
    f8c6:	mov	r0, sl
    f8c8:	bl	12eac <__ssrefill_r>
    f8cc:	cmp	r0, #0
    f8ce:	beq.n	f84e <__ssvfscanf_r+0x3da>
    f8d0:	b.n	f6be <__ssvfscanf_r+0x24a>
    f8d2:	add.w	r4, r4, r4, lsl #2
    f8d6:	add.w	r4, r8, r4, lsl #1
    f8da:	subs	r4, #48	; 0x30
    f8dc:	ldrb.w	r8, [r6, #1]
    f8e0:	mov	r6, r3
    f8e2:	b.n	f526 <__ssvfscanf_r+0xb2>
    f8e4:	ldrb.w	r8, [r6, #1]
    f8e8:	orr.w	r5, r5, #16
    f8ec:	mov	r6, r3
    f8ee:	b.n	f526 <__ssvfscanf_r+0xb2>
    f8f0:	add	r3, sp, #72	; 0x48
    f8f2:	mov	r1, r8
    f8f4:	mov	r0, r3
    f8f6:	movs	r2, #8
    f8f8:	str	r3, [sp, #32]
    f8fa:	bl	c49c <memset>
    f8fe:	ands.w	r9, r5, #16
    f902:	bne.w	101c8 <__ssvfscanf_r+0xd54>
    f906:	ldr	r2, [sp, #20]
    f908:	mov	r3, r2
    f90a:	adds	r3, #4
    f90c:	ldr.w	r8, [r2]
    f910:	str	r3, [sp, #20]
    f912:	movs	r6, #0
    f914:	bl	bcfc <__locale_ctype_ptr>
    f918:	ldr.w	r3, [fp]
    f91c:	ldrb	r3, [r3, #0]
    f91e:	add	r0, r3
    f920:	ldrb	r3, [r0, #1]
    f922:	lsls	r0, r3, #28
    f924:	bmi.n	f92c <__ssvfscanf_r+0x4b8>
    f926:	cmp	r4, #0
    f928:	bne.w	1012c <__ssvfscanf_r+0xcb8>
    f92c:	cmp.w	r9, #0
    f930:	bne.n	f93c <__ssvfscanf_r+0x4c8>
    f932:	str.w	r9, [r8]
    f936:	ldr	r3, [sp, #24]
    f938:	adds	r3, #1
    f93a:	str	r3, [sp, #24]
    f93c:	ldr	r6, [sp, #12]
    f93e:	mov	r4, r6
    f940:	b.n	f504 <__ssvfscanf_r+0x90>
    f942:	ldr	r0, [sp, #20]
    f944:	ldr	r5, [r0, #0]
    f946:	mov	r3, r0
    f948:	adds	r3, #4
    f94a:	add.w	r8, r5, r4
    f94e:	str	r3, [sp, #12]
    f950:	mov	r4, r5
    f952:	b.n	f962 <__ssvfscanf_r+0x4ee>
    f954:	.word	0x0000dd69
    f958:	.word	0x00012af5
    f95c:	ldr.w	r2, [fp]
    f960:	ldrb	r1, [r2, #0]
    f962:	ldrb.w	r3, [r9, r1]
    f966:	adds	r0, r2, #1
    f968:	cbz	r3, f99c <__ssvfscanf_r+0x528>
    f96a:	ldr.w	r3, [fp, #4]
    f96e:	str.w	r0, [fp]
    f972:	subs	r3, #1
    f974:	str.w	r3, [fp, #4]
    f978:	ldrb	r3, [r2, #0]
    f97a:	strb.w	r3, [r4], #1
    f97e:	cmp	r8, r4
    f980:	beq.n	f99c <__ssvfscanf_r+0x528>
    f982:	ldr.w	r3, [fp, #4]
    f986:	cmp	r3, #0
    f988:	bgt.n	f95c <__ssvfscanf_r+0x4e8>
    f98a:	mov	r1, fp
    f98c:	mov	r0, sl
    f98e:	bl	12eac <__ssrefill_r>
    f992:	cmp	r0, #0
    f994:	beq.n	f95c <__ssvfscanf_r+0x4e8>
    f996:	cmp	r5, r4
    f998:	beq.w	f6be <__ssvfscanf_r+0x24a>
    f99c:	subs	r5, r4, r5
    f99e:	beq.w	f510 <__ssvfscanf_r+0x9c>
    f9a2:	ldr	r2, [sp, #24]
    f9a4:	adds	r2, #1
    f9a6:	movs	r3, #0
    f9a8:	str	r2, [sp, #24]
    f9aa:	ldr	r2, [sp, #12]
    f9ac:	str	r2, [sp, #20]
    f9ae:	strb	r3, [r4, #0]
    f9b0:	add	r7, r5
    f9b2:	mov	r4, r6
    f9b4:	b.n	f504 <__ssvfscanf_r+0x90>
    f9b6:	str	r3, [sp, #12]
    f9b8:	bl	bcfc <__locale_ctype_ptr>
    f9bc:	add	r0, r8
    f9be:	ldrb	r3, [r0, #1]
    f9c0:	and.w	r3, r3, #3
    f9c4:	cmp	r3, #1
    f9c6:	ldr.w	r3, [fp, #4]
    f9ca:	beq.w	fafa <__ssvfscanf_r+0x686>
    f9ce:	cmp	r3, #0
    f9d0:	bgt.w	f84e <__ssvfscanf_r+0x3da>
    f9d4:	b.n	f8c4 <__ssvfscanf_r+0x450>
    f9d6:	add	r3, sp, #72	; 0x48
    f9d8:	mov	r0, r3
    f9da:	movs	r2, #8
    f9dc:	movs	r1, #0
    f9de:	str	r3, [sp, #32]
    f9e0:	bl	c49c <memset>
    f9e4:	ands.w	r3, r5, #16
    f9e8:	str	r3, [sp, #40]	; 0x28
    f9ea:	bne.n	fae8 <__ssvfscanf_r+0x674>
    f9ec:	ldr	r2, [sp, #20]
    f9ee:	mov	r3, r2
    f9f0:	adds	r3, #4
    f9f2:	ldr.w	r9, [r2]
    f9f6:	str	r3, [sp, #20]
    f9f8:	movs	r5, #0
    f9fa:	add.w	r8, sp, #336	; 0x150
    f9fe:	bl	bcd8 <__locale_mb_cur_max>
    fa02:	cmp	r0, r5
    fa04:	beq.w	f6be <__ssvfscanf_r+0x24a>
    fa08:	ldmia.w	fp, {r2, r3}
    fa0c:	ldrb.w	r0, [r2], #1
    fa10:	str.w	r2, [fp]
    fa14:	subs	r3, #1
    fa16:	ldr	r2, [sp, #32]
    fa18:	str	r2, [sp, #0]
    fa1a:	adds	r6, r5, #1
    fa1c:	str.w	r3, [fp, #4]
    fa20:	mov	r1, r9
    fa22:	strb.w	r0, [r8, r5]
    fa26:	mov	r3, r6
    fa28:	mov	r2, r8
    fa2a:	mov	r0, sl
    fa2c:	bl	11e04 <_mbrtowc_r>
    fa30:	adds	r1, r0, #1
    fa32:	beq.w	f6be <__ssvfscanf_r+0x24a>
    fa36:	cbnz	r0, fa62 <__ssvfscanf_r+0x5ee>
    fa38:	ldr	r3, [sp, #40]	; 0x28
    fa3a:	cbnz	r3, fa82 <__ssvfscanf_r+0x60e>
    fa3c:	str.w	r3, [r9]
    fa40:	add	r7, r6
    fa42:	subs	r4, #1
    fa44:	add.w	r9, r9, #4
    fa48:	ldr.w	r3, [fp, #4]
    fa4c:	cmp	r3, #0
    fa4e:	mov.w	r5, #0
    fa52:	ble.n	fa70 <__ssvfscanf_r+0x5fc>
    fa54:	cmp	r4, #0
    fa56:	bne.n	f9fe <__ssvfscanf_r+0x58a>
    fa58:	ldr	r3, [sp, #40]	; 0x28
    fa5a:	cmp	r3, #0
    fa5c:	beq.w	f936 <__ssvfscanf_r+0x4c2>
    fa60:	b.n	f93c <__ssvfscanf_r+0x4c8>
    fa62:	adds	r0, #2
    fa64:	bne.n	fa88 <__ssvfscanf_r+0x614>
    fa66:	ldr.w	r3, [fp, #4]
    fa6a:	cmp	r3, #0
    fa6c:	mov	r5, r6
    fa6e:	bgt.n	f9fe <__ssvfscanf_r+0x58a>
    fa70:	mov	r1, fp
    fa72:	mov	r0, sl
    fa74:	bl	12eac <__ssrefill_r>
    fa78:	cmp	r0, #0
    fa7a:	beq.n	fa54 <__ssvfscanf_r+0x5e0>
    fa7c:	cmp	r5, #0
    fa7e:	beq.n	fa58 <__ssvfscanf_r+0x5e4>
    fa80:	b.n	f6be <__ssvfscanf_r+0x24a>
    fa82:	add	r7, r6
    fa84:	subs	r4, #1
    fa86:	b.n	fa48 <__ssvfscanf_r+0x5d4>
    fa88:	ldr	r3, [sp, #40]	; 0x28
    fa8a:	add	r7, r6
    fa8c:	subs	r4, #1
    fa8e:	cmp	r3, #0
    fa90:	bne.n	fa48 <__ssvfscanf_r+0x5d4>
    fa92:	b.n	fa44 <__ssvfscanf_r+0x5d0>
    fa94:	mov	r8, r5
    fa96:	mov	r5, r8
    fa98:	add	r7, r5
    fa9a:	b.n	f9b2 <__ssvfscanf_r+0x53e>
    fa9c:	cmp	r5, #0
    fa9e:	beq.w	f510 <__ssvfscanf_r+0x9c>
    faa2:	add	r7, r5
    faa4:	b.n	f9b2 <__ssvfscanf_r+0x53e>
    faa6:	cmp	r5, #0
    faa8:	bne.w	f7ce <__ssvfscanf_r+0x35a>
    faac:	b.n	f6be <__ssvfscanf_r+0x24a>
    faae:	ldr	r5, [sp, #20]
    fab0:	mov	r3, r4
    fab2:	ldr	r1, [r5, #0]
    fab4:	str.w	fp, [sp]
    fab8:	movs	r2, #1
    faba:	mov	r0, sl
    fabc:	bl	12ee8 <_sfread_r>
    fac0:	adds	r6, r5, #4
    fac2:	cmp	r0, #0
    fac4:	beq.w	f6be <__ssvfscanf_r+0x24a>
    fac8:	ldr	r3, [sp, #24]
    faca:	str	r6, [sp, #20]
    facc:	ldr	r6, [sp, #12]
    face:	adds	r3, #1
    fad0:	add	r7, r0
    fad2:	str	r3, [sp, #24]
    fad4:	mov	r4, r6
    fad6:	b.n	f504 <__ssvfscanf_r+0x90>
    fad8:	mov	r1, fp
    fada:	mov	r0, sl
    fadc:	bl	12eac <__ssrefill_r>
    fae0:	cmp	r0, #0
    fae2:	beq.w	f632 <__ssvfscanf_r+0x1be>
    fae6:	b.n	f6be <__ssvfscanf_r+0x24a>
    fae8:	mov.w	r9, #0
    faec:	b.n	f9f8 <__ssvfscanf_r+0x584>
    faee:	ldrb.w	r8, [r6, #2]
    faf2:	orr.w	r5, r5, #2
    faf6:	adds	r6, #2
    faf8:	b.n	f526 <__ssvfscanf_r+0xb2>
    fafa:	cmp	r3, #0
    fafc:	orr.w	r5, r5, #1
    fb00:	bgt.w	f84e <__ssvfscanf_r+0x3da>
    fb04:	b.n	f8c4 <__ssvfscanf_r+0x450>
    fb06:	lsls	r4, r5, #31
    fb08:	bmi.n	fb24 <__ssvfscanf_r+0x6b0>
    fb0a:	lsls	r0, r5, #30
    fb0c:	bpl.n	fb24 <__ssvfscanf_r+0x6b0>
    fb0e:	ldr	r2, [sp, #20]
    fb10:	ldr	r6, [sp, #12]
    fb12:	ldr	r3, [r2, #0]
    fb14:	mov	r0, r7
    fb16:	asrs	r1, r7, #31
    fb18:	adds	r2, #4
    fb1a:	str	r2, [sp, #20]
    fb1c:	strd	r0, r1, [r3]
    fb20:	mov	r4, r6
    fb22:	b.n	f504 <__ssvfscanf_r+0x90>
    fb24:	ldr	r2, [sp, #20]
    fb26:	ldr	r6, [sp, #12]
    fb28:	ldr	r3, [r2, #0]
    fb2a:	str	r7, [r3, #0]
    fb2c:	mov	r3, r2
    fb2e:	adds	r3, #4
    fb30:	str	r3, [sp, #20]
    fb32:	mov	r4, r6
    fb34:	b.n	f504 <__ssvfscanf_r+0x90>
    fb36:	mov	r1, fp
    fb38:	mov	r0, sl
    fb3a:	bl	12eac <__ssrefill_r>
    fb3e:	cmp	r0, #0
    fb40:	bne.w	f6be <__ssvfscanf_r+0x24a>
    fb44:	ldr	r3, [pc, #504]	; (fd40 <__ssvfscanf_r+0x8cc>)
    fb46:	str	r0, [sp, #16]
    fb48:	str	r3, [sp, #28]
    fb4a:	movs	r6, #3
    fb4c:	b.n	f680 <__ssvfscanf_r+0x20c>
    fb4e:	mov	r1, fp
    fb50:	mov	r0, sl
    fb52:	bl	12eac <__ssrefill_r>
    fb56:	cmp	r0, #0
    fb58:	beq.w	f7ee <__ssvfscanf_r+0x37a>
    fb5c:	b.n	f6be <__ssvfscanf_r+0x24a>
    fb5e:	mov	r1, fp
    fb60:	mov	r0, sl
    fb62:	bl	12eac <__ssrefill_r>
    fb66:	cmp	r0, #0
    fb68:	beq.w	f784 <__ssvfscanf_r+0x310>
    fb6c:	b.n	f6be <__ssvfscanf_r+0x24a>
    fb6e:	mov	r1, fp
    fb70:	mov	r0, sl
    fb72:	bl	12eac <__ssrefill_r>
    fb76:	cmp	r0, #0
    fb78:	beq.w	f8b2 <__ssvfscanf_r+0x43e>
    fb7c:	b.n	f6be <__ssvfscanf_r+0x24a>
    fb7e:	mov	r1, fp
    fb80:	mov	r0, sl
    fb82:	bl	12eac <__ssrefill_r>
    fb86:	cmp	r0, #0
    fb88:	beq.w	f716 <__ssvfscanf_r+0x2a2>
    fb8c:	b.n	f6be <__ssvfscanf_r+0x24a>
    fb8e:	mov	r1, fp
    fb90:	mov	r0, sl
    fb92:	bl	12eac <__ssrefill_r>
    fb96:	cmp	r0, #0
    fb98:	beq.w	f6fe <__ssvfscanf_r+0x28a>
    fb9c:	b.n	f6be <__ssvfscanf_r+0x24a>
    fb9e:	cmp	r6, #3
    fba0:	beq.w	fee2 <__ssvfscanf_r+0xa6e>
    fba4:	cmp	r6, #4
    fba6:	bne.w	10024 <__ssvfscanf_r+0xbb0>
    fbaa:	mov	r0, sl
    fbac:	bl	11de8 <_localeconv_r>
    fbb0:	subs	r3, r4, #1
    fbb2:	ldr	r2, [r0, #0]
    fbb4:	str	r2, [sp, #48]	; 0x30
    fbb6:	cmp.w	r3, #348	; 0x15c
    fbba:	bls.w	1008c <__ssvfscanf_r+0xc18>
    fbbe:	mvn.w	r1, #348	; 0x15c
    fbc2:	adds	r3, r4, r1
    fbc4:	str	r3, [sp, #56]	; 0x38
    fbc6:	movw	r4, #349	; 0x15d
    fbca:	add	r3, sp, #336	; 0x150
    fbcc:	mov.w	r8, #0
    fbd0:	mov	r2, r3
    fbd2:	str	r3, [sp, #40]	; 0x28
    fbd4:	orr.w	r5, r5, #1920	; 0x780
    fbd8:	mov	r3, r8
    fbda:	str.w	r8, [sp, #60]	; 0x3c
    fbde:	str.w	r8, [sp, #52]	; 0x34
    fbe2:	mov	r6, r8
    fbe4:	str.w	r8, [sp, #44]	; 0x2c
    fbe8:	mov	r9, r2
    fbea:	ldr.w	r0, [fp]
    fbee:	ldrb	r1, [r0, #0]
    fbf0:	sub.w	lr, r1, #43	; 0x2b
    fbf4:	cmp.w	lr, #78	; 0x4e
    fbf8:	bhi.w	fe92 <__ssvfscanf_r+0xa1e>
    fbfc:	tbh	[pc, lr, lsl #1]
    fc00:	.word	0x0149007a
    fc04:	.word	0x0149007a
    fc08:	.word	0x006e0149
    fc0c:	.word	0x004f004f
    fc10:	.word	0x004f004f
    fc14:	.word	0x004f004f
    fc18:	.word	0x004f004f
    fc1c:	.word	0x0149004f
    fc20:	.word	0x01490149
    fc24:	.word	0x01490149
    fc28:	.word	0x01490149
    fc2c:	.word	0x01490144
    fc30:	.word	0x01490149
    fc34:	.word	0x0125012c
    fc38:	.word	0x01490149
    fc3c:	.word	0x014900a2
    fc40:	.word	0x01490149
    fc44:	.word	0x008b0149
    fc48:	.word	0x01490149
    fc4c:	.word	0x01490149
    fc50:	.word	0x00850149
    fc54:	.word	0x01490149
    fc58:	.word	0x01490149
    fc5c:	.word	0x0149007f
    fc60:	.word	0x01490149
    fc64:	.word	0x01490149
    fc68:	.word	0x01490149
    fc6c:	.word	0x01490144
    fc70:	.word	0x01490149
    fc74:	.word	0x0125012c
    fc78:	.word	0x01490149
    fc7c:	.word	0x014900a2
    fc80:	.word	0x01490149
    fc84:	.word	0x008b0149
    fc88:	.word	0x01490149
    fc8c:	.word	0x01490149
    fc90:	.word	0x00850149
    fc94:	.word	0x01490149
    fc98:	.word	0x01490149
    fc9c:	.short	0x007f
    fc9e:	cmn.w	r3, r8
    fca2:	bne.n	fcd2 <__ssvfscanf_r+0x85e>
    fca4:	bic.w	r5, r5, #384	; 0x180
    fca8:	strb.w	r1, [r9]
    fcac:	add.w	r9, r9, #1
    fcb0:	ldr.w	r1, [fp, #4]
    fcb4:	subs	r1, #1
    fcb6:	cmp	r1, #0
    fcb8:	add.w	r4, r4, #4294967295
    fcbc:	add.w	r7, r7, #1
    fcc0:	str.w	r1, [fp, #4]
    fcc4:	ble.w	feac <__ssvfscanf_r+0xa38>
    fcc8:	adds	r0, #1
    fcca:	str.w	r0, [fp]
    fcce:	cmp	r4, #0
    fcd0:	bne.n	fbea <__ssvfscanf_r+0x776>
    fcd2:	cmp	r6, #0
    fcd4:	beq.n	fd5c <__ssvfscanf_r+0x8e8>
    fcd6:	bic.w	r5, r5, #256	; 0x100
    fcda:	b.n	fd5c <__ssvfscanf_r+0x8e8>
    fcdc:	lsls	r2, r5, #23
    fcde:	bpl.n	fc9e <__ssvfscanf_r+0x82a>
    fce0:	ldr	r2, [sp, #56]	; 0x38
    fce2:	bic.w	r5, r5, #128	; 0x80
    fce6:	adds	r6, #1
    fce8:	cmp	r2, #0
    fcea:	beq.n	fcb0 <__ssvfscanf_r+0x83c>
    fcec:	subs	r2, #1
    fcee:	str	r2, [sp, #56]	; 0x38
    fcf0:	adds	r4, #1
    fcf2:	b.n	fcb0 <__ssvfscanf_r+0x83c>
    fcf4:	lsls	r2, r5, #24
    fcf6:	bpl.n	fcd2 <__ssvfscanf_r+0x85e>
    fcf8:	bic.w	r5, r5, #128	; 0x80
    fcfc:	b.n	fca8 <__ssvfscanf_r+0x834>
    fcfe:	cmp.w	r8, #7
    fd02:	bne.n	fcd2 <__ssvfscanf_r+0x85e>
    fd04:	mov.w	r8, #8
    fd08:	b.n	fca8 <__ssvfscanf_r+0x834>
    fd0a:	cmp.w	r8, #6
    fd0e:	bne.n	fcd2 <__ssvfscanf_r+0x85e>
    fd10:	mov.w	r8, #7
    fd14:	b.n	fca8 <__ssvfscanf_r+0x834>
    fd16:	cmp	r3, #0
    fd18:	bne.w	fed8 <__ssvfscanf_r+0xa64>
    fd1c:	cbnz	r6, fd2a <__ssvfscanf_r+0x8b6>
    fd1e:	and.w	lr, r5, #1792	; 0x700
    fd22:	cmp.w	lr, #1792	; 0x700
    fd26:	beq.w	101b0 <__ssvfscanf_r+0xd3c>
    fd2a:	cmp.w	r8, #1
    fd2e:	beq.n	fd36 <__ssvfscanf_r+0x8c2>
    fd30:	cmp.w	r8, #4
    fd34:	bne.n	fcd2 <__ssvfscanf_r+0x85e>
    fd36:	add.w	r8, r8, #1
    fd3a:	uxtb.w	r8, r8
    fd3e:	b.n	fca8 <__ssvfscanf_r+0x834>
    fd40:	.word	0x0000dd69
    fd44:	cmp.w	r8, #0
    fd48:	bne.w	fec6 <__ssvfscanf_r+0xa52>
    fd4c:	cmp	r6, #0
    fd4e:	bne.n	fcd6 <__ssvfscanf_r+0x862>
    fd50:	and.w	lr, r5, #1792	; 0x700
    fd54:	cmp.w	lr, #1792	; 0x700
    fd58:	beq.w	101d0 <__ssvfscanf_r+0xd5c>
    fd5c:	subs	r3, #1
    fd5e:	cmp	r3, #1
    fd60:	bls.w	10266 <__ssvfscanf_r+0xdf2>
    fd64:	add.w	r3, r8, #4294967295
    fd68:	cmp	r3, #6
    fd6a:	bhi.n	fd9a <__ssvfscanf_r+0x926>
    fd6c:	cmp.w	r8, #2
    fd70:	bls.w	102b4 <__ssvfscanf_r+0xe40>
    fd74:	cmp.w	r8, #3
    fd78:	beq.n	fd9a <__ssvfscanf_r+0x926>
    fd7a:	sub.w	r4, r8, #4
    fd7e:	uxtb	r4, r4
    fd80:	mvn.w	r8, r4
    fd84:	add	r8, r9
    fd86:	ldrb.w	r1, [r9, #-1]!
    fd8a:	mov	r2, fp
    fd8c:	mov	r0, sl
    fd8e:	bl	12e28 <_sungetc_r>
    fd92:	cmp	r8, r9
    fd94:	bne.n	fd86 <__ssvfscanf_r+0x912>
    fd96:	subs	r7, #1
    fd98:	subs	r7, r7, r4
    fd9a:	lsls	r1, r5, #23
    fd9c:	bpl.n	fdd8 <__ssvfscanf_r+0x964>
    fd9e:	lsls	r2, r5, #21
    fda0:	bmi.w	1028a <__ssvfscanf_r+0xe16>
    fda4:	ldrb.w	r1, [r9, #-1]
    fda8:	cmp	r1, #101	; 0x65
    fdaa:	add.w	r4, r9, #4294967295
    fdae:	add.w	r8, r7, #4294967295
    fdb2:	beq.n	fdcc <__ssvfscanf_r+0x958>
    fdb4:	cmp	r1, #69	; 0x45
    fdb6:	beq.n	fdcc <__ssvfscanf_r+0x958>
    fdb8:	mov	r2, fp
    fdba:	mov	r0, sl
    fdbc:	bl	12e28 <_sungetc_r>
    fdc0:	ldrb.w	r1, [r9, #-2]
    fdc4:	sub.w	r8, r7, #2
    fdc8:	sub.w	r4, r9, #2
    fdcc:	mov	r2, fp
    fdce:	mov	r0, sl
    fdd0:	bl	12e28 <_sungetc_r>
    fdd4:	mov	r7, r8
    fdd6:	mov	r9, r4
    fdd8:	ands.w	r2, r5, #16
    fddc:	bne.w	f93c <__ssvfscanf_r+0x4c8>
    fde0:	and.w	r3, r5, #1536	; 0x600
    fde4:	cmp.w	r3, #1024	; 0x400
    fde8:	strb.w	r2, [r9]
    fdec:	beq.w	101da <__ssvfscanf_r+0xd66>
    fdf0:	ldr	r3, [sp, #52]	; 0x34
    fdf2:	cmp	r3, #0
    fdf4:	bne.w	101fc <__ssvfscanf_r+0xd88>
    fdf8:	ldr	r1, [sp, #40]	; 0x28
    fdfa:	movs	r2, #0
    fdfc:	mov	r0, sl
    fdfe:	bl	dc10 <_strtod_r>
    fe02:	lsls	r3, r5, #31
    fe04:	bmi.w	10092 <__ssvfscanf_r+0xc1e>
    fe08:	ands.w	r5, r5, #2
    fe0c:	bne.w	10092 <__ssvfscanf_r+0xc1e>
    fe10:	vmov	r2, r3, d0
    fe14:	vmov	r0, r1, d0
    fe18:	vstr	d0, [sp, #32]
    fe1c:	bl	b7e4 <__aeabi_dcmpun>
    fe20:	ldr	r4, [sp, #20]
    fe22:	vldr	d0, [sp, #32]
    fe26:	adds	r6, r4, #4
    fe28:	ldr	r4, [r4, #0]
    fe2a:	cmp	r0, #0
    fe2c:	bne.w	102e8 <__ssvfscanf_r+0xe74>
    fe30:	vmov	r0, r1, d0
    fe34:	bl	b8a0 <__aeabi_d2f>
    fe38:	str	r6, [sp, #20]
    fe3a:	str	r0, [r4, #0]
    fe3c:	ldr	r3, [sp, #24]
    fe3e:	ldr	r6, [sp, #12]
    fe40:	adds	r3, #1
    fe42:	str	r3, [sp, #24]
    fe44:	mov	r4, r6
    fe46:	b.w	f504 <__ssvfscanf_r+0x90>
    fe4a:	cmp.w	r8, #2
    fe4e:	bne.w	fcd2 <__ssvfscanf_r+0x85e>
    fe52:	mov.w	r8, #3
    fe56:	b.n	fca8 <__ssvfscanf_r+0x834>
    fe58:	and.w	lr, r5, #1280	; 0x500
    fe5c:	cmp.w	lr, #1024	; 0x400
    fe60:	beq.n	fe6e <__ssvfscanf_r+0x9fa>
    fe62:	lsls	r2, r5, #21
    fe64:	bpl.w	fcd2 <__ssvfscanf_r+0x85e>
    fe68:	cmp	r6, #0
    fe6a:	beq.w	fd5c <__ssvfscanf_r+0x8e8>
    fe6e:	lsls	r2, r5, #22
    fe70:	bmi.n	fe7c <__ssvfscanf_r+0xa08>
    fe72:	ldr	r2, [sp, #44]	; 0x2c
    fe74:	str.w	r9, [sp, #60]	; 0x3c
    fe78:	subs	r2, r6, r2
    fe7a:	str	r2, [sp, #52]	; 0x34
    fe7c:	bic.w	r5, r5, #1920	; 0x780
    fe80:	orr.w	r5, r5, #384	; 0x180
    fe84:	movs	r6, #0
    fe86:	b.n	fca8 <__ssvfscanf_r+0x834>
    fe88:	cmp	r3, #1
    fe8a:	bne.w	fcd2 <__ssvfscanf_r+0x85e>
    fe8e:	movs	r3, #2
    fe90:	b.n	fca8 <__ssvfscanf_r+0x834>
    fe92:	ldr	r2, [sp, #48]	; 0x30
    fe94:	ldrb.w	lr, [r2]
    fe98:	cmp	lr, r1
    fe9a:	bne.w	fcd2 <__ssvfscanf_r+0x85e>
    fe9e:	lsls	r2, r5, #22
    fea0:	bpl.w	fcd2 <__ssvfscanf_r+0x85e>
    fea4:	bic.w	r5, r5, #640	; 0x280
    fea8:	str	r6, [sp, #44]	; 0x2c
    feaa:	b.n	fca8 <__ssvfscanf_r+0x834>
    feac:	mov	r1, fp
    feae:	mov	r0, sl
    feb0:	str	r3, [sp, #32]
    feb2:	bl	12eac <__ssrefill_r>
    feb6:	ldr	r3, [sp, #32]
    feb8:	cmp	r0, #0
    feba:	bne.w	fcd2 <__ssvfscanf_r+0x85e>
    febe:	cmp	r4, #0
    fec0:	bne.w	fbea <__ssvfscanf_r+0x776>
    fec4:	b.n	fcd2 <__ssvfscanf_r+0x85e>
    fec6:	cmp.w	r8, #3
    feca:	beq.w	fd36 <__ssvfscanf_r+0x8c2>
    fece:	cmp.w	r8, #5
    fed2:	beq.w	fd36 <__ssvfscanf_r+0x8c2>
    fed6:	b.n	fcd2 <__ssvfscanf_r+0x85e>
    fed8:	cmp	r3, #2
    feda:	bne.w	fd2a <__ssvfscanf_r+0x8b6>
    fede:	movs	r3, #3
    fee0:	b.n	fca8 <__ssvfscanf_r+0x834>
    fee2:	subs	r3, r4, #1
    fee4:	cmp.w	r3, #348	; 0x15c
    fee8:	itte	hi
    feea:	mvnhi.w	r0, #348	; 0x15c
    feee:	addhi.w	r9, r4, r0
    fef2:	movls	r9, r8
    fef4:	add	r3, sp, #336	; 0x150
    fef6:	mov	r0, r2
    fef8:	mov	r2, r7
    fefa:	mov	r7, r9
    fefc:	ldr.w	r9, [sp, #16]
    ff00:	str	r3, [sp, #40]	; 0x28
    ff02:	it	hi
    ff04:	movwhi	r4, #349	; 0x15d
    ff08:	orr.w	r5, r5, #3456	; 0xd80
    ff0c:	mov	r6, r3
    ff0e:	mov.w	r8, #0
    ff12:	sub.w	r3, r1, #43	; 0x2b
    ff16:	cmp	r3, #77	; 0x4d
    ff18:	bhi.n	ffbe <__ssvfscanf_r+0xb4a>
    ff1a:	tbb	[pc, r3]
    ff1e:	.short	0x507e
    ff20:	.word	0x6f50507e
    ff24:	.word	0x69696969
    ff28:	.word	0x4a696969
    ff2c:	.word	0x5050504a
    ff30:	.word	0x50505050
    ff34:	.word	0x44444444
    ff38:	.word	0x50504444
    ff3c:	.word	0x50505050
    ff40:	.word	0x50505050
    ff44:	.word	0x50505050
    ff48:	.word	0x27505050
    ff4c:	.word	0x50505050
    ff50:	.word	0x50505050
    ff54:	.word	0x44444444
    ff58:	.word	0x50504444
    ff5c:	.word	0x50505050
    ff60:	.word	0x50505050
    ff64:	.word	0x50505050
    ff68:	.word	0x27505050
    ff6c:	and.w	r3, r5, #1536	; 0x600
    ff70:	cmp.w	r3, #512	; 0x200
    ff74:	bne.n	ffbe <__ssvfscanf_r+0xb4a>
    ff76:	bic.w	r5, r5, #512	; 0x200
    ff7a:	orr.w	r5, r5, #1280	; 0x500
    ff7e:	mov.w	r9, #16
    ff82:	strb	r1, [r6, #0]
    ff84:	adds	r6, #1
    ff86:	ldr.w	r3, [fp, #4]
    ff8a:	subs	r3, #1
    ff8c:	cmp	r3, #0
    ff8e:	str.w	r3, [fp, #4]
    ff92:	ble.n	1007a <__ssvfscanf_r+0xc06>
    ff94:	adds	r0, #1
    ff96:	str.w	r0, [fp]
    ff9a:	subs	r4, #1
    ff9c:	beq.n	ffbe <__ssvfscanf_r+0xb4a>
    ff9e:	ldr.w	r0, [fp]
    ffa2:	ldrb	r1, [r0, #0]
    ffa4:	b.n	ff12 <__ssvfscanf_r+0xa9e>
    ffa6:	cmp.w	r9, #10
    ffaa:	ble.n	ffbe <__ssvfscanf_r+0xb4a>
    ffac:	bic.w	r5, r5, #2944	; 0xb80
    ffb0:	b.n	ff82 <__ssvfscanf_r+0xb0e>
    ffb2:	ldr	r3, [pc, #756]	; (102a8 <__ssvfscanf_r+0xe34>)
    ffb4:	ldrsh.w	r9, [r3, r9, lsl #1]
    ffb8:	cmp.w	r9, #8
    ffbc:	bgt.n	ffac <__ssvfscanf_r+0xb38>
    ffbe:	lsls	r1, r5, #23
    ffc0:	mov	r7, r2
    ffc2:	str.w	r9, [sp, #16]
    ffc6:	bpl.n	ffd8 <__ssvfscanf_r+0xb64>
    ffc8:	ldr	r3, [sp, #40]	; 0x28
    ffca:	cmp	r6, r3
    ffcc:	bhi.w	101b8 <__ssvfscanf_r+0xd44>
    ffd0:	ldr	r3, [sp, #40]	; 0x28
    ffd2:	cmp	r6, r3
    ffd4:	beq.w	f510 <__ssvfscanf_r+0x9c>
    ffd8:	ands.w	r4, r5, #16
    ffdc:	beq.w	10104 <__ssvfscanf_r+0xc90>
    ffe0:	ldr	r3, [sp, #40]	; 0x28
    ffe2:	subs	r6, r6, r3
    ffe4:	add	r6, r8
    ffe6:	add	r7, r6
    ffe8:	ldr	r6, [sp, #12]
    ffea:	mov	r4, r6
    ffec:	b.w	f504 <__ssvfscanf_r+0x90>
    fff0:	ldr	r3, [pc, #692]	; (102a8 <__ssvfscanf_r+0xe34>)
    fff2:	bic.w	r5, r5, #2944	; 0xb80
    fff6:	ldrsh.w	r9, [r3, r9, lsl #1]
    fffa:	b.n	ff82 <__ssvfscanf_r+0xb0e>
    fffc:	lsls	r3, r5, #20
    fffe:	bpl.n	ff82 <__ssvfscanf_r+0xb0e>
   10000:	cmp.w	r9, #0
   10004:	bne.n	1000e <__ssvfscanf_r+0xb9a>
   10006:	orr.w	r5, r5, #512	; 0x200
   1000a:	mov.w	r9, #8
   1000e:	lsls	r3, r5, #21
   10010:	bpl.w	10194 <__ssvfscanf_r+0xd20>
   10014:	bic.w	r5, r5, #1408	; 0x580
   10018:	b.n	ff82 <__ssvfscanf_r+0xb0e>
   1001a:	lsls	r3, r5, #24
   1001c:	bpl.n	ffbe <__ssvfscanf_r+0xb4a>
   1001e:	bic.w	r5, r5, #128	; 0x80
   10022:	b.n	ff82 <__ssvfscanf_r+0xb0e>
   10024:	cmp	r4, #0
   10026:	it	eq
   10028:	moveq.w	r4, #4294967295
   1002c:	ands.w	r3, r5, #1
   10030:	bne.w	f8f0 <__ssvfscanf_r+0x47c>
   10034:	lsls	r1, r5, #27
   10036:	bpl.n	100a0 <__ssvfscanf_r+0xc2c>
   10038:	mov	r5, r3
   1003a:	bl	bcfc <__locale_ctype_ptr>
   1003e:	ldr.w	r3, [fp]
   10042:	ldrb	r2, [r3, #0]
   10044:	add	r0, r2
   10046:	adds	r3, #1
   10048:	ldrb	r2, [r0, #1]
   1004a:	lsls	r2, r2, #28
   1004c:	bmi.w	f7ce <__ssvfscanf_r+0x35a>
   10050:	ldr.w	r2, [fp, #4]
   10054:	str.w	r3, [fp]
   10058:	adds	r5, #1
   1005a:	subs	r3, r2, #1
   1005c:	cmp	r4, r5
   1005e:	str.w	r3, [fp, #4]
   10062:	beq.w	f7ce <__ssvfscanf_r+0x35a>
   10066:	cmp	r3, #0
   10068:	bgt.n	1003a <__ssvfscanf_r+0xbc6>
   1006a:	mov	r1, fp
   1006c:	mov	r0, sl
   1006e:	bl	12eac <__ssrefill_r>
   10072:	cmp	r0, #0
   10074:	beq.n	1003a <__ssvfscanf_r+0xbc6>
   10076:	b.w	f7ce <__ssvfscanf_r+0x35a>
   1007a:	mov	r1, fp
   1007c:	mov	r0, sl
   1007e:	str	r2, [sp, #16]
   10080:	bl	12eac <__ssrefill_r>
   10084:	ldr	r2, [sp, #16]
   10086:	cmp	r0, #0
   10088:	beq.n	ff9a <__ssvfscanf_r+0xb26>
   1008a:	b.n	ffbe <__ssvfscanf_r+0xb4a>
   1008c:	str.w	r8, [sp, #56]	; 0x38
   10090:	b.n	fbca <__ssvfscanf_r+0x756>
   10092:	ldr	r2, [sp, #20]
   10094:	ldr	r3, [r2, #0]
   10096:	adds	r2, #4
   10098:	str	r2, [sp, #20]
   1009a:	vstr	d0, [r3]
   1009e:	b.n	fe3c <__ssvfscanf_r+0x9c8>
   100a0:	ldr	r2, [sp, #20]
   100a2:	ldr	r5, [r2, #0]
   100a4:	adds	r6, r2, #4
   100a6:	add	r4, r5
   100a8:	mov	r8, r5
   100aa:	bl	bcfc <__locale_ctype_ptr>
   100ae:	ldr.w	r2, [fp]
   100b2:	ldrb	r3, [r2, #0]
   100b4:	add	r0, r3
   100b6:	adds	r1, r2, #1
   100b8:	ldrb	r3, [r0, #1]
   100ba:	lsls	r3, r3, #28
   100bc:	bmi.n	100ea <__ssvfscanf_r+0xc76>
   100be:	ldr.w	r3, [fp, #4]
   100c2:	str.w	r1, [fp]
   100c6:	subs	r3, #1
   100c8:	str.w	r3, [fp, #4]
   100cc:	ldrb	r3, [r2, #0]
   100ce:	strb.w	r3, [r8], #1
   100d2:	cmp	r4, r8
   100d4:	beq.n	100ec <__ssvfscanf_r+0xc78>
   100d6:	ldr.w	r3, [fp, #4]
   100da:	cmp	r3, #0
   100dc:	bgt.n	100aa <__ssvfscanf_r+0xc36>
   100de:	mov	r1, fp
   100e0:	mov	r0, sl
   100e2:	bl	12eac <__ssrefill_r>
   100e6:	cmp	r0, #0
   100e8:	beq.n	100aa <__ssvfscanf_r+0xc36>
   100ea:	mov	r4, r8
   100ec:	ldr	r2, [sp, #24]
   100ee:	str	r6, [sp, #20]
   100f0:	ldr	r6, [sp, #12]
   100f2:	subs	r5, r4, r5
   100f4:	movs	r3, #0
   100f6:	adds	r2, #1
   100f8:	strb	r3, [r4, #0]
   100fa:	add	r7, r5
   100fc:	str	r2, [sp, #24]
   100fe:	mov	r4, r6
   10100:	b.w	f504 <__ssvfscanf_r+0x90>
   10104:	mov	r2, r4
   10106:	strb	r4, [r6, #0]
   10108:	ldr	r3, [sp, #16]
   1010a:	ldr	r1, [sp, #40]	; 0x28
   1010c:	ldr	r4, [sp, #28]
   1010e:	mov	r0, sl
   10110:	blx	r4
   10112:	lsls	r2, r5, #26
   10114:	bmi.n	101a4 <__ssvfscanf_r+0xd30>
   10116:	lsls	r3, r5, #29
   10118:	bpl.n	10212 <__ssvfscanf_r+0xd9e>
   1011a:	ldr	r2, [sp, #20]
   1011c:	ldr	r3, [r2, #0]
   1011e:	adds	r2, #4
   10120:	str	r2, [sp, #20]
   10122:	strh	r0, [r3, #0]
   10124:	ldr	r3, [sp, #24]
   10126:	adds	r3, #1
   10128:	str	r3, [sp, #24]
   1012a:	b.n	ffe0 <__ssvfscanf_r+0xb6c>
   1012c:	bl	bcd8 <__locale_mb_cur_max>
   10130:	cmp	r6, r0
   10132:	beq.w	f6be <__ssvfscanf_r+0x24a>
   10136:	ldmia.w	fp, {r2, r3}
   1013a:	ldrb.w	r0, [r2], #1
   1013e:	str.w	r2, [fp]
   10142:	ldr	r2, [sp, #32]
   10144:	str	r2, [sp, #0]
   10146:	add	r2, sp, #336	; 0x150
   10148:	adds	r5, r6, #1
   1014a:	subs	r3, #1
   1014c:	strb	r0, [r2, r6]
   1014e:	str.w	r3, [fp, #4]
   10152:	mov	r1, r8
   10154:	mov	r3, r5
   10156:	mov	r0, sl
   10158:	bl	11e04 <_mbrtowc_r>
   1015c:	adds	r6, r0, #1
   1015e:	beq.w	f6be <__ssvfscanf_r+0x24a>
   10162:	cmp	r0, #0
   10164:	bne.n	1023e <__ssvfscanf_r+0xdca>
   10166:	str.w	r0, [r8]
   1016a:	bl	11dc8 <iswspace>
   1016e:	cmp	r0, #0
   10170:	beq.w	102d2 <__ssvfscanf_r+0xe5e>
   10174:	cmp	r5, #0
   10176:	beq.w	f92c <__ssvfscanf_r+0x4b8>
   1017a:	add	r3, sp, #336	; 0x150
   1017c:	adds	r4, r3, r5
   1017e:	subs	r5, #1
   10180:	mov	r2, fp
   10182:	ldrb.w	r1, [r4, #-1]!
   10186:	mov	r0, sl
   10188:	bl	12e28 <_sungetc_r>
   1018c:	cmp	r5, #0
   1018e:	bne.n	1017e <__ssvfscanf_r+0xd0a>
   10190:	b.w	f92c <__ssvfscanf_r+0x4b8>
   10194:	bic.w	r5, r5, #896	; 0x380
   10198:	cbz	r7, 1019e <__ssvfscanf_r+0xd2a>
   1019a:	subs	r7, #1
   1019c:	adds	r4, #1
   1019e:	add.w	r8, r8, #1
   101a2:	b.n	ff86 <__ssvfscanf_r+0xb12>
   101a4:	ldr	r2, [sp, #20]
   101a6:	ldr	r3, [r2, #0]
   101a8:	adds	r2, #4
   101aa:	str	r2, [sp, #20]
   101ac:	str	r0, [r3, #0]
   101ae:	b.n	10124 <__ssvfscanf_r+0xcb0>
   101b0:	bic.w	r5, r5, #1920	; 0x780
   101b4:	movs	r3, #1
   101b6:	b.n	fca8 <__ssvfscanf_r+0x834>
   101b8:	ldrb.w	r1, [r6, #-1]
   101bc:	mov	r2, fp
   101be:	mov	r0, sl
   101c0:	bl	12e28 <_sungetc_r>
   101c4:	subs	r6, #1
   101c6:	b.n	ffd0 <__ssvfscanf_r+0xb5c>
   101c8:	add.w	r8, sp, #68	; 0x44
   101cc:	b.w	f912 <__ssvfscanf_r+0x49e>
   101d0:	bic.w	r5, r5, #1920	; 0x780
   101d4:	mov.w	r8, #1
   101d8:	b.n	fca8 <__ssvfscanf_r+0x834>
   101da:	ldr	r3, [sp, #44]	; 0x2c
   101dc:	subs	r6, r6, r3
   101de:	negs	r2, r6
   101e0:	cmp	r6, #0
   101e2:	beq.w	fdf8 <__ssvfscanf_r+0x984>
   101e6:	addw	r3, sp, #675	; 0x2a3
   101ea:	cmp	r9, r3
   101ec:	it	cs
   101ee:	addwcs	r9, sp, #674	; 0x2a2
   101f2:	mov	r0, r9
   101f4:	ldr	r1, [pc, #180]	; (102ac <__ssvfscanf_r+0xe38>)
   101f6:	bl	c944 <sprintf>
   101fa:	b.n	fdf8 <__ssvfscanf_r+0x984>
   101fc:	ldr	r4, [sp, #60]	; 0x3c
   101fe:	mov	r1, r4
   10200:	movs	r3, #10
   10202:	adds	r1, #1
   10204:	mov	r0, sl
   10206:	bl	dd68 <_strtol_r>
   1020a:	ldr	r3, [sp, #52]	; 0x34
   1020c:	mov	r9, r4
   1020e:	subs	r2, r0, r3
   10210:	b.n	101e6 <__ssvfscanf_r+0xd72>
   10212:	ands.w	r2, r5, #1
   10216:	bne.n	101a4 <__ssvfscanf_r+0xd30>
   10218:	lsls	r4, r5, #30
   1021a:	bpl.n	101a4 <__ssvfscanf_r+0xd30>
   1021c:	ldr	r3, [sp, #28]
   1021e:	mov	r1, r3
   10220:	ldr	r3, [pc, #140]	; (102b0 <__ssvfscanf_r+0xe3c>)
   10222:	cmp	r1, r3
   10224:	mov	r0, sl
   10226:	ldr	r3, [sp, #16]
   10228:	ldr	r1, [sp, #40]	; 0x28
   1022a:	beq.n	102f6 <__ssvfscanf_r+0xe82>
   1022c:	bl	12968 <_strtoll_r>
   10230:	ldr	r2, [sp, #20]
   10232:	ldr	r3, [r2, #0]
   10234:	adds	r2, #4
   10236:	str	r2, [sp, #20]
   10238:	strd	r0, r1, [r3]
   1023c:	b.n	10124 <__ssvfscanf_r+0xcb0>
   1023e:	adds	r0, #2
   10240:	bne.n	10284 <__ssvfscanf_r+0xe10>
   10242:	mov	r6, r5
   10244:	ldr.w	r3, [fp, #4]
   10248:	cmp	r3, #0
   1024a:	bgt.w	f914 <__ssvfscanf_r+0x4a0>
   1024e:	mov	r1, fp
   10250:	mov	r0, sl
   10252:	bl	12eac <__ssrefill_r>
   10256:	cmp	r0, #0
   10258:	beq.w	f914 <__ssvfscanf_r+0x4a0>
   1025c:	cmp	r6, #0
   1025e:	bne.w	f6be <__ssvfscanf_r+0x24a>
   10262:	b.w	f92c <__ssvfscanf_r+0x4b8>
   10266:	ldr	r3, [sp, #40]	; 0x28
   10268:	cmp	r9, r3
   1026a:	bls.w	f510 <__ssvfscanf_r+0x9c>
   1026e:	ldrb.w	r1, [r9, #-1]!
   10272:	mov	r2, fp
   10274:	mov	r0, sl
   10276:	bl	12e28 <_sungetc_r>
   1027a:	ldr	r3, [sp, #40]	; 0x28
   1027c:	cmp	r9, r3
   1027e:	bne.n	1026e <__ssvfscanf_r+0xdfa>
   10280:	b.w	f510 <__ssvfscanf_r+0x9c>
   10284:	ldr.w	r0, [r8]
   10288:	b.n	1016a <__ssvfscanf_r+0xcf6>
   1028a:	ldr	r3, [sp, #40]	; 0x28
   1028c:	cmp	r9, r3
   1028e:	bls.w	f510 <__ssvfscanf_r+0x9c>
   10292:	ldrb.w	r1, [r9, #-1]!
   10296:	mov	r2, fp
   10298:	mov	r0, sl
   1029a:	bl	12e28 <_sungetc_r>
   1029e:	ldr	r3, [sp, #40]	; 0x28
   102a0:	cmp	r9, r3
   102a2:	bne.n	10292 <__ssvfscanf_r+0xe1e>
   102a4:	b.w	f510 <__ssvfscanf_r+0x9c>
   102a8:	.word	0x00013bc4
   102ac:	.word	0x00013be8
   102b0:	.word	0x00012af5
   102b4:	ldr	r3, [sp, #40]	; 0x28
   102b6:	cmp	r9, r3
   102b8:	bls.w	f510 <__ssvfscanf_r+0x9c>
   102bc:	ldrb.w	r1, [r9, #-1]!
   102c0:	mov	r2, fp
   102c2:	mov	r0, sl
   102c4:	bl	12e28 <_sungetc_r>
   102c8:	ldr	r3, [sp, #40]	; 0x28
   102ca:	cmp	r9, r3
   102cc:	bne.n	102bc <__ssvfscanf_r+0xe48>
   102ce:	b.w	f510 <__ssvfscanf_r+0x9c>
   102d2:	add	r7, r5
   102d4:	subs	r4, #1
   102d6:	cmp.w	r9, #0
   102da:	bne.n	102e4 <__ssvfscanf_r+0xe70>
   102dc:	add.w	r8, r8, #4
   102e0:	mov	r6, r9
   102e2:	b.n	10244 <__ssvfscanf_r+0xdd0>
   102e4:	mov	r6, r0
   102e6:	b.n	10244 <__ssvfscanf_r+0xdd0>
   102e8:	mov	r0, r5
   102ea:	bl	af28 <nanf>
   102ee:	str	r6, [sp, #20]
   102f0:	vstr	s0, [r4]
   102f4:	b.n	fe3c <__ssvfscanf_r+0x9c8>
   102f6:	bl	12d04 <_strtoull_r>
   102fa:	b.n	10230 <__ssvfscanf_r+0xdbc>

000102fc <_vdprintf_r>:
   102fc:	push	{r4, r5, r6, r7, lr}
   102fe:	sub.w	sp, sp, #532	; 0x214
   10302:	add	r5, sp, #16
   10304:	str	r3, [sp, #0]
   10306:	mov	r7, r1
   10308:	mov	r3, r2
   1030a:	mov.w	r4, #512	; 0x200
   1030e:	add	r2, sp, #12
   10310:	mov	r1, r5
   10312:	str	r4, [sp, #12]
   10314:	mov	r6, r0
   10316:	bl	12fe4 <_vasnprintf_r>
   1031a:	cbz	r0, 10340 <_vdprintf_r+0x44>
   1031c:	mov	r4, r0
   1031e:	mov	r2, r0
   10320:	mov	r1, r7
   10322:	ldr	r3, [sp, #12]
   10324:	mov	r0, r6
   10326:	bl	1037c <_write_r>
   1032a:	cmp	r4, r5
   1032c:	str	r0, [sp, #12]
   1032e:	beq.n	1033a <_vdprintf_r+0x3e>
   10330:	mov	r0, r6
   10332:	mov	r1, r4
   10334:	bl	11490 <_free_r>
   10338:	ldr	r0, [sp, #12]
   1033a:	add.w	sp, sp, #532	; 0x214
   1033e:	pop	{r4, r5, r6, r7, pc}
   10340:	mov.w	r0, #4294967295
   10344:	b.n	1033a <_vdprintf_r+0x3e>
   10346:	nop

00010348 <vdprintf>:
   10348:	push	{r4}
   1034a:	ldr	r4, [pc, #16]	; (1035c <vdprintf+0x14>)
   1034c:	mov	r3, r2
   1034e:	mov	r2, r1
   10350:	mov	r1, r0
   10352:	ldr	r0, [r4, #0]
   10354:	ldr.w	r4, [sp], #4
   10358:	b.w	102fc <_vdprintf_r>
   1035c:	.word	0x20013dc8

00010360 <__ascii_wctomb>:
   10360:	cbz	r1, 1036c <__ascii_wctomb+0xc>
   10362:	cmp	r2, #255	; 0xff
   10364:	bhi.n	10370 <__ascii_wctomb+0x10>
   10366:	strb	r2, [r1, #0]
   10368:	movs	r0, #1
   1036a:	bx	lr
   1036c:	mov	r0, r1
   1036e:	bx	lr
   10370:	movs	r3, #138	; 0x8a
   10372:	str	r3, [r0, #0]
   10374:	mov.w	r0, #4294967295
   10378:	bx	lr
   1037a:	nop

0001037c <_write_r>:
   1037c:	push	{r4, r5, r6, lr}
   1037e:	mov	r5, r1
   10380:	ldr	r4, [pc, #32]	; (103a4 <_write_r+0x28>)
   10382:	mov	r1, r2
   10384:	mov	r6, r0
   10386:	mov	r2, r3
   10388:	mov	r0, r5
   1038a:	movs	r3, #0
   1038c:	str	r3, [r4, #0]
   1038e:	bl	a980 <_write>
   10392:	adds	r3, r0, #1
   10394:	beq.n	10398 <_write_r+0x1c>
   10396:	pop	{r4, r5, r6, pc}
   10398:	ldr	r3, [r4, #0]
   1039a:	cmp	r3, #0
   1039c:	beq.n	10396 <_write_r+0x1a>
   1039e:	str	r3, [r6, #0]
   103a0:	pop	{r4, r5, r6, pc}
   103a2:	nop
   103a4:	.word	0x20019db4

000103a8 <__register_exitproc>:
   103a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   103ac:	ldr	r4, [pc, #148]	; (10444 <__register_exitproc+0x9c>)
   103ae:	ldr	r5, [r4, #0]
   103b0:	ldr.w	r4, [r5, #328]	; 0x148
   103b4:	mov	r6, r0
   103b6:	mov	r8, r1
   103b8:	mov	sl, r2
   103ba:	mov	r9, r3
   103bc:	cbz	r4, 10430 <__register_exitproc+0x88>
   103be:	ldr	r0, [r4, #4]
   103c0:	cmp	r0, #31
   103c2:	bgt.n	103f4 <__register_exitproc+0x4c>
   103c4:	adds	r3, r0, #1
   103c6:	cbz	r6, 103e6 <__register_exitproc+0x3e>
   103c8:	add.w	r5, r4, r0, lsl #2
   103cc:	movs	r2, #1
   103ce:	str.w	sl, [r5, #136]	; 0x88
   103d2:	ldr.w	r1, [r4, #392]	; 0x188
   103d6:	lsls	r2, r0
   103d8:	orrs	r1, r2
   103da:	cmp	r6, #2
   103dc:	str.w	r1, [r4, #392]	; 0x188
   103e0:	str.w	r9, [r5, #264]	; 0x108
   103e4:	beq.n	10424 <__register_exitproc+0x7c>
   103e6:	adds	r0, #2
   103e8:	str	r3, [r4, #4]
   103ea:	str.w	r8, [r4, r0, lsl #2]
   103ee:	movs	r0, #0
   103f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   103f4:	ldr	r3, [pc, #80]	; (10448 <__register_exitproc+0xa0>)
   103f6:	cbz	r3, 1043a <__register_exitproc+0x92>
   103f8:	mov.w	r0, #400	; 0x190
   103fc:	bl	bd10 <malloc>
   10400:	mov	r4, r0
   10402:	cbz	r0, 1043a <__register_exitproc+0x92>
   10404:	ldr.w	r3, [r5, #328]	; 0x148
   10408:	movs	r7, #0
   1040a:	stmia.w	r0, {r3, r7}
   1040e:	str.w	r4, [r5, #328]	; 0x148
   10412:	mov	r0, r7
   10414:	movs	r3, #1
   10416:	str.w	r7, [r4, #392]	; 0x188
   1041a:	str.w	r7, [r4, #396]	; 0x18c
   1041e:	cmp	r6, #0
   10420:	beq.n	103e6 <__register_exitproc+0x3e>
   10422:	b.n	103c8 <__register_exitproc+0x20>
   10424:	ldr.w	r1, [r4, #396]	; 0x18c
   10428:	orrs	r2, r1
   1042a:	str.w	r2, [r4, #396]	; 0x18c
   1042e:	b.n	103e6 <__register_exitproc+0x3e>
   10430:	add.w	r4, r5, #332	; 0x14c
   10434:	str.w	r4, [r5, #328]	; 0x148
   10438:	b.n	103be <__register_exitproc+0x16>
   1043a:	mov.w	r0, #4294967295
   1043e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10442:	nop
   10444:	.word	0x00013ae8
   10448:	.word	0x0000bd11

0001044c <register_fini>:
   1044c:	ldr	r3, [pc, #8]	; (10458 <register_fini+0xc>)
   1044e:	cbz	r3, 10456 <register_fini+0xa>
   10450:	ldr	r0, [pc, #8]	; (1045c <register_fini+0x10>)
   10452:	b.w	10460 <atexit>
   10456:	bx	lr
   10458:	.word	0x00000000
   1045c:	.word	0x000113cd

00010460 <atexit>:
   10460:	movs	r3, #0
   10462:	mov	r1, r0
   10464:	mov	r2, r3
   10466:	mov	r0, r3
   10468:	b.w	103a8 <__register_exitproc>

0001046c <quorem>:
   1046c:	ldr	r2, [r0, #16]
   1046e:	ldr	r3, [r1, #16]
   10470:	cmp	r3, r2
   10472:	bgt.w	10590 <quorem+0x124>
   10476:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1047a:	add.w	r8, r3, #4294967295
   1047e:	add.w	r7, r1, #20
   10482:	add.w	fp, r0, #20
   10486:	ldr.w	r2, [r7, r8, lsl #2]
   1048a:	ldr.w	r3, [fp, r8, lsl #2]
   1048e:	mov.w	r4, r8, lsl #2
   10492:	sub	sp, #12
   10494:	adds	r2, #1
   10496:	udiv	r9, r3, r2
   1049a:	add.w	r3, fp, r4
   1049e:	str	r4, [sp, #0]
   104a0:	add.w	sl, r7, r4
   104a4:	str	r3, [sp, #4]
   104a6:	cmp.w	r9, #0
   104aa:	beq.n	10520 <quorem+0xb4>
   104ac:	movs	r5, #0
   104ae:	mov	ip, r7
   104b0:	mov	lr, fp
   104b2:	mov	r3, r5
   104b4:	ldr.w	r6, [ip], #4
   104b8:	ldr.w	r2, [lr]
   104bc:	uxth	r4, r6
   104be:	mla	r5, r9, r4, r5
   104c2:	lsrs	r6, r6, #16
   104c4:	lsrs	r4, r5, #16
   104c6:	mla	r4, r9, r6, r4
   104ca:	uxth	r5, r5
   104cc:	subs	r3, r3, r5
   104ce:	uxth	r6, r4
   104d0:	uxtah	r3, r3, r2
   104d4:	rsb	r6, r6, r2, lsr #16
   104d8:	add.w	r6, r6, r3, asr #16
   104dc:	uxth	r3, r3
   104de:	orr.w	r3, r3, r6, lsl #16
   104e2:	cmp	sl, ip
   104e4:	str.w	r3, [lr], #4
   104e8:	mov.w	r5, r4, lsr #16
   104ec:	mov.w	r3, r6, asr #16
   104f0:	bcs.n	104b4 <quorem+0x48>
   104f2:	ldr	r3, [sp, #0]
   104f4:	ldr.w	r3, [fp, r3]
   104f8:	cbnz	r3, 10520 <quorem+0xb4>
   104fa:	ldr	r4, [sp, #4]
   104fc:	subs	r3, r4, #4
   104fe:	cmp	fp, r3
   10500:	bcs.n	1051c <quorem+0xb0>
   10502:	ldr.w	r3, [r4, #-4]
   10506:	cbnz	r3, 1051c <quorem+0xb0>
   10508:	sub.w	r3, r4, #8
   1050c:	b.n	10514 <quorem+0xa8>
   1050e:	ldr	r2, [r3, #0]
   10510:	subs	r3, #4
   10512:	cbnz	r2, 1051c <quorem+0xb0>
   10514:	cmp	fp, r3
   10516:	add.w	r8, r8, #4294967295
   1051a:	bcc.n	1050e <quorem+0xa2>
   1051c:	str.w	r8, [r0, #16]
   10520:	mov	r4, r0
   10522:	bl	12308 <__mcmp>
   10526:	cmp	r0, #0
   10528:	blt.n	10588 <quorem+0x11c>
   1052a:	add.w	r9, r9, #1
   1052e:	mov	r5, fp
   10530:	movs	r3, #0
   10532:	ldr.w	r1, [r7], #4
   10536:	ldr	r0, [r5, #0]
   10538:	uxth	r2, r1
   1053a:	subs	r2, r3, r2
   1053c:	lsrs	r1, r1, #16
   1053e:	uxtah	r2, r2, r0
   10542:	rsb	r3, r1, r0, lsr #16
   10546:	add.w	r3, r3, r2, asr #16
   1054a:	uxth	r1, r2
   1054c:	orr.w	r1, r1, r3, lsl #16
   10550:	cmp	sl, r7
   10552:	str.w	r1, [r5], #4
   10556:	mov.w	r3, r3, asr #16
   1055a:	bcs.n	10532 <quorem+0xc6>
   1055c:	ldr.w	r2, [fp, r8, lsl #2]
   10560:	add.w	r3, fp, r8, lsl #2
   10564:	cbnz	r2, 10588 <quorem+0x11c>
   10566:	subs	r2, r3, #4
   10568:	cmp	fp, r2
   1056a:	bcs.n	10584 <quorem+0x118>
   1056c:	ldr.w	r2, [r3, #-4]
   10570:	cbnz	r2, 10584 <quorem+0x118>
   10572:	subs	r3, #8
   10574:	b.n	1057c <quorem+0x110>
   10576:	ldr	r2, [r3, #0]
   10578:	subs	r3, #4
   1057a:	cbnz	r2, 10584 <quorem+0x118>
   1057c:	cmp	fp, r3
   1057e:	add.w	r8, r8, #4294967295
   10582:	bcc.n	10576 <quorem+0x10a>
   10584:	str.w	r8, [r4, #16]
   10588:	mov	r0, r9
   1058a:	add	sp, #12
   1058c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10590:	movs	r0, #0
   10592:	bx	lr
   10594:			; <UNDEFINED> instruction: 0xffffffff

00010598 <_dtoa_r>:
   10598:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1059c:	vmov	r6, r7, d0
   105a0:	sub	sp, #108	; 0x6c
   105a2:	ldr	r4, [r0, #64]	; 0x40
   105a4:	ldr	r5, [sp, #144]	; 0x90
   105a6:	str	r1, [sp, #0]
   105a8:	mov	r9, r0
   105aa:	str	r2, [sp, #20]
   105ac:	str	r3, [sp, #12]
   105ae:	vmov	sl, s0
   105b2:	mov	fp, r7
   105b4:	cbz	r4, 105cc <_dtoa_r+0x34>
   105b6:	ldr	r2, [r0, #68]	; 0x44
   105b8:	str	r2, [r4, #4]
   105ba:	movs	r3, #1
   105bc:	lsls	r3, r2
   105be:	str	r3, [r4, #8]
   105c0:	mov	r1, r4
   105c2:	bl	11eac <_Bfree>
   105c6:	movs	r3, #0
   105c8:	str.w	r3, [r9, #64]	; 0x40
   105cc:	cmp.w	fp, #0
   105d0:	mov	r4, fp
   105d2:	blt.n	1063e <_dtoa_r+0xa6>
   105d4:	movs	r3, #0
   105d6:	str	r3, [r5, #0]
   105d8:	ldr	r3, [pc, #644]	; (10860 <_dtoa_r+0x2c8>)
   105da:	mov	r2, r3
   105dc:	ands	r3, r4
   105de:	cmp	r3, r2
   105e0:	beq.n	10610 <_dtoa_r+0x78>
   105e2:	movs	r2, #0
   105e4:	movs	r3, #0
   105e6:	mov	r0, sl
   105e8:	mov	r1, fp
   105ea:	bl	b780 <__aeabi_dcmpeq>
   105ee:	mov	r6, sl
   105f0:	mov	r7, fp
   105f2:	mov	r8, r0
   105f4:	cbz	r0, 1064a <_dtoa_r+0xb2>
   105f6:	ldr	r2, [sp, #12]
   105f8:	movs	r3, #1
   105fa:	str	r3, [r2, #0]
   105fc:	ldr	r3, [sp, #148]	; 0x94
   105fe:	cmp	r3, #0
   10600:	beq.w	10780 <_dtoa_r+0x1e8>
   10604:	ldr	r0, [pc, #604]	; (10864 <_dtoa_r+0x2cc>)
   10606:	str	r0, [r3, #0]
   10608:	subs	r0, #1
   1060a:	add	sp, #108	; 0x6c
   1060c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10610:	ldr	r2, [sp, #12]
   10612:	movw	r3, #9999	; 0x270f
   10616:	str	r3, [r2, #0]
   10618:	cmp.w	sl, #0
   1061c:	beq.w	10754 <_dtoa_r+0x1bc>
   10620:	ldr	r0, [pc, #580]	; (10868 <_dtoa_r+0x2d0>)
   10622:	ldr	r3, [sp, #148]	; 0x94
   10624:	cmp	r3, #0
   10626:	beq.n	1060a <_dtoa_r+0x72>
   10628:	ldrb	r3, [r0, #3]
   1062a:	cmp	r3, #0
   1062c:	beq.w	10784 <_dtoa_r+0x1ec>
   10630:	add.w	r3, r0, #8
   10634:	ldr	r2, [sp, #148]	; 0x94
   10636:	str	r3, [r2, #0]
   10638:	add	sp, #108	; 0x6c
   1063a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1063e:	movs	r3, #1
   10640:	bic.w	r4, fp, #2147483648	; 0x80000000
   10644:	str	r3, [r5, #0]
   10646:	mov	fp, r4
   10648:	b.n	105d8 <_dtoa_r+0x40>
   1064a:	add	r2, sp, #96	; 0x60
   1064c:	add	r1, sp, #100	; 0x64
   1064e:	vmov	d0, r6, r7
   10652:	mov	r0, r9
   10654:	bl	12584 <__d2b>
   10658:	lsrs	r5, r4, #20
   1065a:	str	r0, [sp, #40]	; 0x28
   1065c:	bne.w	10766 <_dtoa_r+0x1ce>
   10660:	ldr	r5, [sp, #96]	; 0x60
   10662:	ldr	r6, [sp, #100]	; 0x64
   10664:	add	r6, r5
   10666:	addw	r3, r6, #1074	; 0x432
   1066a:	cmp	r3, #32
   1066c:	ble.w	10b80 <_dtoa_r+0x5e8>
   10670:	rsb	r3, r3, #64	; 0x40
   10674:	addw	r0, r6, #1042	; 0x412
   10678:	lsls	r4, r3
   1067a:	lsr.w	r0, sl, r0
   1067e:	orrs	r0, r4
   10680:	bl	b1c4 <__aeabi_ui2d>
   10684:	movs	r3, #1
   10686:	subs	r4, r6, #1
   10688:	sub.w	r1, r1, #32505856	; 0x1f00000
   1068c:	str	r3, [sp, #60]	; 0x3c
   1068e:	movs	r2, #0
   10690:	ldr	r3, [pc, #472]	; (1086c <_dtoa_r+0x2d4>)
   10692:	bl	af48 <__aeabi_dsub>
   10696:	add	r3, pc, #432	; (adr r3, 10848 <_dtoa_r+0x2b0>)
   10698:	ldrd	r2, r3, [r3]
   1069c:	bl	b2b0 <__aeabi_dmul>
   106a0:	add	r3, pc, #428	; (adr r3, 10850 <_dtoa_r+0x2b8>)
   106a2:	ldrd	r2, r3, [r3]
   106a6:	bl	af4c <__adddf3>
   106aa:	mov	r6, r0
   106ac:	mov	r0, r4
   106ae:	mov	r7, r1
   106b0:	bl	b1e4 <__aeabi_i2d>
   106b4:	add	r3, pc, #416	; (adr r3, 10858 <_dtoa_r+0x2c0>)
   106b6:	ldrd	r2, r3, [r3]
   106ba:	bl	b2b0 <__aeabi_dmul>
   106be:	mov	r2, r0
   106c0:	mov	r3, r1
   106c2:	mov	r0, r6
   106c4:	mov	r1, r7
   106c6:	bl	af4c <__adddf3>
   106ca:	mov	r6, r0
   106cc:	mov	r7, r1
   106ce:	bl	b810 <__aeabi_d2iz>
   106d2:	movs	r2, #0
   106d4:	str	r0, [sp, #16]
   106d6:	movs	r3, #0
   106d8:	mov	r0, r6
   106da:	mov	r1, r7
   106dc:	bl	b794 <__aeabi_dcmplt>
   106e0:	cmp	r0, #0
   106e2:	bne.w	10b36 <_dtoa_r+0x59e>
   106e6:	ldr	r6, [sp, #16]
   106e8:	cmp	r6, #22
   106ea:	bhi.w	10b30 <_dtoa_r+0x598>
   106ee:	ldr	r3, [pc, #384]	; (10870 <_dtoa_r+0x2d8>)
   106f0:	add.w	r3, r3, r6, lsl #3
   106f4:	ldrd	r0, r1, [r3]
   106f8:	mov	r2, sl
   106fa:	mov	r3, fp
   106fc:	bl	b7d0 <__aeabi_dcmpgt>
   10700:	cmp	r0, #0
   10702:	beq.w	10b8a <_dtoa_r+0x5f2>
   10706:	subs	r3, r6, #1
   10708:	str	r3, [sp, #16]
   1070a:	movs	r3, #0
   1070c:	str	r3, [sp, #52]	; 0x34
   1070e:	subs	r5, r5, r4
   10710:	subs.w	r8, r5, #1
   10714:	bmi.w	10b6c <_dtoa_r+0x5d4>
   10718:	movs	r3, #0
   1071a:	str	r3, [sp, #28]
   1071c:	ldr	r3, [sp, #16]
   1071e:	cmp	r3, #0
   10720:	blt.w	10b5a <_dtoa_r+0x5c2>
   10724:	add	r8, r3
   10726:	str	r3, [sp, #48]	; 0x30
   10728:	movs	r3, #0
   1072a:	str	r3, [sp, #24]
   1072c:	ldr	r3, [sp, #0]
   1072e:	cmp	r3, #9
   10730:	bhi.n	10788 <_dtoa_r+0x1f0>
   10732:	cmp	r3, #5
   10734:	ble.w	113c0 <_dtoa_r+0xe28>
   10738:	subs	r3, #4
   1073a:	str	r3, [sp, #0]
   1073c:	movs	r6, #0
   1073e:	ldr	r3, [sp, #0]
   10740:	subs	r3, #2
   10742:	cmp	r3, #3
   10744:	bhi.w	1138e <_dtoa_r+0xdf6>
   10748:	tbh	[pc, r3, lsl #1]
   1074c:	.word	0x0224032b
   10750:	.word	0x04500336
   10754:	ldr	r3, [pc, #272]	; (10868 <_dtoa_r+0x2d0>)
   10756:	ldr	r2, [pc, #284]	; (10874 <_dtoa_r+0x2dc>)
   10758:	ubfx	r0, r4, #0, #20
   1075c:	cmp	r0, #0
   1075e:	ite	ne
   10760:	movne	r0, r3
   10762:	moveq	r0, r2
   10764:	b.n	10622 <_dtoa_r+0x8a>
   10766:	ubfx	r3, fp, #0, #20
   1076a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
   1076e:	subw	r4, r5, #1023	; 0x3ff
   10772:	mov	r0, sl
   10774:	str.w	r8, [sp, #60]	; 0x3c
   10778:	orr.w	r1, r1, #3145728	; 0x300000
   1077c:	ldr	r5, [sp, #96]	; 0x60
   1077e:	b.n	1068e <_dtoa_r+0xf6>
   10780:	ldr	r0, [pc, #244]	; (10878 <_dtoa_r+0x2e0>)
   10782:	b.n	1060a <_dtoa_r+0x72>
   10784:	adds	r3, r0, #3
   10786:	b.n	10634 <_dtoa_r+0x9c>
   10788:	movs	r1, #0
   1078a:	str.w	r1, [r9, #68]	; 0x44
   1078e:	mov	r0, r9
   10790:	mov	r4, r1
   10792:	str	r1, [sp, #0]
   10794:	bl	11e60 <_Balloc>
   10798:	mov.w	r3, #4294967295
   1079c:	str	r3, [sp, #32]
   1079e:	str	r3, [sp, #56]	; 0x38
   107a0:	movs	r3, #1
   107a2:	str	r0, [sp, #36]	; 0x24
   107a4:	str.w	r0, [r9, #64]	; 0x40
   107a8:	str	r4, [sp, #20]
   107aa:	str	r3, [sp, #44]	; 0x2c
   107ac:	ldr	r3, [sp, #100]	; 0x64
   107ae:	cmp	r3, #0
   107b0:	blt.w	10954 <_dtoa_r+0x3bc>
   107b4:	ldr	r2, [sp, #16]
   107b6:	cmp	r2, #14
   107b8:	bgt.w	10954 <_dtoa_r+0x3bc>
   107bc:	ldr	r3, [pc, #176]	; (10870 <_dtoa_r+0x2d8>)
   107be:	add.w	r3, r3, r2, lsl #3
   107c2:	vldr	d7, [r3]
   107c6:	ldr	r3, [sp, #20]
   107c8:	cmp	r3, #0
   107ca:	vstr	d7, [sp]
   107ce:	blt.w	10dce <_dtoa_r+0x836>
   107d2:	mov	r6, sl
   107d4:	mov	r7, fp
   107d6:	ldrd	sl, fp, [sp]
   107da:	mov	r0, r6
   107dc:	mov	r2, sl
   107de:	mov	r3, fp
   107e0:	mov	r1, r7
   107e2:	bl	b504 <__aeabi_ddiv>
   107e6:	bl	b810 <__aeabi_d2iz>
   107ea:	mov	r4, r0
   107ec:	bl	b1e4 <__aeabi_i2d>
   107f0:	mov	r2, sl
   107f2:	mov	r3, fp
   107f4:	bl	b2b0 <__aeabi_dmul>
   107f8:	mov	r3, r1
   107fa:	mov	r2, r0
   107fc:	mov	r1, r7
   107fe:	mov	r0, r6
   10800:	bl	af48 <__aeabi_dsub>
   10804:	ldr	r5, [sp, #36]	; 0x24
   10806:	add.w	r3, r4, #48	; 0x30
   1080a:	strb	r3, [r5, #0]
   1080c:	ldr	r3, [sp, #32]
   1080e:	cmp	r3, #1
   10810:	mov	r6, r0
   10812:	mov	r7, r1
   10814:	add.w	r5, r5, #1
   10818:	beq.n	108de <_dtoa_r+0x346>
   1081a:	movs	r2, #0
   1081c:	ldr	r3, [pc, #92]	; (1087c <_dtoa_r+0x2e4>)
   1081e:	bl	b2b0 <__aeabi_dmul>
   10822:	movs	r2, #0
   10824:	movs	r3, #0
   10826:	mov	r6, r0
   10828:	mov	r7, r1
   1082a:	bl	b780 <__aeabi_dcmpeq>
   1082e:	cmp	r0, #0
   10830:	bne.n	1092e <_dtoa_r+0x396>
   10832:	str.w	r9, [sp, #20]
   10836:	ldr.w	sl, [sp, #32]
   1083a:	ldr.w	fp, [sp, #36]	; 0x24
   1083e:	ldrd	r8, r9, [sp]
   10842:	b.n	10896 <_dtoa_r+0x2fe>
   10844:	nop.w
   10848:	.word	0x636f4361
   1084c:	.word	0x3fd287a7
   10850:	.word	0x8b60c8b3
   10854:	.word	0x3fc68a28
   10858:	.word	0x509f79fb
   1085c:	.word	0x3fd34413
   10860:	.word	0x7ff00000
   10864:	.word	0x00013bb1
   10868:	.word	0x00013d00
   1086c:	.word	0x3ff80000
   10870:	.word	0x00013e08
   10874:	.word	0x00013cf4
   10878:	.word	0x00013bb0
   1087c:	.word	0x40240000
   10880:	bl	b2b0 <__aeabi_dmul>
   10884:	movs	r2, #0
   10886:	movs	r3, #0
   10888:	mov	r6, r0
   1088a:	mov	r7, r1
   1088c:	bl	b780 <__aeabi_dcmpeq>
   10890:	cmp	r0, #0
   10892:	bne.w	10ff2 <_dtoa_r+0xa5a>
   10896:	mov	r2, r8
   10898:	mov	r3, r9
   1089a:	mov	r0, r6
   1089c:	mov	r1, r7
   1089e:	bl	b504 <__aeabi_ddiv>
   108a2:	bl	b810 <__aeabi_d2iz>
   108a6:	mov	r4, r0
   108a8:	bl	b1e4 <__aeabi_i2d>
   108ac:	mov	r2, r8
   108ae:	mov	r3, r9
   108b0:	bl	b2b0 <__aeabi_dmul>
   108b4:	mov	r2, r0
   108b6:	mov	r3, r1
   108b8:	mov	r0, r6
   108ba:	mov	r1, r7
   108bc:	bl	af48 <__aeabi_dsub>
   108c0:	add.w	lr, r4, #48	; 0x30
   108c4:	strb.w	lr, [r5], #1
   108c8:	rsb	lr, fp, r5
   108cc:	cmp	lr, sl
   108ce:	mov	r6, r0
   108d0:	mov	r7, r1
   108d2:	mov.w	r2, #0
   108d6:	ldr	r3, [pc, #696]	; (10b90 <_dtoa_r+0x5f8>)
   108d8:	bne.n	10880 <_dtoa_r+0x2e8>
   108da:	ldr.w	r9, [sp, #20]
   108de:	mov	r2, r6
   108e0:	mov	r3, r7
   108e2:	mov	r0, r6
   108e4:	mov	r1, r7
   108e6:	bl	af4c <__adddf3>
   108ea:	mov	r6, r0
   108ec:	mov	r7, r1
   108ee:	mov	r2, r0
   108f0:	mov	r3, r1
   108f2:	ldrd	r0, r1, [sp]
   108f6:	bl	b794 <__aeabi_dcmplt>
   108fa:	cbnz	r0, 1090e <_dtoa_r+0x376>
   108fc:	mov	r2, r6
   108fe:	mov	r3, r7
   10900:	ldrd	r0, r1, [sp]
   10904:	bl	b780 <__aeabi_dcmpeq>
   10908:	cbz	r0, 1092e <_dtoa_r+0x396>
   1090a:	lsls	r3, r4, #31
   1090c:	bpl.n	1092e <_dtoa_r+0x396>
   1090e:	ldrb.w	r4, [r5, #-1]
   10912:	ldr	r2, [sp, #36]	; 0x24
   10914:	subs	r3, r5, #1
   10916:	b.n	10922 <_dtoa_r+0x38a>
   10918:	cmp	r2, r3
   1091a:	beq.w	11116 <_dtoa_r+0xb7e>
   1091e:	ldrb.w	r4, [r3, #-1]!
   10922:	cmp	r4, #57	; 0x39
   10924:	add.w	r5, r3, #1
   10928:	beq.n	10918 <_dtoa_r+0x380>
   1092a:	adds	r4, #1
   1092c:	strb	r4, [r3, #0]
   1092e:	ldr	r1, [sp, #40]	; 0x28
   10930:	mov	r0, r9
   10932:	bl	11eac <_Bfree>
   10936:	movs	r2, #0
   10938:	ldr	r3, [sp, #16]
   1093a:	strb	r2, [r5, #0]
   1093c:	ldr	r2, [sp, #12]
   1093e:	adds	r3, #1
   10940:	str	r3, [r2, #0]
   10942:	ldr	r3, [sp, #148]	; 0x94
   10944:	cmp	r3, #0
   10946:	beq.w	11080 <_dtoa_r+0xae8>
   1094a:	ldr	r0, [sp, #36]	; 0x24
   1094c:	str	r5, [r3, #0]
   1094e:	add	sp, #108	; 0x6c
   10950:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10954:	ldr	r2, [sp, #44]	; 0x2c
   10956:	cmp	r2, #0
   10958:	beq.w	10b78 <_dtoa_r+0x5e0>
   1095c:	ldr	r2, [sp, #0]
   1095e:	cmp	r2, #1
   10960:	ble.w	10e12 <_dtoa_r+0x87a>
   10964:	ldr	r3, [sp, #32]
   10966:	ldr	r2, [sp, #24]
   10968:	subs	r7, r3, #1
   1096a:	cmp	r2, r7
   1096c:	blt.w	11086 <_dtoa_r+0xaee>
   10970:	subs	r7, r2, r7
   10972:	ldr	r3, [sp, #32]
   10974:	cmp	r3, #0
   10976:	blt.w	1127a <_dtoa_r+0xce2>
   1097a:	ldr	r5, [sp, #28]
   1097c:	ldr	r3, [sp, #32]
   1097e:	ldr	r2, [sp, #28]
   10980:	movs	r1, #1
   10982:	add	r2, r3
   10984:	mov	r0, r9
   10986:	str	r2, [sp, #28]
   10988:	add	r8, r3
   1098a:	bl	12074 <__i2b>
   1098e:	mov	r6, r0
   10990:	cbz	r5, 109ac <_dtoa_r+0x414>
   10992:	cmp.w	r8, #0
   10996:	ble.n	109ac <_dtoa_r+0x414>
   10998:	cmp	r5, r8
   1099a:	ldr	r2, [sp, #28]
   1099c:	mov	r3, r5
   1099e:	it	ge
   109a0:	movge	r3, r8
   109a2:	subs	r2, r2, r3
   109a4:	str	r2, [sp, #28]
   109a6:	subs	r5, r5, r3
   109a8:	rsb	r8, r3, r8
   109ac:	ldr	r3, [sp, #24]
   109ae:	cmp	r3, #0
   109b0:	ble.w	10f9e <_dtoa_r+0xa06>
   109b4:	ldr	r2, [sp, #44]	; 0x2c
   109b6:	cmp	r2, #0
   109b8:	beq.w	10dc0 <_dtoa_r+0x828>
   109bc:	cmp	r7, #0
   109be:	beq.w	10dc0 <_dtoa_r+0x828>
   109c2:	mov	r1, r6
   109c4:	mov	r2, r7
   109c6:	mov	r0, r9
   109c8:	bl	121b8 <__pow5mult>
   109cc:	ldr	r2, [sp, #40]	; 0x28
   109ce:	mov	r1, r0
   109d0:	mov	r6, r0
   109d2:	mov	r0, r9
   109d4:	bl	12088 <__multiply>
   109d8:	ldr	r1, [sp, #40]	; 0x28
   109da:	mov	r4, r0
   109dc:	mov	r0, r9
   109de:	bl	11eac <_Bfree>
   109e2:	ldr	r3, [sp, #24]
   109e4:	subs	r3, r3, r7
   109e6:	str	r3, [sp, #24]
   109e8:	bne.w	10dbe <_dtoa_r+0x826>
   109ec:	movs	r1, #1
   109ee:	mov	r0, r9
   109f0:	bl	12074 <__i2b>
   109f4:	ldr	r3, [sp, #48]	; 0x30
   109f6:	str	r0, [sp, #24]
   109f8:	cmp	r3, #0
   109fa:	beq.w	10e28 <_dtoa_r+0x890>
   109fe:	mov	r1, r0
   10a00:	mov	r2, r3
   10a02:	mov	r0, r9
   10a04:	bl	121b8 <__pow5mult>
   10a08:	ldr	r3, [sp, #0]
   10a0a:	str	r0, [sp, #24]
   10a0c:	cmp	r3, #1
   10a0e:	ble.w	10ff8 <_dtoa_r+0xa60>
   10a12:	movs	r7, #0
   10a14:	ldr	r2, [sp, #24]
   10a16:	ldr	r3, [r2, #16]
   10a18:	add.w	r3, r2, r3, lsl #2
   10a1c:	ldr	r0, [r3, #16]
   10a1e:	bl	11fd8 <__hi0bits>
   10a22:	rsb	r0, r0, #32
   10a26:	add	r0, r8
   10a28:	ands.w	r0, r0, #31
   10a2c:	beq.w	10e24 <_dtoa_r+0x88c>
   10a30:	rsb	r3, r0, #32
   10a34:	cmp	r3, #4
   10a36:	ble.w	113b4 <_dtoa_r+0xe1c>
   10a3a:	rsb	r0, r0, #28
   10a3e:	ldr	r3, [sp, #28]
   10a40:	add	r3, r0
   10a42:	str	r3, [sp, #28]
   10a44:	add	r5, r0
   10a46:	add	r8, r0
   10a48:	ldr	r3, [sp, #28]
   10a4a:	cmp	r3, #0
   10a4c:	ble.n	10a5a <_dtoa_r+0x4c2>
   10a4e:	mov	r1, r4
   10a50:	mov	r2, r3
   10a52:	mov	r0, r9
   10a54:	bl	12258 <__lshift>
   10a58:	mov	r4, r0
   10a5a:	cmp.w	r8, #0
   10a5e:	ble.n	10a6c <_dtoa_r+0x4d4>
   10a60:	mov	r2, r8
   10a62:	ldr	r1, [sp, #24]
   10a64:	mov	r0, r9
   10a66:	bl	12258 <__lshift>
   10a6a:	str	r0, [sp, #24]
   10a6c:	ldr	r3, [sp, #52]	; 0x34
   10a6e:	cmp	r3, #0
   10a70:	bne.w	10f68 <_dtoa_r+0x9d0>
   10a74:	ldr	r3, [sp, #32]
   10a76:	cmp	r3, #0
   10a78:	ble.w	10fa2 <_dtoa_r+0xa0a>
   10a7c:	ldr	r3, [sp, #44]	; 0x2c
   10a7e:	cmp	r3, #0
   10a80:	bne.w	10e6c <_dtoa_r+0x8d4>
   10a84:	ldr.w	fp, [sp, #36]	; 0x24
   10a88:	ldr	r7, [sp, #32]
   10a8a:	ldr.w	r8, [sp, #24]
   10a8e:	mov	r5, fp
   10a90:	b.n	10a98 <_dtoa_r+0x500>
   10a92:	bl	11ec0 <__multadd>
   10a96:	mov	r4, r0
   10a98:	mov	r1, r8
   10a9a:	mov	r0, r4
   10a9c:	bl	1046c <quorem>
   10aa0:	add.w	sl, r0, #48	; 0x30
   10aa4:	strb.w	sl, [r5], #1
   10aa8:	rsb	r3, fp, r5
   10aac:	cmp	r3, r7
   10aae:	mov.w	r2, #10
   10ab2:	mov.w	r3, #0
   10ab6:	mov	r1, r4
   10ab8:	mov	r0, r9
   10aba:	blt.n	10a92 <_dtoa_r+0x4fa>
   10abc:	ldr	r3, [sp, #36]	; 0x24
   10abe:	ldr	r2, [sp, #32]
   10ac0:	cmp	r2, #1
   10ac2:	ite	ge
   10ac4:	addge	r3, r3, r2
   10ac6:	addlt	r3, #1
   10ac8:	mov	r5, r3
   10aca:	mov.w	fp, #0
   10ace:	mov	r1, r4
   10ad0:	movs	r2, #1
   10ad2:	mov	r0, r9
   10ad4:	bl	12258 <__lshift>
   10ad8:	ldr	r1, [sp, #24]
   10ada:	str	r0, [sp, #40]	; 0x28
   10adc:	bl	12308 <__mcmp>
   10ae0:	cmp	r0, #0
   10ae2:	ble.w	110f0 <_dtoa_r+0xb58>
   10ae6:	ldrb.w	r2, [r5, #-1]
   10aea:	ldr	r1, [sp, #36]	; 0x24
   10aec:	subs	r3, r5, #1
   10aee:	b.n	10afa <_dtoa_r+0x562>
   10af0:	cmp	r3, r1
   10af2:	beq.w	10fde <_dtoa_r+0xa46>
   10af6:	ldrb.w	r2, [r3, #-1]!
   10afa:	cmp	r2, #57	; 0x39
   10afc:	add.w	r5, r3, #1
   10b00:	beq.n	10af0 <_dtoa_r+0x558>
   10b02:	adds	r2, #1
   10b04:	strb	r2, [r3, #0]
   10b06:	ldr	r1, [sp, #24]
   10b08:	mov	r0, r9
   10b0a:	bl	11eac <_Bfree>
   10b0e:	cmp	r6, #0
   10b10:	beq.w	1092e <_dtoa_r+0x396>
   10b14:	cmp.w	fp, #0
   10b18:	beq.n	10b26 <_dtoa_r+0x58e>
   10b1a:	cmp	fp, r6
   10b1c:	beq.n	10b26 <_dtoa_r+0x58e>
   10b1e:	mov	r1, fp
   10b20:	mov	r0, r9
   10b22:	bl	11eac <_Bfree>
   10b26:	mov	r1, r6
   10b28:	mov	r0, r9
   10b2a:	bl	11eac <_Bfree>
   10b2e:	b.n	1092e <_dtoa_r+0x396>
   10b30:	movs	r3, #1
   10b32:	str	r3, [sp, #52]	; 0x34
   10b34:	b.n	1070e <_dtoa_r+0x176>
   10b36:	ldr.w	r8, [sp, #16]
   10b3a:	mov	r0, r8
   10b3c:	bl	b1e4 <__aeabi_i2d>
   10b40:	mov	r2, r0
   10b42:	mov	r3, r1
   10b44:	mov	r0, r6
   10b46:	mov	r1, r7
   10b48:	bl	b780 <__aeabi_dcmpeq>
   10b4c:	cmp	r0, #0
   10b4e:	bne.w	106e6 <_dtoa_r+0x14e>
   10b52:	add.w	r3, r8, #4294967295
   10b56:	str	r3, [sp, #16]
   10b58:	b.n	106e6 <_dtoa_r+0x14e>
   10b5a:	ldr	r2, [sp, #28]
   10b5c:	ldr	r3, [sp, #16]
   10b5e:	subs	r2, r2, r3
   10b60:	negs	r3, r3
   10b62:	str	r3, [sp, #24]
   10b64:	movs	r3, #0
   10b66:	str	r2, [sp, #28]
   10b68:	str	r3, [sp, #48]	; 0x30
   10b6a:	b.n	1072c <_dtoa_r+0x194>
   10b6c:	rsb	r3, r8, #0
   10b70:	str	r3, [sp, #28]
   10b72:	mov.w	r8, #0
   10b76:	b.n	1071c <_dtoa_r+0x184>
   10b78:	ldr	r7, [sp, #24]
   10b7a:	ldr	r5, [sp, #28]
   10b7c:	ldr	r6, [sp, #44]	; 0x2c
   10b7e:	b.n	10990 <_dtoa_r+0x3f8>
   10b80:	rsb	r4, r3, #32
   10b84:	lsl.w	r0, sl, r4
   10b88:	b.n	10680 <_dtoa_r+0xe8>
   10b8a:	str	r0, [sp, #52]	; 0x34
   10b8c:	b.n	1070e <_dtoa_r+0x176>
   10b8e:	nop
   10b90:	.word	0x40240000
   10b94:	movs	r3, #0
   10b96:	str	r3, [sp, #44]	; 0x2c
   10b98:	ldr	r3, [sp, #16]
   10b9a:	ldr	r2, [sp, #20]
   10b9c:	add	r3, r2
   10b9e:	str	r3, [sp, #56]	; 0x38
   10ba0:	adds	r3, #1
   10ba2:	cmp	r3, #0
   10ba4:	str	r3, [sp, #32]
   10ba6:	ble.w	110a4 <_dtoa_r+0xb0c>
   10baa:	ldr	r4, [sp, #32]
   10bac:	mov	r5, r4
   10bae:	movs	r1, #0
   10bb0:	cmp	r5, #23
   10bb2:	str.w	r1, [r9, #68]	; 0x44
   10bb6:	bls.n	10bd0 <_dtoa_r+0x638>
   10bb8:	movs	r2, #1
   10bba:	movs	r3, #4
   10bbc:	lsls	r3, r3, #1
   10bbe:	add.w	r0, r3, #20
   10bc2:	cmp	r0, r5
   10bc4:	mov	r1, r2
   10bc6:	add.w	r2, r2, #1
   10bca:	bls.n	10bbc <_dtoa_r+0x624>
   10bcc:	str.w	r1, [r9, #68]	; 0x44
   10bd0:	mov	r0, r9
   10bd2:	bl	11e60 <_Balloc>
   10bd6:	cmp	r4, #14
   10bd8:	str	r0, [sp, #36]	; 0x24
   10bda:	str.w	r0, [r9, #64]	; 0x40
   10bde:	bhi.w	107ac <_dtoa_r+0x214>
   10be2:	cmp	r6, #0
   10be4:	beq.w	107ac <_dtoa_r+0x214>
   10be8:	ldr	r1, [sp, #16]
   10bea:	cmp	r1, #0
   10bec:	strd	sl, fp, [sp, #64]	; 0x40
   10bf0:	ble.w	11128 <_dtoa_r+0xb90>
   10bf4:	ldr	r3, [pc, #576]	; (10e38 <_dtoa_r+0x8a0>)
   10bf6:	and.w	r2, r1, #15
   10bfa:	asrs	r6, r1, #4
   10bfc:	add.w	r3, r3, r2, lsl #3
   10c00:	lsls	r0, r6, #27
   10c02:	ldrd	r4, r5, [r3]
   10c06:	bpl.w	11096 <_dtoa_r+0xafe>
   10c0a:	ldr	r3, [pc, #560]	; (10e3c <_dtoa_r+0x8a4>)
   10c0c:	mov	r0, sl
   10c0e:	mov	r1, fp
   10c10:	ldrd	r2, r3, [r3, #32]
   10c14:	bl	b504 <__aeabi_ddiv>
   10c18:	strd	r0, r1, [sp, #72]	; 0x48
   10c1c:	and.w	r6, r6, #15
   10c20:	mov.w	sl, #3
   10c24:	cbz	r6, 10c48 <_dtoa_r+0x6b0>
   10c26:	ldr	r7, [pc, #532]	; (10e3c <_dtoa_r+0x8a4>)
   10c28:	lsls	r1, r6, #31
   10c2a:	bpl.n	10c40 <_dtoa_r+0x6a8>
   10c2c:	mov	r0, r4
   10c2e:	mov	r1, r5
   10c30:	ldrd	r2, r3, [r7]
   10c34:	bl	b2b0 <__aeabi_dmul>
   10c38:	add.w	sl, sl, #1
   10c3c:	mov	r4, r0
   10c3e:	mov	r5, r1
   10c40:	asrs	r6, r6, #1
   10c42:	add.w	r7, r7, #8
   10c46:	bne.n	10c28 <_dtoa_r+0x690>
   10c48:	mov	r2, r4
   10c4a:	mov	r3, r5
   10c4c:	ldrd	r0, r1, [sp, #72]	; 0x48
   10c50:	bl	b504 <__aeabi_ddiv>
   10c54:	mov	r6, r0
   10c56:	mov	r7, r1
   10c58:	ldr	r3, [sp, #52]	; 0x34
   10c5a:	cbz	r3, 10c6e <_dtoa_r+0x6d6>
   10c5c:	movs	r2, #0
   10c5e:	ldr	r3, [pc, #480]	; (10e40 <_dtoa_r+0x8a8>)
   10c60:	mov	r0, r6
   10c62:	mov	r1, r7
   10c64:	bl	b794 <__aeabi_dcmplt>
   10c68:	cmp	r0, #0
   10c6a:	bne.w	112a2 <_dtoa_r+0xd0a>
   10c6e:	mov	r0, sl
   10c70:	bl	b1e4 <__aeabi_i2d>
   10c74:	mov	r2, r6
   10c76:	mov	r3, r7
   10c78:	bl	b2b0 <__aeabi_dmul>
   10c7c:	ldr	r3, [pc, #452]	; (10e44 <_dtoa_r+0x8ac>)
   10c7e:	movs	r2, #0
   10c80:	bl	af4c <__adddf3>
   10c84:	ldr	r3, [sp, #32]
   10c86:	mov	r4, r0
   10c88:	sub.w	r5, r1, #54525952	; 0x3400000
   10c8c:	cmp	r3, #0
   10c8e:	beq.w	11048 <_dtoa_r+0xab0>
   10c92:	ldr	r3, [sp, #16]
   10c94:	str	r3, [sp, #88]	; 0x58
   10c96:	ldr	r3, [sp, #32]
   10c98:	str	r3, [sp, #72]	; 0x48
   10c9a:	ldr	r3, [sp, #44]	; 0x2c
   10c9c:	cmp	r3, #0
   10c9e:	beq.w	111ca <_dtoa_r+0xc32>
   10ca2:	ldr	r2, [sp, #72]	; 0x48
   10ca4:	ldr	r3, [pc, #400]	; (10e38 <_dtoa_r+0x8a0>)
   10ca6:	ldr	r1, [pc, #416]	; (10e48 <_dtoa_r+0x8b0>)
   10ca8:	add.w	r3, r3, r2, lsl #3
   10cac:	ldrd	r2, r3, [r3, #-8]
   10cb0:	movs	r0, #0
   10cb2:	bl	b504 <__aeabi_ddiv>
   10cb6:	mov	r2, r4
   10cb8:	mov	r3, r5
   10cba:	bl	af48 <__aeabi_dsub>
   10cbe:	mov	sl, r0
   10cc0:	mov	fp, r1
   10cc2:	mov	r0, r6
   10cc4:	mov	r1, r7
   10cc6:	bl	b810 <__aeabi_d2iz>
   10cca:	mov	r4, r0
   10ccc:	bl	b1e4 <__aeabi_i2d>
   10cd0:	mov	r2, r0
   10cd2:	mov	r3, r1
   10cd4:	mov	r0, r6
   10cd6:	mov	r1, r7
   10cd8:	bl	af48 <__aeabi_dsub>
   10cdc:	adds	r4, #48	; 0x30
   10cde:	ldr	r5, [sp, #36]	; 0x24
   10ce0:	uxtb	r4, r4
   10ce2:	mov	r6, r0
   10ce4:	mov	r7, r1
   10ce6:	strb	r4, [r5, #0]
   10ce8:	mov	r2, r0
   10cea:	mov	r3, r1
   10cec:	mov	r0, sl
   10cee:	mov	r1, fp
   10cf0:	adds	r5, #1
   10cf2:	bl	b7d0 <__aeabi_dcmpgt>
   10cf6:	cmp	r0, #0
   10cf8:	bne.n	10d9c <_dtoa_r+0x804>
   10cfa:	mov	r2, r6
   10cfc:	mov	r3, r7
   10cfe:	movs	r0, #0
   10d00:	ldr	r1, [pc, #316]	; (10e40 <_dtoa_r+0x8a8>)
   10d02:	bl	af48 <__aeabi_dsub>
   10d06:	mov	r2, r0
   10d08:	mov	r3, r1
   10d0a:	mov	r0, sl
   10d0c:	mov	r1, fp
   10d0e:	bl	b7d0 <__aeabi_dcmpgt>
   10d12:	cmp	r0, #0
   10d14:	bne.w	11328 <_dtoa_r+0xd90>
   10d18:	ldr	r2, [sp, #72]	; 0x48
   10d1a:	cmp	r2, #1
   10d1c:	ble.w	1110e <_dtoa_r+0xb76>
   10d20:	ldr	r3, [sp, #72]	; 0x48
   10d22:	ldr	r2, [sp, #36]	; 0x24
   10d24:	str.w	r8, [sp, #72]	; 0x48
   10d28:	add	r3, r2
   10d2a:	mov	r8, r3
   10d2c:	b.n	10d4a <_dtoa_r+0x7b2>
   10d2e:	movs	r0, #0
   10d30:	ldr	r1, [pc, #268]	; (10e40 <_dtoa_r+0x8a8>)
   10d32:	bl	af48 <__aeabi_dsub>
   10d36:	mov	r2, sl
   10d38:	mov	r3, fp
   10d3a:	bl	b794 <__aeabi_dcmplt>
   10d3e:	cmp	r0, #0
   10d40:	bne.w	11328 <_dtoa_r+0xd90>
   10d44:	cmp	r5, r8
   10d46:	beq.w	1110a <_dtoa_r+0xb72>
   10d4a:	mov	r0, sl
   10d4c:	mov	r1, fp
   10d4e:	movs	r2, #0
   10d50:	ldr	r3, [pc, #248]	; (10e4c <_dtoa_r+0x8b4>)
   10d52:	bl	b2b0 <__aeabi_dmul>
   10d56:	movs	r2, #0
   10d58:	ldr	r3, [pc, #240]	; (10e4c <_dtoa_r+0x8b4>)
   10d5a:	mov	sl, r0
   10d5c:	mov	fp, r1
   10d5e:	mov	r0, r6
   10d60:	mov	r1, r7
   10d62:	bl	b2b0 <__aeabi_dmul>
   10d66:	mov	r7, r1
   10d68:	mov	r6, r0
   10d6a:	bl	b810 <__aeabi_d2iz>
   10d6e:	mov	r4, r0
   10d70:	bl	b1e4 <__aeabi_i2d>
   10d74:	mov	r2, r0
   10d76:	mov	r3, r1
   10d78:	mov	r0, r6
   10d7a:	mov	r1, r7
   10d7c:	bl	af48 <__aeabi_dsub>
   10d80:	adds	r4, #48	; 0x30
   10d82:	uxtb	r4, r4
   10d84:	mov	r2, sl
   10d86:	mov	r3, fp
   10d88:	strb.w	r4, [r5], #1
   10d8c:	mov	r6, r0
   10d8e:	mov	r7, r1
   10d90:	bl	b794 <__aeabi_dcmplt>
   10d94:	mov	r2, r6
   10d96:	mov	r3, r7
   10d98:	cmp	r0, #0
   10d9a:	beq.n	10d2e <_dtoa_r+0x796>
   10d9c:	ldr	r3, [sp, #88]	; 0x58
   10d9e:	str	r3, [sp, #16]
   10da0:	b.n	1092e <_dtoa_r+0x396>
   10da2:	movs	r3, #0
   10da4:	str	r3, [sp, #44]	; 0x2c
   10da6:	ldr	r3, [sp, #20]
   10da8:	cmp	r3, #0
   10daa:	ble.w	110ae <_dtoa_r+0xb16>
   10dae:	mov	r5, r3
   10db0:	mov	r4, r3
   10db2:	str	r3, [sp, #56]	; 0x38
   10db4:	str	r3, [sp, #32]
   10db6:	b.n	10bae <_dtoa_r+0x616>
   10db8:	movs	r3, #1
   10dba:	str	r3, [sp, #44]	; 0x2c
   10dbc:	b.n	10da6 <_dtoa_r+0x80e>
   10dbe:	str	r4, [sp, #40]	; 0x28
   10dc0:	ldr	r2, [sp, #24]
   10dc2:	ldr	r1, [sp, #40]	; 0x28
   10dc4:	mov	r0, r9
   10dc6:	bl	121b8 <__pow5mult>
   10dca:	mov	r4, r0
   10dcc:	b.n	109ec <_dtoa_r+0x454>
   10dce:	ldr	r3, [sp, #32]
   10dd0:	cmp	r3, #0
   10dd2:	bgt.w	107d2 <_dtoa_r+0x23a>
   10dd6:	bne.w	11078 <_dtoa_r+0xae0>
   10dda:	movs	r2, #0
   10ddc:	ldr	r3, [pc, #112]	; (10e50 <_dtoa_r+0x8b8>)
   10dde:	ldrd	r0, r1, [sp]
   10de2:	bl	b2b0 <__aeabi_dmul>
   10de6:	mov	r3, fp
   10de8:	mov	r2, sl
   10dea:	bl	b7bc <__aeabi_dcmpge>
   10dee:	ldr	r3, [sp, #32]
   10df0:	str	r3, [sp, #24]
   10df2:	mov	r6, r3
   10df4:	cmp	r0, #0
   10df6:	beq.w	10fce <_dtoa_r+0xa36>
   10dfa:	ldr	r3, [sp, #20]
   10dfc:	ldr	r5, [sp, #36]	; 0x24
   10dfe:	mvns	r3, r3
   10e00:	str	r3, [sp, #16]
   10e02:	ldr	r1, [sp, #24]
   10e04:	mov	r0, r9
   10e06:	bl	11eac <_Bfree>
   10e0a:	cmp	r6, #0
   10e0c:	beq.w	1092e <_dtoa_r+0x396>
   10e10:	b.n	10b26 <_dtoa_r+0x58e>
   10e12:	ldr	r2, [sp, #60]	; 0x3c
   10e14:	cmp	r2, #0
   10e16:	beq.w	1128a <_dtoa_r+0xcf2>
   10e1a:	addw	r3, r3, #1075	; 0x433
   10e1e:	ldr	r7, [sp, #24]
   10e20:	ldr	r5, [sp, #28]
   10e22:	b.n	1097e <_dtoa_r+0x3e6>
   10e24:	movs	r0, #28
   10e26:	b.n	10a3e <_dtoa_r+0x4a6>
   10e28:	ldr	r3, [sp, #0]
   10e2a:	cmp	r3, #1
   10e2c:	ble.w	11330 <_dtoa_r+0xd98>
   10e30:	ldr	r7, [sp, #48]	; 0x30
   10e32:	movs	r0, #1
   10e34:	b.n	10a26 <_dtoa_r+0x48e>
   10e36:	nop
   10e38:	.word	0x00013e08
   10e3c:	.word	0x00013ed0
   10e40:	.word	0x3ff00000
   10e44:	.word	0x401c0000
   10e48:	.word	0x3fe00000
   10e4c:	.word	0x40240000
   10e50:	.word	0x40140000
   10e54:	mov	r1, r6
   10e56:	movs	r3, #0
   10e58:	movs	r2, #10
   10e5a:	mov	r0, r9
   10e5c:	bl	11ec0 <__multadd>
   10e60:	ldr	r3, [sp, #56]	; 0x38
   10e62:	cmp	r3, #0
   10e64:	mov	r6, r0
   10e66:	ble.w	11384 <_dtoa_r+0xdec>
   10e6a:	str	r3, [sp, #32]
   10e6c:	cmp	r5, #0
   10e6e:	ble.n	10e7c <_dtoa_r+0x8e4>
   10e70:	mov	r1, r6
   10e72:	mov	r2, r5
   10e74:	mov	r0, r9
   10e76:	bl	12258 <__lshift>
   10e7a:	mov	r6, r0
   10e7c:	cmp	r7, #0
   10e7e:	bne.w	1117a <_dtoa_r+0xbe2>
   10e82:	mov	r8, r6
   10e84:	ldr	r3, [sp, #32]
   10e86:	ldr	r2, [sp, #36]	; 0x24
   10e88:	subs	r3, #1
   10e8a:	adds	r3, r2, r3
   10e8c:	str	r3, [sp, #32]
   10e8e:	and.w	r3, sl, #1
   10e92:	str	r3, [sp, #40]	; 0x28
   10e94:	mov	r7, r2
   10e96:	ldr.w	fp, [sp, #24]
   10e9a:	mov	r0, r4
   10e9c:	mov	r1, fp
   10e9e:	bl	1046c <quorem>
   10ea2:	mov	r1, r6
   10ea4:	mov	r5, r0
   10ea6:	mov	r0, r4
   10ea8:	bl	12308 <__mcmp>
   10eac:	mov	r2, r8
   10eae:	mov	r1, fp
   10eb0:	mov	sl, r0
   10eb2:	mov	r0, r9
   10eb4:	bl	1234c <__mdiff>
   10eb8:	ldr	r2, [r0, #12]
   10eba:	mov	fp, r0
   10ebc:	add.w	r3, r5, #48	; 0x30
   10ec0:	cmp	r2, #0
   10ec2:	bne.n	10f58 <_dtoa_r+0x9c0>
   10ec4:	mov	r1, r0
   10ec6:	mov	r0, r4
   10ec8:	str	r3, [sp, #28]
   10eca:	bl	12308 <__mcmp>
   10ece:	mov	r1, fp
   10ed0:	str	r0, [sp, #20]
   10ed2:	mov	r0, r9
   10ed4:	bl	11eac <_Bfree>
   10ed8:	ldr	r2, [sp, #20]
   10eda:	ldr	r3, [sp, #28]
   10edc:	cbnz	r2, 10eea <_dtoa_r+0x952>
   10ede:	ldr	r1, [sp, #0]
   10ee0:	cbnz	r1, 10eea <_dtoa_r+0x952>
   10ee2:	ldr	r1, [sp, #40]	; 0x28
   10ee4:	cmp	r1, #0
   10ee6:	beq.w	11354 <_dtoa_r+0xdbc>
   10eea:	cmp.w	sl, #0
   10eee:	blt.w	110b8 <_dtoa_r+0xb20>
   10ef2:	bne.n	10f00 <_dtoa_r+0x968>
   10ef4:	ldr	r1, [sp, #0]
   10ef6:	cbnz	r1, 10f00 <_dtoa_r+0x968>
   10ef8:	ldr	r1, [sp, #40]	; 0x28
   10efa:	cmp	r1, #0
   10efc:	beq.w	110b8 <_dtoa_r+0xb20>
   10f00:	cmp	r2, #0
   10f02:	bgt.w	111a2 <_dtoa_r+0xc0a>
   10f06:	ldr	r2, [sp, #32]
   10f08:	strb	r3, [r7, #0]
   10f0a:	add.w	sl, r7, #1
   10f0e:	cmp	r7, r2
   10f10:	mov	r5, sl
   10f12:	beq.w	111ba <_dtoa_r+0xc22>
   10f16:	mov	r1, r4
   10f18:	movs	r3, #0
   10f1a:	movs	r2, #10
   10f1c:	mov	r0, r9
   10f1e:	bl	11ec0 <__multadd>
   10f22:	cmp	r6, r8
   10f24:	mov	r4, r0
   10f26:	mov	r1, r6
   10f28:	mov.w	r3, #0
   10f2c:	mov.w	r2, #10
   10f30:	mov	r0, r9
   10f32:	beq.n	10f4c <_dtoa_r+0x9b4>
   10f34:	bl	11ec0 <__multadd>
   10f38:	mov	r1, r8
   10f3a:	mov	r6, r0
   10f3c:	movs	r3, #0
   10f3e:	movs	r2, #10
   10f40:	mov	r0, r9
   10f42:	bl	11ec0 <__multadd>
   10f46:	mov	r7, sl
   10f48:	mov	r8, r0
   10f4a:	b.n	10e96 <_dtoa_r+0x8fe>
   10f4c:	bl	11ec0 <__multadd>
   10f50:	mov	r7, sl
   10f52:	mov	r6, r0
   10f54:	mov	r8, r0
   10f56:	b.n	10e96 <_dtoa_r+0x8fe>
   10f58:	mov	r1, r0
   10f5a:	mov	r0, r9
   10f5c:	str	r3, [sp, #20]
   10f5e:	bl	11eac <_Bfree>
   10f62:	movs	r2, #1
   10f64:	ldr	r3, [sp, #20]
   10f66:	b.n	10eea <_dtoa_r+0x952>
   10f68:	ldr	r1, [sp, #24]
   10f6a:	mov	r0, r4
   10f6c:	bl	12308 <__mcmp>
   10f70:	cmp	r0, #0
   10f72:	bge.w	10a74 <_dtoa_r+0x4dc>
   10f76:	mov	r1, r4
   10f78:	ldr	r4, [sp, #16]
   10f7a:	movs	r3, #0
   10f7c:	subs	r4, #1
   10f7e:	movs	r2, #10
   10f80:	mov	r0, r9
   10f82:	str	r4, [sp, #16]
   10f84:	bl	11ec0 <__multadd>
   10f88:	ldr	r3, [sp, #44]	; 0x2c
   10f8a:	mov	r4, r0
   10f8c:	cmp	r3, #0
   10f8e:	bne.w	10e54 <_dtoa_r+0x8bc>
   10f92:	ldr	r3, [sp, #56]	; 0x38
   10f94:	cmp	r3, #0
   10f96:	ble.w	11374 <_dtoa_r+0xddc>
   10f9a:	str	r3, [sp, #32]
   10f9c:	b.n	10a84 <_dtoa_r+0x4ec>
   10f9e:	ldr	r4, [sp, #40]	; 0x28
   10fa0:	b.n	109ec <_dtoa_r+0x454>
   10fa2:	ldr	r3, [sp, #0]
   10fa4:	cmp	r3, #2
   10fa6:	ble.w	10a7c <_dtoa_r+0x4e4>
   10faa:	ldr	r3, [sp, #32]
   10fac:	cmp	r3, #0
   10fae:	bne.w	112ec <_dtoa_r+0xd54>
   10fb2:	ldr	r1, [sp, #24]
   10fb4:	movs	r2, #5
   10fb6:	mov	r0, r9
   10fb8:	bl	11ec0 <__multadd>
   10fbc:	mov	r1, r0
   10fbe:	str	r0, [sp, #24]
   10fc0:	mov	r0, r4
   10fc2:	bl	12308 <__mcmp>
   10fc6:	cmp	r0, #0
   10fc8:	str	r4, [sp, #40]	; 0x28
   10fca:	ble.w	10dfa <_dtoa_r+0x862>
   10fce:	ldr	r2, [sp, #16]
   10fd0:	ldr	r1, [sp, #36]	; 0x24
   10fd2:	movs	r3, #49	; 0x31
   10fd4:	adds	r2, #1
   10fd6:	str	r2, [sp, #16]
   10fd8:	strb	r3, [r1, #0]
   10fda:	adds	r5, r1, #1
   10fdc:	b.n	10e02 <_dtoa_r+0x86a>
   10fde:	ldr	r2, [sp, #16]
   10fe0:	adds	r2, #1
   10fe2:	str	r2, [sp, #16]
   10fe4:	ldr	r2, [sp, #36]	; 0x24
   10fe6:	movs	r3, #49	; 0x31
   10fe8:	strb	r3, [r2, #0]
   10fea:	b.n	10b06 <_dtoa_r+0x56e>
   10fec:	movs	r3, #1
   10fee:	str	r3, [sp, #44]	; 0x2c
   10ff0:	b.n	10b98 <_dtoa_r+0x600>
   10ff2:	ldr.w	r9, [sp, #20]
   10ff6:	b.n	1092e <_dtoa_r+0x396>
   10ff8:	cmp.w	sl, #0
   10ffc:	bne.w	10a12 <_dtoa_r+0x47a>
   11000:	ubfx	r3, fp, #0, #20
   11004:	cmp	r3, #0
   11006:	bne.w	11286 <_dtoa_r+0xcee>
   1100a:	bic.w	r7, fp, #2147483648	; 0x80000000
   1100e:	lsrs	r7, r7, #20
   11010:	lsls	r7, r7, #20
   11012:	cbz	r7, 11020 <_dtoa_r+0xa88>
   11014:	ldr	r3, [sp, #28]
   11016:	adds	r3, #1
   11018:	str	r3, [sp, #28]
   1101a:	add.w	r8, r8, #1
   1101e:	movs	r7, #1
   11020:	ldr	r3, [sp, #48]	; 0x30
   11022:	movs	r0, #1
   11024:	cmp	r3, #0
   11026:	beq.w	10a26 <_dtoa_r+0x48e>
   1102a:	b.n	10a14 <_dtoa_r+0x47c>
   1102c:	mov	r0, sl
   1102e:	bl	b1e4 <__aeabi_i2d>
   11032:	mov	r2, r6
   11034:	mov	r3, r7
   11036:	bl	b2b0 <__aeabi_dmul>
   1103a:	movs	r2, #0
   1103c:	ldr	r3, [pc, #764]	; (1133c <_dtoa_r+0xda4>)
   1103e:	bl	af4c <__adddf3>
   11042:	mov	r4, r0
   11044:	sub.w	r5, r1, #54525952	; 0x3400000
   11048:	mov	r0, r6
   1104a:	mov	r1, r7
   1104c:	movs	r2, #0
   1104e:	ldr	r3, [pc, #752]	; (11340 <_dtoa_r+0xda8>)
   11050:	bl	af48 <__aeabi_dsub>
   11054:	mov	r2, r4
   11056:	mov	r3, r5
   11058:	mov	r6, r0
   1105a:	mov	r7, r1
   1105c:	bl	b7d0 <__aeabi_dcmpgt>
   11060:	cmp	r0, #0
   11062:	bne.w	111c2 <_dtoa_r+0xc2a>
   11066:	mov	r2, r4
   11068:	add.w	r3, r5, #2147483648	; 0x80000000
   1106c:	mov	r0, r6
   1106e:	mov	r1, r7
   11070:	bl	b794 <__aeabi_dcmplt>
   11074:	cmp	r0, #0
   11076:	beq.n	1110e <_dtoa_r+0xb76>
   11078:	movs	r3, #0
   1107a:	str	r3, [sp, #24]
   1107c:	mov	r6, r3
   1107e:	b.n	10dfa <_dtoa_r+0x862>
   11080:	ldr	r0, [sp, #36]	; 0x24
   11082:	b.w	1060a <_dtoa_r+0x72>
   11086:	ldr	r3, [sp, #24]
   11088:	ldr	r2, [sp, #48]	; 0x30
   1108a:	str	r7, [sp, #24]
   1108c:	subs	r3, r7, r3
   1108e:	add	r2, r3
   11090:	str	r2, [sp, #48]	; 0x30
   11092:	movs	r7, #0
   11094:	b.n	10972 <_dtoa_r+0x3da>
   11096:	vldr	d7, [sp, #64]	; 0x40
   1109a:	mov.w	sl, #2
   1109e:	vstr	d7, [sp, #72]	; 0x48
   110a2:	b.n	10c24 <_dtoa_r+0x68c>
   110a4:	mov	r4, r3
   110a6:	movs	r1, #0
   110a8:	str.w	r1, [r9, #68]	; 0x44
   110ac:	b.n	10bd0 <_dtoa_r+0x638>
   110ae:	movs	r4, #1
   110b0:	str	r4, [sp, #56]	; 0x38
   110b2:	str	r4, [sp, #32]
   110b4:	str	r4, [sp, #20]
   110b6:	b.n	110a6 <_dtoa_r+0xb0e>
   110b8:	cmp	r2, #0
   110ba:	mov	sl, r3
   110bc:	ble.n	110e2 <_dtoa_r+0xb4a>
   110be:	mov	r1, r4
   110c0:	movs	r2, #1
   110c2:	mov	r0, r9
   110c4:	bl	12258 <__lshift>
   110c8:	ldr	r1, [sp, #24]
   110ca:	mov	r4, r0
   110cc:	bl	12308 <__mcmp>
   110d0:	cmp	r0, #0
   110d2:	ble.w	11366 <_dtoa_r+0xdce>
   110d6:	cmp.w	sl, #57	; 0x39
   110da:	beq.w	112f0 <_dtoa_r+0xd58>
   110de:	add.w	sl, r5, #49	; 0x31
   110e2:	mov	fp, r6
   110e4:	strb.w	sl, [r7]
   110e8:	adds	r5, r7, #1
   110ea:	mov	r6, r8
   110ec:	str	r4, [sp, #40]	; 0x28
   110ee:	b.n	10b06 <_dtoa_r+0x56e>
   110f0:	bne.n	110fc <_dtoa_r+0xb64>
   110f2:	tst.w	sl, #1
   110f6:	beq.n	110fc <_dtoa_r+0xb64>
   110f8:	b.n	10ae6 <_dtoa_r+0x54e>
   110fa:	mov	r5, r2
   110fc:	ldrb.w	r3, [r5, #-1]
   11100:	cmp	r3, #48	; 0x30
   11102:	add.w	r2, r5, #4294967295
   11106:	beq.n	110fa <_dtoa_r+0xb62>
   11108:	b.n	10b06 <_dtoa_r+0x56e>
   1110a:	ldr.w	r8, [sp, #72]	; 0x48
   1110e:	ldrd	sl, fp, [sp, #64]	; 0x40
   11112:	b.w	107ac <_dtoa_r+0x214>
   11116:	ldr	r1, [sp, #36]	; 0x24
   11118:	movs	r2, #48	; 0x30
   1111a:	strb	r2, [r1, #0]
   1111c:	ldr	r2, [sp, #16]
   1111e:	ldrb.w	r4, [r5, #-1]
   11122:	adds	r2, #1
   11124:	str	r2, [sp, #16]
   11126:	b.n	1092a <_dtoa_r+0x392>
   11128:	ldr	r3, [sp, #16]
   1112a:	negs	r4, r3
   1112c:	cmp	r4, #0
   1112e:	beq.w	11298 <_dtoa_r+0xd00>
   11132:	ldr	r3, [pc, #528]	; (11344 <_dtoa_r+0xdac>)
   11134:	and.w	r2, r4, #15
   11138:	add.w	r3, r3, r2, lsl #3
   1113c:	ldrd	r2, r3, [r3]
   11140:	ldrd	r0, r1, [sp, #64]	; 0x40
   11144:	bl	b2b0 <__aeabi_dmul>
   11148:	asrs	r4, r4, #4
   1114a:	mov	r6, r0
   1114c:	mov	r7, r1
   1114e:	beq.w	1137e <_dtoa_r+0xde6>
   11152:	ldr	r5, [pc, #500]	; (11348 <_dtoa_r+0xdb0>)
   11154:	mov.w	sl, #2
   11158:	lsls	r2, r4, #31
   1115a:	bpl.n	11170 <_dtoa_r+0xbd8>
   1115c:	mov	r0, r6
   1115e:	mov	r1, r7
   11160:	ldrd	r2, r3, [r5]
   11164:	bl	b2b0 <__aeabi_dmul>
   11168:	add.w	sl, sl, #1
   1116c:	mov	r6, r0
   1116e:	mov	r7, r1
   11170:	asrs	r4, r4, #1
   11172:	add.w	r5, r5, #8
   11176:	bne.n	11158 <_dtoa_r+0xbc0>
   11178:	b.n	10c58 <_dtoa_r+0x6c0>
   1117a:	ldr	r1, [r6, #4]
   1117c:	mov	r0, r9
   1117e:	bl	11e60 <_Balloc>
   11182:	ldr	r3, [r6, #16]
   11184:	adds	r2, r3, #2
   11186:	mov	r5, r0
   11188:	lsls	r2, r2, #2
   1118a:	add.w	r1, r6, #12
   1118e:	adds	r0, #12
   11190:	bl	9220 <memcpy>
   11194:	mov	r1, r5
   11196:	movs	r2, #1
   11198:	mov	r0, r9
   1119a:	bl	12258 <__lshift>
   1119e:	mov	r8, r0
   111a0:	b.n	10e84 <_dtoa_r+0x8ec>
   111a2:	cmp	r3, #57	; 0x39
   111a4:	beq.w	112f0 <_dtoa_r+0xd58>
   111a8:	add.w	sl, r3, #1
   111ac:	mov	fp, r6
   111ae:	strb.w	sl, [r7]
   111b2:	adds	r5, r7, #1
   111b4:	mov	r6, r8
   111b6:	str	r4, [sp, #40]	; 0x28
   111b8:	b.n	10b06 <_dtoa_r+0x56e>
   111ba:	mov	fp, r6
   111bc:	mov	sl, r3
   111be:	mov	r6, r8
   111c0:	b.n	10ace <_dtoa_r+0x536>
   111c2:	movs	r3, #0
   111c4:	str	r3, [sp, #24]
   111c6:	mov	r6, r3
   111c8:	b.n	10fce <_dtoa_r+0xa36>
   111ca:	ldr	r3, [sp, #72]	; 0x48
   111cc:	ldr	r1, [pc, #372]	; (11344 <_dtoa_r+0xdac>)
   111ce:	subs	r2, r3, #1
   111d0:	add.w	r1, r1, r2, lsl #3
   111d4:	mov	r3, r5
   111d6:	str	r2, [sp, #92]	; 0x5c
   111d8:	ldrd	r0, r1, [r1]
   111dc:	mov	r2, r4
   111de:	bl	b2b0 <__aeabi_dmul>
   111e2:	strd	r0, r1, [sp, #80]	; 0x50
   111e6:	mov	r1, r7
   111e8:	mov	r0, r6
   111ea:	bl	b810 <__aeabi_d2iz>
   111ee:	mov	r4, r0
   111f0:	bl	b1e4 <__aeabi_i2d>
   111f4:	mov	r3, r1
   111f6:	mov	r2, r0
   111f8:	mov	r1, r7
   111fa:	mov	r0, r6
   111fc:	bl	af48 <__aeabi_dsub>
   11200:	ldr	r3, [sp, #72]	; 0x48
   11202:	mov	r7, r1
   11204:	ldr	r1, [sp, #36]	; 0x24
   11206:	adds	r4, #48	; 0x30
   11208:	cmp	r3, #1
   1120a:	mov	r6, r0
   1120c:	strb	r4, [r1, #0]
   1120e:	add.w	r5, r1, #1
   11212:	beq.n	11256 <_dtoa_r+0xcbe>
   11214:	ldr	r3, [sp, #72]	; 0x48
   11216:	ldr	r2, [sp, #36]	; 0x24
   11218:	add	r3, r2
   1121a:	mov	sl, r3
   1121c:	mov	fp, r5
   1121e:	movs	r2, #0
   11220:	ldr	r3, [pc, #296]	; (1134c <_dtoa_r+0xdb4>)
   11222:	mov	r0, r6
   11224:	mov	r1, r7
   11226:	bl	b2b0 <__aeabi_dmul>
   1122a:	mov	r7, r1
   1122c:	mov	r6, r0
   1122e:	bl	b810 <__aeabi_d2iz>
   11232:	mov	r4, r0
   11234:	bl	b1e4 <__aeabi_i2d>
   11238:	adds	r4, #48	; 0x30
   1123a:	mov	r2, r0
   1123c:	mov	r3, r1
   1123e:	mov	r0, r6
   11240:	mov	r1, r7
   11242:	bl	af48 <__aeabi_dsub>
   11246:	strb.w	r4, [fp], #1
   1124a:	cmp	sl, fp
   1124c:	mov	r6, r0
   1124e:	mov	r7, r1
   11250:	bne.n	1121e <_dtoa_r+0xc86>
   11252:	ldr	r3, [sp, #92]	; 0x5c
   11254:	add	r5, r3
   11256:	movs	r2, #0
   11258:	ldr	r3, [pc, #244]	; (11350 <_dtoa_r+0xdb8>)
   1125a:	ldrd	r0, r1, [sp, #80]	; 0x50
   1125e:	bl	af4c <__adddf3>
   11262:	mov	r2, r6
   11264:	mov	r3, r7
   11266:	bl	b794 <__aeabi_dcmplt>
   1126a:	cmp	r0, #0
   1126c:	beq.n	11300 <_dtoa_r+0xd68>
   1126e:	ldr	r3, [sp, #88]	; 0x58
   11270:	str	r3, [sp, #16]
   11272:	ldrb.w	r4, [r5, #-1]
   11276:	b.w	10912 <_dtoa_r+0x37a>
   1127a:	ldr	r3, [sp, #28]
   1127c:	ldr	r2, [sp, #32]
   1127e:	subs	r5, r3, r2
   11280:	movs	r3, #0
   11282:	b.w	1097e <_dtoa_r+0x3e6>
   11286:	movs	r7, #0
   11288:	b.n	11020 <_dtoa_r+0xa88>
   1128a:	ldr	r3, [sp, #96]	; 0x60
   1128c:	ldr	r7, [sp, #24]
   1128e:	ldr	r5, [sp, #28]
   11290:	rsb	r3, r3, #54	; 0x36
   11294:	b.w	1097e <_dtoa_r+0x3e6>
   11298:	ldrd	r6, r7, [sp, #64]	; 0x40
   1129c:	mov.w	sl, #2
   112a0:	b.n	10c58 <_dtoa_r+0x6c0>
   112a2:	ldr	r3, [sp, #32]
   112a4:	cmp	r3, #0
   112a6:	beq.w	1102c <_dtoa_r+0xa94>
   112aa:	ldr	r3, [sp, #56]	; 0x38
   112ac:	cmp	r3, #0
   112ae:	ble.w	1110e <_dtoa_r+0xb76>
   112b2:	movs	r2, #0
   112b4:	ldr	r3, [pc, #148]	; (1134c <_dtoa_r+0xdb4>)
   112b6:	mov	r0, r6
   112b8:	mov	r1, r7
   112ba:	bl	b2b0 <__aeabi_dmul>
   112be:	mov	r6, r0
   112c0:	mov	r7, r1
   112c2:	add.w	r0, sl, #1
   112c6:	bl	b1e4 <__aeabi_i2d>
   112ca:	mov	r2, r6
   112cc:	mov	r3, r7
   112ce:	bl	b2b0 <__aeabi_dmul>
   112d2:	movs	r2, #0
   112d4:	ldr	r3, [pc, #100]	; (1133c <_dtoa_r+0xda4>)
   112d6:	bl	af4c <__adddf3>
   112da:	ldr	r2, [sp, #16]
   112dc:	ldr	r3, [sp, #56]	; 0x38
   112de:	str	r3, [sp, #72]	; 0x48
   112e0:	subs	r2, #1
   112e2:	mov	r4, r0
   112e4:	sub.w	r5, r1, #54525952	; 0x3400000
   112e8:	str	r2, [sp, #88]	; 0x58
   112ea:	b.n	10c9a <_dtoa_r+0x702>
   112ec:	str	r4, [sp, #40]	; 0x28
   112ee:	b.n	10dfa <_dtoa_r+0x862>
   112f0:	movs	r2, #57	; 0x39
   112f2:	mov	fp, r6
   112f4:	str	r4, [sp, #40]	; 0x28
   112f6:	mov	r6, r8
   112f8:	strb	r2, [r7, #0]
   112fa:	adds	r5, r7, #1
   112fc:	b.w	10aea <_dtoa_r+0x552>
   11300:	ldrd	r2, r3, [sp, #80]	; 0x50
   11304:	movs	r0, #0
   11306:	ldr	r1, [pc, #72]	; (11350 <_dtoa_r+0xdb8>)
   11308:	bl	af48 <__aeabi_dsub>
   1130c:	mov	r2, r6
   1130e:	mov	r3, r7
   11310:	bl	b7d0 <__aeabi_dcmpgt>
   11314:	cbnz	r0, 1131a <_dtoa_r+0xd82>
   11316:	b.n	1110e <_dtoa_r+0xb76>
   11318:	mov	r5, r2
   1131a:	ldrb.w	r3, [r5, #-1]
   1131e:	cmp	r3, #48	; 0x30
   11320:	add.w	r2, r5, #4294967295
   11324:	beq.n	11318 <_dtoa_r+0xd80>
   11326:	b.n	10d9c <_dtoa_r+0x804>
   11328:	ldr	r3, [sp, #88]	; 0x58
   1132a:	str	r3, [sp, #16]
   1132c:	b.w	10912 <_dtoa_r+0x37a>
   11330:	cmp.w	sl, #0
   11334:	bne.w	10e30 <_dtoa_r+0x898>
   11338:	b.n	11000 <_dtoa_r+0xa68>
   1133a:	nop
   1133c:	.word	0x401c0000
   11340:	.word	0x40140000
   11344:	.word	0x00013e08
   11348:	.word	0x00013ed0
   1134c:	.word	0x40240000
   11350:	.word	0x3fe00000
   11354:	cmp	r3, #57	; 0x39
   11356:	mov	fp, sl
   11358:	mov	sl, r3
   1135a:	beq.n	112f0 <_dtoa_r+0xd58>
   1135c:	cmp.w	fp, #0
   11360:	bgt.w	110de <_dtoa_r+0xb46>
   11364:	b.n	110e2 <_dtoa_r+0xb4a>
   11366:	bne.w	110e2 <_dtoa_r+0xb4a>
   1136a:	tst.w	sl, #1
   1136e:	beq.w	110e2 <_dtoa_r+0xb4a>
   11372:	b.n	110d6 <_dtoa_r+0xb3e>
   11374:	ldr	r3, [sp, #0]
   11376:	cmp	r3, #2
   11378:	bgt.n	113c6 <_dtoa_r+0xe2e>
   1137a:	ldr	r3, [sp, #56]	; 0x38
   1137c:	b.n	10f9a <_dtoa_r+0xa02>
   1137e:	mov.w	sl, #2
   11382:	b.n	10c58 <_dtoa_r+0x6c0>
   11384:	ldr	r3, [sp, #0]
   11386:	cmp	r3, #2
   11388:	bgt.n	113c6 <_dtoa_r+0xe2e>
   1138a:	ldr	r3, [sp, #56]	; 0x38
   1138c:	b.n	10e6a <_dtoa_r+0x8d2>
   1138e:	movs	r4, #0
   11390:	str.w	r4, [r9, #68]	; 0x44
   11394:	mov	r1, r4
   11396:	mov	r0, r9
   11398:	bl	11e60 <_Balloc>
   1139c:	mov.w	r3, #4294967295
   113a0:	str	r3, [sp, #32]
   113a2:	str	r3, [sp, #56]	; 0x38
   113a4:	movs	r3, #1
   113a6:	str	r0, [sp, #36]	; 0x24
   113a8:	str	r4, [sp, #20]
   113aa:	str.w	r0, [r9, #64]	; 0x40
   113ae:	str	r3, [sp, #44]	; 0x2c
   113b0:	b.w	107ac <_dtoa_r+0x214>
   113b4:	beq.w	10a48 <_dtoa_r+0x4b0>
   113b8:	rsb	r0, r0, #60	; 0x3c
   113bc:	b.w	10a3e <_dtoa_r+0x4a6>
   113c0:	movs	r6, #1
   113c2:	b.w	1073e <_dtoa_r+0x1a6>
   113c6:	ldr	r3, [sp, #56]	; 0x38
   113c8:	str	r3, [sp, #32]
   113ca:	b.n	10faa <_dtoa_r+0xa12>

000113cc <__libc_fini_array>:
   113cc:	push	{r3, r4, r5, lr}
   113ce:	ldr	r5, [pc, #28]	; (113ec <__libc_fini_array+0x20>)
   113d0:	ldr	r4, [pc, #28]	; (113f0 <__libc_fini_array+0x24>)
   113d2:	subs	r4, r5, r4
   113d4:	asrs	r4, r4, #2
   113d6:	beq.n	113e4 <__libc_fini_array+0x18>
   113d8:	subs	r4, #1
   113da:	ldr.w	r3, [r5, #-4]!
   113de:	blx	r3
   113e0:	cmp	r4, #0
   113e2:	bne.n	113d8 <__libc_fini_array+0xc>
   113e4:	ldmia.w	sp!, {r3, r4, r5, lr}
   113e8:	b.w	13f64 <__init_array_end>
	...

000113f4 <_malloc_trim_r>:
   113f4:	push	{r3, r4, r5, r6, r7, lr}
   113f6:	ldr	r7, [pc, #140]	; (11484 <_malloc_trim_r+0x90>)
   113f8:	mov	r4, r1
   113fa:	mov	r6, r0
   113fc:	bl	c538 <__malloc_lock>
   11400:	ldr	r3, [r7, #8]
   11402:	ldr	r5, [r3, #4]
   11404:	bic.w	r5, r5, #3
   11408:	subs	r1, r5, r4
   1140a:	addw	r1, r1, #4079	; 0xfef
   1140e:	bic.w	r1, r1, #4080	; 0xff0
   11412:	bic.w	r1, r1, #15
   11416:	sub.w	r4, r1, #4096	; 0x1000
   1141a:	cmp.w	r4, #4096	; 0x1000
   1141e:	blt.n	11430 <_malloc_trim_r+0x3c>
   11420:	movs	r1, #0
   11422:	mov	r0, r6
   11424:	bl	c920 <_sbrk_r>
   11428:	ldr	r3, [r7, #8]
   1142a:	add	r3, r5
   1142c:	cmp	r0, r3
   1142e:	beq.n	1143a <_malloc_trim_r+0x46>
   11430:	mov	r0, r6
   11432:	bl	c53c <__malloc_unlock>
   11436:	movs	r0, #0
   11438:	pop	{r3, r4, r5, r6, r7, pc}
   1143a:	negs	r1, r4
   1143c:	mov	r0, r6
   1143e:	bl	c920 <_sbrk_r>
   11442:	adds	r0, #1
   11444:	beq.n	11462 <_malloc_trim_r+0x6e>
   11446:	ldr	r3, [pc, #64]	; (11488 <_malloc_trim_r+0x94>)
   11448:	ldr	r2, [r7, #8]
   1144a:	ldr	r1, [r3, #0]
   1144c:	subs	r5, r5, r4
   1144e:	orr.w	r5, r5, #1
   11452:	mov	r0, r6
   11454:	subs	r1, r1, r4
   11456:	str	r5, [r2, #4]
   11458:	str	r1, [r3, #0]
   1145a:	bl	c53c <__malloc_unlock>
   1145e:	movs	r0, #1
   11460:	pop	{r3, r4, r5, r6, r7, pc}
   11462:	movs	r1, #0
   11464:	mov	r0, r6
   11466:	bl	c920 <_sbrk_r>
   1146a:	ldr	r2, [r7, #8]
   1146c:	subs	r3, r0, r2
   1146e:	cmp	r3, #15
   11470:	ble.n	11430 <_malloc_trim_r+0x3c>
   11472:	ldr	r4, [pc, #24]	; (1148c <_malloc_trim_r+0x98>)
   11474:	ldr	r1, [pc, #16]	; (11488 <_malloc_trim_r+0x94>)
   11476:	ldr	r4, [r4, #0]
   11478:	orr.w	r3, r3, #1
   1147c:	subs	r0, r0, r4
   1147e:	str	r3, [r2, #4]
   11480:	str	r0, [r1, #0]
   11482:	b.n	11430 <_malloc_trim_r+0x3c>
   11484:	.word	0x20013f38
   11488:	.word	0x20019d78
   1148c:	.word	0x20014344

00011490 <_free_r>:
   11490:	cmp	r1, #0
   11492:	beq.n	11520 <_free_r+0x90>
   11494:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11498:	mov	r5, r1
   1149a:	mov	r8, r0
   1149c:	bl	c538 <__malloc_lock>
   114a0:	ldr.w	r7, [r5, #-4]
   114a4:	ldr	r1, [pc, #424]	; (11650 <_free_r+0x1c0>)
   114a6:	bic.w	r3, r7, #1
   114aa:	sub.w	r4, r5, #8
   114ae:	adds	r2, r4, r3
   114b0:	ldr	r6, [r1, #8]
   114b2:	ldr	r0, [r2, #4]
   114b4:	cmp	r2, r6
   114b6:	bic.w	r0, r0, #3
   114ba:	beq.n	11582 <_free_r+0xf2>
   114bc:	lsls	r6, r7, #31
   114be:	str	r0, [r2, #4]
   114c0:	bmi.n	114da <_free_r+0x4a>
   114c2:	ldr.w	r7, [r5, #-8]
   114c6:	subs	r4, r4, r7
   114c8:	add.w	lr, r1, #8
   114cc:	ldr	r5, [r4, #8]
   114ce:	cmp	r5, lr
   114d0:	add	r3, r7
   114d2:	beq.n	115b4 <_free_r+0x124>
   114d4:	ldr	r7, [r4, #12]
   114d6:	str	r7, [r5, #12]
   114d8:	str	r5, [r7, #8]
   114da:	adds	r5, r2, r0
   114dc:	ldr	r5, [r5, #4]
   114de:	lsls	r5, r5, #31
   114e0:	bpl.n	11568 <_free_r+0xd8>
   114e2:	orr.w	r2, r3, #1
   114e6:	str	r2, [r4, #4]
   114e8:	str	r3, [r4, r3]
   114ea:	cmp.w	r3, #512	; 0x200
   114ee:	bcs.n	11522 <_free_r+0x92>
   114f0:	lsrs	r3, r3, #3
   114f2:	adds	r2, r3, #1
   114f4:	ldr	r5, [r1, #4]
   114f6:	ldr.w	r7, [r1, r2, lsl #3]
   114fa:	str	r7, [r4, #8]
   114fc:	movs	r0, #1
   114fe:	asrs	r3, r3, #2
   11500:	lsl.w	r3, r0, r3
   11504:	add.w	r0, r1, r2, lsl #3
   11508:	orrs	r5, r3
   1150a:	subs	r0, #8
   1150c:	str	r0, [r4, #12]
   1150e:	str	r5, [r1, #4]
   11510:	str.w	r4, [r1, r2, lsl #3]
   11514:	str	r4, [r7, #12]
   11516:	mov	r0, r8
   11518:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1151c:	b.w	c53c <__malloc_unlock>
   11520:	bx	lr
   11522:	lsrs	r2, r3, #9
   11524:	cmp	r2, #4
   11526:	bhi.n	115d0 <_free_r+0x140>
   11528:	lsrs	r2, r3, #6
   1152a:	add.w	r7, r2, #57	; 0x39
   1152e:	lsls	r7, r7, #1
   11530:	add.w	r5, r2, #56	; 0x38
   11534:	add.w	r0, r1, r7, lsl #2
   11538:	ldr.w	r2, [r1, r7, lsl #2]
   1153c:	ldr	r1, [pc, #272]	; (11650 <_free_r+0x1c0>)
   1153e:	subs	r0, #8
   11540:	cmp	r0, r2
   11542:	beq.n	115e0 <_free_r+0x150>
   11544:	ldr	r1, [r2, #4]
   11546:	bic.w	r1, r1, #3
   1154a:	cmp	r3, r1
   1154c:	bcs.n	11554 <_free_r+0xc4>
   1154e:	ldr	r2, [r2, #8]
   11550:	cmp	r0, r2
   11552:	bne.n	11544 <_free_r+0xb4>
   11554:	ldr	r0, [r2, #12]
   11556:	str	r0, [r4, #12]
   11558:	str	r2, [r4, #8]
   1155a:	str	r4, [r0, #8]
   1155c:	str	r4, [r2, #12]
   1155e:	mov	r0, r8
   11560:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   11564:	b.w	c53c <__malloc_unlock>
   11568:	ldr	r5, [r2, #8]
   1156a:	ldr	r7, [pc, #232]	; (11654 <_free_r+0x1c4>)
   1156c:	cmp	r5, r7
   1156e:	add	r3, r0
   11570:	beq.n	115f2 <_free_r+0x162>
   11572:	ldr	r0, [r2, #12]
   11574:	str	r0, [r5, #12]
   11576:	orr.w	r2, r3, #1
   1157a:	str	r5, [r0, #8]
   1157c:	str	r2, [r4, #4]
   1157e:	str	r3, [r4, r3]
   11580:	b.n	114ea <_free_r+0x5a>
   11582:	lsls	r7, r7, #31
   11584:	add	r3, r0
   11586:	bmi.n	11598 <_free_r+0x108>
   11588:	ldr.w	r2, [r5, #-8]
   1158c:	subs	r4, r4, r2
   1158e:	add	r3, r2
   11590:	ldr	r0, [r4, #8]
   11592:	ldr	r2, [r4, #12]
   11594:	str	r2, [r0, #12]
   11596:	str	r0, [r2, #8]
   11598:	ldr	r2, [pc, #188]	; (11658 <_free_r+0x1c8>)
   1159a:	ldr	r2, [r2, #0]
   1159c:	orr.w	r0, r3, #1
   115a0:	cmp	r3, r2
   115a2:	str	r0, [r4, #4]
   115a4:	str	r4, [r1, #8]
   115a6:	bcc.n	11516 <_free_r+0x86>
   115a8:	ldr	r3, [pc, #176]	; (1165c <_free_r+0x1cc>)
   115aa:	mov	r0, r8
   115ac:	ldr	r1, [r3, #0]
   115ae:	bl	113f4 <_malloc_trim_r>
   115b2:	b.n	11516 <_free_r+0x86>
   115b4:	adds	r1, r2, r0
   115b6:	ldr	r1, [r1, #4]
   115b8:	lsls	r1, r1, #31
   115ba:	bmi.n	11646 <_free_r+0x1b6>
   115bc:	ldr	r1, [r2, #8]
   115be:	ldr	r2, [r2, #12]
   115c0:	str	r2, [r1, #12]
   115c2:	add	r3, r0
   115c4:	orr.w	r0, r3, #1
   115c8:	str	r1, [r2, #8]
   115ca:	str	r0, [r4, #4]
   115cc:	str	r3, [r4, r3]
   115ce:	b.n	11516 <_free_r+0x86>
   115d0:	cmp	r2, #20
   115d2:	bhi.n	11604 <_free_r+0x174>
   115d4:	add.w	r7, r2, #92	; 0x5c
   115d8:	lsls	r7, r7, #1
   115da:	add.w	r5, r2, #91	; 0x5b
   115de:	b.n	11534 <_free_r+0xa4>
   115e0:	asrs	r2, r5, #2
   115e2:	ldr	r3, [r1, #4]
   115e4:	movs	r5, #1
   115e6:	lsl.w	r2, r5, r2
   115ea:	orrs	r3, r2
   115ec:	str	r3, [r1, #4]
   115ee:	mov	r2, r0
   115f0:	b.n	11556 <_free_r+0xc6>
   115f2:	orr.w	r2, r3, #1
   115f6:	str	r4, [r1, #20]
   115f8:	str	r4, [r1, #16]
   115fa:	str	r5, [r4, #12]
   115fc:	str	r5, [r4, #8]
   115fe:	str	r2, [r4, #4]
   11600:	str	r3, [r4, r3]
   11602:	b.n	11516 <_free_r+0x86>
   11604:	cmp	r2, #84	; 0x54
   11606:	bhi.n	11616 <_free_r+0x186>
   11608:	lsrs	r2, r3, #12
   1160a:	add.w	r7, r2, #111	; 0x6f
   1160e:	lsls	r7, r7, #1
   11610:	add.w	r5, r2, #110	; 0x6e
   11614:	b.n	11534 <_free_r+0xa4>
   11616:	cmp.w	r2, #340	; 0x154
   1161a:	bhi.n	1162a <_free_r+0x19a>
   1161c:	lsrs	r2, r3, #15
   1161e:	add.w	r7, r2, #120	; 0x78
   11622:	lsls	r7, r7, #1
   11624:	add.w	r5, r2, #119	; 0x77
   11628:	b.n	11534 <_free_r+0xa4>
   1162a:	movw	r0, #1364	; 0x554
   1162e:	cmp	r2, r0
   11630:	bhi.n	11640 <_free_r+0x1b0>
   11632:	lsrs	r2, r3, #18
   11634:	add.w	r7, r2, #125	; 0x7d
   11638:	lsls	r7, r7, #1
   1163a:	add.w	r5, r2, #124	; 0x7c
   1163e:	b.n	11534 <_free_r+0xa4>
   11640:	movs	r7, #254	; 0xfe
   11642:	movs	r5, #126	; 0x7e
   11644:	b.n	11534 <_free_r+0xa4>
   11646:	orr.w	r2, r3, #1
   1164a:	str	r2, [r4, #4]
   1164c:	str	r3, [r4, r3]
   1164e:	b.n	11516 <_free_r+0x86>
   11650:	.word	0x20013f38
   11654:	.word	0x20013f40
   11658:	.word	0x20014340
   1165c:	.word	0x20019d74

00011660 <rshift>:
   11660:	ldr	r2, [r0, #16]
   11662:	asrs	r3, r1, #5
   11664:	cmp	r3, r2
   11666:	bge.n	116c6 <rshift+0x66>
   11668:	push	{r4, r5, r6, r7, lr}
   1166a:	ands.w	r1, r1, #31
   1166e:	add.w	r6, r0, #20
   11672:	add.w	r2, r6, r2, lsl #2
   11676:	add.w	lr, r6, r3, lsl #2
   1167a:	beq.n	116d0 <rshift+0x70>
   1167c:	ldr.w	r3, [r6, r3, lsl #2]
   11680:	add.w	r5, lr, #4
   11684:	cmp	r2, r5
   11686:	lsr.w	r4, r3, r1
   1168a:	rsb	ip, r1, #32
   1168e:	bls.n	11704 <rshift+0xa4>
   11690:	add.w	r7, r0, #16
   11694:	ldr	r3, [r5, #0]
   11696:	lsl.w	r3, r3, ip
   1169a:	orrs	r3, r4
   1169c:	str.w	r3, [r7, #4]!
   116a0:	ldr.w	r3, [r5], #4
   116a4:	cmp	r2, r5
   116a6:	lsr.w	r4, r3, r1
   116aa:	bhi.n	11694 <rshift+0x34>
   116ac:	rsb	r2, lr, r2
   116b0:	subs	r2, #5
   116b2:	bic.w	r2, r2, #3
   116b6:	adds	r2, #4
   116b8:	add	r2, r6
   116ba:	str	r4, [r2, #0]
   116bc:	cbz	r4, 116c0 <rshift+0x60>
   116be:	adds	r2, #4
   116c0:	subs	r3, r2, r6
   116c2:	asrs	r3, r3, #2
   116c4:	b.n	116f4 <rshift+0x94>
   116c6:	movs	r3, #0
   116c8:	str	r3, [r0, #16]
   116ca:	movs	r3, #0
   116cc:	str	r3, [r0, #20]
   116ce:	bx	lr
   116d0:	cmp	r2, lr
   116d2:	bls.n	116fa <rshift+0x9a>
   116d4:	add.w	r4, r0, #16
   116d8:	mov	r1, lr
   116da:	ldr.w	r5, [r1], #4
   116de:	str.w	r5, [r4, #4]!
   116e2:	cmp	r2, r1
   116e4:	bhi.n	116da <rshift+0x7a>
   116e6:	mvn.w	r3, lr
   116ea:	add	r3, r2
   116ec:	bic.w	r3, r3, #3
   116f0:	adds	r3, #4
   116f2:	asrs	r3, r3, #2
   116f4:	str	r3, [r0, #16]
   116f6:	cbz	r3, 116fe <rshift+0x9e>
   116f8:	pop	{r4, r5, r6, r7, pc}
   116fa:	movs	r3, #0
   116fc:	str	r3, [r0, #16]
   116fe:	movs	r3, #0
   11700:	str	r3, [r0, #20]
   11702:	pop	{r4, r5, r6, r7, pc}
   11704:	mov	r2, r6
   11706:	b.n	116ba <rshift+0x5a>

00011708 <__gethex>:
   11708:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1170c:	sub	sp, #44	; 0x2c
   1170e:	mov	r9, r1
   11710:	str	r0, [sp, #20]
   11712:	ldr	r0, [sp, #88]	; 0x58
   11714:	str	r2, [sp, #12]
   11716:	str	r3, [sp, #32]
   11718:	bl	11de4 <__localeconv_l>
   1171c:	ldr	r3, [r0, #0]
   1171e:	str	r3, [sp, #8]
   11720:	mov	r0, r3
   11722:	mov	r4, r3
   11724:	bl	cb80 <strlen>
   11728:	ldr.w	r3, [r9]
   1172c:	str	r0, [sp, #0]
   1172e:	ldrb	r2, [r3, #2]
   11730:	adds	r1, r4, r0
   11732:	cmp	r2, #48	; 0x30
   11734:	ldrb.w	fp, [r1, #-1]
   11738:	bne.w	11a8e <__gethex+0x386>
   1173c:	adds	r3, #3
   1173e:	mov.w	r8, #0
   11742:	mov	r4, r3
   11744:	ldrb.w	r2, [r3], #1
   11748:	cmp	r2, #48	; 0x30
   1174a:	add.w	r8, r8, #1
   1174e:	beq.n	11742 <__gethex+0x3a>
   11750:	ldr	r6, [pc, #712]	; (11a1c <__gethex+0x314>)
   11752:	ldrb	r3, [r6, r2]
   11754:	cmp	r3, #0
   11756:	beq.w	1193a <__gethex+0x232>
   1175a:	ldrb	r3, [r4, #0]
   1175c:	mov.w	sl, #0
   11760:	ldrb	r3, [r6, r3]
   11762:	mov	r5, sl
   11764:	mov	r7, r4
   11766:	cbz	r3, 11772 <__gethex+0x6a>
   11768:	ldrb.w	r3, [r7, #1]!
   1176c:	ldrb	r3, [r6, r3]
   1176e:	cmp	r3, #0
   11770:	bne.n	11768 <__gethex+0x60>
   11772:	ldr	r2, [sp, #0]
   11774:	ldr	r1, [sp, #8]
   11776:	mov	r0, r7
   11778:	bl	cc5c <strncmp>
   1177c:	cmp	r0, #0
   1177e:	beq.w	118a6 <__gethex+0x19e>
   11782:	ldrb	r3, [r7, #0]
   11784:	cmp	r5, #0
   11786:	beq.w	11a6c <__gethex+0x364>
   1178a:	subs	r5, r5, r7
   1178c:	lsls	r2, r5, #2
   1178e:	str	r2, [sp, #4]
   11790:	cmp	r3, #80	; 0x50
   11792:	beq.w	118b8 <__gethex+0x1b0>
   11796:	cmp	r3, #112	; 0x70
   11798:	beq.w	118b8 <__gethex+0x1b0>
   1179c:	mov	r5, r7
   1179e:	str.w	r7, [r9]
   117a2:	cmp.w	sl, #0
   117a6:	bne.w	11918 <__gethex+0x210>
   117aa:	subs	r3, r5, r4
   117ac:	subs	r3, #1
   117ae:	cmp	r3, #7
   117b0:	mov	r1, sl
   117b2:	ble.n	117be <__gethex+0xb6>
   117b4:	asrs	r3, r3, #1
   117b6:	cmp	r3, #7
   117b8:	add.w	r1, r1, #1
   117bc:	bgt.n	117b4 <__gethex+0xac>
   117be:	ldr	r0, [sp, #20]
   117c0:	bl	11e60 <_Balloc>
   117c4:	mov	r3, r0
   117c6:	adds	r3, #20
   117c8:	cmp	r5, r4
   117ca:	str	r0, [sp, #16]
   117cc:	str	r3, [sp, #28]
   117ce:	bls.w	11b78 <__gethex+0x470>
   117d2:	mov	r9, r3
   117d4:	ldr	r3, [sp, #0]
   117d6:	mov.w	r8, #0
   117da:	rsb	r3, r3, #1
   117de:	mov	r7, r8
   117e0:	str	r3, [sp, #24]
   117e2:	b.n	11804 <__gethex+0xfc>
   117e4:	cmp	r7, #32
   117e6:	beq.w	11928 <__gethex+0x220>
   117ea:	mov	r2, r7
   117ec:	adds	r7, #4
   117ee:	ldrb.w	r3, [r5, #-1]
   117f2:	ldrb	r3, [r6, r3]
   117f4:	mov	r5, sl
   117f6:	and.w	r3, r3, #15
   117fa:	lsls	r3, r2
   117fc:	cmp	r5, r4
   117fe:	orr.w	r8, r8, r3
   11802:	bls.n	11830 <__gethex+0x128>
   11804:	ldrb.w	r3, [r5, #-1]
   11808:	cmp	r3, fp
   1180a:	add.w	sl, r5, #4294967295
   1180e:	bne.n	117e4 <__gethex+0xdc>
   11810:	ldr	r3, [sp, #24]
   11812:	add	r3, sl
   11814:	cmp	r3, r4
   11816:	bcc.n	117e4 <__gethex+0xdc>
   11818:	mov	r0, r3
   1181a:	ldr	r2, [sp, #0]
   1181c:	ldr	r1, [sp, #8]
   1181e:	str	r3, [sp, #36]	; 0x24
   11820:	bl	cc5c <strncmp>
   11824:	ldr	r3, [sp, #36]	; 0x24
   11826:	cmp	r0, #0
   11828:	bne.n	117e4 <__gethex+0xdc>
   1182a:	mov	r5, r3
   1182c:	cmp	r5, r4
   1182e:	bhi.n	11804 <__gethex+0xfc>
   11830:	str.w	r8, [r9], #4
   11834:	ldr	r3, [sp, #28]
   11836:	ldr	r2, [sp, #16]
   11838:	rsb	r9, r3, r9
   1183c:	mov.w	r3, r9, asr #2
   11840:	str	r3, [r2, #16]
   11842:	mov	r0, r8
   11844:	mov.w	r9, r3, lsl #5
   11848:	bl	11fd8 <__hi0bits>
   1184c:	ldr	r3, [sp, #12]
   1184e:	ldr	r6, [r3, #0]
   11850:	rsb	r0, r0, r9
   11854:	cmp	r0, r6
   11856:	bgt.w	11a20 <__gethex+0x318>
   1185a:	blt.w	11a70 <__gethex+0x368>
   1185e:	movs	r7, #0
   11860:	ldr	r3, [sp, #12]
   11862:	ldr	r2, [sp, #4]
   11864:	ldr	r3, [r3, #8]
   11866:	cmp	r2, r3
   11868:	bgt.w	1199a <__gethex+0x292>
   1186c:	ldr	r0, [sp, #12]
   1186e:	ldr	r1, [sp, #4]
   11870:	ldr	r3, [r0, #4]
   11872:	cmp	r1, r3
   11874:	bge.w	119e2 <__gethex+0x2da>
   11878:	subs	r5, r3, r1
   1187a:	cmp	r6, r5
   1187c:	bgt.w	11a9e <__gethex+0x396>
   11880:	ldr	r2, [r0, #12]
   11882:	cmp	r2, #2
   11884:	beq.w	11b86 <__gethex+0x47e>
   11888:	cmp	r2, #3
   1188a:	beq.w	11b46 <__gethex+0x43e>
   1188e:	cmp	r2, #1
   11890:	beq.w	11b8e <__gethex+0x486>
   11894:	ldr	r0, [sp, #20]
   11896:	ldr	r1, [sp, #16]
   11898:	bl	11eac <_Bfree>
   1189c:	ldr	r2, [sp, #80]	; 0x50
   1189e:	movs	r3, #0
   118a0:	str	r3, [r2, #0]
   118a2:	movs	r0, #80	; 0x50
   118a4:	b.n	11922 <__gethex+0x21a>
   118a6:	cmp	r5, #0
   118a8:	beq.w	11ade <__gethex+0x3d6>
   118ac:	ldrb	r3, [r7, #0]
   118ae:	b.n	1178a <__gethex+0x82>
   118b0:	movs	r3, #0
   118b2:	str	r3, [sp, #4]
   118b4:	mov.w	sl, #1
   118b8:	ldrb	r3, [r7, #1]
   118ba:	cmp	r3, #43	; 0x2b
   118bc:	beq.w	11a18 <__gethex+0x310>
   118c0:	cmp	r3, #45	; 0x2d
   118c2:	beq.n	119b0 <__gethex+0x2a8>
   118c4:	adds	r1, r7, #1
   118c6:	movs	r5, #0
   118c8:	ldrb	r3, [r6, r3]
   118ca:	ldr	r0, [pc, #336]	; (11a1c <__gethex+0x314>)
   118cc:	subs	r2, r3, #1
   118ce:	cmp	r2, #24
   118d0:	bhi.w	1179c <__gethex+0x94>
   118d4:	ldrb	r2, [r1, #1]
   118d6:	ldrb	r2, [r0, r2]
   118d8:	subs	r0, r2, #1
   118da:	cmp	r0, #24
   118dc:	sub.w	r3, r3, #16
   118e0:	add.w	r1, r1, #1
   118e4:	bhi.n	118fe <__gethex+0x1f6>
   118e6:	ldrb.w	r0, [r1, #1]!
   118ea:	add.w	r3, r3, r3, lsl #2
   118ee:	add.w	r3, r2, r3, lsl #1
   118f2:	ldrb	r2, [r6, r0]
   118f4:	subs	r0, r2, #1
   118f6:	cmp	r0, #24
   118f8:	sub.w	r3, r3, #16
   118fc:	bls.n	118e6 <__gethex+0x1de>
   118fe:	cbz	r5, 11902 <__gethex+0x1fa>
   11900:	negs	r3, r3
   11902:	ldr	r2, [sp, #4]
   11904:	mov	r5, r7
   11906:	add	r2, r3
   11908:	mov	r7, r1
   1190a:	str	r2, [sp, #4]
   1190c:	str.w	r7, [r9]
   11910:	cmp.w	sl, #0
   11914:	beq.w	117aa <__gethex+0xa2>
   11918:	cmp.w	r8, #0
   1191c:	ite	eq
   1191e:	moveq	r0, #6
   11920:	movne	r0, #0
   11922:	add	sp, #44	; 0x2c
   11924:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11928:	str.w	r8, [r9]
   1192c:	mov.w	r8, #0
   11930:	add.w	r9, r9, #4
   11934:	mov	r2, r8
   11936:	movs	r7, #4
   11938:	b.n	117ee <__gethex+0xe6>
   1193a:	ldr	r5, [sp, #0]
   1193c:	ldr	r1, [sp, #8]
   1193e:	mov	r2, r5
   11940:	mov	r0, r4
   11942:	bl	cc5c <strncmp>
   11946:	cmp	r0, #0
   11948:	beq.n	119b8 <__gethex+0x2b0>
   1194a:	ldrb	r3, [r4, #0]
   1194c:	mov	r7, r4
   1194e:	cmp	r3, #80	; 0x50
   11950:	beq.n	118b0 <__gethex+0x1a8>
   11952:	cmp	r3, #112	; 0x70
   11954:	beq.n	118b0 <__gethex+0x1a8>
   11956:	str.w	r7, [r9]
   1195a:	b.n	11918 <__gethex+0x210>
   1195c:	ldr	r3, [sp, #16]
   1195e:	ldr	r3, [r3, #8]
   11960:	cmp	r7, r3
   11962:	bge.w	11bce <__gethex+0x4c6>
   11966:	mov	r3, r7
   11968:	ldr	r0, [sp, #16]
   1196a:	add.w	r2, r0, r3, lsl #2
   1196e:	movs	r1, #1
   11970:	adds	r3, #1
   11972:	cmp	r4, #2
   11974:	str	r3, [r0, #16]
   11976:	str	r1, [r2, #20]
   11978:	beq.w	11bac <__gethex+0x4a4>
   1197c:	cmp	r7, r3
   1197e:	bge.w	11b38 <__gethex+0x430>
   11982:	movs	r1, #1
   11984:	ldr	r0, [sp, #16]
   11986:	bl	11660 <rshift>
   1198a:	ldr	r3, [sp, #12]
   1198c:	ldr	r2, [sp, #4]
   1198e:	ldr	r3, [r3, #8]
   11990:	adds	r2, #1
   11992:	cmp	r2, r3
   11994:	str	r2, [sp, #4]
   11996:	ble.w	11b3e <__gethex+0x436>
   1199a:	ldr	r0, [sp, #20]
   1199c:	ldr	r1, [sp, #16]
   1199e:	bl	11eac <_Bfree>
   119a2:	ldr	r2, [sp, #80]	; 0x50
   119a4:	movs	r3, #0
   119a6:	movs	r0, #163	; 0xa3
   119a8:	str	r3, [r2, #0]
   119aa:	add	sp, #44	; 0x2c
   119ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   119b0:	movs	r5, #1
   119b2:	ldrb	r3, [r7, #2]
   119b4:	adds	r1, r7, #2
   119b6:	b.n	118c8 <__gethex+0x1c0>
   119b8:	ldrb	r2, [r4, r5]
   119ba:	ldrb	r3, [r6, r2]
   119bc:	adds	r7, r4, r5
   119be:	cmp	r3, #0
   119c0:	beq.n	11a96 <__gethex+0x38e>
   119c2:	cmp	r2, #48	; 0x30
   119c4:	mov	r4, r7
   119c6:	bne.n	119d2 <__gethex+0x2ca>
   119c8:	ldrb.w	r3, [r4, #1]!
   119cc:	cmp	r3, #48	; 0x30
   119ce:	beq.n	119c8 <__gethex+0x2c0>
   119d0:	ldrb	r3, [r6, r3]
   119d2:	clz	sl, r3
   119d6:	mov	r5, r7
   119d8:	mov.w	sl, sl, lsr #5
   119dc:	mov.w	r8, #1
   119e0:	b.n	11764 <__gethex+0x5c>
   119e2:	movs	r4, #1
   119e4:	cbz	r7, 11a00 <__gethex+0x2f8>
   119e6:	ldr	r3, [sp, #12]
   119e8:	ldr	r3, [r3, #12]
   119ea:	cmp	r3, #2
   119ec:	beq.w	11afa <__gethex+0x3f2>
   119f0:	cmp	r3, #3
   119f2:	beq.w	11b02 <__gethex+0x3fa>
   119f6:	cmp	r3, #1
   119f8:	beq.w	11b66 <__gethex+0x45e>
   119fc:	orr.w	r4, r4, #16
   11a00:	ldr	r3, [sp, #80]	; 0x50
   11a02:	mov	r2, r3
   11a04:	ldr	r3, [sp, #16]
   11a06:	str	r3, [r2, #0]
   11a08:	ldr	r3, [sp, #32]
   11a0a:	mov	r2, r3
   11a0c:	ldr	r3, [sp, #4]
   11a0e:	str	r3, [r2, #0]
   11a10:	mov	r0, r4
   11a12:	add	sp, #44	; 0x2c
   11a14:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11a18:	movs	r5, #0
   11a1a:	b.n	119b2 <__gethex+0x2aa>
   11a1c:	.word	0x00013d04
   11a20:	subs	r4, r0, r6
   11a22:	mov	r1, r4
   11a24:	ldr	r0, [sp, #16]
   11a26:	bl	126e8 <__any_on>
   11a2a:	cmp	r0, #0
   11a2c:	beq.n	11a9a <__gethex+0x392>
   11a2e:	subs	r2, r4, #1
   11a30:	asrs	r1, r2, #5
   11a32:	ldr	r0, [sp, #28]
   11a34:	and.w	r3, r2, #31
   11a38:	ldr.w	r1, [r0, r1, lsl #2]
   11a3c:	movs	r7, #1
   11a3e:	lsl.w	r3, r7, r3
   11a42:	tst	r3, r1
   11a44:	beq.n	11a5c <__gethex+0x354>
   11a46:	cmp	r2, r7
   11a48:	ble.w	11b82 <__gethex+0x47a>
   11a4c:	subs	r1, r4, #2
   11a4e:	ldr	r0, [sp, #16]
   11a50:	bl	126e8 <__any_on>
   11a54:	cmp	r0, #0
   11a56:	beq.w	11b82 <__gethex+0x47a>
   11a5a:	movs	r7, #3
   11a5c:	ldr	r3, [sp, #4]
   11a5e:	ldr	r0, [sp, #16]
   11a60:	add	r3, r4
   11a62:	mov	r1, r4
   11a64:	str	r3, [sp, #4]
   11a66:	bl	11660 <rshift>
   11a6a:	b.n	11860 <__gethex+0x158>
   11a6c:	str	r5, [sp, #4]
   11a6e:	b.n	11790 <__gethex+0x88>
   11a70:	subs	r4, r6, r0
   11a72:	ldr	r1, [sp, #16]
   11a74:	ldr	r0, [sp, #20]
   11a76:	mov	r2, r4
   11a78:	bl	12258 <__lshift>
   11a7c:	ldr	r3, [sp, #4]
   11a7e:	str	r0, [sp, #16]
   11a80:	subs	r3, r3, r4
   11a82:	str	r3, [sp, #4]
   11a84:	mov	r3, r0
   11a86:	adds	r3, #20
   11a88:	str	r3, [sp, #28]
   11a8a:	movs	r7, #0
   11a8c:	b.n	11860 <__gethex+0x158>
   11a8e:	adds	r4, r3, #2
   11a90:	mov.w	r8, #0
   11a94:	b.n	11750 <__gethex+0x48>
   11a96:	mov	r3, r2
   11a98:	b.n	1194e <__gethex+0x246>
   11a9a:	mov	r7, r0
   11a9c:	b.n	11a5c <__gethex+0x354>
   11a9e:	subs	r4, r5, #1
   11aa0:	cmp	r7, #0
   11aa2:	bne.n	11b42 <__gethex+0x43a>
   11aa4:	cbz	r4, 11ab0 <__gethex+0x3a8>
   11aa6:	mov	r1, r4
   11aa8:	ldr	r0, [sp, #16]
   11aaa:	bl	126e8 <__any_on>
   11aae:	mov	r7, r0
   11ab0:	asrs	r3, r4, #5
   11ab2:	ldr	r2, [sp, #28]
   11ab4:	ldr	r0, [sp, #16]
   11ab6:	ldr.w	r2, [r2, r3, lsl #2]
   11aba:	and.w	r4, r4, #31
   11abe:	movs	r3, #1
   11ac0:	lsl.w	r4, r3, r4
   11ac4:	tst	r4, r2
   11ac6:	mov	r1, r5
   11ac8:	it	ne
   11aca:	orrne.w	r7, r7, #2
   11ace:	bl	11660 <rshift>
   11ad2:	ldr	r3, [sp, #12]
   11ad4:	ldr	r3, [r3, #4]
   11ad6:	str	r3, [sp, #4]
   11ad8:	subs	r6, r6, r5
   11ada:	movs	r4, #2
   11adc:	b.n	119e4 <__gethex+0x2dc>
   11ade:	ldr	r1, [sp, #0]
   11ae0:	ldrb	r3, [r7, r1]
   11ae2:	ldrb	r2, [r6, r3]
   11ae4:	adds	r5, r7, r1
   11ae6:	mov	r7, r5
   11ae8:	cmp	r2, #0
   11aea:	beq.w	1178a <__gethex+0x82>
   11aee:	ldrb.w	r3, [r7, #1]!
   11af2:	ldrb	r2, [r6, r3]
   11af4:	cmp	r2, #0
   11af6:	bne.n	11aee <__gethex+0x3e6>
   11af8:	b.n	1178a <__gethex+0x82>
   11afa:	ldr	r3, [sp, #84]	; 0x54
   11afc:	rsb	r3, r3, #1
   11b00:	str	r3, [sp, #84]	; 0x54
   11b02:	ldr	r3, [sp, #84]	; 0x54
   11b04:	cmp	r3, #0
   11b06:	beq.w	119fc <__gethex+0x2f4>
   11b0a:	ldr	r3, [sp, #16]
   11b0c:	ldr	r5, [sp, #28]
   11b0e:	ldr	r7, [r3, #16]
   11b10:	mov.w	r8, r7, lsl #2
   11b14:	add.w	r0, r5, r8
   11b18:	mov	r3, r5
   11b1a:	movs	r1, #0
   11b1c:	b.n	11b28 <__gethex+0x420>
   11b1e:	str.w	r1, [r3], #4
   11b22:	cmp	r0, r3
   11b24:	bls.w	1195c <__gethex+0x254>
   11b28:	ldr	r2, [r3, #0]
   11b2a:	cmp.w	r2, #4294967295
   11b2e:	beq.n	11b1e <__gethex+0x416>
   11b30:	adds	r2, #1
   11b32:	cmp	r4, #2
   11b34:	str	r2, [r3, #0]
   11b36:	beq.n	11bac <__gethex+0x4a4>
   11b38:	ands.w	r6, r6, #31
   11b3c:	bne.n	11bba <__gethex+0x4b2>
   11b3e:	movs	r4, #33	; 0x21
   11b40:	b.n	11a00 <__gethex+0x2f8>
   11b42:	movs	r7, #1
   11b44:	b.n	11ab0 <__gethex+0x3a8>
   11b46:	ldr	r2, [sp, #84]	; 0x54
   11b48:	cmp	r2, #0
   11b4a:	beq.w	11894 <__gethex+0x18c>
   11b4e:	ldr	r1, [sp, #32]
   11b50:	str	r3, [r1, #0]
   11b52:	ldr	r3, [sp, #28]
   11b54:	ldr	r1, [sp, #16]
   11b56:	movs	r2, #1
   11b58:	str	r2, [r1, #16]
   11b5a:	str	r2, [r3, #0]
   11b5c:	ldr	r3, [sp, #80]	; 0x50
   11b5e:	mov	r2, r3
   11b60:	movs	r0, #98	; 0x62
   11b62:	str	r1, [r2, #0]
   11b64:	b.n	11922 <__gethex+0x21a>
   11b66:	lsls	r2, r7, #30
   11b68:	bpl.w	119fc <__gethex+0x2f4>
   11b6c:	ldr	r3, [sp, #28]
   11b6e:	ldr	r3, [r3, #0]
   11b70:	orrs	r3, r7
   11b72:	lsls	r3, r3, #31
   11b74:	bmi.n	11b0a <__gethex+0x402>
   11b76:	b.n	119fc <__gethex+0x2f4>
   11b78:	ldr.w	r9, [sp, #28]
   11b7c:	mov.w	r8, #0
   11b80:	b.n	11830 <__gethex+0x128>
   11b82:	movs	r7, #2
   11b84:	b.n	11a5c <__gethex+0x354>
   11b86:	ldr	r2, [sp, #84]	; 0x54
   11b88:	cmp	r2, #0
   11b8a:	beq.n	11b4e <__gethex+0x446>
   11b8c:	b.n	11894 <__gethex+0x18c>
   11b8e:	cmp	r6, r5
   11b90:	bne.w	11894 <__gethex+0x18c>
   11b94:	cmp	r6, #1
   11b96:	ble.n	11b4e <__gethex+0x446>
   11b98:	subs	r1, r6, #1
   11b9a:	ldr	r0, [sp, #16]
   11b9c:	bl	126e8 <__any_on>
   11ba0:	cmp	r0, #0
   11ba2:	beq.w	11894 <__gethex+0x18c>
   11ba6:	ldr	r3, [sp, #12]
   11ba8:	ldr	r3, [r3, #4]
   11baa:	b.n	11b4e <__gethex+0x446>
   11bac:	ldr	r3, [sp, #12]
   11bae:	ldr	r3, [r3, #0]
   11bb0:	subs	r3, #1
   11bb2:	cmp	r6, r3
   11bb4:	beq.n	11c00 <__gethex+0x4f8>
   11bb6:	movs	r4, #34	; 0x22
   11bb8:	b.n	11a00 <__gethex+0x2f8>
   11bba:	add	r5, r8
   11bbc:	rsb	r6, r6, #32
   11bc0:	ldr.w	r0, [r5, #-4]
   11bc4:	bl	11fd8 <__hi0bits>
   11bc8:	cmp	r0, r6
   11bca:	bge.n	11b3e <__gethex+0x436>
   11bcc:	b.n	11982 <__gethex+0x27a>
   11bce:	ldr	r3, [sp, #16]
   11bd0:	ldr.w	r9, [sp, #20]
   11bd4:	ldr	r1, [r3, #4]
   11bd6:	mov	r0, r9
   11bd8:	adds	r1, #1
   11bda:	bl	11e60 <_Balloc>
   11bde:	ldr	r1, [sp, #16]
   11be0:	ldr	r3, [r1, #16]
   11be2:	adds	r2, r3, #2
   11be4:	mov	r5, r0
   11be6:	lsls	r2, r2, #2
   11be8:	adds	r1, #12
   11bea:	adds	r0, #12
   11bec:	bl	9220 <memcpy>
   11bf0:	ldr	r1, [sp, #16]
   11bf2:	mov	r0, r9
   11bf4:	bl	11eac <_Bfree>
   11bf8:	str	r5, [sp, #16]
   11bfa:	ldr	r3, [r5, #16]
   11bfc:	adds	r5, #20
   11bfe:	b.n	11968 <__gethex+0x260>
   11c00:	asrs	r3, r6, #5
   11c02:	and.w	r6, r6, #31
   11c06:	ldr.w	r2, [r5, r3, lsl #2]
   11c0a:	movs	r3, #1
   11c0c:	lsls	r3, r6
   11c0e:	tst	r3, r2
   11c10:	ite	ne
   11c12:	movne	r4, #33	; 0x21
   11c14:	moveq	r4, #34	; 0x22
   11c16:	b.n	11a00 <__gethex+0x2f8>

00011c18 <__match>:
   11c18:	push	{r4, r5}
   11c1a:	ldr	r4, [r0, #0]
   11c1c:	b.n	11c30 <__match+0x18>
   11c1e:	ldrb.w	r3, [r4, #1]!
   11c22:	sub.w	r5, r3, #65	; 0x41
   11c26:	cmp	r5, #25
   11c28:	it	ls
   11c2a:	addls	r3, #32
   11c2c:	cmp	r3, r2
   11c2e:	bne.n	11c42 <__match+0x2a>
   11c30:	ldrb.w	r2, [r1], #1
   11c34:	cmp	r2, #0
   11c36:	bne.n	11c1e <__match+0x6>
   11c38:	adds	r4, #1
   11c3a:	str	r4, [r0, #0]
   11c3c:	movs	r0, #1
   11c3e:	pop	{r4, r5}
   11c40:	bx	lr
   11c42:	movs	r0, #0
   11c44:	pop	{r4, r5}
   11c46:	bx	lr

00011c48 <__hexnan>:
   11c48:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11c4c:	ldr	r3, [r1, #0]
   11c4e:	ldr.w	r9, [pc, #372]	; 11dc4 <__hexnan+0x17c>
   11c52:	sub	sp, #20
   11c54:	asrs	r1, r3, #5
   11c56:	add.w	r1, r2, r1, lsl #2
   11c5a:	ands.w	r3, r3, #31
   11c5e:	str	r1, [sp, #4]
   11c60:	itt	ne
   11c62:	addne	r1, #4
   11c64:	strne	r1, [sp, #4]
   11c66:	ldr	r4, [sp, #4]
   11c68:	str	r0, [sp, #8]
   11c6a:	str	r3, [sp, #12]
   11c6c:	movs	r3, #0
   11c6e:	mov	r1, r3
   11c70:	str.w	r3, [r4, #-4]
   11c74:	mov	sl, r3
   11c76:	mov	lr, r3
   11c78:	ldr	r3, [sp, #8]
   11c7a:	sub.w	ip, r4, #4
   11c7e:	ldr	r5, [r3, #0]
   11c80:	mov	r8, ip
   11c82:	mov	r0, ip
   11c84:	ldrb.w	r3, [r5, #1]!
   11c88:	cbz	r3, 11cd4 <__hexnan+0x8c>
   11c8a:	ldrb.w	r4, [r9, r3]
   11c8e:	cmp	r4, #0
   11c90:	bne.n	11d1a <__hexnan+0xd2>
   11c92:	cmp	r3, #32
   11c94:	bhi.n	11d52 <__hexnan+0x10a>
   11c96:	cmp	lr, sl
   11c98:	ble.n	11c84 <__hexnan+0x3c>
   11c9a:	cmp	r0, r8
   11c9c:	bcs.n	11cc6 <__hexnan+0x7e>
   11c9e:	cmp	r1, #7
   11ca0:	bgt.n	11cc6 <__hexnan+0x7e>
   11ca2:	rsb	r1, r1, #8
   11ca6:	lsls	r1, r1, #2
   11ca8:	ldr	r6, [r0, #0]
   11caa:	rsb	fp, r1, #32
   11cae:	mov	r3, r0
   11cb0:	ldr	r7, [r3, #4]
   11cb2:	lsl.w	r4, r7, fp
   11cb6:	orrs	r4, r6
   11cb8:	lsr.w	r6, r7, r1
   11cbc:	str	r4, [r3, #0]
   11cbe:	str.w	r6, [r3, #4]!
   11cc2:	cmp	r8, r3
   11cc4:	bhi.n	11cb0 <__hexnan+0x68>
   11cc6:	cmp	r0, r2
   11cc8:	bhi.n	11d40 <__hexnan+0xf8>
   11cca:	ldrb.w	r3, [r5, #1]!
   11cce:	movs	r1, #8
   11cd0:	cmp	r3, #0
   11cd2:	bne.n	11c8a <__hexnan+0x42>
   11cd4:	cmp.w	lr, #0
   11cd8:	beq.n	11d56 <__hexnan+0x10e>
   11cda:	cmp	r0, r8
   11cdc:	bcs.n	11ce2 <__hexnan+0x9a>
   11cde:	cmp	r1, #7
   11ce0:	ble.n	11d9c <__hexnan+0x154>
   11ce2:	cmp	r0, r2
   11ce4:	bls.n	11d5e <__hexnan+0x116>
   11ce6:	mov	r3, r2
   11ce8:	ldr.w	r1, [r0], #4
   11cec:	str.w	r1, [r3], #4
   11cf0:	cmp	ip, r0
   11cf2:	bcs.n	11ce8 <__hexnan+0xa0>
   11cf4:	movs	r1, #0
   11cf6:	str.w	r1, [r3], #4
   11cfa:	cmp	ip, r3
   11cfc:	bcs.n	11cf6 <__hexnan+0xae>
   11cfe:	ldr	r3, [sp, #4]
   11d00:	ldr.w	r3, [r3, #-4]
   11d04:	cbnz	r3, 11d12 <__hexnan+0xca>
   11d06:	cmp	r2, ip
   11d08:	beq.n	11d80 <__hexnan+0x138>
   11d0a:	ldr.w	r3, [ip, #-4]!
   11d0e:	cmp	r3, #0
   11d10:	beq.n	11d06 <__hexnan+0xbe>
   11d12:	movs	r0, #5
   11d14:	add	sp, #20
   11d16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11d1a:	adds	r1, #1
   11d1c:	cmp	r1, #8
   11d1e:	add.w	lr, lr, #1
   11d22:	ble.n	11d32 <__hexnan+0xea>
   11d24:	cmp	r0, r2
   11d26:	bls.n	11c84 <__hexnan+0x3c>
   11d28:	movs	r3, #0
   11d2a:	str.w	r3, [r0, #-4]
   11d2e:	movs	r1, #1
   11d30:	subs	r0, #4
   11d32:	ldr	r3, [r0, #0]
   11d34:	and.w	r4, r4, #15
   11d38:	orr.w	r4, r4, r3, lsl #4
   11d3c:	str	r4, [r0, #0]
   11d3e:	b.n	11c84 <__hexnan+0x3c>
   11d40:	movs	r3, #0
   11d42:	sub.w	r8, r0, #4
   11d46:	str.w	r3, [r0, #-4]
   11d4a:	mov	sl, lr
   11d4c:	mov	r0, r8
   11d4e:	mov	r1, r3
   11d50:	b.n	11c84 <__hexnan+0x3c>
   11d52:	cmp	r3, #41	; 0x29
   11d54:	beq.n	11d8e <__hexnan+0x146>
   11d56:	movs	r0, #4
   11d58:	add	sp, #20
   11d5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11d5e:	ldr	r3, [sp, #12]
   11d60:	cmp	r3, #0
   11d62:	beq.n	11cfe <__hexnan+0xb6>
   11d64:	ldr	r4, [sp, #4]
   11d66:	ldr	r3, [sp, #12]
   11d68:	ldr.w	r1, [r4, #-4]
   11d6c:	rsb	r3, r3, #32
   11d70:	mov.w	r0, #4294967295
   11d74:	lsr.w	r3, r0, r3
   11d78:	ands	r3, r1
   11d7a:	str.w	r3, [r4, #-4]
   11d7e:	b.n	11d04 <__hexnan+0xbc>
   11d80:	movs	r3, #1
   11d82:	movs	r0, #5
   11d84:	str.w	r3, [ip]
   11d88:	add	sp, #20
   11d8a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11d8e:	ldr	r3, [sp, #8]
   11d90:	adds	r5, #1
   11d92:	str	r5, [r3, #0]
   11d94:	cmp.w	lr, #0
   11d98:	bne.n	11cda <__hexnan+0x92>
   11d9a:	b.n	11d56 <__hexnan+0x10e>
   11d9c:	rsb	r3, r1, #8
   11da0:	lsls	r3, r3, #2
   11da2:	ldr	r5, [r0, #0]
   11da4:	rsb	r7, r3, #32
   11da8:	mov	r1, r0
   11daa:	ldr	r6, [r1, #4]
   11dac:	lsl.w	r4, r6, r7
   11db0:	orrs	r4, r5
   11db2:	lsr.w	r5, r6, r3
   11db6:	str	r4, [r1, #0]
   11db8:	str.w	r5, [r1, #4]!
   11dbc:	cmp	r8, r1
   11dbe:	bhi.n	11daa <__hexnan+0x162>
   11dc0:	b.n	11ce2 <__hexnan+0x9a>
   11dc2:	nop
   11dc4:	.word	0x00013d04

00011dc8 <iswspace>:
   11dc8:	cmp	r0, #255	; 0xff
   11dca:	bls.n	11dd0 <iswspace+0x8>
   11dcc:	movs	r0, #0
   11dce:	bx	lr
   11dd0:	push	{r4, lr}
   11dd2:	mov	r4, r0
   11dd4:	bl	bcfc <__locale_ctype_ptr>
   11dd8:	add	r0, r4
   11dda:	ldrb	r0, [r0, #1]
   11ddc:	and.w	r0, r0, #8
   11de0:	uxtb	r0, r0
   11de2:	pop	{r4, pc}

00011de4 <__localeconv_l>:
   11de4:	adds	r0, #240	; 0xf0
   11de6:	bx	lr

00011de8 <_localeconv_r>:
   11de8:	ldr	r2, [pc, #16]	; (11dfc <_localeconv_r+0x14>)
   11dea:	ldr	r3, [pc, #20]	; (11e00 <_localeconv_r+0x18>)
   11dec:	ldr	r2, [r2, #0]
   11dee:	ldr	r0, [r2, #52]	; 0x34
   11df0:	cmp	r0, #0
   11df2:	it	eq
   11df4:	moveq	r0, r3
   11df6:	adds	r0, #240	; 0xf0
   11df8:	bx	lr
   11dfa:	nop
   11dfc:	.word	0x20013dc8
   11e00:	.word	0x20013dcc

00011e04 <_mbrtowc_r>:
   11e04:	push	{r4, r5, r6, r7, lr}
   11e06:	sub	sp, #12
   11e08:	mov	r7, r0
   11e0a:	ldr	r5, [sp, #32]
   11e0c:	cbz	r2, 11e34 <_mbrtowc_r+0x30>
   11e0e:	ldr	r4, [pc, #68]	; (11e54 <_mbrtowc_r+0x50>)
   11e10:	ldr	r6, [pc, #68]	; (11e58 <_mbrtowc_r+0x54>)
   11e12:	ldr	r4, [r4, #0]
   11e14:	ldr	r4, [r4, #52]	; 0x34
   11e16:	str	r5, [sp, #0]
   11e18:	cmp	r4, #0
   11e1a:	it	eq
   11e1c:	moveq	r4, r6
   11e1e:	ldr.w	r4, [r4, #228]	; 0xe4
   11e22:	blx	r4
   11e24:	adds	r3, r0, #1
   11e26:	bne.n	11e30 <_mbrtowc_r+0x2c>
   11e28:	movs	r2, #0
   11e2a:	movs	r3, #138	; 0x8a
   11e2c:	str	r2, [r5, #0]
   11e2e:	str	r3, [r7, #0]
   11e30:	add	sp, #12
   11e32:	pop	{r4, r5, r6, r7, pc}
   11e34:	ldr	r3, [pc, #28]	; (11e54 <_mbrtowc_r+0x50>)
   11e36:	ldr	r1, [pc, #32]	; (11e58 <_mbrtowc_r+0x54>)
   11e38:	ldr	r3, [r3, #0]
   11e3a:	ldr	r3, [r3, #52]	; 0x34
   11e3c:	str	r5, [sp, #0]
   11e3e:	cmp	r3, #0
   11e40:	it	eq
   11e42:	moveq	r3, r1
   11e44:	mov	r4, r2
   11e46:	mov	r1, r4
   11e48:	ldr	r2, [pc, #16]	; (11e5c <_mbrtowc_r+0x58>)
   11e4a:	ldr.w	r4, [r3, #228]	; 0xe4
   11e4e:	movs	r3, #1
   11e50:	blx	r4
   11e52:	b.n	11e24 <_mbrtowc_r+0x20>
   11e54:	.word	0x20013dc8
   11e58:	.word	0x20013dcc
   11e5c:	.word	0x000131e4

00011e60 <_Balloc>:
   11e60:	ldr	r3, [r0, #76]	; 0x4c
   11e62:	push	{r4, r5, r6, lr}
   11e64:	mov	r5, r0
   11e66:	mov	r4, r1
   11e68:	cbz	r3, 11e7e <_Balloc+0x1e>
   11e6a:	ldr.w	r0, [r3, r4, lsl #2]
   11e6e:	cbz	r0, 11e92 <_Balloc+0x32>
   11e70:	ldr	r2, [r0, #0]
   11e72:	str.w	r2, [r3, r4, lsl #2]
   11e76:	movs	r3, #0
   11e78:	str	r3, [r0, #16]
   11e7a:	str	r3, [r0, #12]
   11e7c:	pop	{r4, r5, r6, pc}
   11e7e:	movs	r2, #33	; 0x21
   11e80:	movs	r1, #4
   11e82:	bl	13044 <_calloc_r>
   11e86:	str	r0, [r5, #76]	; 0x4c
   11e88:	mov	r3, r0
   11e8a:	cmp	r0, #0
   11e8c:	bne.n	11e6a <_Balloc+0xa>
   11e8e:	movs	r0, #0
   11e90:	pop	{r4, r5, r6, pc}
   11e92:	movs	r1, #1
   11e94:	lsl.w	r6, r1, r4
   11e98:	adds	r2, r6, #5
   11e9a:	mov	r0, r5
   11e9c:	lsls	r2, r2, #2
   11e9e:	bl	13044 <_calloc_r>
   11ea2:	cmp	r0, #0
   11ea4:	beq.n	11e8e <_Balloc+0x2e>
   11ea6:	str	r4, [r0, #4]
   11ea8:	str	r6, [r0, #8]
   11eaa:	b.n	11e76 <_Balloc+0x16>

00011eac <_Bfree>:
   11eac:	cbz	r1, 11ebc <_Bfree+0x10>
   11eae:	ldr	r3, [r0, #76]	; 0x4c
   11eb0:	ldr	r2, [r1, #4]
   11eb2:	ldr.w	r0, [r3, r2, lsl #2]
   11eb6:	str	r0, [r1, #0]
   11eb8:	str.w	r1, [r3, r2, lsl #2]
   11ebc:	bx	lr
   11ebe:	nop

00011ec0 <__multadd>:
   11ec0:	push	{r4, r5, r6, r7, lr}
   11ec2:	ldr	r4, [r1, #16]
   11ec4:	sub	sp, #12
   11ec6:	mov	r5, r1
   11ec8:	mov	r6, r0
   11eca:	add.w	lr, r1, #20
   11ece:	movs	r7, #0
   11ed0:	ldr.w	r0, [lr]
   11ed4:	uxth	r1, r0
   11ed6:	mla	r1, r2, r1, r3
   11eda:	lsrs	r3, r1, #16
   11edc:	lsrs	r0, r0, #16
   11ede:	mla	r3, r2, r0, r3
   11ee2:	uxth	r1, r1
   11ee4:	adds	r7, #1
   11ee6:	add.w	r1, r1, r3, lsl #16
   11eea:	cmp	r4, r7
   11eec:	str.w	r1, [lr], #4
   11ef0:	mov.w	r3, r3, lsr #16
   11ef4:	bgt.n	11ed0 <__multadd+0x10>
   11ef6:	cbz	r3, 11f08 <__multadd+0x48>
   11ef8:	ldr	r2, [r5, #8]
   11efa:	cmp	r4, r2
   11efc:	bge.n	11f0e <__multadd+0x4e>
   11efe:	add.w	r2, r5, r4, lsl #2
   11f02:	adds	r4, #1
   11f04:	str	r3, [r2, #20]
   11f06:	str	r4, [r5, #16]
   11f08:	mov	r0, r5
   11f0a:	add	sp, #12
   11f0c:	pop	{r4, r5, r6, r7, pc}
   11f0e:	ldr	r1, [r5, #4]
   11f10:	str	r3, [sp, #4]
   11f12:	adds	r1, #1
   11f14:	mov	r0, r6
   11f16:	bl	11e60 <_Balloc>
   11f1a:	ldr	r2, [r5, #16]
   11f1c:	adds	r2, #2
   11f1e:	add.w	r1, r5, #12
   11f22:	mov	r7, r0
   11f24:	lsls	r2, r2, #2
   11f26:	adds	r0, #12
   11f28:	bl	9220 <memcpy>
   11f2c:	ldr	r2, [r6, #76]	; 0x4c
   11f2e:	ldr	r1, [r5, #4]
   11f30:	ldr	r3, [sp, #4]
   11f32:	ldr.w	r0, [r2, r1, lsl #2]
   11f36:	str	r0, [r5, #0]
   11f38:	str.w	r5, [r2, r1, lsl #2]
   11f3c:	mov	r5, r7
   11f3e:	b.n	11efe <__multadd+0x3e>

00011f40 <__s2b>:
   11f40:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11f44:	ldr	r4, [pc, #140]	; (11fd4 <__s2b+0x94>)
   11f46:	ldr	r5, [sp, #32]
   11f48:	mov	r7, r3
   11f4a:	adds	r3, #8
   11f4c:	smull	r4, lr, r4, r3
   11f50:	asrs	r3, r3, #31
   11f52:	rsb	lr, r3, lr, asr #1
   11f56:	cmp.w	lr, #1
   11f5a:	mov	r6, r0
   11f5c:	mov	r4, r1
   11f5e:	mov	r8, r2
   11f60:	ble.n	11fce <__s2b+0x8e>
   11f62:	movs	r3, #1
   11f64:	movs	r1, #0
   11f66:	lsls	r3, r3, #1
   11f68:	cmp	lr, r3
   11f6a:	add.w	r1, r1, #1
   11f6e:	bgt.n	11f66 <__s2b+0x26>
   11f70:	mov	r0, r6
   11f72:	bl	11e60 <_Balloc>
   11f76:	movs	r3, #1
   11f78:	cmp.w	r8, #9
   11f7c:	str	r5, [r0, #20]
   11f7e:	str	r3, [r0, #16]
   11f80:	ble.n	11fc6 <__s2b+0x86>
   11f82:	add.w	r9, r4, #9
   11f86:	mov	r5, r9
   11f88:	add	r4, r8
   11f8a:	ldrb.w	r3, [r5], #1
   11f8e:	mov	r1, r0
   11f90:	subs	r3, #48	; 0x30
   11f92:	movs	r2, #10
   11f94:	mov	r0, r6
   11f96:	bl	11ec0 <__multadd>
   11f9a:	cmp	r5, r4
   11f9c:	bne.n	11f8a <__s2b+0x4a>
   11f9e:	add.w	r4, r9, r8
   11fa2:	subs	r4, #8
   11fa4:	cmp	r7, r8
   11fa6:	ble.n	11fc2 <__s2b+0x82>
   11fa8:	rsb	r7, r8, r7
   11fac:	add	r7, r4
   11fae:	ldrb.w	r3, [r4], #1
   11fb2:	mov	r1, r0
   11fb4:	subs	r3, #48	; 0x30
   11fb6:	movs	r2, #10
   11fb8:	mov	r0, r6
   11fba:	bl	11ec0 <__multadd>
   11fbe:	cmp	r7, r4
   11fc0:	bne.n	11fae <__s2b+0x6e>
   11fc2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11fc6:	adds	r4, #10
   11fc8:	mov.w	r8, #9
   11fcc:	b.n	11fa4 <__s2b+0x64>
   11fce:	movs	r1, #0
   11fd0:	b.n	11f70 <__s2b+0x30>
   11fd2:	nop
   11fd4:	.word	0x38e38e39

00011fd8 <__hi0bits>:
   11fd8:	lsrs	r3, r0, #16
   11fda:	lsls	r3, r3, #16
   11fdc:	cbnz	r3, 1200c <__hi0bits+0x34>
   11fde:	lsls	r0, r0, #16
   11fe0:	movs	r3, #16
   11fe2:	tst.w	r0, #4278190080	; 0xff000000
   11fe6:	itt	eq
   11fe8:	lsleq	r0, r0, #8
   11fea:	addeq	r3, #8
   11fec:	tst.w	r0, #4026531840	; 0xf0000000
   11ff0:	itt	eq
   11ff2:	lsleq	r0, r0, #4
   11ff4:	addeq	r3, #4
   11ff6:	tst.w	r0, #3221225472	; 0xc0000000
   11ffa:	itt	eq
   11ffc:	lsleq	r0, r0, #2
   11ffe:	addeq	r3, #2
   12000:	cmp	r0, #0
   12002:	blt.n	12014 <__hi0bits+0x3c>
   12004:	lsls	r2, r0, #1
   12006:	bmi.n	12010 <__hi0bits+0x38>
   12008:	movs	r0, #32
   1200a:	bx	lr
   1200c:	movs	r3, #0
   1200e:	b.n	11fe2 <__hi0bits+0xa>
   12010:	adds	r0, r3, #1
   12012:	bx	lr
   12014:	mov	r0, r3
   12016:	bx	lr

00012018 <__lo0bits>:
   12018:	ldr	r3, [r0, #0]
   1201a:	ands.w	r2, r3, #7
   1201e:	beq.n	12030 <__lo0bits+0x18>
   12020:	lsls	r1, r3, #31
   12022:	bmi.n	12066 <__lo0bits+0x4e>
   12024:	lsls	r2, r3, #30
   12026:	bmi.n	1206a <__lo0bits+0x52>
   12028:	lsrs	r3, r3, #2
   1202a:	str	r3, [r0, #0]
   1202c:	movs	r0, #2
   1202e:	bx	lr
   12030:	uxth	r1, r3
   12032:	cbnz	r1, 12038 <__lo0bits+0x20>
   12034:	lsrs	r3, r3, #16
   12036:	movs	r2, #16
   12038:	tst.w	r3, #255	; 0xff
   1203c:	itt	eq
   1203e:	lsreq	r3, r3, #8
   12040:	addeq	r2, #8
   12042:	lsls	r1, r3, #28
   12044:	itt	eq
   12046:	lsreq	r3, r3, #4
   12048:	addeq	r2, #4
   1204a:	lsls	r1, r3, #30
   1204c:	itt	eq
   1204e:	lsreq	r3, r3, #2
   12050:	addeq	r2, #2
   12052:	lsls	r1, r3, #31
   12054:	bmi.n	12060 <__lo0bits+0x48>
   12056:	lsrs	r3, r3, #1
   12058:	bne.n	1205e <__lo0bits+0x46>
   1205a:	movs	r0, #32
   1205c:	bx	lr
   1205e:	adds	r2, #1
   12060:	str	r3, [r0, #0]
   12062:	mov	r0, r2
   12064:	bx	lr
   12066:	movs	r0, #0
   12068:	bx	lr
   1206a:	lsrs	r3, r3, #1
   1206c:	str	r3, [r0, #0]
   1206e:	movs	r0, #1
   12070:	bx	lr
   12072:	nop

00012074 <__i2b>:
   12074:	push	{r4, lr}
   12076:	mov	r4, r1
   12078:	movs	r1, #1
   1207a:	bl	11e60 <_Balloc>
   1207e:	movs	r2, #1
   12080:	str	r4, [r0, #20]
   12082:	str	r2, [r0, #16]
   12084:	pop	{r4, pc}
   12086:	nop

00012088 <__multiply>:
   12088:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1208c:	ldr	r5, [r1, #16]
   1208e:	ldr	r7, [r2, #16]
   12090:	cmp	r5, r7
   12092:	sub	sp, #12
   12094:	mov	r4, r1
   12096:	mov	r6, r2
   12098:	bge.n	120a4 <__multiply+0x1c>
   1209a:	mov	r2, r5
   1209c:	mov	r4, r6
   1209e:	mov	r5, r7
   120a0:	mov	r6, r1
   120a2:	mov	r7, r2
   120a4:	ldr	r3, [r4, #8]
   120a6:	ldr	r1, [r4, #4]
   120a8:	add.w	r8, r5, r7
   120ac:	cmp	r8, r3
   120ae:	it	gt
   120b0:	addgt	r1, #1
   120b2:	bl	11e60 <_Balloc>
   120b6:	add.w	ip, r0, #20
   120ba:	add.w	r9, ip, r8, lsl #2
   120be:	cmp	ip, r9
   120c0:	str	r0, [sp, #0]
   120c2:	bcs.n	120d0 <__multiply+0x48>
   120c4:	mov	r3, ip
   120c6:	movs	r1, #0
   120c8:	str.w	r1, [r3], #4
   120cc:	cmp	r9, r3
   120ce:	bhi.n	120c8 <__multiply+0x40>
   120d0:	add.w	r2, r6, #20
   120d4:	add.w	sl, r2, r7, lsl #2
   120d8:	add.w	r3, r4, #20
   120dc:	cmp	r2, sl
   120de:	add.w	lr, r3, r5, lsl #2
   120e2:	bcs.n	1218e <__multiply+0x106>
   120e4:	str.w	r9, [sp, #4]
   120e8:	mov	r9, r3
   120ea:	ldr.w	r3, [r2], #4
   120ee:	uxth.w	fp, r3
   120f2:	cmp.w	fp, #0
   120f6:	beq.n	1213a <__multiply+0xb2>
   120f8:	movs	r0, #0
   120fa:	mov	r7, r9
   120fc:	mov	r6, ip
   120fe:	mov	r5, r0
   12100:	b.n	12104 <__multiply+0x7c>
   12102:	mov	r6, r3
   12104:	ldr.w	r4, [r7], #4
   12108:	ldr	r0, [r6, #0]
   1210a:	uxth	r1, r4
   1210c:	uxth	r3, r0
   1210e:	mla	r1, fp, r1, r3
   12112:	lsrs	r4, r4, #16
   12114:	lsrs	r0, r0, #16
   12116:	adds	r3, r1, r5
   12118:	mla	r0, fp, r4, r0
   1211c:	add.w	r0, r0, r3, lsr #16
   12120:	uxth	r1, r3
   12122:	mov	r3, r6
   12124:	orr.w	r1, r1, r0, lsl #16
   12128:	cmp	lr, r7
   1212a:	mov.w	r5, r0, lsr #16
   1212e:	str.w	r1, [r3], #4
   12132:	bhi.n	12102 <__multiply+0x7a>
   12134:	str	r5, [r6, #4]
   12136:	ldr.w	r3, [r2, #-4]
   1213a:	movs.w	fp, r3, lsr #16
   1213e:	beq.n	12182 <__multiply+0xfa>
   12140:	ldr.w	r3, [ip]
   12144:	mov	r7, ip
   12146:	mov	r0, r3
   12148:	mov	r5, r9
   1214a:	movs	r1, #0
   1214c:	b.n	12150 <__multiply+0xc8>
   1214e:	mov	r7, r6
   12150:	ldrh	r4, [r5, #0]
   12152:	lsrs	r0, r0, #16
   12154:	mla	r0, fp, r4, r0
   12158:	add	r1, r0
   1215a:	uxth	r4, r3
   1215c:	mov	r6, r7
   1215e:	orr.w	r3, r4, r1, lsl #16
   12162:	str.w	r3, [r6], #4
   12166:	ldr	r0, [r7, #4]
   12168:	ldr.w	r4, [r5], #4
   1216c:	uxth	r3, r0
   1216e:	lsrs	r4, r4, #16
   12170:	mla	r4, fp, r4, r3
   12174:	add.w	r3, r4, r1, lsr #16
   12178:	cmp	lr, r5
   1217a:	mov.w	r1, r3, lsr #16
   1217e:	bhi.n	1214e <__multiply+0xc6>
   12180:	str	r3, [r7, #4]
   12182:	cmp	sl, r2
   12184:	add.w	ip, ip, #4
   12188:	bhi.n	120ea <__multiply+0x62>
   1218a:	ldr.w	r9, [sp, #4]
   1218e:	cmp.w	r8, #0
   12192:	ble.n	121ac <__multiply+0x124>
   12194:	ldr.w	r3, [r9, #-4]
   12198:	sub.w	r9, r9, #4
   1219c:	cbz	r3, 121a6 <__multiply+0x11e>
   1219e:	b.n	121ac <__multiply+0x124>
   121a0:	ldr.w	r3, [r9, #-4]!
   121a4:	cbnz	r3, 121ac <__multiply+0x124>
   121a6:	subs.w	r8, r8, #1
   121aa:	bne.n	121a0 <__multiply+0x118>
   121ac:	ldr	r0, [sp, #0]
   121ae:	str.w	r8, [r0, #16]
   121b2:	add	sp, #12
   121b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000121b8 <__pow5mult>:
   121b8:	ands.w	r3, r2, #3
   121bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   121c0:	mov	r4, r2
   121c2:	mov	r7, r0
   121c4:	bne.n	12224 <__pow5mult+0x6c>
   121c6:	mov	r6, r1
   121c8:	asrs	r4, r4, #2
   121ca:	beq.n	12206 <__pow5mult+0x4e>
   121cc:	ldr	r5, [r7, #72]	; 0x48
   121ce:	cbz	r5, 12236 <__pow5mult+0x7e>
   121d0:	lsls	r3, r4, #31
   121d2:	mov.w	r8, #0
   121d6:	bmi.n	121e6 <__pow5mult+0x2e>
   121d8:	asrs	r4, r4, #1
   121da:	beq.n	12206 <__pow5mult+0x4e>
   121dc:	ldr	r0, [r5, #0]
   121de:	cbz	r0, 1220c <__pow5mult+0x54>
   121e0:	mov	r5, r0
   121e2:	lsls	r3, r4, #31
   121e4:	bpl.n	121d8 <__pow5mult+0x20>
   121e6:	mov	r2, r5
   121e8:	mov	r1, r6
   121ea:	mov	r0, r7
   121ec:	bl	12088 <__multiply>
   121f0:	cbz	r6, 12220 <__pow5mult+0x68>
   121f2:	ldr	r2, [r6, #4]
   121f4:	ldr	r3, [r7, #76]	; 0x4c
   121f6:	asrs	r4, r4, #1
   121f8:	ldr.w	r1, [r3, r2, lsl #2]
   121fc:	str	r1, [r6, #0]
   121fe:	str.w	r6, [r3, r2, lsl #2]
   12202:	mov	r6, r0
   12204:	bne.n	121dc <__pow5mult+0x24>
   12206:	mov	r0, r6
   12208:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1220c:	mov	r2, r5
   1220e:	mov	r1, r5
   12210:	mov	r0, r7
   12212:	bl	12088 <__multiply>
   12216:	str	r0, [r5, #0]
   12218:	str.w	r8, [r0]
   1221c:	mov	r5, r0
   1221e:	b.n	121e2 <__pow5mult+0x2a>
   12220:	mov	r6, r0
   12222:	b.n	121d8 <__pow5mult+0x20>
   12224:	subs	r2, r3, #1
   12226:	ldr	r5, [pc, #44]	; (12254 <__pow5mult+0x9c>)
   12228:	movs	r3, #0
   1222a:	ldr.w	r2, [r5, r2, lsl #2]
   1222e:	bl	11ec0 <__multadd>
   12232:	mov	r6, r0
   12234:	b.n	121c8 <__pow5mult+0x10>
   12236:	movs	r1, #1
   12238:	mov	r0, r7
   1223a:	bl	11e60 <_Balloc>
   1223e:	movw	r1, #625	; 0x271
   12242:	movs	r2, #1
   12244:	movs	r3, #0
   12246:	str	r1, [r0, #20]
   12248:	str	r2, [r0, #16]
   1224a:	mov	r5, r0
   1224c:	str	r0, [r7, #72]	; 0x48
   1224e:	str	r3, [r0, #0]
   12250:	b.n	121d0 <__pow5mult+0x18>
   12252:	nop
   12254:	.word	0x00013ef8

00012258 <__lshift>:
   12258:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1225c:	mov	r9, r2
   1225e:	ldr	r2, [r1, #16]
   12260:	ldr	r3, [r1, #8]
   12262:	mov.w	r4, r9, asr #5
   12266:	add.w	r8, r4, r2
   1226a:	add.w	r5, r8, #1
   1226e:	cmp	r5, r3
   12270:	mov	r6, r1
   12272:	mov	sl, r0
   12274:	ldr	r1, [r1, #4]
   12276:	ble.n	12282 <__lshift+0x2a>
   12278:	lsls	r3, r3, #1
   1227a:	cmp	r5, r3
   1227c:	add.w	r1, r1, #1
   12280:	bgt.n	12278 <__lshift+0x20>
   12282:	mov	r0, sl
   12284:	bl	11e60 <_Balloc>
   12288:	cmp	r4, #0
   1228a:	add.w	r2, r0, #20
   1228e:	ble.n	12302 <__lshift+0xaa>
   12290:	add.w	r3, r2, r4, lsl #2
   12294:	movs	r1, #0
   12296:	str.w	r1, [r2], #4
   1229a:	cmp	r3, r2
   1229c:	bne.n	12296 <__lshift+0x3e>
   1229e:	ldr	r4, [r6, #16]
   122a0:	add.w	r1, r6, #20
   122a4:	ands.w	r9, r9, #31
   122a8:	add.w	lr, r1, r4, lsl #2
   122ac:	beq.n	122f2 <__lshift+0x9a>
   122ae:	rsb	r2, r9, #32
   122b2:	movs	r4, #0
   122b4:	ldr	r7, [r1, #0]
   122b6:	lsl.w	ip, r7, r9
   122ba:	orr.w	r4, ip, r4
   122be:	mov	ip, r3
   122c0:	str.w	r4, [r3], #4
   122c4:	ldr.w	r4, [r1], #4
   122c8:	cmp	lr, r1
   122ca:	lsr.w	r4, r4, r2
   122ce:	bhi.n	122b4 <__lshift+0x5c>
   122d0:	str.w	r4, [ip, #4]
   122d4:	cbz	r4, 122da <__lshift+0x82>
   122d6:	add.w	r5, r8, #2
   122da:	ldr.w	r3, [sl, #76]	; 0x4c
   122de:	ldr	r2, [r6, #4]
   122e0:	subs	r5, #1
   122e2:	ldr.w	r1, [r3, r2, lsl #2]
   122e6:	str	r5, [r0, #16]
   122e8:	str	r1, [r6, #0]
   122ea:	str.w	r6, [r3, r2, lsl #2]
   122ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   122f2:	subs	r3, #4
   122f4:	ldr.w	r2, [r1], #4
   122f8:	str.w	r2, [r3, #4]!
   122fc:	cmp	lr, r1
   122fe:	bhi.n	122f4 <__lshift+0x9c>
   12300:	b.n	122da <__lshift+0x82>
   12302:	mov	r3, r2
   12304:	b.n	1229e <__lshift+0x46>
   12306:	nop

00012308 <__mcmp>:
   12308:	ldr	r2, [r0, #16]
   1230a:	ldr	r3, [r1, #16]
   1230c:	subs	r2, r2, r3
   1230e:	bne.n	12338 <__mcmp+0x30>
   12310:	lsls	r3, r3, #2
   12312:	adds	r0, #20
   12314:	adds	r1, #20
   12316:	add	r1, r3
   12318:	push	{r4}
   1231a:	add	r3, r0
   1231c:	b.n	12322 <__mcmp+0x1a>
   1231e:	cmp	r0, r3
   12320:	bcs.n	1233c <__mcmp+0x34>
   12322:	ldr.w	r4, [r3, #-4]!
   12326:	ldr.w	r2, [r1, #-4]!
   1232a:	cmp	r4, r2
   1232c:	beq.n	1231e <__mcmp+0x16>
   1232e:	bcc.n	12344 <__mcmp+0x3c>
   12330:	movs	r0, #1
   12332:	ldr.w	r4, [sp], #4
   12336:	bx	lr
   12338:	mov	r0, r2
   1233a:	bx	lr
   1233c:	movs	r0, #0
   1233e:	ldr.w	r4, [sp], #4
   12342:	bx	lr
   12344:	mov.w	r0, #4294967295
   12348:	b.n	12332 <__mcmp+0x2a>
   1234a:	nop

0001234c <__mdiff>:
   1234c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12350:	ldr	r3, [r1, #16]
   12352:	mov	r7, r1
   12354:	ldr	r1, [r2, #16]
   12356:	subs	r3, r3, r1
   12358:	cmp	r3, #0
   1235a:	mov	r8, r2
   1235c:	bne.n	1238e <__mdiff+0x42>
   1235e:	lsls	r1, r1, #2
   12360:	add.w	r2, r7, #20
   12364:	add.w	r5, r8, #20
   12368:	adds	r3, r2, r1
   1236a:	add	r1, r5
   1236c:	b.n	12372 <__mdiff+0x26>
   1236e:	cmp	r2, r3
   12370:	bcs.n	12430 <__mdiff+0xe4>
   12372:	ldr.w	r6, [r3, #-4]!
   12376:	ldr.w	r4, [r1, #-4]!
   1237a:	cmp	r6, r4
   1237c:	beq.n	1236e <__mdiff+0x22>
   1237e:	bcs.n	12442 <__mdiff+0xf6>
   12380:	mov	r3, r7
   12382:	mov	r4, r2
   12384:	mov	r7, r8
   12386:	mov.w	r9, #1
   1238a:	mov	r8, r3
   1238c:	b.n	1239c <__mdiff+0x50>
   1238e:	blt.n	1244c <__mdiff+0x100>
   12390:	add.w	r5, r7, #20
   12394:	add.w	r4, r2, #20
   12398:	mov.w	r9, #0
   1239c:	ldr	r1, [r7, #4]
   1239e:	bl	11e60 <_Balloc>
   123a2:	ldr.w	r3, [r8, #16]
   123a6:	ldr	r6, [r7, #16]
   123a8:	str.w	r9, [r0, #12]
   123ac:	add.w	ip, r4, r3, lsl #2
   123b0:	mov	lr, r4
   123b2:	add.w	r7, r5, r6, lsl #2
   123b6:	add.w	r4, r0, #20
   123ba:	movs	r3, #0
   123bc:	ldr.w	r1, [lr], #4
   123c0:	ldr.w	r8, [r5], #4
   123c4:	uxth	r2, r1
   123c6:	uxtah	r3, r3, r8
   123ca:	lsrs	r1, r1, #16
   123cc:	subs	r2, r3, r2
   123ce:	rsb	r3, r1, r8, lsr #16
   123d2:	add.w	r3, r3, r2, asr #16
   123d6:	uxth	r2, r2
   123d8:	orr.w	r2, r2, r3, lsl #16
   123dc:	cmp	ip, lr
   123de:	str.w	r2, [r4], #4
   123e2:	mov.w	r3, r3, asr #16
   123e6:	bhi.n	123bc <__mdiff+0x70>
   123e8:	cmp	r7, r5
   123ea:	bls.n	1241c <__mdiff+0xd0>
   123ec:	mov	ip, r4
   123ee:	mov	r1, r5
   123f0:	ldr.w	lr, [r1], #4
   123f4:	uxtah	r2, r3, lr
   123f8:	asrs	r3, r2, #16
   123fa:	add.w	r3, r3, lr, lsr #16
   123fe:	uxth	r2, r2
   12400:	orr.w	r2, r2, r3, lsl #16
   12404:	cmp	r7, r1
   12406:	str.w	r2, [ip], #4
   1240a:	mov.w	r3, r3, asr #16
   1240e:	bhi.n	123f0 <__mdiff+0xa4>
   12410:	mvns	r5, r5
   12412:	add	r5, r7
   12414:	bic.w	r5, r5, #3
   12418:	adds	r5, #4
   1241a:	add	r4, r5
   1241c:	subs	r4, #4
   1241e:	cbnz	r2, 1242a <__mdiff+0xde>
   12420:	ldr.w	r3, [r4, #-4]!
   12424:	subs	r6, #1
   12426:	cmp	r3, #0
   12428:	beq.n	12420 <__mdiff+0xd4>
   1242a:	str	r6, [r0, #16]
   1242c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   12430:	movs	r1, #0
   12432:	bl	11e60 <_Balloc>
   12436:	movs	r2, #1
   12438:	movs	r3, #0
   1243a:	str	r2, [r0, #16]
   1243c:	str	r3, [r0, #20]
   1243e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   12442:	mov	r4, r5
   12444:	mov.w	r9, #0
   12448:	mov	r5, r2
   1244a:	b.n	1239c <__mdiff+0x50>
   1244c:	mov	r3, r7
   1244e:	add.w	r4, r7, #20
   12452:	add.w	r5, r8, #20
   12456:	mov	r7, r8
   12458:	mov.w	r9, #1
   1245c:	mov	r8, r3
   1245e:	b.n	1239c <__mdiff+0x50>

00012460 <__ulp>:
   12460:	ldr	r3, [pc, #76]	; (124b0 <__ulp+0x50>)
   12462:	vmov	r2, s1
   12466:	ands	r2, r3
   12468:	sub.w	r3, r2, #54525952	; 0x3400000
   1246c:	cmp	r3, #0
   1246e:	ble.n	1247a <__ulp+0x1a>
   12470:	movs	r0, #0
   12472:	mov	r1, r3
   12474:	vmov	d0, r0, r1
   12478:	bx	lr
   1247a:	negs	r3, r3
   1247c:	asrs	r3, r3, #20
   1247e:	cmp	r3, #19
   12480:	ble.n	1249e <__ulp+0x3e>
   12482:	subs	r3, #20
   12484:	cmp	r3, #30
   12486:	ittte	le
   12488:	rsble	r3, r3, #31
   1248c:	movle	r2, #1
   1248e:	lslle.w	r3, r2, r3
   12492:	movgt	r3, #1
   12494:	movs	r1, #0
   12496:	mov	r0, r3
   12498:	vmov	d0, r0, r1
   1249c:	bx	lr
   1249e:	mov.w	r2, #524288	; 0x80000
   124a2:	movs	r0, #0
   124a4:	asr.w	r1, r2, r3
   124a8:	vmov	d0, r0, r1
   124ac:	bx	lr
   124ae:	nop
   124b0:	.word	0x7ff00000

000124b4 <__b2d>:
   124b4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   124b8:	ldr	r6, [r0, #16]
   124ba:	add.w	r8, r0, #20
   124be:	add.w	r6, r8, r6, lsl #2
   124c2:	ldr.w	r7, [r6, #-4]
   124c6:	mov	r0, r7
   124c8:	bl	11fd8 <__hi0bits>
   124cc:	rsb	r3, r0, #32
   124d0:	cmp	r0, #10
   124d2:	str	r3, [r1, #0]
   124d4:	sub.w	r3, r6, #4
   124d8:	bgt.n	1250c <__b2d+0x58>
   124da:	cmp	r8, r3
   124dc:	rsb	r2, r0, #11
   124e0:	it	cc
   124e2:	ldrcc.w	r3, [r6, #-8]
   124e6:	lsr.w	r1, r7, r2
   124ea:	add.w	r0, r0, #21
   124ee:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   124f2:	ite	cc
   124f4:	lsrcc	r3, r2
   124f6:	movcs	r3, #0
   124f8:	lsl.w	r0, r7, r0
   124fc:	orr.w	r5, r5, #3145728	; 0x300000
   12500:	orr.w	r4, r0, r3
   12504:	vmov	d0, r4, r5
   12508:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1250c:	cmp	r8, r3
   1250e:	bcs.n	12552 <__b2d+0x9e>
   12510:	subs.w	r3, r0, #11
   12514:	ldr.w	r2, [r6, #-8]
   12518:	beq.n	12558 <__b2d+0xa4>
   1251a:	lsl.w	r0, r7, r3
   1251e:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   12522:	rsb	lr, r3, #32
   12526:	sub.w	r1, r6, #8
   1252a:	orr.w	r7, r7, #3145728	; 0x300000
   1252e:	lsr.w	r0, r2, lr
   12532:	cmp	r8, r1
   12534:	orr.w	r5, r7, r0
   12538:	bcs.n	1257c <__b2d+0xc8>
   1253a:	ldr.w	r1, [r6, #-12]
   1253e:	lsl.w	r0, r2, r3
   12542:	lsr.w	r3, r1, lr
   12546:	orrs	r0, r3
   12548:	mov	r4, r0
   1254a:	vmov	d0, r4, r5
   1254e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12552:	subs	r0, #11
   12554:	bne.n	1256a <__b2d+0xb6>
   12556:	mov	r2, r0
   12558:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   1255c:	orr.w	r5, r5, #3145728	; 0x300000
   12560:	mov	r4, r2
   12562:	vmov	d0, r4, r5
   12566:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1256a:	lsl.w	r0, r7, r0
   1256e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   12572:	movs	r0, #0
   12574:	orr.w	r5, r5, #3145728	; 0x300000
   12578:	mov	r4, r0
   1257a:	b.n	1254a <__b2d+0x96>
   1257c:	lsl.w	r0, r2, r3
   12580:	mov	r4, r0
   12582:	b.n	1254a <__b2d+0x96>

00012584 <__d2b>:
   12584:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12588:	vmov	r6, r7, d0
   1258c:	sub	sp, #12
   1258e:	mov	r8, r1
   12590:	movs	r1, #1
   12592:	mov	r4, r7
   12594:	ubfx	r5, r7, #20, #11
   12598:	mov	r7, r2
   1259a:	bl	11e60 <_Balloc>
   1259e:	ubfx	r4, r4, #0, #20
   125a2:	mov	r9, r0
   125a4:	cbz	r5, 125aa <__d2b+0x26>
   125a6:	orr.w	r4, r4, #1048576	; 0x100000
   125aa:	str	r4, [sp, #4]
   125ac:	cbz	r6, 125f6 <__d2b+0x72>
   125ae:	add	r0, sp, #8
   125b0:	str.w	r6, [r0, #-8]!
   125b4:	bl	12018 <__lo0bits>
   125b8:	cmp	r0, #0
   125ba:	bne.n	12626 <__d2b+0xa2>
   125bc:	ldmia.w	sp, {r2, r3}
   125c0:	str.w	r2, [r9, #20]
   125c4:	cmp	r3, #0
   125c6:	ite	eq
   125c8:	moveq	r1, #1
   125ca:	movne	r1, #2
   125cc:	str.w	r3, [r9, #24]
   125d0:	str.w	r1, [r9, #16]
   125d4:	cbnz	r5, 1260e <__d2b+0x8a>
   125d6:	add.w	r3, r9, r1, lsl #2
   125da:	subw	r0, r0, #1074	; 0x432
   125de:	str.w	r0, [r8]
   125e2:	ldr	r0, [r3, #16]
   125e4:	bl	11fd8 <__hi0bits>
   125e8:	rsb	r0, r0, r1, lsl #5
   125ec:	str	r0, [r7, #0]
   125ee:	mov	r0, r9
   125f0:	add	sp, #12
   125f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   125f6:	add	r0, sp, #4
   125f8:	bl	12018 <__lo0bits>
   125fc:	ldr	r3, [sp, #4]
   125fe:	str.w	r3, [r9, #20]
   12602:	movs	r1, #1
   12604:	adds	r0, #32
   12606:	str.w	r1, [r9, #16]
   1260a:	cmp	r5, #0
   1260c:	beq.n	125d6 <__d2b+0x52>
   1260e:	subw	r5, r5, #1075	; 0x433
   12612:	add	r5, r0
   12614:	rsb	r0, r0, #53	; 0x35
   12618:	str.w	r5, [r8]
   1261c:	str	r0, [r7, #0]
   1261e:	mov	r0, r9
   12620:	add	sp, #12
   12622:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   12626:	ldmia.w	sp, {r2, r3}
   1262a:	rsb	r1, r0, #32
   1262e:	lsl.w	r1, r3, r1
   12632:	orrs	r2, r1
   12634:	lsrs	r3, r0
   12636:	str	r3, [sp, #4]
   12638:	str.w	r2, [r9, #20]
   1263c:	b.n	125c4 <__d2b+0x40>
   1263e:	nop

00012640 <__ratio>:
   12640:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12644:	sub	sp, #12
   12646:	mov	r8, r1
   12648:	mov	r1, sp
   1264a:	mov	r9, r0
   1264c:	bl	124b4 <__b2d>
   12650:	mov	r0, r8
   12652:	add	r1, sp, #4
   12654:	vmov	r4, r5, d0
   12658:	bl	124b4 <__b2d>
   1265c:	ldmia.w	sp, {r1, r3}
   12660:	ldr.w	r2, [r9, #16]
   12664:	ldr.w	r0, [r8, #16]
   12668:	subs	r1, r1, r3
   1266a:	subs	r0, r2, r0
   1266c:	add.w	r3, r1, r0, lsl #5
   12670:	cmp	r3, #0
   12672:	vmov	r6, r7, d0
   12676:	ble.n	12694 <__ratio+0x54>
   12678:	add.w	r1, r5, r3, lsl #20
   1267c:	mov	r5, r1
   1267e:	mov	r2, r6
   12680:	mov	r3, r7
   12682:	mov	r0, r4
   12684:	mov	r1, r5
   12686:	bl	b504 <__aeabi_ddiv>
   1268a:	vmov	d0, r0, r1
   1268e:	add	sp, #12
   12690:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   12694:	sub.w	r9, r7, r3, lsl #20
   12698:	vmov	r6, s0
   1269c:	mov	r7, r9
   1269e:	b.n	1267e <__ratio+0x3e>

000126a0 <__copybits>:
   126a0:	push	{r4, r5, r6}
   126a2:	ldr	r4, [r2, #16]
   126a4:	add.w	r3, r2, #20
   126a8:	subs	r1, #1
   126aa:	asrs	r6, r1, #5
   126ac:	add.w	r4, r3, r4, lsl #2
   126b0:	adds	r6, #1
   126b2:	cmp	r3, r4
   126b4:	add.w	r6, r0, r6, lsl #2
   126b8:	bcs.n	126d4 <__copybits+0x34>
   126ba:	subs	r1, r0, #4
   126bc:	ldr.w	r5, [r3], #4
   126c0:	str.w	r5, [r1, #4]!
   126c4:	cmp	r4, r3
   126c6:	bhi.n	126bc <__copybits+0x1c>
   126c8:	subs	r3, r4, r2
   126ca:	subs	r3, #21
   126cc:	bic.w	r3, r3, #3
   126d0:	adds	r3, #4
   126d2:	add	r0, r3
   126d4:	cmp	r6, r0
   126d6:	bls.n	126e2 <__copybits+0x42>
   126d8:	movs	r3, #0
   126da:	str.w	r3, [r0], #4
   126de:	cmp	r6, r0
   126e0:	bhi.n	126da <__copybits+0x3a>
   126e2:	pop	{r4, r5, r6}
   126e4:	bx	lr
   126e6:	nop

000126e8 <__any_on>:
   126e8:	ldr	r3, [r0, #16]
   126ea:	asrs	r2, r1, #5
   126ec:	cmp	r3, r2
   126ee:	push	{r4}
   126f0:	add.w	r4, r0, #20
   126f4:	bge.n	12718 <__any_on+0x30>
   126f6:	add.w	r3, r4, r3, lsl #2
   126fa:	cmp	r4, r3
   126fc:	bcs.n	12742 <__any_on+0x5a>
   126fe:	ldr.w	r0, [r3, #-4]
   12702:	subs	r3, #4
   12704:	cbz	r0, 1270e <__any_on+0x26>
   12706:	b.n	12734 <__any_on+0x4c>
   12708:	ldr.w	r2, [r3, #-4]!
   1270c:	cbnz	r2, 12734 <__any_on+0x4c>
   1270e:	cmp	r4, r3
   12710:	bcc.n	12708 <__any_on+0x20>
   12712:	ldr.w	r4, [sp], #4
   12716:	bx	lr
   12718:	ble.n	1273c <__any_on+0x54>
   1271a:	ands.w	r1, r1, #31
   1271e:	beq.n	1273c <__any_on+0x54>
   12720:	ldr.w	r0, [r4, r2, lsl #2]
   12724:	lsr.w	r3, r0, r1
   12728:	lsl.w	r1, r3, r1
   1272c:	cmp	r0, r1
   1272e:	add.w	r3, r4, r2, lsl #2
   12732:	beq.n	126fa <__any_on+0x12>
   12734:	movs	r0, #1
   12736:	ldr.w	r4, [sp], #4
   1273a:	bx	lr
   1273c:	add.w	r3, r4, r2, lsl #2
   12740:	b.n	126fa <__any_on+0x12>
   12742:	movs	r0, #0
   12744:	b.n	12712 <__any_on+0x2a>
   12746:	nop

00012748 <__sccl>:
   12748:	push	{r4, r5, r6}
   1274a:	ldrb	r5, [r1, #0]
   1274c:	cmp	r5, #94	; 0x5e
   1274e:	beq.n	127b0 <__sccl+0x68>
   12750:	movs	r2, #0
   12752:	adds	r1, #1
   12754:	mov	r6, r2
   12756:	subs	r3, r0, #1
   12758:	add.w	r4, r0, #255	; 0xff
   1275c:	strb.w	r2, [r3, #1]!
   12760:	cmp	r3, r4
   12762:	bne.n	1275c <__sccl+0x14>
   12764:	cbz	r5, 12788 <__sccl+0x40>
   12766:	eor.w	r2, r6, #1
   1276a:	strb	r2, [r0, r5]
   1276c:	adds	r4, r1, #1
   1276e:	ldrb.w	r3, [r4, #-1]
   12772:	cmp	r3, #45	; 0x2d
   12774:	beq.n	12794 <__sccl+0x4c>
   12776:	cmp	r3, #93	; 0x5d
   12778:	beq.n	1278e <__sccl+0x46>
   1277a:	cbz	r3, 12782 <__sccl+0x3a>
   1277c:	mov	r5, r3
   1277e:	mov	r1, r4
   12780:	b.n	1276a <__sccl+0x22>
   12782:	mov	r0, r1
   12784:	pop	{r4, r5, r6}
   12786:	bx	lr
   12788:	subs	r0, r1, #1
   1278a:	pop	{r4, r5, r6}
   1278c:	bx	lr
   1278e:	mov	r0, r4
   12790:	pop	{r4, r5, r6}
   12792:	bx	lr
   12794:	ldrb	r6, [r1, #1]
   12796:	cmp	r6, #93	; 0x5d
   12798:	beq.n	1277c <__sccl+0x34>
   1279a:	cmp	r5, r6
   1279c:	bgt.n	1277c <__sccl+0x34>
   1279e:	adds	r1, #2
   127a0:	adds	r3, r0, r5
   127a2:	adds	r5, #1
   127a4:	cmp	r6, r5
   127a6:	strb.w	r2, [r3, #1]!
   127aa:	bgt.n	127a2 <__sccl+0x5a>
   127ac:	adds	r4, #2
   127ae:	b.n	1276e <__sccl+0x26>
   127b0:	movs	r2, #1
   127b2:	ldrb	r5, [r1, #1]
   127b4:	mov	r6, r2
   127b6:	adds	r1, #2
   127b8:	b.n	12756 <__sccl+0xe>
   127ba:	nop

000127bc <_strtoll_l.isra.0>:
   127bc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   127c0:	sub	sp, #20
   127c2:	mov	sl, r3
   127c4:	str	r1, [sp, #8]
   127c6:	str	r0, [sp, #12]
   127c8:	str	r2, [sp, #4]
   127ca:	mov	r7, r1
   127cc:	ldr	r6, [sp, #56]	; 0x38
   127ce:	b.n	127d2 <_strtoll_l.isra.0+0x16>
   127d0:	mov	r7, r5
   127d2:	mov	r5, r7
   127d4:	mov	r0, r6
   127d6:	ldrb.w	r4, [r5], #1
   127da:	bl	bcf4 <__locale_ctype_ptr_l>
   127de:	add	r0, r4
   127e0:	ldrb	r3, [r0, #1]
   127e2:	and.w	r3, r3, #8
   127e6:	and.w	r2, r3, #255	; 0xff
   127ea:	cmp	r3, #0
   127ec:	bne.n	127d0 <_strtoll_l.isra.0+0x14>
   127ee:	cmp	r4, #45	; 0x2d
   127f0:	beq.w	128fa <_strtoll_l.isra.0+0x13e>
   127f4:	cmp	r4, #43	; 0x2b
   127f6:	it	eq
   127f8:	ldrbeq	r4, [r7, #1]
   127fa:	str	r2, [sp, #0]
   127fc:	it	eq
   127fe:	addeq	r5, r7, #2
   12800:	cmp.w	sl, #0
   12804:	beq.n	12820 <_strtoll_l.isra.0+0x64>
   12806:	cmp.w	sl, #16
   1280a:	beq.w	12938 <_strtoll_l.isra.0+0x17c>
   1280e:	ldr	r3, [sp, #0]
   12810:	mov	r6, sl
   12812:	asrs	r7, r6, #31
   12814:	cbnz	r3, 12832 <_strtoll_l.isra.0+0x76>
   12816:	mov.w	r8, #4294967295
   1281a:	mvn.w	r9, #2147483648	; 0x80000000
   1281e:	b.n	1283a <_strtoll_l.isra.0+0x7e>
   12820:	cmp	r4, #48	; 0x30
   12822:	beq.n	12924 <_strtoll_l.isra.0+0x168>
   12824:	movs	r6, #10
   12826:	movs	r7, #0
   12828:	mov.w	sl, #10
   1282c:	ldr	r3, [sp, #0]
   1282e:	cmp	r3, #0
   12830:	beq.n	12816 <_strtoll_l.isra.0+0x5a>
   12832:	mov.w	r8, #0
   12836:	mov.w	r9, #2147483648	; 0x80000000
   1283a:	mov	r2, r6
   1283c:	mov	r3, r7
   1283e:	mov	r0, r8
   12840:	mov	r1, r9
   12842:	bl	b940 <__aeabi_uldivmod>
   12846:	mov	r3, r7
   12848:	mov	fp, r2
   1284a:	mov	r0, r8
   1284c:	mov	r2, r6
   1284e:	mov	r1, r9
   12850:	bl	b940 <__aeabi_uldivmod>
   12854:	mov.w	lr, #0
   12858:	movs	r2, #0
   1285a:	movs	r3, #0
   1285c:	b.n	1287e <_strtoll_l.isra.0+0xc2>
   1285e:	beq.n	128ec <_strtoll_l.isra.0+0x130>
   12860:	mul.w	r4, r2, r7
   12864:	mla	r4, r6, r3, r4
   12868:	umull	r2, r3, r2, r6
   1286c:	add	r3, r4
   1286e:	adds.w	r2, r2, ip
   12872:	adc.w	r3, r3, ip, asr #31
   12876:	mov.w	lr, #1
   1287a:	ldrb.w	r4, [r5], #1
   1287e:	sub.w	ip, r4, #48	; 0x30
   12882:	cmp.w	ip, #9
   12886:	bls.n	12896 <_strtoll_l.isra.0+0xda>
   12888:	sub.w	ip, r4, #65	; 0x41
   1288c:	cmp.w	ip, #25
   12890:	bhi.n	128ae <_strtoll_l.isra.0+0xf2>
   12892:	sub.w	ip, r4, #55	; 0x37
   12896:	cmp	sl, ip
   12898:	ble.n	128c0 <_strtoll_l.isra.0+0x104>
   1289a:	cmp.w	lr, #4294967295
   1289e:	beq.n	1287a <_strtoll_l.isra.0+0xbe>
   128a0:	cmp	r1, r3
   128a2:	it	eq
   128a4:	cmpeq	r0, r2
   128a6:	bcs.n	1285e <_strtoll_l.isra.0+0xa2>
   128a8:	mov.w	lr, #4294967295
   128ac:	b.n	1287a <_strtoll_l.isra.0+0xbe>
   128ae:	sub.w	ip, r4, #97	; 0x61
   128b2:	cmp.w	ip, #25
   128b6:	bhi.n	128c0 <_strtoll_l.isra.0+0x104>
   128b8:	sub.w	ip, r4, #87	; 0x57
   128bc:	cmp	sl, ip
   128be:	bgt.n	1289a <_strtoll_l.isra.0+0xde>
   128c0:	cmp.w	lr, #4294967295
   128c4:	beq.n	12904 <_strtoll_l.isra.0+0x148>
   128c6:	ldr	r1, [sp, #0]
   128c8:	cbz	r1, 128d0 <_strtoll_l.isra.0+0x114>
   128ca:	negs	r2, r2
   128cc:	sbc.w	r3, r3, r3, lsl #1
   128d0:	ldr	r1, [sp, #4]
   128d2:	cmp	r1, #0
   128d4:	beq.n	1295c <_strtoll_l.isra.0+0x1a0>
   128d6:	cmp.w	lr, #0
   128da:	bne.n	1291c <_strtoll_l.isra.0+0x160>
   128dc:	ldr	r5, [sp, #8]
   128de:	mov	r0, r2
   128e0:	mov	r1, r3
   128e2:	ldr	r3, [sp, #4]
   128e4:	str	r5, [r3, #0]
   128e6:	add	sp, #20
   128e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   128ec:	cmp	fp, ip
   128ee:	bge.n	12860 <_strtoll_l.isra.0+0xa4>
   128f0:	mov	r2, r0
   128f2:	mov	r3, r1
   128f4:	mov.w	lr, #4294967295
   128f8:	b.n	1287a <_strtoll_l.isra.0+0xbe>
   128fa:	movs	r3, #1
   128fc:	adds	r5, r7, #2
   128fe:	ldrb	r4, [r7, #1]
   12900:	str	r3, [sp, #0]
   12902:	b.n	12800 <_strtoll_l.isra.0+0x44>
   12904:	ldr	r3, [sp, #0]
   12906:	cbnz	r3, 12954 <_strtoll_l.isra.0+0x198>
   12908:	mov.w	r0, #4294967295
   1290c:	mvn.w	r1, #2147483648	; 0x80000000
   12910:	ldr	r2, [sp, #12]
   12912:	movs	r3, #34	; 0x22
   12914:	str	r3, [r2, #0]
   12916:	ldr	r3, [sp, #4]
   12918:	cbnz	r3, 12920 <_strtoll_l.isra.0+0x164>
   1291a:	b.n	128e6 <_strtoll_l.isra.0+0x12a>
   1291c:	mov	r0, r2
   1291e:	mov	r1, r3
   12920:	subs	r5, #1
   12922:	b.n	128e2 <_strtoll_l.isra.0+0x126>
   12924:	ldrb	r3, [r5, #0]
   12926:	and.w	r3, r3, #223	; 0xdf
   1292a:	cmp	r3, #88	; 0x58
   1292c:	beq.n	12946 <_strtoll_l.isra.0+0x18a>
   1292e:	movs	r6, #8
   12930:	movs	r7, #0
   12932:	mov.w	sl, #8
   12936:	b.n	1282c <_strtoll_l.isra.0+0x70>
   12938:	cmp	r4, #48	; 0x30
   1293a:	bne.n	12962 <_strtoll_l.isra.0+0x1a6>
   1293c:	ldrb	r3, [r5, #0]
   1293e:	and.w	r3, r3, #223	; 0xdf
   12942:	cmp	r3, #88	; 0x58
   12944:	bne.n	12962 <_strtoll_l.isra.0+0x1a6>
   12946:	ldrb	r4, [r5, #1]
   12948:	movs	r6, #16
   1294a:	movs	r7, #0
   1294c:	adds	r5, #2
   1294e:	mov.w	sl, #16
   12952:	b.n	1282c <_strtoll_l.isra.0+0x70>
   12954:	movs	r0, #0
   12956:	mov.w	r1, #2147483648	; 0x80000000
   1295a:	b.n	12910 <_strtoll_l.isra.0+0x154>
   1295c:	mov	r0, r2
   1295e:	mov	r1, r3
   12960:	b.n	128e6 <_strtoll_l.isra.0+0x12a>
   12962:	movs	r6, #16
   12964:	movs	r7, #0
   12966:	b.n	1282c <_strtoll_l.isra.0+0x70>

00012968 <_strtoll_r>:
   12968:	push	{r4, r5, lr}
   1296a:	ldr	r4, [pc, #24]	; (12984 <_strtoll_r+0x1c>)
   1296c:	ldr	r5, [pc, #24]	; (12988 <_strtoll_r+0x20>)
   1296e:	ldr	r4, [r4, #0]
   12970:	ldr	r4, [r4, #52]	; 0x34
   12972:	sub	sp, #12
   12974:	cmp	r4, #0
   12976:	it	eq
   12978:	moveq	r4, r5
   1297a:	str	r4, [sp, #0]
   1297c:	bl	127bc <_strtoll_l.isra.0>
   12980:	add	sp, #12
   12982:	pop	{r4, r5, pc}
   12984:	.word	0x20013dc8
   12988:	.word	0x20013dcc

0001298c <_strtoul_l.isra.0>:
   1298c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12990:	ldr.w	r9, [sp, #40]	; 0x28
   12994:	mov	r6, r1
   12996:	mov	r7, r0
   12998:	mov	r5, r2
   1299a:	mov	r8, r3
   1299c:	mov	fp, r1
   1299e:	b.n	129a2 <_strtoul_l.isra.0+0x16>
   129a0:	mov	fp, r4
   129a2:	mov	r4, fp
   129a4:	mov	r0, r9
   129a6:	ldrb.w	sl, [r4], #1
   129aa:	bl	bcf4 <__locale_ctype_ptr_l>
   129ae:	add	r0, sl
   129b0:	ldrb	r0, [r0, #1]
   129b2:	and.w	r0, r0, #8
   129b6:	and.w	ip, r0, #255	; 0xff
   129ba:	cmp	r0, #0
   129bc:	bne.n	129a0 <_strtoul_l.isra.0+0x14>
   129be:	mov	r1, sl
   129c0:	cmp	r1, #45	; 0x2d
   129c2:	beq.n	12a88 <_strtoul_l.isra.0+0xfc>
   129c4:	cmp	r1, #43	; 0x2b
   129c6:	itt	eq
   129c8:	ldrbeq.w	r1, [fp, #1]
   129cc:	addeq.w	r4, fp, #2
   129d0:	cmp.w	r8, #0
   129d4:	beq.n	129f0 <_strtoul_l.isra.0+0x64>
   129d6:	cmp.w	r8, #16
   129da:	beq.n	12a96 <_strtoul_l.isra.0+0x10a>
   129dc:	mov.w	r3, #4294967295
   129e0:	udiv	r3, r3, r8
   129e4:	mul.w	sl, r8, r3
   129e8:	mvn.w	sl, sl
   129ec:	mov	r9, r8
   129ee:	b.n	12a00 <_strtoul_l.isra.0+0x74>
   129f0:	cmp	r1, #48	; 0x30
   129f2:	beq.n	12ab8 <_strtoul_l.isra.0+0x12c>
   129f4:	mov.w	r8, #10
   129f8:	ldr	r3, [pc, #244]	; (12af0 <_strtoul_l.isra.0+0x164>)
   129fa:	mov	r9, r8
   129fc:	mov.w	sl, #5
   12a00:	mov.w	lr, #0
   12a04:	mov	r0, lr
   12a06:	b.n	12a16 <_strtoul_l.isra.0+0x8a>
   12a08:	beq.n	12a6a <_strtoul_l.isra.0+0xde>
   12a0a:	mla	r0, r9, r0, r2
   12a0e:	mov.w	lr, #1
   12a12:	ldrb.w	r1, [r4], #1
   12a16:	sub.w	r2, r1, #48	; 0x30
   12a1a:	cmp	r2, #9
   12a1c:	bls.n	12a2a <_strtoul_l.isra.0+0x9e>
   12a1e:	sub.w	r2, r1, #65	; 0x41
   12a22:	cmp	r2, #25
   12a24:	bhi.n	12a3e <_strtoul_l.isra.0+0xb2>
   12a26:	sub.w	r2, r1, #55	; 0x37
   12a2a:	cmp	r8, r2
   12a2c:	ble.n	12a4e <_strtoul_l.isra.0+0xc2>
   12a2e:	cmp.w	lr, #4294967295
   12a32:	beq.n	12a12 <_strtoul_l.isra.0+0x86>
   12a34:	cmp	r0, r3
   12a36:	bls.n	12a08 <_strtoul_l.isra.0+0x7c>
   12a38:	mov.w	lr, #4294967295
   12a3c:	b.n	12a12 <_strtoul_l.isra.0+0x86>
   12a3e:	sub.w	r2, r1, #97	; 0x61
   12a42:	cmp	r2, #25
   12a44:	bhi.n	12a4e <_strtoul_l.isra.0+0xc2>
   12a46:	sub.w	r2, r1, #87	; 0x57
   12a4a:	cmp	r8, r2
   12a4c:	bgt.n	12a2e <_strtoul_l.isra.0+0xa2>
   12a4e:	cmp.w	lr, #4294967295
   12a52:	beq.n	12a78 <_strtoul_l.isra.0+0xec>
   12a54:	cmp.w	ip, #0
   12a58:	beq.n	12a5c <_strtoul_l.isra.0+0xd0>
   12a5a:	negs	r0, r0
   12a5c:	cbz	r5, 12a74 <_strtoul_l.isra.0+0xe8>
   12a5e:	cmp.w	lr, #0
   12a62:	bne.n	12a80 <_strtoul_l.isra.0+0xf4>
   12a64:	str	r6, [r5, #0]
   12a66:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12a6a:	cmp	r2, sl
   12a6c:	ble.n	12a0a <_strtoul_l.isra.0+0x7e>
   12a6e:	mov.w	lr, #4294967295
   12a72:	b.n	12a12 <_strtoul_l.isra.0+0x86>
   12a74:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12a78:	movs	r3, #34	; 0x22
   12a7a:	str	r3, [r7, #0]
   12a7c:	mov	r0, lr
   12a7e:	cbz	r5, 12ad2 <_strtoul_l.isra.0+0x146>
   12a80:	subs	r6, r4, #1
   12a82:	str	r6, [r5, #0]
   12a84:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12a88:	add.w	r4, fp, #2
   12a8c:	ldrb.w	r1, [fp, #1]
   12a90:	mov.w	ip, #1
   12a94:	b.n	129d0 <_strtoul_l.isra.0+0x44>
   12a96:	cmp	r1, #48	; 0x30
   12a98:	bne.n	12ad6 <_strtoul_l.isra.0+0x14a>
   12a9a:	ldrb	r3, [r4, #0]
   12a9c:	and.w	r3, r3, #223	; 0xdf
   12aa0:	cmp	r3, #88	; 0x58
   12aa2:	bne.n	12ae2 <_strtoul_l.isra.0+0x156>
   12aa4:	mov.w	r9, #16
   12aa8:	ldrb	r1, [r4, #1]
   12aaa:	mov	r8, r9
   12aac:	mov.w	sl, #15
   12ab0:	adds	r4, #2
   12ab2:	mvn.w	r3, #4026531840	; 0xf0000000
   12ab6:	b.n	12a00 <_strtoul_l.isra.0+0x74>
   12ab8:	ldrb	r3, [r4, #0]
   12aba:	and.w	r3, r3, #223	; 0xdf
   12abe:	cmp	r3, #88	; 0x58
   12ac0:	beq.n	12aa4 <_strtoul_l.isra.0+0x118>
   12ac2:	mov.w	r8, #8
   12ac6:	mov	r9, r8
   12ac8:	mov.w	sl, #7
   12acc:	mvn.w	r3, #3758096384	; 0xe0000000
   12ad0:	b.n	12a00 <_strtoul_l.isra.0+0x74>
   12ad2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12ad6:	mov.w	sl, #15
   12ada:	mvn.w	r3, #4026531840	; 0xf0000000
   12ade:	mov	r9, r8
   12ae0:	b.n	12a00 <_strtoul_l.isra.0+0x74>
   12ae2:	mov	r9, r8
   12ae4:	mov.w	sl, #15
   12ae8:	mvn.w	r3, #4026531840	; 0xf0000000
   12aec:	b.n	12a00 <_strtoul_l.isra.0+0x74>
   12aee:	nop
   12af0:	.word	0x19999999

00012af4 <_strtoul_r>:
   12af4:	push	{r4, r5, lr}
   12af6:	ldr	r4, [pc, #24]	; (12b10 <_strtoul_r+0x1c>)
   12af8:	ldr	r5, [pc, #24]	; (12b14 <_strtoul_r+0x20>)
   12afa:	ldr	r4, [r4, #0]
   12afc:	ldr	r4, [r4, #52]	; 0x34
   12afe:	sub	sp, #12
   12b00:	cmp	r4, #0
   12b02:	it	eq
   12b04:	moveq	r4, r5
   12b06:	str	r4, [sp, #0]
   12b08:	bl	1298c <_strtoul_l.isra.0>
   12b0c:	add	sp, #12
   12b0e:	pop	{r4, r5, pc}
   12b10:	.word	0x20013dc8
   12b14:	.word	0x20013dcc

00012b18 <_strtoull_l.isra.0>:
   12b18:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12b1c:	sub	sp, #20
   12b1e:	mov	fp, r1
   12b20:	str	r0, [sp, #8]
   12b22:	mov	r7, r2
   12b24:	mov	r6, r3
   12b26:	mov	r8, r1
   12b28:	ldr	r4, [sp, #56]	; 0x38
   12b2a:	b.n	12b2e <_strtoull_l.isra.0+0x16>
   12b2c:	mov	r8, r5
   12b2e:	mov	r5, r8
   12b30:	mov	r0, r4
   12b32:	ldrb.w	r9, [r5], #1
   12b36:	bl	bcf4 <__locale_ctype_ptr_l>
   12b3a:	add	r0, r9
   12b3c:	ldrb	r3, [r0, #1]
   12b3e:	and.w	r3, r3, #8
   12b42:	and.w	r2, r3, #255	; 0xff
   12b46:	cmp	r3, #0
   12b48:	bne.n	12b2c <_strtoull_l.isra.0+0x14>
   12b4a:	mov	r4, r9
   12b4c:	cmp	r4, #45	; 0x2d
   12b4e:	beq.w	12c6a <_strtoull_l.isra.0+0x152>
   12b52:	cmp	r4, #43	; 0x2b
   12b54:	it	eq
   12b56:	ldrbeq.w	r4, [r8, #1]
   12b5a:	str	r2, [sp, #4]
   12b5c:	it	eq
   12b5e:	addeq.w	r5, r8, #2
   12b62:	cbz	r6, 12b9c <_strtoull_l.isra.0+0x84>
   12b64:	cmp	r6, #16
   12b66:	beq.w	12c78 <_strtoull_l.isra.0+0x160>
   12b6a:	mov.w	r9, r6, asr #31
   12b6e:	mov	r2, r6
   12b70:	mov	r3, r9
   12b72:	mov.w	r0, #4294967295
   12b76:	mov.w	r1, #4294967295
   12b7a:	bl	b940 <__aeabi_uldivmod>
   12b7e:	mov	r2, r6
   12b80:	str	r0, [sp, #12]
   12b82:	mov	sl, r1
   12b84:	mov	r3, r9
   12b86:	mov.w	r0, #4294967295
   12b8a:	mov.w	r1, #4294967295
   12b8e:	bl	b940 <__aeabi_uldivmod>
   12b92:	mov	r8, r6
   12b94:	mov	lr, r2
   12b96:	ldr	r2, [sp, #12]
   12b98:	mov	r3, sl
   12b9a:	b.n	12bb6 <_strtoull_l.isra.0+0x9e>
   12b9c:	cmp	r4, #48	; 0x30
   12b9e:	beq.w	12ca4 <_strtoull_l.isra.0+0x18c>
   12ba2:	ldr	r3, [pc, #348]	; (12d00 <_strtoull_l.isra.0+0x1e8>)
   12ba4:	mov.w	lr, #5
   12ba8:	mov.w	r2, #2576980377	; 0x99999999
   12bac:	mov.w	r8, #10
   12bb0:	mov.w	r9, #0
   12bb4:	movs	r6, #10
   12bb6:	mov.w	ip, #0
   12bba:	movs	r0, #0
   12bbc:	movs	r1, #0
   12bbe:	b.n	12be6 <_strtoull_l.isra.0+0xce>
   12bc0:	cmp	r1, r3
   12bc2:	it	eq
   12bc4:	cmpeq	r0, r2
   12bc6:	beq.n	12c4a <_strtoull_l.isra.0+0x132>
   12bc8:	mul.w	r4, r0, r9
   12bcc:	mla	r4, r8, r1, r4
   12bd0:	umull	r0, r1, r0, r8
   12bd4:	add	r1, r4
   12bd6:	adds.w	r0, r0, sl
   12bda:	adc.w	r1, r1, sl, asr #31
   12bde:	mov.w	ip, #1
   12be2:	ldrb.w	r4, [r5], #1
   12be6:	sub.w	sl, r4, #48	; 0x30
   12bea:	cmp.w	sl, #9
   12bee:	bls.n	12bfe <_strtoull_l.isra.0+0xe6>
   12bf0:	sub.w	sl, r4, #65	; 0x41
   12bf4:	cmp.w	sl, #25
   12bf8:	bhi.n	12c16 <_strtoull_l.isra.0+0xfe>
   12bfa:	sub.w	sl, r4, #55	; 0x37
   12bfe:	cmp	r6, sl
   12c00:	ble.n	12c28 <_strtoull_l.isra.0+0x110>
   12c02:	cmp.w	ip, #4294967295
   12c06:	beq.n	12be2 <_strtoull_l.isra.0+0xca>
   12c08:	cmp	r3, r1
   12c0a:	it	eq
   12c0c:	cmpeq	r2, r0
   12c0e:	bcs.n	12bc0 <_strtoull_l.isra.0+0xa8>
   12c10:	mov.w	ip, #4294967295
   12c14:	b.n	12be2 <_strtoull_l.isra.0+0xca>
   12c16:	sub.w	sl, r4, #97	; 0x61
   12c1a:	cmp.w	sl, #25
   12c1e:	bhi.n	12c28 <_strtoull_l.isra.0+0x110>
   12c20:	sub.w	sl, r4, #87	; 0x57
   12c24:	cmp	r6, sl
   12c26:	bgt.n	12c02 <_strtoull_l.isra.0+0xea>
   12c28:	cmp.w	ip, #4294967295
   12c2c:	beq.n	12c54 <_strtoull_l.isra.0+0x13c>
   12c2e:	ldr	r3, [sp, #4]
   12c30:	cbz	r3, 12c38 <_strtoull_l.isra.0+0x120>
   12c32:	negs	r0, r0
   12c34:	sbc.w	r1, r1, r1, lsl #1
   12c38:	cbz	r7, 12c44 <_strtoull_l.isra.0+0x12c>
   12c3a:	cmp.w	ip, #0
   12c3e:	bne.n	12c66 <_strtoull_l.isra.0+0x14e>
   12c40:	mov	r5, fp
   12c42:	str	r5, [r7, #0]
   12c44:	add	sp, #20
   12c46:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12c4a:	cmp	sl, lr
   12c4c:	ble.n	12bc8 <_strtoull_l.isra.0+0xb0>
   12c4e:	mov.w	ip, #4294967295
   12c52:	b.n	12be2 <_strtoull_l.isra.0+0xca>
   12c54:	ldr	r2, [sp, #8]
   12c56:	movs	r3, #34	; 0x22
   12c58:	str	r3, [r2, #0]
   12c5a:	mov.w	r0, #4294967295
   12c5e:	mov.w	r1, #4294967295
   12c62:	cmp	r7, #0
   12c64:	beq.n	12c44 <_strtoull_l.isra.0+0x12c>
   12c66:	subs	r5, #1
   12c68:	b.n	12c42 <_strtoull_l.isra.0+0x12a>
   12c6a:	movs	r3, #1
   12c6c:	add.w	r5, r8, #2
   12c70:	ldrb.w	r4, [r8, #1]
   12c74:	str	r3, [sp, #4]
   12c76:	b.n	12b62 <_strtoull_l.isra.0+0x4a>
   12c78:	cmp	r4, #48	; 0x30
   12c7a:	bne.n	12cc6 <_strtoull_l.isra.0+0x1ae>
   12c7c:	ldrb	r3, [r5, #0]
   12c7e:	and.w	r3, r3, #223	; 0xdf
   12c82:	cmp	r3, #88	; 0x58
   12c84:	bne.n	12cdc <_strtoull_l.isra.0+0x1c4>
   12c86:	mov.w	r3, #4294967295
   12c8a:	ldrb	r4, [r5, #1]
   12c8c:	str	r3, [sp, #12]
   12c8e:	mov.w	lr, #15
   12c92:	adds	r5, #2
   12c94:	mvn.w	sl, #4026531840	; 0xf0000000
   12c98:	mov.w	r8, #16
   12c9c:	mov.w	r9, #0
   12ca0:	movs	r6, #16
   12ca2:	b.n	12b96 <_strtoull_l.isra.0+0x7e>
   12ca4:	ldrb	r3, [r5, #0]
   12ca6:	and.w	r3, r3, #223	; 0xdf
   12caa:	cmp	r3, #88	; 0x58
   12cac:	beq.n	12c86 <_strtoull_l.isra.0+0x16e>
   12cae:	mov.w	lr, #7
   12cb2:	mov.w	r2, #4294967295
   12cb6:	mvn.w	r3, #3758096384	; 0xe0000000
   12cba:	mov.w	r8, #8
   12cbe:	mov.w	r9, #0
   12cc2:	movs	r6, #8
   12cc4:	b.n	12bb6 <_strtoull_l.isra.0+0x9e>
   12cc6:	mov.w	lr, #15
   12cca:	mov.w	r2, #4294967295
   12cce:	mvn.w	r3, #4026531840	; 0xf0000000
   12cd2:	mov.w	r8, #16
   12cd6:	mov.w	r9, #0
   12cda:	b.n	12bb6 <_strtoull_l.isra.0+0x9e>
   12cdc:	mov.w	r8, #16
   12ce0:	mov.w	r9, #0
   12ce4:	mov	r2, r8
   12ce6:	mov	r3, r9
   12ce8:	mov.w	r0, #4294967295
   12cec:	mov.w	r1, #4294967295
   12cf0:	bl	b940 <__aeabi_uldivmod>
   12cf4:	mvn.w	r3, #4026531840	; 0xf0000000
   12cf8:	mov	lr, r2
   12cfa:	mov.w	r2, #4294967295
   12cfe:	b.n	12bb6 <_strtoull_l.isra.0+0x9e>
   12d00:	.word	0x19999999

00012d04 <_strtoull_r>:
   12d04:	push	{r4, r5, lr}
   12d06:	ldr	r4, [pc, #24]	; (12d20 <_strtoull_r+0x1c>)
   12d08:	ldr	r5, [pc, #24]	; (12d24 <_strtoull_r+0x20>)
   12d0a:	ldr	r4, [r4, #0]
   12d0c:	ldr	r4, [r4, #52]	; 0x34
   12d0e:	sub	sp, #12
   12d10:	cmp	r4, #0
   12d12:	it	eq
   12d14:	moveq	r4, r5
   12d16:	str	r4, [sp, #0]
   12d18:	bl	12b18 <_strtoull_l.isra.0>
   12d1c:	add	sp, #12
   12d1e:	pop	{r4, r5, pc}
   12d20:	.word	0x20013dc8
   12d24:	.word	0x20013dcc

00012d28 <__ssprint_r>:
   12d28:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12d2c:	ldr	r3, [r2, #8]
   12d2e:	sub	sp, #12
   12d30:	mov	r8, r2
   12d32:	cmp	r3, #0
   12d34:	beq.n	12e1c <__ssprint_r+0xf4>
   12d36:	mov	fp, r0
   12d38:	mov.w	r9, #0
   12d3c:	ldr	r6, [r2, #0]
   12d3e:	ldr	r0, [r1, #0]
   12d40:	ldr	r3, [r1, #8]
   12d42:	mov	r5, r1
   12d44:	mov	r4, r9
   12d46:	cmp	r4, #0
   12d48:	beq.n	12dd6 <__ssprint_r+0xae>
   12d4a:	cmp	r4, r3
   12d4c:	mov	r7, r3
   12d4e:	mov	sl, r3
   12d50:	bcc.n	12de0 <__ssprint_r+0xb8>
   12d52:	ldrh	r3, [r5, #12]
   12d54:	tst.w	r3, #1152	; 0x480
   12d58:	beq.n	12db6 <__ssprint_r+0x8e>
   12d5a:	ldr	r7, [r5, #20]
   12d5c:	ldr	r1, [r5, #16]
   12d5e:	add.w	r7, r7, r7, lsl #1
   12d62:	rsb	sl, r1, r0
   12d66:	add.w	r7, r7, r7, lsr #31
   12d6a:	adds	r0, r4, #1
   12d6c:	asrs	r7, r7, #1
   12d6e:	add	r0, sl
   12d70:	cmp	r0, r7
   12d72:	mov	r2, r7
   12d74:	itt	hi
   12d76:	movhi	r7, r0
   12d78:	movhi	r2, r7
   12d7a:	lsls	r3, r3, #21
   12d7c:	bpl.n	12de6 <__ssprint_r+0xbe>
   12d7e:	mov	r1, r2
   12d80:	mov	r0, fp
   12d82:	bl	bd30 <_malloc_r>
   12d86:	cmp	r0, #0
   12d88:	beq.n	12dfa <__ssprint_r+0xd2>
   12d8a:	mov	r2, sl
   12d8c:	ldr	r1, [r5, #16]
   12d8e:	str	r0, [sp, #4]
   12d90:	bl	9220 <memcpy>
   12d94:	ldrh	r2, [r5, #12]
   12d96:	ldr	r3, [sp, #4]
   12d98:	bic.w	r2, r2, #1152	; 0x480
   12d9c:	orr.w	r2, r2, #128	; 0x80
   12da0:	strh	r2, [r5, #12]
   12da2:	rsb	r2, sl, r7
   12da6:	add.w	r0, r3, sl
   12daa:	str	r7, [r5, #20]
   12dac:	str	r3, [r5, #16]
   12dae:	str	r0, [r5, #0]
   12db0:	str	r2, [r5, #8]
   12db2:	mov	r7, r4
   12db4:	mov	sl, r4
   12db6:	mov	r2, sl
   12db8:	mov	r1, r9
   12dba:	bl	c3d4 <memmove>
   12dbe:	ldr.w	r2, [r8, #8]
   12dc2:	ldr	r3, [r5, #8]
   12dc4:	ldr	r0, [r5, #0]
   12dc6:	subs	r3, r3, r7
   12dc8:	add	r0, sl
   12dca:	subs	r4, r2, r4
   12dcc:	str	r3, [r5, #8]
   12dce:	str	r0, [r5, #0]
   12dd0:	str.w	r4, [r8, #8]
   12dd4:	cbz	r4, 12e1c <__ssprint_r+0xf4>
   12dd6:	ldr.w	r9, [r6]
   12dda:	ldr	r4, [r6, #4]
   12ddc:	adds	r6, #8
   12dde:	b.n	12d46 <__ssprint_r+0x1e>
   12de0:	mov	r7, r4
   12de2:	mov	sl, r4
   12de4:	b.n	12db6 <__ssprint_r+0x8e>
   12de6:	mov	r0, fp
   12de8:	bl	c540 <_realloc_r>
   12dec:	mov	r3, r0
   12dee:	cmp	r0, #0
   12df0:	bne.n	12da2 <__ssprint_r+0x7a>
   12df2:	ldr	r1, [r5, #16]
   12df4:	mov	r0, fp
   12df6:	bl	11490 <_free_r>
   12dfa:	movs	r3, #12
   12dfc:	str.w	r3, [fp]
   12e00:	ldrh	r3, [r5, #12]
   12e02:	movs	r2, #0
   12e04:	orr.w	r3, r3, #64	; 0x40
   12e08:	mov.w	r0, #4294967295
   12e0c:	strh	r3, [r5, #12]
   12e0e:	str.w	r2, [r8, #8]
   12e12:	str.w	r2, [r8, #4]
   12e16:	add	sp, #12
   12e18:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12e1c:	movs	r0, #0
   12e1e:	str.w	r0, [r8, #4]
   12e22:	add	sp, #12
   12e24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00012e28 <_sungetc_r>:
   12e28:	adds	r3, r1, #1
   12e2a:	push	{r4, r5, r6, lr}
   12e2c:	beq.n	12e66 <_sungetc_r+0x3e>
   12e2e:	ldrh	r3, [r2, #12]
   12e30:	ldr	r4, [r2, #48]	; 0x30
   12e32:	bic.w	r3, r3, #32
   12e36:	strh	r3, [r2, #12]
   12e38:	uxtb	r5, r1
   12e3a:	cbz	r4, 12e6c <_sungetc_r+0x44>
   12e3c:	mov	r4, r2
   12e3e:	ldr	r2, [r2, #4]
   12e40:	ldr	r3, [r4, #52]	; 0x34
   12e42:	cmp	r2, r3
   12e44:	mov	r6, r1
   12e46:	bge.n	12e5c <_sungetc_r+0x34>
   12e48:	ldr	r3, [r4, #0]
   12e4a:	subs	r2, r3, #1
   12e4c:	str	r2, [r4, #0]
   12e4e:	strb.w	r6, [r3, #-1]
   12e52:	ldr	r3, [r4, #4]
   12e54:	adds	r3, #1
   12e56:	str	r3, [r4, #4]
   12e58:	mov	r0, r5
   12e5a:	pop	{r4, r5, r6, pc}
   12e5c:	mov	r1, r4
   12e5e:	bl	12f6c <__submore>
   12e62:	cmp	r0, #0
   12e64:	beq.n	12e48 <_sungetc_r+0x20>
   12e66:	mov.w	r5, #4294967295
   12e6a:	b.n	12e58 <_sungetc_r+0x30>
   12e6c:	ldr	r0, [r2, #16]
   12e6e:	ldr	r3, [r2, #0]
   12e70:	cbz	r0, 12e7e <_sungetc_r+0x56>
   12e72:	cmp	r0, r3
   12e74:	bcs.n	12e7e <_sungetc_r+0x56>
   12e76:	ldrb.w	r0, [r3, #-1]
   12e7a:	cmp	r5, r0
   12e7c:	beq.n	12e9e <_sungetc_r+0x76>
   12e7e:	str	r3, [r2, #56]	; 0x38
   12e80:	mov	r3, r2
   12e82:	ldr	r6, [r2, #4]
   12e84:	str	r6, [r2, #60]	; 0x3c
   12e86:	add.w	r4, r2, #64	; 0x40
   12e8a:	movs	r0, #3
   12e8c:	str	r0, [r2, #52]	; 0x34
   12e8e:	str	r4, [r2, #48]	; 0x30
   12e90:	strb.w	r1, [r3, #66]!
   12e94:	movs	r1, #1
   12e96:	str	r3, [r2, #0]
   12e98:	str	r1, [r2, #4]
   12e9a:	mov	r0, r5
   12e9c:	pop	{r4, r5, r6, pc}
   12e9e:	ldr	r1, [r2, #4]
   12ea0:	subs	r3, #1
   12ea2:	adds	r1, #1
   12ea4:	str	r3, [r2, #0]
   12ea6:	str	r1, [r2, #4]
   12ea8:	b.n	12e58 <_sungetc_r+0x30>
   12eaa:	nop

00012eac <__ssrefill_r>:
   12eac:	push	{r4, lr}
   12eae:	mov	r4, r1
   12eb0:	ldr	r1, [r1, #48]	; 0x30
   12eb2:	cbz	r1, 12ed0 <__ssrefill_r+0x24>
   12eb4:	add.w	r3, r4, #64	; 0x40
   12eb8:	cmp	r1, r3
   12eba:	beq.n	12ec0 <__ssrefill_r+0x14>
   12ebc:	bl	11490 <_free_r>
   12ec0:	ldr	r3, [r4, #60]	; 0x3c
   12ec2:	str	r3, [r4, #4]
   12ec4:	movs	r0, #0
   12ec6:	str	r0, [r4, #48]	; 0x30
   12ec8:	cbz	r3, 12ed0 <__ssrefill_r+0x24>
   12eca:	ldr	r3, [r4, #56]	; 0x38
   12ecc:	str	r3, [r4, #0]
   12ece:	pop	{r4, pc}
   12ed0:	ldrh	r3, [r4, #12]
   12ed2:	ldr	r2, [r4, #16]
   12ed4:	str	r2, [r4, #0]
   12ed6:	orr.w	r3, r3, #32
   12eda:	movs	r2, #0
   12edc:	strh	r3, [r4, #12]
   12ede:	str	r2, [r4, #4]
   12ee0:	mov.w	r0, #4294967295
   12ee4:	pop	{r4, pc}
   12ee6:	nop

00012ee8 <_sfread_r>:
   12ee8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12eec:	sub	sp, #12
   12eee:	mul.w	r9, r2, r3
   12ef2:	str	r2, [sp, #4]
   12ef4:	mov	sl, r3
   12ef6:	ldr	r4, [sp, #48]	; 0x30
   12ef8:	cmp.w	r9, #0
   12efc:	beq.n	12f52 <_sfread_r+0x6a>
   12efe:	mov	r7, r0
   12f00:	mov	r6, r1
   12f02:	mov	r5, r9
   12f04:	mov.w	r8, #0
   12f08:	b.n	12f2a <_sfread_r+0x42>
   12f0a:	ldr	r1, [r4, #0]
   12f0c:	bl	9220 <memcpy>
   12f10:	ldr	r2, [r4, #0]
   12f12:	str.w	r8, [r4, #4]
   12f16:	add	r2, fp
   12f18:	str	r2, [r4, #0]
   12f1a:	mov	r1, r4
   12f1c:	mov	r0, r7
   12f1e:	add	r6, fp
   12f20:	rsb	r5, fp, r5
   12f24:	bl	12eac <__ssrefill_r>
   12f28:	cbnz	r0, 12f5a <_sfread_r+0x72>
   12f2a:	ldr.w	fp, [r4, #4]
   12f2e:	cmp	r5, fp
   12f30:	mov	r0, r6
   12f32:	mov	r2, fp
   12f34:	bhi.n	12f0a <_sfread_r+0x22>
   12f36:	mov	r2, r5
   12f38:	ldr	r1, [r4, #0]
   12f3a:	bl	9220 <memcpy>
   12f3e:	ldr	r2, [r4, #4]
   12f40:	ldr	r3, [r4, #0]
   12f42:	subs	r2, r2, r5
   12f44:	add	r3, r5
   12f46:	mov	r0, sl
   12f48:	str	r2, [r4, #4]
   12f4a:	str	r3, [r4, #0]
   12f4c:	add	sp, #12
   12f4e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12f52:	mov	r0, r9
   12f54:	add	sp, #12
   12f56:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12f5a:	ldr	r3, [sp, #4]
   12f5c:	rsb	r9, r5, r9
   12f60:	udiv	r0, r9, r3
   12f64:	add	sp, #12
   12f66:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12f6a:	nop

00012f6c <__submore>:
   12f6c:	add.w	r3, r1, #64	; 0x40
   12f70:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12f74:	mov	r4, r1
   12f76:	ldr	r1, [r1, #48]	; 0x30
   12f78:	cmp	r1, r3
   12f7a:	beq.n	12fa6 <__submore+0x3a>
   12f7c:	ldr	r6, [r4, #52]	; 0x34
   12f7e:	lsls	r7, r6, #1
   12f80:	mov	r2, r7
   12f82:	bl	c540 <_realloc_r>
   12f86:	mov	r5, r0
   12f88:	cbz	r0, 12fdc <__submore+0x70>
   12f8a:	add.w	r8, r0, r6
   12f8e:	mov	r2, r6
   12f90:	mov	r0, r8
   12f92:	mov	r1, r5
   12f94:	bl	9220 <memcpy>
   12f98:	str.w	r8, [r4]
   12f9c:	str	r5, [r4, #48]	; 0x30
   12f9e:	str	r7, [r4, #52]	; 0x34
   12fa0:	movs	r0, #0
   12fa2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12fa6:	mov.w	r1, #1024	; 0x400
   12faa:	bl	bd30 <_malloc_r>
   12fae:	cbz	r0, 12fdc <__submore+0x70>
   12fb0:	ldrb.w	r3, [r4, #66]	; 0x42
   12fb4:	str	r0, [r4, #48]	; 0x30
   12fb6:	mov.w	r2, #1024	; 0x400
   12fba:	str	r2, [r4, #52]	; 0x34
   12fbc:	strb.w	r3, [r0, #1023]	; 0x3ff
   12fc0:	ldrb.w	r3, [r4, #65]	; 0x41
   12fc4:	strb.w	r3, [r0, #1022]	; 0x3fe
   12fc8:	ldrb.w	r3, [r4, #64]	; 0x40
   12fcc:	strb.w	r3, [r0, #1021]	; 0x3fd
   12fd0:	addw	r0, r0, #1021	; 0x3fd
   12fd4:	str	r0, [r4, #0]
   12fd6:	movs	r0, #0
   12fd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12fdc:	mov.w	r0, #4294967295
   12fe0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00012fe4 <_vasnprintf_r>:
   12fe4:	push	{r4, r5, r6, lr}
   12fe6:	mov	r5, r2
   12fe8:	sub	sp, #104	; 0x68
   12fea:	ldr	r4, [r2, #0]
   12fec:	cbz	r1, 12ff2 <_vasnprintf_r+0xe>
   12fee:	cmp	r4, #0
   12ff0:	bne.n	13028 <_vasnprintf_r+0x44>
   12ff2:	movs	r4, #0
   12ff4:	mov.w	r2, #648	; 0x288
   12ff8:	strh.w	r2, [sp, #12]
   12ffc:	str	r4, [sp, #0]
   12ffe:	str	r4, [sp, #16]
   13000:	mov	r2, r3
   13002:	movw	r6, #65535	; 0xffff
   13006:	ldr	r3, [sp, #120]	; 0x78
   13008:	str	r4, [sp, #8]
   1300a:	mov	r1, sp
   1300c:	str	r4, [sp, #20]
   1300e:	strh.w	r6, [sp, #14]
   13012:	bl	dd90 <_svfprintf_r>
   13016:	cmp	r0, #0
   13018:	blt.n	1303e <_vasnprintf_r+0x5a>
   1301a:	ldr	r3, [sp, #0]
   1301c:	str	r0, [r5, #0]
   1301e:	movs	r2, #0
   13020:	strb	r2, [r3, #0]
   13022:	ldr	r0, [sp, #16]
   13024:	add	sp, #104	; 0x68
   13026:	pop	{r4, r5, r6, pc}
   13028:	mov.w	r2, #1544	; 0x608
   1302c:	str	r1, [sp, #0]
   1302e:	str	r1, [sp, #16]
   13030:	strh.w	r2, [sp, #12]
   13034:	bge.n	13000 <_vasnprintf_r+0x1c>
   13036:	movs	r3, #139	; 0x8b
   13038:	str	r3, [r0, #0]
   1303a:	movs	r0, #0
   1303c:	b.n	13024 <_vasnprintf_r+0x40>
   1303e:	movs	r0, #0
   13040:	b.n	13024 <_vasnprintf_r+0x40>
   13042:	nop

00013044 <_calloc_r>:
   13044:	push	{r4, lr}
   13046:	mul.w	r1, r2, r1
   1304a:	bl	bd30 <_malloc_r>
   1304e:	mov	r4, r0
   13050:	cbz	r0, 1308a <_calloc_r+0x46>
   13052:	ldr.w	r2, [r0, #-4]
   13056:	bic.w	r2, r2, #3
   1305a:	subs	r2, #4
   1305c:	cmp	r2, #36	; 0x24
   1305e:	bhi.n	13092 <_calloc_r+0x4e>
   13060:	cmp	r2, #19
   13062:	bls.n	1308e <_calloc_r+0x4a>
   13064:	movs	r3, #0
   13066:	cmp	r2, #27
   13068:	str	r3, [r0, #0]
   1306a:	str	r3, [r0, #4]
   1306c:	bls.n	1309c <_calloc_r+0x58>
   1306e:	cmp	r2, #36	; 0x24
   13070:	str	r3, [r0, #8]
   13072:	str	r3, [r0, #12]
   13074:	iteee	ne
   13076:	addne.w	r2, r0, #16
   1307a:	streq	r3, [r0, #16]
   1307c:	streq	r3, [r0, #20]
   1307e:	addeq.w	r2, r0, #24
   13082:	movs	r3, #0
   13084:	str	r3, [r2, #0]
   13086:	str	r3, [r2, #4]
   13088:	str	r3, [r2, #8]
   1308a:	mov	r0, r4
   1308c:	pop	{r4, pc}
   1308e:	mov	r2, r0
   13090:	b.n	13082 <_calloc_r+0x3e>
   13092:	movs	r1, #0
   13094:	bl	c49c <memset>
   13098:	mov	r0, r4
   1309a:	pop	{r4, pc}
   1309c:	add.w	r2, r0, #8
   130a0:	b.n	13082 <_calloc_r+0x3e>
   130a2:	nop

000130a4 <vtable for AudioStream>:
	...
   130ac:	....

000130b0 <vtable for mRecordQueue<250>>:
	...
   130b8:	u...

000130bc <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   130c4:	........m.......
   130d4:	-...........

000130e0 <vtable for FsFile>:
	...
   130e8:	........m.......
   130f8:	-...........%02d
   13108:	:%02d:%02d..%04d
   13118:	/%02d/%02d..%d %
   13128:	d %d %d %d %d %d
   13138:	....%s_%04d_%02d
   13148:	_%02d_%02d_%02d_
   13158:	%02d%s..%04d_%02
   13168:	d_%02d_%02d_%02d
   13178:	_%02d...RIFF....
   13188:	WAVE....fmt ....
   13198:	data....%04d_%02
   131a8:	d_%02d,.%02d_%02
   131b8:	d_%02d,.%10d....
   131c8:	SD_s_%s.txt.Conf
   131d8:	ig.txt..%s......
   131e8:	%d..Envi_%s.txt.
   131f8:	%10.1f,.close ac
   13208:	quisition...Hibe
   13218:	rnate now 1.Hibe
   13228:	rnate now 3.?!xa
   13238:	....oar1234ndtch
   13248:	wseikp..%02d....
   13258:	%c %5d on_time..
   13268:	....%c %5d acq_t
   13278:	ime.....%c %5d r
   13288:	ep_rate.....%c %
   13298:	5d first_hour...
   132a8:	%c %5d second_ho
   132b8:	ur......%c %5d t
   132c8:	hird_hour...%c %
   132d8:	5d last_hour....
   132e8:	%c %s name......
   132f8:	%c %s date......
   13308:	%c %s time......
   13318:	exter 'a' to pri
   13328:	nt this.exter '?
   13338:	c' to read value
   13348:	 c=(o,a,r,1,2,3,
   13358:	4,n,d,t,c,h,w,s,
   13368:	m,i,k,p)....  e.
   13378:	g.: ?1 will prin
   13388:	t first hour....
   13398:	exter '!cval' to
   133a8:	 read value c=(0
   133b8:	,a,r,1,2,3,4,n,d
   133c8:	,t,c,h,w,s,m,i,k
   133d8:	,p) and val is n
   133e8:	ew value....  e.
   133f8:	g.: !110 will se
   13408:	t first hour to 
   13418:	10..exter 'xval'
   13428:	 to exit menu (x
   13438:	 is delay in min
   13448:	utes, -1 means i
   13458:	mmediate)...  e.
   13468:	g.: x10 will exi
   13478:	t and hibernate 
   13488:	for 10 minutes..
   13498:	        x-1 with
   134a8:	 exit and start 
   134b8:	immediately.micr
   134c8:	oSoundRecorder..
   134d8:	End of Setup....
   134e8:	logFile.txt.SdEr
   134f8:	ror: 0X.,0X.Chec
   13508:	k SD format.....
   13518:	error: .file.wri
   13528:	te data failed..
   13538:	file.open failed
   13548:	....file.preAllo
   13558:	cate failed.clos
   13568:	ed...loop: %5d %
   13578:	4d; %5d %5d; %5d
   13588:	.....loop: %5d %
   13598:	4d; %5d %5d; %5d
   135a8:	....

000135ac <monthDays>:
   135ac:	............

000135b8 <vtable for AudioInputI2S>:
	...
   135c0:	y(..

000135c4 <vtable for AudioControlSGTL5000>:
	...
   135cc:	1-..M*......Q*..
   135dc:	=-..

000135e0 <vtable for Stream>:
	...
   135e8:	....5...m...q...
   135f8:	............

00013604 <vtable for File>:
	...
   1360c:	./..5...m.......
   1361c:	...../......q3..
   1362c:	.3...0..........
   1363c:	............./..
   1364c:	./..)/..5/..I/..
   1365c:	U/.../..

00013664 <vtable for SDFile>:
	...
   1366c:	./..5...m...!1..
   1367c:	.2.../...1..-4..
   1368c:	.3..50..A2...2..
   1369c:	.1...2..%2...2..
   136ac:	./.../..51..Y2..
   136bc:	I0...1..  File  
   136cc:	  this=%x, f=%x.
   136dc:	....   SDFile th
   136ec:	is=%x, refcount=
   136fc:	%u..

00013700 <TwoWire::i2c0_hardware>:
   13700:	4..@@.....".0...
   13710:	....!./.........

00013720 <TwoWire::i2c1_hardware>:
   13720:	4..@....&:......
   13730:	..%;............

00013740 <TwoWire::i2c2_hardware>:
   13740:	(..@@...........
   13750:	............J...

00013760 <vtable for TwoWire>:
	...
   13768:	.6...6..m....6..
   13778:	]6..i6...6..

00013784 <vtable for SDClass>:
	...
   1378c:	q?...=..u=...>..
   1379c:	.=..e>...>..=?..
   137ac:	EXFAT...

000137b4 <vtable for SdSpiCard>:
	...
   137bc:	yx..}x..Ey..ex..
   137cc:	m|...{...}..e...
   137dc:	.x..}}..]x..ax..
   137ec:	}{..u{...z..u...
   137fc:	ux...~..-}..5~..

0001380c <vtable for SdioCard>:
	...
   13814:	e...............
   13824:	........q.......
   13834:	9...Y...........
   13844:	....9...U.......
   13854:	....)...........

00013864 <digital_pin_to_info_PGM>:
   13864:	@..C@..@D..CD..@
   13874:	...C...@0..C0..@
   13884:	4..C4..@...C...@
   13894:	...C...@...C...@
   138a4:	...C...@...C...@
   138b4:	...C...@...C...@
   138c4:	...C...@...C...@
   138d4:	...C...@...C...@
   138e4:	...C...@...C...@
   138f4:	...C...@...C...@
   13904:	...C...@...C...@
   13914:	...C...@...C...@
   13924:	h .Ch..@...C...@
   13934:	8..C8..@<..C<..@
   13944:	@..C@..@H..CH..@
   13954:	L..CL..@(..C(..@
   13964:	,..C,..@` .C`..@
   13974:	d .Cd..@ ..C ..@
   13984:	$..C$..@(..C(..@
   13994:	,..C,..@D..CD..@
   139a4:	p..Cp..@t..Ct..@
   139b4:	h..Ch..@P..CP..@
   139c4:	X..CX..@\..C\..@
   139d4:	T..CT..@ ..C ..@
   139e4:	$..C$..@...C...@
   139f4:	...C...@8..C8..@
   13a04:	4..C4..@0..C0..@
   13a14:	<..C<..@,..C,..@
   13a24:	( .C(..@, .C,..@
   13a34:	. .C...@. .C...@
   13a44:	. .C...@. .C...@
   13a54:	. .C...@. .C...@

00013a64 <vtable for usb_serial_class>:
	...
   13a6c:	-...%...!.......
   13a7c:	................
   13a8c:	....

00013a90 <usb_endpoint_config_table>:
   13a90:	....

00013a94 <usb_descriptor_list>:
   13a94:	.....8. ........
   13aa4:	$9. C........9. 
   13ab4:	.........9. ....
   13ac4:	....h9. ........
   13ad4:	.9. ............
   13ae4:	....

00013ae8 <_global_impure_ptr>:
   13ae8:	.9. C...POSIX...
   13af8:	....

00013afc <fpi.6173>:
   13afc:	5...............
   13b0c:	....nf..inity...
   13b1c:	an..

00013b20 <fpinan.6209>:
   13b20:	4...............
   13b30:	........

00013b38 <tinytens>:
   13b38:	.......<3...#.I9
   13b48:	=..D...2......[%
   13b58:	Co.d(.h.

00013b60 <zeroes.7258>:
   13b60:	0000000000000000
   13b70:	INF.inf.NAN.nan.
   13b80:	0123456789ABCDEF
   13b90:	....0123456789ab
   13ba0:	cdef....(null)..
   13bb0:	0...

00013bb4 <blanks.7257>:
   13bb4:	                

00013bc4 <basefix.7328>:
   13bc4:	................
   13bd4:	................
   13be4:	....e%ld....

00013bf0 <_ctype_>:
   13bf0:	.         ((((( 
   13c00:	                
   13c10:	 ...............
   13c20:	................
   13c30:	..AAAAAA........
   13c40:	................
   13c50:	..BBBBBB........
   13c60:	................
   13c70:	 ...............
	...
   13cf0:	....Infinity....
   13d00:	NaN.

00013d04 <__hexdig>:
	...
   13d34:	................
   13d44:	................
	...
   13d64:	................
	...
   13e04:	....

00013e08 <__mprec_tens>:
   13e08:	.......?......$@
   13e18:	......Y@.....@.@
   13e28:	.......@.....j.@
   13e38:	.......A......cA
   13e48:	.......A....e..A
   13e58:	... _..B....vH7B
   13e68:	......mB..@..0.B
   13e78:	.......B..4&.k.C
   13e88:	...7y.AC....W4vC
   13e98:	..Ngm..C.=.`.X.C
   13ea8:	@..x...DP.....KD
   13eb8:	..M....D.J...-.D
   13ec8:	...yCx.D

00013ed0 <__mprec_bigtens>:
   13ed0:	...7y.AC.n.....F
   13ee0:	..?..O8M2.0.Hw.Z
   13ef0:	<.s..O.u

00013ef8 <p05.6087>:
   13ef8:	........}...

00013f04 <_init>:
   13f04:	push	{r3, r4, r5, r6, r7, lr}
   13f06:	nop
   13f08:	pop	{r3, r4, r5, r6, r7}
   13f0a:	pop	{r3}
   13f0c:	mov	lr, r3
   13f0e:	bx	lr

00013f10 <__init_array_start>:
   13f10:	.word	0x0001044d

00013f14 <__frame_dummy_init_array_entry>:
   13f14:	5...1....'...)..
   13f24:	.*...*..5*..!...
   13f34:	9...i........4..
   13f44:	.4...4...4...4..
   13f54:	.5..-6..E6..A@..

Disassembly of section .fini:

00013f64 <_fini>:
   13f64:	push	{r3, r4, r5, r6, r7, lr}
   13f66:	nop
