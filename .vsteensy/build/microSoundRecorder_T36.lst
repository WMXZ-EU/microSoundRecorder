
.vsteensy/build/microSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00013864 l    d  .fini	00000000 .fini
00013868 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
200135d0 l    d  .usbbuffers	00000000 .usbbuffers
20013930 l    d  .data	00000000 .data
200147b0 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
000090e0 l     F .text	0000000c startup_default_early_hook
000090ec l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
200147b0 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
200147b4 l       .bss	00000000 object.8610
00013814 l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 myAPP.cpp
00000584 l     F .text	0000001c llwuISR()
000007dc l     F .text	00000030 getTime(char*) [clone .constprop.28]
0000080c l     F .text	00000030 getDate(char*) [clone .constprop.29]
00001e08 l     F .text	0000012c _GLOBAL__sub_I_acqParameters
20014cec l     O .bss	00000004 loop::t3
20014cf0 l     O .bss	00000004 loop::t4
1fff0200 l     O .dmabuffers	00000400 i2s_rx_buffer_32
1fff0600 l     O .dmabuffers	00022d94 setup::data
20018ef4 l     O .bss	00000028 makeFilename(char*)::filename
20018f1c l     O .bss	00000004 checkDutyCycle(ACQ_Parameters_s*, short)::t_start
20018f4c l     O .bss	00000030 wavHeader(unsigned long)::wheader
20018f7c l     O .bss	00000004 loop::loopCount
200190e8 l     O .bss	00000002 checkDutyCycle(ACQ_Parameters_s*, short)::recording
20019910 l     O .bss	00000002 loop::state
20019914 l     O .bss	00000004 loop::t0
00000000 l    df *ABS*	00000000 Time.cpp
20019918 l     O .bss	00000004 cacheTime
2001991c l     O .bss	00000007 tm
20019924 l     O .bss	00000004 sysTime
20019928 l     O .bss	00000001 Status
20019930 l     O .bss	00000004 prevMillis
2001398c l     O .data	00000004 syncInterval
00012c68 l     O .text	0000000c monthDays
20019934 l     O .bss	00000004 nextSyncTime
00000000 l    df *ABS*	00000000 output_pwm.cpp
000022a8 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE
00000000 l    df *ABS*	00000000 input_i2s.cpp
000022c0 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE
00000000 l    df *ABS*	00000000 output_pt8211.cpp
000022d8 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE
00000000 l    df *ABS*	00000000 output_adat.cpp
000022f0 l     F .text	00000018 _GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_adc.cpp
00002308 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE
00000000 l    df *ABS*	00000000 output_dac.cpp
00002320 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE
00000000 l    df *ABS*	00000000 input_adcs.cpp
00002338 l     F .text	00000030 _GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE
00000000 l    df *ABS*	00000000 input_i2s_quad.cpp
00002368 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E
00000000 l    df *ABS*	00000000 output_dacs.cpp
00002380 l     F .text	00000018 _GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE
00000000 l    df *ABS*	00000000 play_sd_wav.cpp
00002558 l     F .text	00000024 File::dec_refcount() [clone .isra.16]
00000000 l    df *ABS*	00000000 output_i2s_quad.cpp
00002928 l     F .text	00000018 _GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_i2s_oct.cpp
00002940 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E
00000000 l    df *ABS*	00000000 output_tdm.cpp
00002958 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE
00000000 l    df *ABS*	00000000 input_tdm.cpp
00002970 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE
00000000 l    df *ABS*	00000000 input_i2s_hex.cpp
00002988 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E
00000000 l    df *ABS*	00000000 input_pdm.cpp
000029a0 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE
00000000 l    df *ABS*	00000000 output_i2s.cpp
000029b8 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE
00000000 l    df *ABS*	00000000 output_spdif.cpp
000029d0 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE
00000000 l    df *ABS*	00000000 WireKinetis.cpp
200199cc l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SD.cpp
00002fd4 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
00012dd4 l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
00012dee l     O .text	0000012c lookupTable
00012f1a l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
000047e4 l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
000051ac l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
000069dc l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
000073b8 l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
000073be l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007ba0 l     F .text	00000028 sdIrs()
00007bc8 l     F .text	00000018 isBusyCommandComplete()
00007be0 l     F .text	00000010 isBusyCommandInhibit()
00007bf0 l     F .text	00000014 isBusyDat()
00007c04 l     F .text	0000000c isBusyDMA()
00007c10 l     F .text	00000014 isBusyFifoRead()
00007c24 l     F .text	00000014 isBusyFifoWrite()
00007c38 l     F .text	00000018 isBusyTransferComplete()
00007c50 l     F .text	00000098 setSdclk(unsigned long)
00007d4c l     F .text	00000024 waitTimeout(bool (*)())
00007d70 l     F .text	00000040 yieldTimeout(bool (*)())
00007de0 l     F .text	00000054 cardCommand(unsigned long, unsigned long)
00007e34 l     F .text	00000020 statusCMD13()
00007e54 l     F .text	00000010 isBusyCMD13()
00007e68 l     F .text	00000068 readReg16(unsigned long, void*)
00007ed0 l     F .text	00000020 waitDmaStatus() [clone .part.4]
00007ef0 l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
000080c8 l     F .text	0000005c waitTransferComplete()
00008464 l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
20019ea8 l     O .bss	00000001 m_version2
20019ea9 l     O .bss	00000010 m_cid
20019ebc l     O .bss	00000004 m_busyFcn
20019ec0 l     O .bss	00000001 m_highCapacity
20019ec4 l     O .bss	00000004 m_ocr
20019ec8 l     O .bss	00000004 m_rca
20019ecc l     O .bss	00000001 m_transferActive
20019ed0 l     O .bss	00000004 m_irqstat
20013d44 l     O .data	00000001 m_errorCode
20019ed4 l     O .bss	00000001 m_initDone
20019ed5 l     O .bss	00000010 m_csd
20019ee5 l     O .bss	00000001 m_dmaBusy
20019ee8 l     O .bss	00000004 m_sdClkKhz
20019eec l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 SdSpiChipSelect.cpp
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
20019ef1 l     O .bss	00000001 tx_noautoflush
20019ef4 l     O .bss	00000004 tx_packet
20019ef8 l     O .bss	00000001 transmit_previous_timeout
20019efc l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 analog.c
20019f01 l     O .bss	00000001 calibrating
20013d45 l     O .data	00000001 analog_config_bits
20019f02 l     O .bss	00000001 analog_reference_internal
20013d46 l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 pins_teensy.c
0000915c l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
20013d4c l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
00009414 l     F .text	00000040 endpoint0_transmit
20019f08 l     O .bss	00000004 ep0_tx_ptr
20019f0c l     O .bss	00000010 rx_last
20019f1c l     O .bss	00000004 tx_state
20019f20 l     O .bss	00000040 ep0_rx0_buf
20019f60 l     O .bss	00000010 rx_first
20019f70 l     O .bss	00000001 ep0_tx_bdt_bank
20019f74 l     O .bss	00000040 ep0_rx1_buf
20019fb4 l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
20019fc4 l     O .bss	00000010 tx_last
20019fd4 l     O .bss	00000008 setup
20019fdc l     O .bss	00000002 ep0_tx_len
20019fdf l     O .bss	00000008 reply_buffer
20019fe8 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
20019fe9 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 AudioStream.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 usb_desc.c
20013d65 l     O .data	00000012 device_descriptor
20013d90 l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _arm_addsubsf3.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000b454 l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000c3fc l     F .text	00000038 sulp
000133fc l     O .text	00000014 fpi.6173
00013420 l     O .text	00000014 fpinan.6209
00013438 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000d330 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00013460 l     O .text	00000010 zeroes.7258
000134b4 l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
000134c4 l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000fb4c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000fb6c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00010d60 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
000137f8 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 strtoll.c
00011ebc l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
0001208c l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00012218 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
20013e08 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
200147b0 l       .bss	00000000 __bss_start__
2001a0f0 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
00005840  w    F .text	00000026 FatPartition::cacheSync()
000090d8  w    F .text	00000006 adc0_isr
00002474  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
00003428 g     F .text	000000a4 toUpcase(unsigned short)
0000acec g     F .text	0000002c .hidden __aeabi_dcmpun
00008dbc g     F .text	0000001c usb_serial_available
20019104 g     O .bss	00000008 I2S_32::dma
00011de8 g     F .text	0000005e __any_on
0000acb0 g     F .text	00000012 .hidden __aeabi_dcmple
0000c1b0 g     F .text	000000ba strcpy
000065e0 g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000abec g     F .text	0000007a .hidden __cmpdf2
2001a008 g     O .bss	00000004 AudioStream::memory_pool
000083ec g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009c60  w    F .text	000000d8 yield
00006420 g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000abec g     F .text	0000007a .hidden __eqdf2
00007328  w    F .text	00000002 SdSpiCard::~SdSpiCard()
20013d78 g     O .data	00000018 usb_string_manufacturer_name_default
000063b8 g     F .text	00000068 FatFile::truncate()
20013c08 g     O .data	0000013c Wire1
0000362c g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
0000a75c g     F .text	0000005a .hidden __floatdidf
000090a4  w    F .text	00000034 hard_fault_isr
000090d8  w    F .text	00000006 dma_ch6_isr
2001a00c g     O .bss	00000001 AudioStream::update_scheduled
20019e98 g     O .bss	00000004 FsDateTime::callback
00002ecc  w    F .text	00000050 SdBase<FsVolume>::restart()
20013964 g     O .data	00000028 acqParameters
000013ce g     F .text	00000026 boundaryCheck(int, int, int)
0000527c g     F .text	0000005c FatFormatter::initPbs()
00009ec8 g     F .text	00000020 Print::println()
00002a88 g     F .text	00000114 TwoWire::isr()
2001a084 g     O .bss	00000002 AudioStream::memory_used
000090d8  w    F .text	00000006 uart0_lon_isr
00003ec0 g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
000094b0 g     F .text	00000078 usb_rx_memory
0000730c  w    F .text	00000004 SdSpiCard::errorCode() const
000023c0  w    F .text	0000000c File::flush()
0000240e  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
000090d8  w    F .text	00000006 dma_ch8_isr
00001430 g     F .text	000003c0 doMenu()
0000bc30 g     F .text	00000002 __malloc_unlock
000073d8 g     F .text	00000026 SdSpiCard::spiStart()
000028a0  w    F .text	00000088 SDFile::openNextFile(unsigned char)
20019ea4 g     O .bss	00000004 FsVolume::m_cwv
00005e64 g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
00008fec g     F .text	000000b8 analog_init
00009528 g     F .text	00000080 usb_tx
0000d310 g     F .text	00000020 _strtod_r
000090d8  w    F .text	00000006 portcd_isr
0000f9fc g     F .text	0000004a _vdprintf_r
00005f4e g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
0000a430 g     F .text	00000018 .hidden __aeabi_llsr
00012cc4  w    O .text	0000005c vtable for SDFile
000125e8 g     F .text	00000082 _sfread_r
0000bb64 g     F .text	000000c6 memmove
20019980 g     O .bss	00000008 AudioOutputAnalogStereo::dma
0000b490 g     F .text	00000014 __locale_ctype_ptr
00008a54 g     F .text	00000060 SdioCard::stopTransmission(bool)
00011560 g     F .text	0000004c _Balloc
000090d8  w    F .text	00000006 can1_rx_warn_isr
00013870 g       .ARM.exidx	00000000 __exidx_end
000090d8  w    F .text	00000006 dma_error_isr
00002e92  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
00006830 g     F .text	00000046 FatPartition::freeChain(unsigned long)
20019ffc g     O .bss	00000001 EventResponder::runningFromYield
000075be g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
00002b9c g     F .text	0000000c i2c0_isr
00009e9e g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000abdc g     F .text	0000008a .hidden __gtdf2
0000b3f8 g     F .text	0000000c __errno
0000265a  w    F .text	0000000a SDFile::isDirectory()
00004dca g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
00002398  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
000090d8  w    F .text	00000006 portd_isr
000090d8  w    F .text	00000006 enet_error_isr
0000763a  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
00012d60 g     O .text	00000020 TwoWire::i2c2_hardware
0000257c  w    F .text	0000001c File::~File()
00000cec g     F .text	00000070 makeFilename(char*)
20019fec g     O .bss	00000004 EventResponder::firstInterrupt
200190f0 g     O .bss	00000014 patchCord2
000114e4 g     F .text	00000004 __localeconv_l
0000732a  w    F .text	0000000e SdSpiCard::~SdSpiCard()
0000357e g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
000070be g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
000090d8  w    F .text	00000006 tpm1_isr
000047cc g     F .text	00000018 ExFatPartition::rootLength()
000008a0  w    F .text	00000014 Print::println(__FlashStringHelper const*)
00002824  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
00007310  w    F .text	00000004 SdSpiCard::errorData() const
00009e90  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00013164 g     O .text	00000200 digital_pin_to_info_PGM
0000671e g     F .text	00000092 FatPartition::allocContiguous(unsigned long, unsigned long*)
2001a0ec g     O .bss	00000004 errno
0000780c g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
00004558 g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000c0dc g     F .text	00000004 __seofread
00013870 g       .ARM.exidx	00000000 _etext
200147b0 g       .bss	00000000 _sbss
000052d8 g     F .text	0000005c FatFormatter::writeMbr()
00008b40  w    F .text	00000006 sdCsInit(unsigned char)
00002f80 g     F .text	00000054 SDClass::mediaPresent()
0000ac78 g     F .text	00000010 .hidden __aeabi_cdcmple
00007cf4 g     F .text	0000000c SdioCard::errorData() const
00002708  w    F .text	00000018 FsBaseFile::peek()
0000ae54 g     F .text	00000160 .hidden __aeabi_fadd
0000832c g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
0000ae50 g     F .text	00000164 .hidden __subsf3
000091a0 g     F .text	0000001c digitalRead
000090d8  w    F .text	00000006 porte_isr
00001b0c g     F .text	000002fc loop
0000a10c g     F .text	0000001a AudioStream::receiveReadOnly(unsigned int)
000090d8  w    F .text	00000006 portb_isr
000090d8  w    F .text	00000006 spi1_isr
000090d8  w    F .text	00000006 uart3_status_isr
00003c94 g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
000090d8  w    F .text	00000006 mcm_isr
00008858 g     F .text	000000c4 SdioCard::readData(unsigned char*)
0000a2d0 g     F .text	00000026 Stream::peekNextDigit()
00000734  w    F .text	00000010 c_uSD::~c_uSD()
00007456 g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
20019ff0 g     O .bss	00000004 EventResponder::lastInterrupt
0000b094 g     F .text	00000024 .hidden __aeabi_f2lz
000090d8  w    F .text	00000006 uart1_status_isr
00007120 g     F .text	00000028 FsBaseFile::close()
00008b4c g     F .text	000001a6 memcpy
000090d8  w    F .text	00000006 randnum_isr
00011348 g     F .text	00000180 __hexnan
0000ac68 g     F .text	00000020 .hidden __aeabi_cdrcmple
000023a4  w    F .text	0000000c File::available()
000008b4  w    F .text	00000018 Print::println(unsigned long)
00003038 g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
0000078c  w    F .text	00000050 mRecordQueue<500>::update()
0000463e g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
00005b1c g     F .text	00000028 FatFile::peek()
0000d490 g     F .text	000016e4 _svfprintf_r
0000a6ec g     F .text	00000022 .hidden __floatsidf
20019988  w    O .bss	00000001 SDFile::name()::zeroterm
20019f04 g     O .bss	00000004 systick_millis_count
0000abe4 g     F .text	00000082 .hidden __ltdf2
00004d24 g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
000090a4  w    F .text	00000034 bus_fault_isr
0000251c  w    F .text	0000003c SDFile::truncate(unsigned long long)
000090d8  w    F .text	00000006 watchdog_isr
0000b064 g     F .text	00000000 .hidden __aeabi_uldivmod
00002ba8 g     F .text	0000000c i2c1_isr
20019fe7 g     O .bss	00000001 usb_configuration
000090d8  w    F .text	00000006 dma_ch11_isr
0000057c  w    F .text	00000006 SdCardInterface::status()
00008ab4 g     F .text	0000001c SdioCard::syncDevice()
000081ac g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
000005a0  w    F .text	00000054 StreamFile<FsBaseFile, unsigned long long>::available()
00005b44 g     F .text	0000003a FatFile::readDirCache(bool)
00011d40 g     F .text	00000060 __ratio
00002bb4 g     F .text	0000000c i2c2_isr
2001a010 g     O .bss	00000070 AudioStream::memory_pool_available_mask
20019960 g     O .bss	00000008 AudioOutputAnalog::dma
20013d78  w    O .data	00000018 usb_string_manufacturer_name
2001a0e4 g     O .bss	00000008 usb_rx_byte_count_data
000090d8  w    F .text	00000006 pit1_isr
0000b4a4 g     F .text	00000010 malloc
20018f48 g     O .bss	00000004 maxNoise
000090d8  w    F .text	00000006 dma_ch4_isr
00012d40 g     O .text	00000020 TwoWire::i2c1_hardware
2001910c g     O .bss	000007fc queue
0000a224 g     F .text	00000074 software_isr
000073c4  w    F .text	00000014 SysCall::curTimeMS()
00002f1c g     F .text	00000064 SDClass::format(int, char, Print&)
000127e0  w    O .text	00000024 vtable for FsFile
000114c8 g     F .text	0000001c iswspace
000090d8  w    F .text	00000006 dma_ch7_isr
000029f4  w    F .text	0000001e TwoWire::read()
0000afbc g     F .text	0000001c .hidden __aeabi_i2f
00013708 g     O .text	000000c8 __mprec_tens
00009bcc g     F .text	00000094 usb_init
00000b20 g     F .text	00000010 I2S_stopClock()
2001a082 g     O .bss	00000002 AudioStream::memory_pool_first_mask
00007324  w    F .text	00000004 SdSpiCard::type() const
0000ad68 g     F .text	00000040 .hidden __fixunsdfsi
000090d8  w    F .text	00000006 lptmr_isr
00002734  w    F .text	00000058 SDFile::seek(unsigned long long, int)
2001a0ac g     O .bss	00000004 __malloc_top_pad
0000913c g     F .text	00000020 rtc_set
000125ac g     F .text	0000003a __ssrefill_r
000074b6 g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00004edc g     F .text	000000be ExFatFile::truncate()
20013930 g     O .data	00000000 .hidden __dso_handle
0000a6cc g     F .text	0000001e .hidden __aeabi_ui2d
0000083c  w    F .text	00000048 AudioStream::AudioStream(unsigned char, audio_block_struct**)
000114e8 g     F .text	0000001c _localeconv_r
00012404 g     F .text	00000024 _strtoull_r
00009120 g     F .text	00000010 attachInterruptVector
00011774 g     F .text	00000012 __i2b
20013930 g       .data	00000000 _sdata
2001990c g     O .bss	00000004 maxValue
00012d20 g     O .text	00000020 TwoWire::i2c0_hardware
00005438 g     F .text	000001a8 FatFormatter::makeFat32()
0000b104 g     F .text	000002e2 .hidden __udivmoddi4
0000a448 g     F .text	00000000 .hidden __aeabi_drsub
00005866 g     F .text	00000036 FatFile::addCluster()
0000c014 g     F .text	00000024 _sbrk_r
00007844 g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
00007dc0 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
00008d38 g     F .text	0000004c usb_serial_getchar
000090d8  w    F .text	00000006 can1_bus_off_isr
000090d8  w    F .text	00000006 ftm2_isr
000024dc  w    F .text	00000040 SDFile::name()
2001a0d8 g     O .bss	00000008 usb_cdc_line_coding
00009160 g     F .text	00000040 digitalWrite
20019ff4 g     O .bss	00000004 EventResponder::lastYield
000090d8  w    F .text	00000006 uart5_status_isr
000090d8  w    F .text	00000006 lpuart0_status_isr
00003c6e g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
0001338e g     O .text	00000004 usb_endpoint_config_table
000090d8  w    F .text	00000006 dma_ch9_isr
00000884  w    F .text	0000001c Print::write(char const*)
00000c6c  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
000090d8  w    F .text	00000006 pit2_isr
00003514 g     F .text	00000028 ExFatFormatter::syncUpcase()
000027ee  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000ac9c g     F .text	00000012 .hidden __aeabi_dcmplt
20019080 g     O .bss	00000050 logFile
2001a0a8 g     O .bss	00000004 __malloc_max_sbrked_mem
000025c4  w    F .text	00000018 SDFile::position()
000091bc g     F .text	00000064 pinMode
00007a9a g     F .text	00000028 SdSpiCard::writeStop()
20018f80 g     O .bss	00000100 tempBuffer
000093d0 g     F .text	00000044 usb_free
000090d8  w    F .text	00000006 i2c3_isr
0000a710 g     F .text	0000003a .hidden __extendsfdf2
0000eb74 g     F .text	00000e88 __ssvfscanf_r
0000aa0c g     F .text	000001d0 .hidden __aeabi_ddiv
00000c54  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
0000a454 g     F .text	00000276 .hidden __adddf3
20013990 g     O .data	0000013c Wire2
00007b0e g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
000023b0  w    F .text	00000010 File::peek()
00006878 g     F .text	0000005c FatPartition::freeClusterCount()
00002de4  w    F .text	00000078 SDClass::open(char const*, unsigned char)
00011bb4 g     F .text	000000d0 __b2d
000019f8  w    F .text	00000028 SdBase<FsVolume>::errorHalt(char const*)
00013868 g       .ARM.exidx	00000000 __exidx_start
0000a7b8 g     F .text	00000254 .hidden __aeabi_dmul
00000780  w    F .text	0000000c DMAChannel::~DMAChannel()
000079d8 g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
000090d8  w    F .text	00000006 pit0_isr
20019ff8 g     O .bss	00000004 EventResponder::firstYield
000133e8 g     O .text	00000004 _global_impure_ptr
000090d8  w    F .text	00000006 can1_error_isr
000030cc g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000cd2  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00002864  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000bc34 g     F .text	000003de _realloc_r
0000272a  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000b404 g     F .text	00000050 __libc_init_array
2001a0f0 g       .bss	00000000 __bss_end
00002664  w    F .text	00000028 SDFile::rewindDirectory()
000029e8  w    F .text	0000000c TwoWire::available()
000090d8  w    F .text	00000006 can0_wakeup_isr
0000439a g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
00007d00 g     F .text	0000001c SdioCard::readCID(CID*)
00013604 g     O .text	00000100 __hexdig
00004ac2 g     F .text	000000de ExFatFile::addDirCluster()
000090d8  w    F .text	00000006 flash_cmd_isr
00007920 g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00007ac2 g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
000137d0 g     O .text	00000028 __mprec_bigtens
00011640 g     F .text	00000098 __s2b
00009e78  w    F .text	00000004 usb_serial_class::clear()
0000a6cc g     F .text	0000001e .hidden __floatunsidf
000090d8  w    F .text	00000006 uart2_status_isr
000090f0 g     F .text	0000002c _sbrk
00000474 g     F .text	0000009c I2S_32::isr32()
00011a08 g     F .text	00000042 __mcmp
00012da4 g     O .text	00000030 vtable for SDClass
2001999c g     O .bss	00000008 AudioOutputTDM::dma
20013d48 g     O .data	00000004 __brkval
20019f00 g     O .bss	00000001 usb_cdc_line_rtsdtr
00002060 g     F .text	00000020 refreshCache(long)
00008fa4 g     F .text	00000048 usb_serial_flush_callback
00013804 g     F .text	00000000 _init
00005928 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
000090d8  w    F .text	00000006 svcall_isr
00009f98 g     F .text	00000070 AudioStream::initialize_memory(audio_block_struct*, unsigned int)
00002c5a  w    F .text	00000056 SDClass::remove(char const*)
000026a8  w    F .text	00000026 SDFile::close()
000090d8  w    F .text	00000006 dma_ch15_isr
000026d0  w    F .text	00000024 SDFile::~SDFile()
0000ada8 g     F .text	0000009e .hidden __aeabi_d2f
00002254 g     F .text	00000014 day()
0000ae50 g     F .text	00000164 .hidden __aeabi_fsub
00012d80 g     O .text	00000024 vtable for TwoWire
000090d8  w    F .text	00000006 uart1_error_isr
00010acc g     F .text	00000028 __libc_fini_array
0000c438 g     F .text	00000ed8 _strtod_l
00011318 g     F .text	00000030 __match
000090d8  w    F .text	00000006 usbhs_phy_isr
20019968 g     O .bss	00000008 AudioInputAnalogStereo::dma0
200190d0 g     O .bss	00000018 acq
2001a0f0 g       .bss	00000000 _ebss
000082b4 g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00006132 g     F .text	00000042 FatFile::preAllocate(unsigned long)
20019950 g     O .bss	00000008 AudioOutputADAT::dma
00000760  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::flush()
00000548  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
000116d8 g     F .text	00000040 __hi0bits
00003be2 g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000ad18 g     F .text	0000004e .hidden __fixdfsi
00004ba0 g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
000090d8 g     F .text	00000006 unused_isr
00002864  w    F .text	0000003c SDFile::SDFile(FsFile const&)
000090d8  w    F .text	00000006 spi0_isr
0000afe8 g     F .text	0000007c .hidden __floatdisf
000090d8  w    F .text	00000006 dma_ch3_isr
00002bc0  w    F .text	00000002 SDClass::~SDClass()
00000780  w    F .text	0000000c DMAChannel::~DMAChannel()
20014ef4 g     O .bss	00004000 diskBuffer
20018f24 g     O .bss	00000020 text
00001104 g     F .text	00000020 rtcSetup()
00001068 g     F .text	0000009c c_uSD::loadConfig(unsigned long*, int, long*, int)
00006c92 g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
0000257c  w    F .text	0000001c File::~File()
000127b0  w    O .text	0000000c vtable for mRecordQueue<500>
000055e0 g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
0000227c g     F .text	0000000e year()
0000569a g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
0000a362 g     F .text	00000004 operator delete(void*, unsigned int)
000090d8  w    F .text	00000006 flash_error_isr
0000a430 g     F .text	00000018 .hidden __lshrdi3
0000a454 g     F .text	00000276 .hidden __aeabi_dadd
0000abe4 g     F .text	00000082 .hidden __ledf2
000009a0 g     F .text	000000d0 I2S_32::begin()
000090d8  w    F .text	00000006 uart5_error_isr
0000b0b8 g     F .text	0000004c .hidden __aeabi_f2ulz
000090d8  w    F .text	00000006 rtc_seconds_isr
000090d8  w    F .text	00000006 pdb_isr
000118b8 g     F .text	000000a0 __pow5mult
00005d84 g     F .text	0000004e FatFile::rmdir()
0000a74c g     F .text	0000006a .hidden __aeabi_ul2d
000090a4  w    F .text	00000034 usage_fault_isr
000090d8  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
000067b0 g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
000090d8  w    F .text	00000006 dma_ch14_isr
00009e22  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
00002bc2  w    F .text	00000044 SDClass::exists(char const*)
00000744 g     F .text	00000004 getTeensy3Time()
00000000  w      *UND*	00000000 __deregister_frame_info
2001a0e0 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
00001124 g     F .text	00000024 rtcSetAlarm(unsigned long)
00009e68 g     F .text	00000010 systick_isr
000090d8  w    F .text	00000006 rtc_alarm_isr
00000a70 g     F .text	000000b0 I2S_dividers(unsigned long*, unsigned long, unsigned long)
000078ba g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
2001a000 g     O .bss	00000004 AudioStream::first_update
000090d8  w    F .text	00000006 dma_ch2_isr
00000d5c g     F .text	00000094 wavHeader(unsigned long)
20013d54 g     O .data	00000010 Serial
2001a004 g     O .bss	00000002 AudioStream::memory_used_max
00002080 g     F .text	00000014 year(long)
000090d8  w    F .text	00000006 ftm1_isr
00000774  w    F .text	0000000c AudioConnection::~AudioConnection()
00009e98  w    F .text	00000006 usb_serial_class::write(unsigned char)
000071c6 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
000090e0  w    F .text	0000000c startup_early_hook
00007b3a g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
000090d8  w    F .text	00000006 dma_ch13_isr
00004838 g     F .text	00000092 ExFatFile::addCluster()
00012c98  w    O .text	0000002c vtable for File
000090d8  w    F .text	00000006 uart2_error_isr
00002dac  w    F .text	00000036 SDClass::usedSize()
00008d84 g     F .text	00000038 usb_serial_peekchar
0000acd8 g     F .text	00000012 .hidden __aeabi_dcmpgt
0000ba60 g     F .text	00000000 memchr
000066c2 g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
20013dee g     O .data	00000016 usb_string_serial_number_default
000090a4 g     F .text	00000034 fault_isr
00010b90 g     F .text	000001d0 _free_r
00008124 g     F .text	00000088 SdioCard::readStop()
000033da g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000b46c g     F .text	0000001c __locale_mb_cur_max
0000acc4 g     F .text	00000012 .hidden __aeabi_dcmpge
000090d8  w    F .text	00000006 usb_charge_isr
00002154 g     F .text	00000040 setTime(long)
00006b6a g     F .text	00000128 FatFile::makeSFN(FatName_t*)
00009e88  w    F .text	00000004 usb_serial_class::flush()
0000359a g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
00012528 g     F .text	00000082 _sungetc_r
000090d8  w    F .text	00000006 cmt_isr
0000a450 g     F .text	0000027a .hidden __aeabi_dsub
000068d4 g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
000090d8  w    F .text	00000006 usbhs_isr
200147ac g     O .data	00000004 __malloc_sbrk_base
00009e80  w    F .text	00000004 usb_serial_class::read()
000090d8  w    F .text	00000006 ftm3_isr
00012068 g     F .text	00000024 _strtoll_r
20019908 g     O .bss	00000002 I2S_32::block_offset
000090d8  w    F .text	00000006 tsi0_isr
0000700c g     F .text	000000b2 FatFile::remove()
200147cc g     O .bss	00000520 uSD
0000a74c g     F .text	0000006a .hidden __floatundidf
0000911c  w    F .text	00000002 __cxa_pure_virtual
00011958 g     F .text	000000ae __lshift
00006088 g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000090d8  w    F .text	00000006 spi2_isr
20019970 g     O .bss	00000008 AudioInputAnalogStereo::dma1
0000afbc g     F .text	0000001c .hidden __floatsisf
00012428 g     F .text	00000100 __ssprint_r
000126e4 g     F .text	0000005e _vasnprintf_r
00000b30 g     F .text	00000010 I2S_stop()
0000a35c  w    F .text	00000002 serialEvent()
20019f71 g     O .bss	00000001 usb_reboot_timer
20019938 g     O .bss	00000008 AudioOutputPWM::dma
0000faa8 g     F .text	000000a4 __register_exitproc
000042e0 g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000228c g     F .text	0000001c setSyncProvider(long (*)())
0000c35c g     F .text	000000a0 strncmp
000027aa  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
0000124c g     F .text	00000144 checkDutyCycle(ACQ_Parameters_s*, short)
00004be8 g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
00005334 g     F .text	00000104 FatFormatter::makeFat16()
0000083c  w    F .text	00000048 AudioStream::AudioStream(unsigned char, audio_block_struct**)
00008dd8 g     F .text	00000030 usb_serial_flush_input
0000469c g     F .text	00000064 ExFatPartition::freeClusterCount()
00012c5c g     O .text	0000000c vtable for I2S_32
00011788 g     F .text	00000130 __multiply
00008ee8 g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
2001a0b0 g     O .bss	00000028 __malloc_current_mallinfo
00011c84 g     F .text	000000ba __d2b
2001a088 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
000090d8  w    F .text	00000006 can0_bus_off_isr
00007db0  w    F .text	0000000e SdioCard::~SdioCard()
000008cc g     F .text	000000d4 I2S_32::config_i2s()
20019fde g     O .bss	00000001 usb_rx_memory_needed
00008240 g     F .text	00000074 SdioCard::writeStart(unsigned long)
000121f4 g     F .text	00000024 _strtoul_r
000095a8 g     F .text	00000624 usb_isr
0000b3ec g     F .text	0000000c __cxa_atexit
00003d10 g     F .text	00000184 ExFatFile::read(void*, unsigned int)
0000a200 g     F .text	00000024 AudioStream::update_setup()
0000a6ec g     F .text	00000022 .hidden __aeabi_i2d
0000b094 g     F .text	00000024 .hidden __fixsfdi
00002720  w    F .text	0000000a SDFile::peek()
0000338e g     F .text	0000004c FsCache::sync()
0000a356 g     F .text	00000006 Stream::parseInt()
0000bb00 g     F .text	00000062 memcmp
20018f20 g     O .bss	00000004 I2S_32::block_right
00013364  w    O .text	00000028 vtable for usb_serial_class
00006a96 g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
000090d8  w    F .text	00000006 uart3_error_isr
0000afd8 g     F .text	0000008c .hidden __floatundisf
20013938 g     O .data	00000005 postfix
00008b46  w    F .text	00000004 sdCsWrite(unsigned char, bool)
0000a298 g     F .text	00000038 Stream::timedPeek()
0000c084 g     F .text	00000058 sscanf
0000b3e8  w    F .text	00000002 .hidden __aeabi_ldiv0
00004950 g     F .text	00000052 ExFatFile::rmdir()
200199ac g     O .bss	00000008 AudioInputI2SHex::dma
000090d8  w    F .text	00000006 porta_isr
00002d66  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000aa0c g     F .text	000001d0 .hidden __divdf3
00001148 g     F .text	00000104 setWakeupCallandSleep(unsigned long)
00011da0 g     F .text	00000046 __copybits
200135d0 g     O .usbbuffers	00000360 usb_buffer_memory
00007338 g     F .text	00000080 SdSpiCard::sectorCount()
000090d8  w    F .text	00000006 low_voltage_isr
200143a0 g     O .data	00000408 __malloc_av_
0000afb4 g     F .text	00000024 .hidden __aeabi_ui2f
000090d8  w    F .text	00000006 can0_error_isr
00009288 g     F .text	0000010c _init_Teensyduino_internal_
20013934 g     O .data	00000004 outptr
000027a0  w    F .text	0000000a SDFile::flush()
0000a7b8 g     F .text	00000254 .hidden __muldf3
00008f48 g     F .text	0000005c usb_serial_flush_output
000090d8  w    F .text	00000006 dma_ch12_isr
20019940 g     O .bss	00000008 AudioInputI2S::dma
0000bc2c g     F .text	00000002 __malloc_lock
00003ad0 g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
000090d8  w    F .text	00000006 can1_wakeup_isr
20013400 g     O .dmabuffers	000001d0 _VectorsRam
000051d4 g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00012744 g     F .text	0000005e _calloc_r
000090d8  w    F .text	00000006 pit3_isr
2001992c g     O .bss	00000004 getTimePtr
20013d50 g     O .data	00000001 yield_active_check_flags
000090d8  w    F .text	00000006 enet_rx_isr
00004a84 g     F .text	0000003e ExFatFile::sync()
00006174 g     F .text	00000196 FatFile::rename(FatFile*, char const*)
00008ad0 g     F .text	00000070 SdioCard::isBusy()
000090d8  w    F .text	00000006 portc_isr
00007996 g     F .text	00000026 SdSpiCard::readStop()
00000b40 g     F .text	000000f0 I2S_modification(unsigned long, unsigned short, int)
20019978 g     O .bss	00000008 AudioInputI2SQuad::dma
00008cf4 g     F .text	00000000 memset
00009f86 g     F .text	00000010 main
200199bc g     O .bss	00000008 AudioOutputI2S::dma
2001a0a4 g     O .bss	00000004 __malloc_max_total_mem
000043d6 g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
0000afe8 g     F .text	0000007c .hidden __aeabi_l2f
200190ec g     O .bss	00000004 I2S_32::block_left
00002194 g     F .text	00000084 now()
00004f9c g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
000090a4  w    F .text	00000034 memmanage_fault_isr
00003300 g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
20013940 g     O .data	00000020 snipParameters
00005f1a g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00002630  w    F .text	0000000a SDFile::available()
0000a368 g     F .text	00000070 usb_init_serialnumber
00001390 g     F .text	0000003e setRTCTime(int, int, int, int, int, int)
0000d468 g     F .text	00000024 _strtol_r
0000ada8 g     F .text	0000009e .hidden __truncdfsf2
00013864 g       .text	00000000 __init_array_end
0000fc98 g     F .text	00000e34 _dtoa_r
0000b4c4 g     F .text	00000570 _malloc_r
2001a0a0 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
000090d8  w    F .text	00000006 debugmonitor_isr
0000fa60 g     F .text	0000001a __ascii_wctomb
0000269e  w    F .text	0000000a SDFile::isOpen()
000070be g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a75c g     F .text	0000005a .hidden __aeabi_l2d
20019ea0 g     O .bss	00000004 FatVolume::m_cwv
20019994 g     O .bss	00000008 AudioInputI2SOct::dma
0001266c g     F .text	00000078 __submore
61d5b976 g       *ABS*	00000000 __rtc_localtime
00009220 g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
00000df0 g     F .text	00000158 c_uSD::init()
0000afd8 g     F .text	0000008c .hidden __aeabi_ul2f
000090d8  w    F .text	00000006 cmp1_isr
0000b0b8 g     F .text	0000004c .hidden __fixunssfdi
000090d8  w    F .text	00000006 ftm0_isr
20013960 g     O .data	00000002 mustStore
000049a4 g     F .text	000000e0 ExFatFile::syncDir()
00010af4 g     F .text	0000009c _malloc_trim_r
20013dea g     O .data	00000004 string0
00008e08 g     F .text	000000e0 usb_serial_write
000090ec  w    F .text	00000002 startup_late_hook
000025dc  w    F .text	00000054 FsBaseFile::available() const
00009e84  w    F .text	00000004 usb_serial_class::available()
00000f48 g     F .text	00000080 c_uSD::close()
20013d64 g     O .data	00000001 _serialEvent_default
00005dd4 g     F .text	00000080 FatFile::sync()
000069fa g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
00002cb0  w    F .text	0000004e SDClass::mkdir(char const*)
00004812  w    F .text	00000026 ExFatPartition::cacheSync()
20013dd4  w    O .data	00000016 usb_string_product_name
0000925c g     F .text	0000002a delay
0000abec g     F .text	0000007a .hidden __nedf2
000090d8  w    F .text	00000006 tpm0_isr
20019fea g     O .bss	00000002 dma_channel_allocated_mask
00003c4e g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000c8c  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00013864 g     F .fini	00000000 _fini
0000278c  w    F .text	00000014 FsBaseFile::sync()
00002a2a g     F .text	00000026 TwoWire::write(unsigned char)
20019948 g     O .bss	00000008 AudioOutputPT8211::dma
00002268 g     F .text	00000014 month()
00001a20 g     F .text	000000ec c_uSD::write(short*, long)
0000788a g     F .text	00000030 SdSpiCard::readStart(unsigned long)
000043a8 g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
00007520 g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
00009ef6 g     F .text	0000001a Print::printf(char const*, ...)
0000c038 g     F .text	0000004c sprintf
000090d8  w    F .text	00000006 i2s0_rx_isr
000090d8  w    F .text	00000006 uart4_error_isr
00005e54 g     F .text	00000010 FatFile::close()
000026f4  w    F .text	00000014 SDFile::~SDFile()
0000fb60 g     F .text	0000000c atexit
00007d48  w    F .text	00000002 SdioCard::~SdioCard()
00000748  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::peek()
000023f2  w    F .text	0000001c File::write(unsigned char)
0000fa7c g     F .text	0000002c _write_r
000005f4 g     F .text	0000008c I2S_32::update()
200199d0 g     O .bss	000004c8 SD
00007ff0 g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
20018f44 g     O .bss	00000001 I2S_32::update_responsibility
00006638  w    F .text	00000020 FsCache::clear()
0000ae48 g     F .text	0000016c .hidden __aeabi_frsub
0000a094 g     F .text	00000050 AudioStream::release(audio_block_struct*)
000090d8  w    F .text	00000006 can0_message_isr
0000a418 g     F .text	0000000c nanf
20014230 g     O .data	00000004 _impure_ptr
00012c74  w    O .text	00000024 vtable for Stream
000090d8  w    F .text	00000006 can1_message_isr
00003e94 g     F .text	0000002c ExFatFile::peek()
000127bc  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
200199c4 g     O .bss	00000008 AudioOutputSPDIF::dma
00011504 g     F .text	0000005c _mbrtowc_r
000090d8  w    F .text	00000006 nmi_isr
20013acc g     O .data	0000013c Wire
0000285a  w    F .text	0000000a SDFile::write(void const*, unsigned int)
0000a0e4 g     F .text	00000028 AudioStream::transmit(audio_block_struct*, unsigned char)
000072e0 g     F .text	00000028 FsVolume::open(char const*, int)
00007ce8 g     F .text	0000000c SdioCard::errorCode() const
00005f0c g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000cc8  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
00013810 g       .text	00000000 __preinit_array_end
00000680 g     F .text	0000009c dateTime(unsigned short*, unsigned short*, unsigned char*)
00007328  w    F .text	00000002 SdSpiCard::~SdSpiCard()
200199a4 g     O .bss	00000008 AudioInputTDM::dma
000090d8  w    F .text	00000006 sdhc_isr
0000222c g     F .text	00000014 minute()
0000071c  w    F .text	00000018 FsFile::~FsFile()
00004700 g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
00004ca6 g     F .text	0000007e ExFatFile::preAllocate(unsigned long long)
00004522 g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00007a08 g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000ba34 g     F .text	0000002a __ascii_mbtowc
00007424 g     F .text	00000032 SdSpiCard::isBusy()
00011b60 g     F .text	00000054 __ulp
000130a4 g     O .text	00000060 vtable for SdSpiCard
0000a008 g     F .text	0000008c AudioStream::allocate()
20014cf4 g     O .bss	00000200 header
00007882  w    F .text	00000008 SdSpiCard::readCID(CID*)
00002a12  w    F .text	00000016 TwoWire::peek()
00002a28  w    F .text	00000002 TwoWire::flush()
000017f0 g     F .text	00000170 setup
00013394 g     O .text	00000054 usb_descriptor_list
00009454 g     F .text	00000038 usb_rx
00007e64 g     F .text	00000004 SdioCard::status()
000090d8  w    F .text	00000006 dma_ch10_isr
00005f6e g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000470  w    F .text	00000002 Print::flush()
0000268c  w    F .text	00000012 FsBaseFile::isOpen() const
0000ad68 g     F .text	00000040 .hidden __aeabi_d2uiz
00000fc8 g     F .text	000000a0 c_uSD::storeConfig(unsigned long*, int, long*, int)
000090d8  w    F .text	00000006 uart0_error_isr
0000263a  w    F .text	00000020 FsBaseFile::isDir() const
00002c06  w    F .text	00000054 SDClass::rmdir(char const*)
00009394 g     F .text	0000003c usb_malloc
000059a4 g     F .text	00000178 FatFile::read(void*, unsigned int)
000090d8  w    F .text	00000006 i2s0_isr
00005946 g     F .text	00000030 FatFile::openRoot(FatVolume*)
20019e9c g     O .bss	00000004 ExFatVolume::m_cwv
20030000 g       .bss	00000000 _estack
00007308 g     F .text	00000004 operator new(unsigned int, unsigned long*)
0000787a  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
00009de0 g     F .text	00000034 DMAChannel::release()
000023cc  w    F .text	00000026 File::read()
00008f00 g     F .text	00000048 usb_serial_write_buffer_free
00007596 g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
000073fe g     F .text	00000026 SdSpiCard::spiStop()
000090d8  w    F .text	00000006 enet_timer_isr
00006d24 g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000a126 g     F .text	00000064 AudioConnection::connect()
0000ac88 g     F .text	00000012 .hidden __aeabi_dcmpeq
00002094 g     F .text	000000c0 makeTime(tmElements_t const&)
200199b4 g     O .bss	00000008 AudioInputPDM::dma
00002a50 g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
00002598  w    F .text	00000014 File::~File()
00009ee8  w    F .text	0000000e _write
200147b0 g       .data	00000000 _edata
00004604 g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
00007d48  w    F .text	00000002 SdioCard::~SdioCard()
000090d8  w    F .text	00000006 i2s0_tx_isr
000090d8  w    F .text	00000006 adc1_isr
000034cc g     F .text	00000048 FsName::get16()
000079bc g     F .text	0000001c SdSpiCard::syncDevice()
00003b80 g     F .text	00000062 ExFatFile::hashName(ExName_t*)
0000589c g     F .text	0000008c FatFile::addDirCluster()
00005f8e g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
00009e8c  w    F .text	00000004 usb_serial_class::availableForWrite()
2001393e g     O .data	00000002 I2S_32::shift
000090d8  w    F .text	00000006 cmp0_isr
0000660e g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
0000a3d8 g     F .text	00000040 ultoa
00002bc0  w    F .text	00000002 SDClass::~SDClass()
00007658 g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
00002240 g     F .text	00000014 second()
00001960  w    F .text	00000098 SdBase<FsVolume>::errorHalt(Print*)
00007148 g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
00009e14  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
0000a35e g     F .text	00000004 operator new(unsigned int)
00009e28 g     F .text	0000003c EventResponder::runFromInterrupt()
200147a8 g     O .data	00000004 __malloc_trim_threshold
00009e7c  w    F .text	00000004 usb_serial_class::peek()
0000a18a g     F .text	00000076 AudioConnection::disconnect()
0000afb4 g     F .text	00000024 .hidden __floatunsisf
00011a4c g     F .text	00000114 __mdiff
00007d38 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000ad18 g     F .text	0000004e .hidden __aeabi_d2iz
000045c0 g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
20019ef0 g     O .bss	00000001 usb_cdc_transmit_flush_timer
0000574c g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
00003f90 g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
2001a086 g     O .bss	00000002 AudioStream::cpu_cycles_total
000090d8  w    F .text	00000006 pit_isr
00002218 g     F .text	00000014 hour()
00008124 g     F .text	00000088 SdioCard::writeStop()
00007b82  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00011e48 g     F .text	00000072 __sccl
00003c1a g     F .text	00000014 ExFatFile::close()
000134f0 g     O .text	00000101 _ctype_
000090d8  w    F .text	00000006 dac0_isr
00007314  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00013810 g       .text	00000000 __init_array_start
0000b3e8  w    F .text	00000002 .hidden __aeabi_idiv0
000090d8  w    F .text	00000006 can1_tx_warn_isr
0000acec g     F .text	0000002c .hidden __unorddf2
0000353c g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
00003150 g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
00002cfe  w    F .text	00000068 SDClass::rename(char const*, char const*)
000090d8  w    F .text	00000006 uart0_status_isr
000090d8  w    F .text	00000006 mcg_isr
0000a2f6 g     F .text	00000060 Stream::parseInt(char)
00000400 g     O .text	00000010 flashconfigbytes
00009d38 g     F .text	000000a8 DMAChannel::begin(bool)
0000c280 g     F .text	000000dc strlen
00005976 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000b488 g     F .text	00000006 __locale_ctype_ptr_l
00002e5c  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000ac78 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000abdc g     F .text	0000008a .hidden __gedf2
00005b7e g     F .text	000000ac FatFile::seekSet(unsigned long)
00006f74 g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
00010e08 g     F .text	00000510 __gethex
20013dd4 g     O .data	00000016 usb_string_product_name_default
2001998c g     O .bss	00000008 AudioOutputI2SQuad::dma
0000fa48 g     F .text	00000018 vdprintf
000090d8  w    F .text	00000006 dma_ch1_isr
00007f8c g     F .text	00000064 SdioCard::sectorCount()
00007224 g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
00000734  w    F .text	00000010 c_uSD::~c_uSD()
0000948c g     F .text	00000024 usb_tx_packet_count
00005cec g     F .text	00000098 FatFile::openNext(FatFile*, int)
0000c0e0 g     F .text	000000ce strchr
0000915c  w    F .text	00000002 startup_middle_hook
00013104 g     O .text	00000060 vtable for SdioCard
0000a710 g     F .text	0000003a .hidden __aeabi_f2d
000090d8  w    F .text	00000006 dma_ch5_isr
0000583c g     F .text	00000004 FatFile::getName(char*, unsigned int)
000090d8  w    F .text	00000006 can0_rx_warn_isr
00000c30  w    F .text	00000024 FsBaseFile::open(char const*, int)
000090d8  w    F .text	00000006 can0_tx_warn_isr
000090d8  w    F .text	00000006 uart4_status_isr
0000891c g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
20019958 g     O .bss	00000008 AudioInputAnalog::dma
2001a080 g     O .bss	00000002 AudioStream::cpu_cycles_total_max
00005680  w    F .text	0000001a FatFile::cacheDir(unsigned short)
0000a450 g     F .text	0000027a .hidden __subdf3
00013810 g       .text	00000000 __preinit_array_start
000127a4  w    O .text	0000000c vtable for AudioStream
0000447c g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000cb4  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
00011718 g     F .text	0000005a __lo0bits
00004596 g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
00005c2a g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
0000630a g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
00000510  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
0000a424 g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
0000071c  w    F .text	00000018 FsFile::~FsFile()
00009130 g     F .text	0000000c rtc_get
000048ca g     F .text	00000086 ExFatFile::remove()
000090d8  w    F .text	00000006 cmp2_isr
0000ae54 g     F .text	00000160 .hidden __addsf3
00009e64 g     F .text	00000004 pendablesrvreq_isr
00002d86  w    F .text	00000026 SDClass::totalSize()
00000774  w    F .text	0000000c AudioConnection::~AudioConnection()
0000046c  w    F .text	00000004 Print::availableForWrite()
20014234 g     O .data	0000016c __global_locale
000090d8  w    F .text	00000006 wakeup_isr
000084fc g     F .text	0000035c SdioCard::begin(SdioConfig)
00003c2e g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
000090d8  w    F .text	00000006 cmp3_isr
00001f34 g     F .text	0000012c breakTime(long, tmElements_t&)
00009f10 g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
000013f4 g     F .text	0000003a boundaryCheck2(int, int, int, int)
00006658 g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000b4b4 g     F .text	00000010 free
000090d8  w    F .text	00000006 tpm2_isr
00003a84 g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
000115c0 g     F .text	00000080 __multadd
000115ac g     F .text	00000012 _Bfree
000025ac  w    F .text	00000018 SDFile::size()
000056c2 g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
000090d8  w    F .text	00000006 dma_ch0_isr
000026d0  w    F .text	00000024 SDFile::~SDFile()
20013dee  w    O .data	00000016 usb_string_serial_number
000090d8  w    F .text	00000006 enet_tx_isr
00008990 g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
00007d1c g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ............
    if (tz & 0X40) {
      sign = '-';
      10:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	................
      30:	........e...i...
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	.+...+..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	%...............
     150:	................
     160:	.........+......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	90e0 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	9288 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	913c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	913c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	90ec <startup_late_hook>
	__libc_init_array();
     32c:	bl	b404 <__libc_init_array>

	main();
     330:	bl	9f86 <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x200147b0
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x0001386c
     364:	.word	0x20013930
     368:	.word	0x200147b0
     36c:	.word	0x2001a0f0
     370:	.word	0x20013400
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x61d5b976
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x200147b0
     42c:	.word	0x00000000
     430:	.word	0x00013868

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x200147b4
     460:	.word	0x00013868
     464:	.word	0x200147b0
     468:	.word	0x00000000

0000046c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     46c:	movs	r0, #0
     46e:	bx	lr

00000470 <Print::flush()>:
	virtual void flush()				{ }
     470:	bx	lr
     472:	Address 0x00000472 is out of bounds.


00000474 <I2S_32::isr32()>:

  dma.attachInterrupt(isr32); 
}

void I2S_32::isr32(void)
{
     474:	push	{r4, r5, r6, lr}
  uint32_t daddr, offset;
  const int32_t *src, *end;
  int16_t *dest_left, *dest_right;
  audio_block_t *left, *right;

  daddr = (uint32_t)(dma.TCD->DADDR);
     476:	ldr	r3, [pc, #116]	; (4ec <I2S_32::isr32()+0x78>)
     478:	ldr	r2, [r3, #0]
     47a:	ldrb	r1, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     47c:	ldr	r3, [pc, #112]	; (4f0 <I2S_32::isr32()+0x7c>)
     47e:	ldr	r2, [r2, #16]
     480:	strb	r1, [r3, #0]

  dma.clearInterrupt();
  
  if (daddr < (uint32_t)i2s_rx_buffer_32 + sizeof(i2s_rx_buffer_32) / 2) {
     482:	ldr	r3, [pc, #112]	; (4f4 <I2S_32::isr32()+0x80>)
     484:	cmp	r2, r3
     486:	bcs.n	496 <I2S_32::isr32()+0x22>
    // DMA is receiving to the first half of the buffer
    // need to remove data from the second half
    src = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES];
    end = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES*2];
    if (I2S_32::update_responsibility) AudioStream::update_all();
     488:	ldr	r2, [pc, #108]	; (4f8 <I2S_32::isr32()+0x84>)
     48a:	ldrb	r2, [r2, #0]
     48c:	cbz	r2, 49e <I2S_32::isr32()+0x2a>
	void transmit(audio_block_t *block, unsigned char index = 0);
	audio_block_t * receiveReadOnly(unsigned int index = 0);
	audio_block_t * receiveWritable(unsigned int index = 0);
	static bool update_setup(void);
	static void update_stop(void);
	static void update_all(void) { NVIC_SET_PENDING(IRQ_SOFTWARE); }
     48e:	ldr	r2, [pc, #108]	; (4fc <I2S_32::isr32()+0x88>)
     490:	movs	r1, #1
     492:	str	r1, [r2, #0]
     494:	b.n	49e <I2S_32::isr32()+0x2a>
  } else {
    // DMA is receiving to the second half of the buffer
    // need to remove data from the first half
    src = (int32_t *)&i2s_rx_buffer_32[0];
    end = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES];
     496:	mov	r0, r3
    end = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES*2];
    if (I2S_32::update_responsibility) AudioStream::update_all();
  } else {
    // DMA is receiving to the second half of the buffer
    // need to remove data from the first half
    src = (int32_t *)&i2s_rx_buffer_32[0];
     498:	sub.w	r3, r3, #512	; 0x200
     49c:	b.n	4a2 <I2S_32::isr32()+0x2e>
  
  if (daddr < (uint32_t)i2s_rx_buffer_32 + sizeof(i2s_rx_buffer_32) / 2) {
    // DMA is receiving to the first half of the buffer
    // need to remove data from the second half
    src = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES];
    end = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES*2];
     49e:	add.w	r0, r3, #512	; 0x200
    end = (int32_t *)&i2s_rx_buffer_32[AUDIO_BLOCK_SAMPLES];
  }
  
   // extract 16 bit from 32 bit I2S buffer but shift to right first
   // there will be two buffers with each having "AUDIO_BLOCK_SAMPLES" samples
  left = I2S_32::block_left;
     4a2:	ldr	r2, [pc, #92]	; (500 <I2S_32::isr32()+0x8c>)
     4a4:	ldr	r1, [r2, #0]
  right = I2S_32::block_right;
     4a6:	ldr	r2, [pc, #92]	; (504 <I2S_32::isr32()+0x90>)
     4a8:	ldr	r4, [r2, #0]
  if (left != NULL && right != NULL) {
     4aa:	cbz	r1, 4ea <I2S_32::isr32()+0x76>
     4ac:	cbz	r4, 4ea <I2S_32::isr32()+0x76>
    offset = I2S_32::block_offset;
     4ae:	ldr	r5, [pc, #88]	; (508 <I2S_32::isr32()+0x94>)
     4b0:	ldrh	r2, [r5, #0]
    if (offset <= AUDIO_BLOCK_SAMPLES/2) {
     4b2:	cmp	r2, #64	; 0x40
     4b4:	bhi.n	4ea <I2S_32::isr32()+0x76>
      dest_left = &(left->data[offset]);
      dest_right = &(right->data[offset]);
      I2S_32::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
     4b6:	add.w	r6, r2, #64	; 0x40
  left = I2S_32::block_left;
  right = I2S_32::block_right;
  if (left != NULL && right != NULL) {
    offset = I2S_32::block_offset;
    if (offset <= AUDIO_BLOCK_SAMPLES/2) {
      dest_left = &(left->data[offset]);
     4ba:	lsls	r2, r2, #1
     4bc:	add	r1, r2
      dest_right = &(right->data[offset]);
      I2S_32::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
     4be:	strh	r6, [r5, #0]
  right = I2S_32::block_right;
  if (left != NULL && right != NULL) {
    offset = I2S_32::block_offset;
    if (offset <= AUDIO_BLOCK_SAMPLES/2) {
      dest_left = &(left->data[offset]);
      dest_right = &(right->data[offset]);
     4c0:	add	r2, r4
      I2S_32::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
      do {
        *dest_left++ = (*src++)>>I2S_32::shift;
     4c2:	ldr	r5, [pc, #72]	; (50c <I2S_32::isr32()+0x98>)
     4c4:	adds	r1, #2
     4c6:	adds	r2, #2
     4c8:	ldr.w	r4, [r3], #8
     4cc:	ldrsh.w	r6, [r5]
     4d0:	asrs	r4, r6
     4d2:	strh.w	r4, [r1, #2]!
        *dest_right++ = (*src++)>>I2S_32::shift;
     4d6:	ldr.w	r4, [r3, #-4]
     4da:	ldrsh.w	r6, [r5]
      } while (src < end);
     4de:	cmp	r0, r3
      dest_left = &(left->data[offset]);
      dest_right = &(right->data[offset]);
      I2S_32::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
      do {
        *dest_left++ = (*src++)>>I2S_32::shift;
        *dest_right++ = (*src++)>>I2S_32::shift;
     4e0:	asr.w	r4, r4, r6
     4e4:	strh.w	r4, [r2, #2]!
      } while (src < end);
     4e8:	bhi.n	4c8 <I2S_32::isr32()+0x54>
     4ea:	pop	{r4, r5, r6, pc}
     4ec:	.word	0x20019104
     4f0:	.word	0x4000801f
     4f4:	.word	0x1fff0400
     4f8:	.word	0x20018f44
     4fc:	.word	0xe000e208
     500:	.word	0x200190ec
     504:	.word	0x20018f20
     508:	.word	0x20019908
     50c:	.word	0x2001393e

00000510 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
     510:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     514:	ldr	r5, [sp, #32]
     516:	mov	r7, r0
     518:	mov	r6, r2
     51a:	add.w	r9, r3, r1
     51e:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
     520:	cmp	r4, r9
     522:	beq.n	542 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
     524:	ldr	r3, [r7, #0]
     526:	mov	r2, r6
     528:	ldr	r3, [r3, #12]
     52a:	mov	r1, r4
     52c:	mov	r0, r7
     52e:	blx	r3
     530:	add.w	r8, r4, #1
     534:	cbz	r0, 544 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
     536:	mov	r0, r4
     538:	ldr	r2, [sp, #36]	; 0x24
     53a:	mov	r1, r6
     53c:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
     53e:	mov	r4, r8
     540:	b.n	520 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
     542:	movs	r0, #1
  }
     544:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00000548 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
     548:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     54c:	mov	r5, r0
     54e:	mov	r7, r3
     550:	add.w	r8, r2, r1
     554:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
     556:	cmp	r4, r8
     558:	beq.n	576 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
     55a:	ldr	r3, [r5, #0]
     55c:	ldr	r1, [sp, #24]
     55e:	ldr	r6, [r3, #32]
     560:	mov	r0, r4
     562:	blx	r7
     564:	mov	r1, r4
     566:	mov	r2, r0
     568:	mov	r0, r5
     56a:	blx	r6
     56c:	adds	r4, #1
     56e:	cmp	r0, #0
     570:	bne.n	556 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
     572:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
     576:	movs	r0, #1
  }
     578:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000057c <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
     57c:	mov.w	r0, #4294967295
     580:	bx	lr
     582:	Address 0x00000582 is out of bounds.


00000584 <llwuISR()>:

static void llwuISR(void)
{
    //
#if defined(HAS_KINETIS_LLWU_32CH)
    LLWU_MF5 |= LLWU_MF5_MWUF5_MASK; // clear source in LLWU Flag register
     584:	ldr	r2, [pc, #16]	; (598 <llwuISR()+0x14>)
     586:	ldrb	r3, [r2, #0]
     588:	orr.w	r3, r3, #32
     58c:	strb	r3, [r2, #0]
#else
    LLWU_F3 |= LLWU_F3_MWUF5_MASK; // clear source in LLWU Flag register
#endif
    //
    RTC_IER = 0;// clear RTC interrupts
     58e:	ldr	r3, [pc, #12]	; (59c <llwuISR()+0x18>)
     590:	movs	r2, #0
     592:	str	r2, [r3, #0]
     594:	bx	lr
     596:	nop
     598:	.word	0x4007c00d
     59c:	.word	0x4003d01c

000005a0 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     5a0:	ldr	r2, [r0, #72]	; 0x48
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     5a2:	push	{r4, r5, lr}
           m_xFile ? m_xFile->available() : 0;
     5a4:	cbz	r2, 5c0 <StreamFile<FsBaseFile, unsigned long long>::available()+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     5a6:	ldrb	r3, [r2, #0]
     5a8:	and.w	r3, r3, #8
     5ac:	and.w	r0, r3, #255	; 0xff
     5b0:	cbz	r3, 5f2 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     5b2:	ldr	r3, [r2, #28]
     5b4:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     5b6:	subs	r0, r3, r0
     5b8:	bpl.n	5f2 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     5ba:	mvn.w	r0, #2147483648	; 0x80000000
     5be:	b.n	5f2 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     5c0:	ldr	r0, [r0, #76]	; 0x4c
     5c2:	cbz	r0, 5f2 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     5c4:	ldrb.w	r3, [r0, #49]	; 0x31
     5c8:	lsls	r3, r3, #28
     5ca:	bpl.n	5dc <StreamFile<FsBaseFile, unsigned long long>::available()+0x3c>
     5cc:	ldrd	r4, r5, [r0, #16]
     5d0:	ldrd	r2, r3, [r0]
     5d4:	subs	r0, r4, r2
     5d6:	sbc.w	r1, r5, r3
     5da:	b.n	5e0 <StreamFile<FsBaseFile, unsigned long long>::available()+0x40>
     5dc:	movs	r0, #0
     5de:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     5e0:	movs	r3, #0
     5e2:	mvn.w	r2, #2147483648	; 0x80000000
     5e6:	cmp	r3, r1
     5e8:	it	eq
     5ea:	cmpeq	r2, r0
     5ec:	bcs.n	5f2 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     5ee:	mov	r0, r2
     5f0:	pop	{r4, r5, pc}
    return BaseFile::available();
  }
     5f2:	pop	{r4, r5, pc}

000005f4 <I2S_32::update()>:
    }
  }
}

void I2S_32::update(void)
{
     5f4:	push	{r3, r4, r5, r6, r7, lr}
     5f6:	mov	r6, r0
  audio_block_t *new_left=NULL, *new_right=NULL, *out_left=NULL, *out_right=NULL;

  // allocate 2 new blocks, but if one fails, allocate neither
  new_left = allocate();
     5f8:	bl	a008 <AudioStream::allocate()>
  if (new_left != NULL) {
     5fc:	mov	r4, r0
     5fe:	cbz	r0, 612 <I2S_32::update()+0x1e>
    new_right = allocate();
     600:	bl	a008 <AudioStream::allocate()>
    if (new_right == NULL) {
     604:	mov	r5, r0
     606:	cbnz	r0, 614 <I2S_32::update()+0x20>
      release(new_left);
     608:	mov	r0, r4
     60a:	bl	a094 <AudioStream::release(audio_block_struct*)>
      new_left = NULL;
     60e:	mov	r4, r5
     610:	b.n	614 <I2S_32::update()+0x20>
  }
}

void I2S_32::update(void)
{
  audio_block_t *new_left=NULL, *new_right=NULL, *out_left=NULL, *out_right=NULL;
     612:	mov	r5, r0
    if (new_right == NULL) {
      release(new_left);
      new_left = NULL;
    }
  }
  __disable_irq();
     614:	cpsid	i
  if (block_offset >= AUDIO_BLOCK_SAMPLES) {
     616:	ldr	r3, [pc, #92]	; (674 <I2S_32::update()+0x80>)
     618:	ldrh	r2, [r3, #0]
     61a:	cmp	r2, #127	; 0x7f
     61c:	bls.n	64c <I2S_32::update()+0x58>
      { block_left->data[64]=1<<10;
        block_right->data[32]=1<<9;
        count=0;
      }
#endif
    out_left = block_left;
     61e:	ldr	r2, [pc, #88]	; (678 <I2S_32::update()+0x84>)
     620:	ldr	r7, [r2, #0]
    block_left = new_left;
     622:	str	r4, [r2, #0]
    out_right = block_right;
     624:	ldr	r2, [pc, #84]	; (67c <I2S_32::update()+0x88>)
     626:	ldr	r4, [r2, #0]
    block_right = new_right;
     628:	str	r5, [r2, #0]
    block_offset = 0;
     62a:	movs	r2, #0
     62c:	strh	r2, [r3, #0]
    __enable_irq();
     62e:	cpsie	i
    
    // then transmit the DMA's former blocks
    transmit(out_left, 0);
     630:	mov	r1, r7
     632:	mov	r0, r6
     634:	bl	a0e4 <AudioStream::transmit(audio_block_struct*, unsigned char)>
    release(out_left);
     638:	mov	r0, r7
     63a:	bl	a094 <AudioStream::release(audio_block_struct*)>
    transmit(out_right, 1);
     63e:	mov	r0, r6
     640:	movs	r2, #1
     642:	mov	r1, r4
     644:	bl	a0e4 <AudioStream::transmit(audio_block_struct*, unsigned char)>
    release(out_right);
     648:	mov	r0, r4
     64a:	b.n	668 <I2S_32::update()+0x74>
  } else if (new_left != NULL) {
     64c:	cbz	r4, 670 <I2S_32::update()+0x7c>
    // the DMA didn't fill blocks, but we allocated blocks
    if (block_left == NULL) {
     64e:	ldr	r1, [pc, #40]	; (678 <I2S_32::update()+0x84>)
     650:	ldr	r2, [r1, #0]
     652:	cbnz	r2, 65e <I2S_32::update()+0x6a>
      // the DMA doesn't have any blocks to fill, so
      // give it the ones we just allocated
      block_left = new_left;
     654:	str	r4, [r1, #0]
      block_right = new_right;
     656:	ldr	r1, [pc, #36]	; (67c <I2S_32::update()+0x88>)
      block_offset = 0;
     658:	strh	r2, [r3, #0]
    // the DMA didn't fill blocks, but we allocated blocks
    if (block_left == NULL) {
      // the DMA doesn't have any blocks to fill, so
      // give it the ones we just allocated
      block_left = new_left;
      block_right = new_right;
     65a:	str	r5, [r1, #0]
     65c:	b.n	670 <I2S_32::update()+0x7c>
      block_offset = 0;
      __enable_irq();
    } else {
      // the DMA already has blocks, doesn't need these
      __enable_irq();
     65e:	cpsie	i
      release(new_left);
     660:	mov	r0, r4
     662:	bl	a094 <AudioStream::release(audio_block_struct*)>
      release(new_right);
     666:	mov	r0, r5
    // The DMA didn't fill blocks, and we could not allocate
    // memory... the system is likely starving for memory!
    // Sadly, there's nothing we can do.
    __enable_irq();
  }
}
     668:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      __enable_irq();
    } else {
      // the DMA already has blocks, doesn't need these
      __enable_irq();
      release(new_left);
      release(new_right);
     66c:	b.w	a094 <AudioStream::release(audio_block_struct*)>
    }
  } else {
    // The DMA didn't fill blocks, and we could not allocate
    // memory... the system is likely starving for memory!
    // Sadly, there's nothing we can do.
    __enable_irq();
     670:	cpsie	i
     672:	pop	{r3, r4, r5, r6, r7, pc}
     674:	.word	0x20019908
     678:	.word	0x200190ec
     67c:	.word	0x20018f20

00000680 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:

#include <TimeLib.h>

// Call back for file timestamps (used by FS).  Only called for file create and sync().
  void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{
     680:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     684:	mov	r5, r1
     686:	mov	r4, r2
     688:	mov	r6, r0
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());
     68a:	bl	227c <year()>
     68e:	mov	r7, r0
     690:	bl	2268 <month()>
     694:	mov	r8, r0
     696:	bl	2254 <day()>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
     69a:	subw	r3, r7, #1980	; 0x7bc
     69e:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
     6a0:	cmp	r3, #127	; 0x7f
     6a2:	bhi.n	6c6 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x46>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     6a4:	uxtb.w	r2, r8
     6a8:	cmp	r2, #12
     6aa:	bhi.n	6c6 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x46>
     6ac:	uxtb	r0, r0
     6ae:	cmp	r0, #31
     6b0:	bhi.n	6c6 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x46>
         year << 9 | month << 5 | day;
     6b2:	mov.w	r8, r8, lsl #5
     6b6:	and.w	r8, r8, #8160	; 0x1fe0
     6ba:	orr.w	r0, r8, r0
     6be:	orr.w	r3, r0, r3, lsl #9
     6c2:	uxth	r3, r3
     6c4:	b.n	6c8 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x48>
     6c6:	movs	r3, #0
     6c8:	strh	r3, [r6, #0]

  // Return time using FS_TIME macro to format fields.
  *time = FS_TIME(hour(), minute(), second());
     6ca:	bl	2218 <hour()>
     6ce:	mov	r7, r0
     6d0:	bl	222c <minute()>
     6d4:	mov	r6, r0
     6d6:	bl	2240 <second()>
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
     6da:	uxtb	r3, r7
     6dc:	cmp	r3, #23
     6de:	bhi.n	704 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x84>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     6e0:	uxtb	r3, r6
     6e2:	cmp	r3, #59	; 0x3b
     6e4:	bhi.n	704 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x84>
     6e6:	uxtb	r3, r0
     6e8:	cmp	r3, #59	; 0x3b
     6ea:	bhi.n	704 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x84>
         hour << 11 | minute << 5 | second >> 1;
     6ec:	lsls	r7, r7, #11
     6ee:	lsls	r6, r6, #5
     6f0:	and.w	r7, r7, #522240	; 0x7f800
     6f4:	and.w	r6, r6, #8160	; 0x1fe0
     6f8:	orrs	r6, r7
     6fa:	ubfx	r0, r0, #1, #7
     6fe:	orrs	r0, r6
     700:	uxth	r0, r0
     702:	b.n	706 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x86>
     704:	movs	r0, #0
     706:	strh	r0, [r5, #0]

  // Return low time bits in units of 10 ms.
  *ms10 = second() & 1 ? 100 : 0;
     708:	bl	2240 <second()>
     70c:	tst.w	r0, #1
     710:	ite	ne
     712:	movne	r3, #100	; 0x64
     714:	moveq	r3, #0
     716:	strb	r3, [r4, #0]
     718:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000071c <FsFile::~FsFile()>:
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     71c:	push	{r4, lr}
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     71e:	ldr	r3, [pc, #16]	; (730 <FsFile::~FsFile()+0x14>)
     720:	mov	r4, r0
     722:	str.w	r3, [r0], #16
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     726:	bl	7120 <FsBaseFile::close()>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     72a:	mov	r0, r4
     72c:	pop	{r4, pc}
     72e:	nop
     730:	.word	0x000127c4

00000734 <c_uSD::~c_uSD()>:
int16_t diskBuffer[BUFFERSIZE];
int16_t *outptr = diskBuffer;

char header[512];

class c_uSD
     734:	push	{r4, lr}
     736:	mov	r4, r0
     738:	add.w	r0, r0, #1216	; 0x4c0
     73c:	bl	71c <FsFile::~FsFile()>
     740:	mov	r0, r4
     742:	pop	{r4, pc}

00000744 <getTeensy3Time()>:
uint32_t makeTime(const DateTimeFields &tm); // convert DateTimeFields to 32 bit time

class teensy3_clock_class
{
public:
	static unsigned long get(void) __attribute__((always_inline)) { return rtc_get(); }
     744:	b.w	9130 <rtc_get>

00000748 <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     748:	mov	r3, r0
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
     74a:	ldr	r0, [r0, #72]	; 0x48
           m_xFile ? m_xFile->peek() : -1;
     74c:	cbz	r0, 752 <StreamFile<FsBaseFile, unsigned long long>::peek()+0xa>
     74e:	b.w	5b1c <FatFile::peek()>
     752:	ldr	r0, [r3, #76]	; 0x4c
     754:	cbz	r0, 75a <StreamFile<FsBaseFile, unsigned long long>::peek()+0x12>
     756:	b.w	3e94 <ExFatFile::peek()>
    return BaseFile::peek();
  }
     75a:	mov.w	r0, #4294967295
     75e:	bx	lr

00000760 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     760:	mov	r3, r0
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
     762:	ldr	r0, [r0, #72]	; 0x48
           m_xFile ? m_xFile->sync() : false;
     764:	cbz	r0, 76a <StreamFile<FsBaseFile, unsigned long long>::flush()+0xa>
     766:	b.w	5dd4 <FatFile::sync()>
     76a:	ldr	r0, [r3, #76]	; 0x4c
     76c:	cbz	r0, 772 <StreamFile<FsBaseFile, unsigned long long>::flush()+0x12>
     76e:	b.w	4a84 <ExFatFile::sync()>
     772:	bx	lr

00000774 <AudioConnection::~AudioConnection()>:
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
		{ isConnected = false;
		  connect(); }
	friend class AudioStream;
	~AudioConnection() {
     774:	push	{r4, lr}
     776:	mov	r4, r0
		disconnect();
     778:	bl	a18a <AudioConnection::disconnect()>
	}
     77c:	mov	r0, r4
     77e:	pop	{r4, pc}

00000780 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     780:	push	{r4, lr}
     782:	mov	r4, r0
		release();
     784:	bl	9de0 <DMAChannel::release()>
	}
     788:	mov	r0, r4
     78a:	pop	{r4, pc}

0000078c <mRecordQueue<500>::update()>:
	release(userblock);
	userblock = NULL;
}

template <int mq>
void mRecordQueue<mq>::update(void)
     78c:	push	{r4, lr}
{
	audio_block_t *block;
	uint16_t h;

	block = receiveReadOnly();
     78e:	movs	r1, #0
	release(userblock);
	userblock = NULL;
}

template <int mq>
void mRecordQueue<mq>::update(void)
     790:	mov	r4, r0
{
	audio_block_t *block;
	uint16_t h;

	block = receiveReadOnly();
     792:	bl	a10c <AudioStream::receiveReadOnly(unsigned int)>
	if (!block) return;
     796:	cbz	r0, 7da <mRecordQueue<500>::update()+0x4e>
	if (!enabled) {
     798:	ldrh.w	r3, [r4, #2040]	; 0x7f8
     79c:	uxth	r3, r3
     79e:	cbnz	r3, 7a8 <mRecordQueue<500>::update()+0x1c>
    dropCount++; // flag for main to know
	} else {
		queue[h] = block; // store incomming data
		head = h;
	}
}
     7a0:	ldmia.w	sp!, {r4, lr}
	uint16_t h;

	block = receiveReadOnly();
	if (!block) return;
	if (!enabled) {
		release(block);
     7a4:	b.w	a094 <AudioStream::release(audio_block_struct*)>
		return;
	}
	h = head + 1;
     7a8:	ldrh.w	r3, [r4, #2036]	; 0x7f4
	if (h >= mq) h = 0;
	if (h == tail) {
     7ac:	ldrh.w	r2, [r4, #2038]	; 0x7f6
	if (!block) return;
	if (!enabled) {
		release(block);
		return;
	}
	h = head + 1;
     7b0:	adds	r3, #1
     7b2:	uxth	r3, r3
	if (h >= mq) h = 0;
     7b4:	cmp.w	r3, #500	; 0x1f4
     7b8:	it	cs
     7ba:	movcs	r3, #0
	if (h == tail) {
     7bc:	uxth	r2, r2
     7be:	cmp	r3, r2
     7c0:	bne.n	7ce <mRecordQueue<500>::update()+0x42>
		release(block); // drop incomming data
     7c2:	bl	a094 <AudioStream::release(audio_block_struct*)>
    dropCount++; // flag for main to know
     7c6:	ldr	r3, [r4, #24]
     7c8:	adds	r3, #1
     7ca:	str	r3, [r4, #24]
     7cc:	pop	{r4, pc}
	} else {
		queue[h] = block; // store incomming data
     7ce:	add.w	r2, r3, #8
     7d2:	str.w	r0, [r4, r2, lsl #2]
		head = h;
     7d6:	strh.w	r3, [r4, #2036]	; 0x7f4
     7da:	pop	{r4, pc}

000007dc <getTime(char*) [clone .constprop.28]>:
{
    sprintf(text,"%04d/%02d/%02d",year(), month(), day());
    return text;  
}

static char * getTime(char *text)
     7dc:	push	{r0, r1, r4, r5, r6, lr}
{
    sprintf(text,"%02d:%02d:%02d",hour(),minute(),second());
     7de:	bl	2218 <hour()>
     7e2:	mov	r5, r0
     7e4:	bl	222c <minute()>
     7e8:	mov	r6, r0
     7ea:	bl	2240 <second()>
     7ee:	ldr	r4, [pc, #20]	; (804 <getTime(char*) [clone .constprop.28]+0x28>)
     7f0:	str	r0, [sp, #0]
     7f2:	mov	r3, r6
     7f4:	mov	r2, r5
     7f6:	ldr	r1, [pc, #16]	; (808 <getTime(char*) [clone .constprop.28]+0x2c>)
     7f8:	mov	r0, r4
     7fa:	bl	c038 <sprintf>
    return text;
}
     7fe:	mov	r0, r4
     800:	add	sp, #8
     802:	pop	{r4, r5, r6, pc}
     804:	.word	0x20018f24
     808:	.word	0x00012804

0000080c <getDate(char*) [clone .constprop.29]>:
*/


#include <TimeLib.h>

static char * getDate(char *text)
     80c:	push	{r0, r1, r4, r5, r6, lr}
{
    sprintf(text,"%04d/%02d/%02d",year(), month(), day());
     80e:	bl	227c <year()>
     812:	mov	r5, r0
     814:	bl	2268 <month()>
     818:	mov	r6, r0
     81a:	bl	2254 <day()>
     81e:	ldr	r4, [pc, #20]	; (834 <getDate(char*) [clone .constprop.29]+0x28>)
     820:	str	r0, [sp, #0]
     822:	mov	r3, r6
     824:	mov	r2, r5
     826:	ldr	r1, [pc, #16]	; (838 <getDate(char*) [clone .constprop.29]+0x2c>)
     828:	mov	r0, r4
     82a:	bl	c038 <sprintf>
    return text;  
}
     82e:	mov	r0, r4
     830:	add	sp, #8
     832:	pop	{r4, r5, r6, pc}
     834:	.word	0x20018f24
     838:	.word	0x00012813

0000083c <AudioStream::AudioStream(unsigned char, audio_block_struct**)>:

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     83c:	ldr	r3, [pc, #60]	; (87c <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x40>)
     83e:	str	r3, [r0, #0]
			active = false;
     840:	movs	r3, #0

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     842:	strb	r1, [r0, #9]
     844:	str	r2, [r0, #16]
			active = false;
     846:	strb	r3, [r0, #8]
			destination_list = NULL;
     848:	str	r3, [r0, #12]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     84a:	mov	r1, r3
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     84c:	ldrb	r2, [r0, #9]
     84e:	cmp	r3, r2
     850:	bge.n	85c <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x20>
				inputQueue[i] = NULL;
     852:	ldr	r2, [r0, #16]
     854:	str.w	r1, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     858:	adds	r3, #1
     85a:	b.n	84c <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x10>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
     85c:	ldr	r2, [pc, #32]	; (880 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x44>)
     85e:	ldr	r3, [r2, #0]
     860:	cbnz	r3, 866 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x2a>
				first_update = this;
     862:	str	r0, [r2, #0]
     864:	b.n	870 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x34>
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
     866:	ldr	r2, [r3, #20]
     868:	cbz	r2, 86e <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x32>
     86a:	mov	r3, r2
     86c:	b.n	866 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x2a>
				p->next_update = this;
     86e:	str	r0, [r3, #20]
			}
			next_update = NULL;
     870:	movs	r3, #0
     872:	str	r3, [r0, #20]
			cpu_cycles = 0;
     874:	strh	r3, [r0, #4]
			cpu_cycles_max = 0;
     876:	strh	r3, [r0, #6]
			numConnections = 0;
     878:	strb	r3, [r0, #10]
		}
     87a:	bx	lr
     87c:	.word	0x000127ac
     880:	.word	0x2001a000

00000884 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     884:	push	{r4, r5, r6, lr}
     886:	mov	r4, r0
     888:	mov	r0, r1
     88a:	mov	r5, r1
     88c:	bl	c280 <strlen>
     890:	ldr	r3, [r4, #0]
     892:	mov	r2, r0
     894:	mov	r1, r5
     896:	mov	r0, r4
     898:	ldr	r3, [r3, #4]
     89a:	ldmia.w	sp!, {r4, r5, r6, lr}
     89e:	bx	r3

000008a0 <Print::println(__FlashStringHelper const*)>:
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     8a0:	push	{r3, r4, r5, lr}
     8a2:	mov	r5, r0
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
     8a4:	bl	884 <Print::write(char const*)>
     8a8:	mov	r4, r0
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     8aa:	mov	r0, r5
     8ac:	bl	9ec8 <Print::println()>
     8b0:	add	r0, r4
     8b2:	pop	{r3, r4, r5, pc}

000008b4 <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
     8b4:	push	{r3, r4, r5, lr}

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     8b6:	movs	r2, #10
     8b8:	movs	r3, #0

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
     8ba:	mov	r5, r0

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     8bc:	bl	9f10 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
     8c0:	mov	r4, r0

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
     8c2:	mov	r0, r5
     8c4:	bl	9ec8 <Print::println()>
     8c8:	add	r0, r4
     8ca:	pop	{r3, r4, r5, pc}

000008cc <I2S_32::config_i2s()>:
#endif
#endif

void I2S_32::config_i2s(void)
{
  SIM_SCGC6 |= SIM_SCGC6_I2S;
     8cc:	ldr	r3, [pc, #148]	; (964 <I2S_32::config_i2s()+0x98>)
  SIM_SCGC7 |= SIM_SCGC7_DMA;
     8ce:	ldr	r1, [pc, #152]	; (968 <I2S_32::config_i2s()+0x9c>)
#endif
#endif

void I2S_32::config_i2s(void)
{
  SIM_SCGC6 |= SIM_SCGC6_I2S;
     8d0:	ldr	r2, [r3, #0]
     8d2:	orr.w	r2, r2, #32768	; 0x8000
  #define MCLK_SRC  0  // system clock
#endif
#endif

void I2S_32::config_i2s(void)
{
     8d6:	push	{r4, r5, lr}
  SIM_SCGC6 |= SIM_SCGC6_I2S;
     8d8:	str	r2, [r3, #0]
  SIM_SCGC7 |= SIM_SCGC7_DMA;
     8da:	ldr	r2, [r1, #0]
     8dc:	orr.w	r2, r2, #2
     8e0:	str	r2, [r1, #0]
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     8e2:	ldr	r2, [r3, #0]
     8e4:	orr.w	r2, r2, #2
     8e8:	str	r2, [r3, #0]

  // if either transmitter or receiver is enabled, do nothing
  if (I2S0_TCSR & I2S_TCSR_TE) return;
     8ea:	ldr	r3, [pc, #128]	; (96c <I2S_32::config_i2s()+0xa0>)
     8ec:	ldr	r3, [r3, #0]
     8ee:	cmp	r3, #0
     8f0:	blt.n	962 <I2S_32::config_i2s()+0x96>
  if (I2S0_RCSR & I2S_RCSR_RE) return;
     8f2:	ldr	r3, [pc, #124]	; (970 <I2S_32::config_i2s()+0xa4>)
     8f4:	ldr	r3, [r3, #0]
     8f6:	cmp	r3, #0
     8f8:	blt.n	962 <I2S_32::config_i2s()+0x96>

  // enable MCLK output
  I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
     8fa:	ldr	r3, [pc, #120]	; (974 <I2S_32::config_i2s()+0xa8>)
     8fc:	mov.w	r2, #1124073472	; 0x43000000
     900:	str	r2, [r3, #0]
  while (I2S0_MCR & I2S_MCR_DUF) ;
     902:	ldr	r2, [r3, #0]
     904:	cmp	r2, #0
     906:	blt.n	902 <I2S_32::config_i2s()+0x36>
  I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
     908:	ldr	r3, [pc, #108]	; (978 <I2S_32::config_i2s()+0xac>)
  I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
    | I2S_TCR2_BCD | I2S_TCR2_DIV(1);
  I2S0_TCR3 = I2S_TCR3_TCE;
  I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
    | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
  I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     90a:	ldr	r5, [pc, #112]	; (97c <I2S_32::config_i2s()+0xb0>)
  I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
  while (I2S0_MCR & I2S_MCR_DUF) ;
  I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));

  // configure transmitter
  I2S0_TMR = 0;
     90c:	movs	r4, #0
  if (I2S0_RCSR & I2S_RCSR_RE) return;

  // enable MCLK output
  I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
  while (I2S0_MCR & I2S_MCR_DUF) ;
  I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
     90e:	movw	r2, #4112	; 0x1010
     912:	str	r2, [r3, #0]

  // configure transmitter
  I2S0_TMR = 0;
     914:	str.w	r4, [r3, #-164]
     918:	subs	r3, #164	; 0xa4
  I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
     91a:	movs	r0, #1
  I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
    | I2S_TCR2_BCD | I2S_TCR2_DIV(1);
     91c:	ldr	r2, [pc, #96]	; (980 <I2S_32::config_i2s()+0xb4>)
  while (I2S0_MCR & I2S_MCR_DUF) ;
  I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));

  // configure transmitter
  I2S0_TMR = 0;
  I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
     91e:	str.w	r0, [r3, #-92]
  I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
    | I2S_TCR2_BCD | I2S_TCR2_DIV(1);
  I2S0_TCR3 = I2S_TCR3_TCE;
     922:	mov.w	r1, #65536	; 0x10000

  // configure transmitter
  I2S0_TMR = 0;
  I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
  I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
    | I2S_TCR2_BCD | I2S_TCR2_DIV(1);
     926:	str.w	r2, [r3, #-88]
  I2S0_TCR3 = I2S_TCR3_TCE;
  I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
    | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     92a:	ldr	r2, [pc, #88]	; (984 <I2S_32::config_i2s()+0xb8>)
  // configure transmitter
  I2S0_TMR = 0;
  I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
  I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
    | I2S_TCR2_BCD | I2S_TCR2_DIV(1);
  I2S0_TCR3 = I2S_TCR3_TCE;
     92c:	str.w	r1, [r3, #-84]
  I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
    | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     930:	str.w	r2, [r3, #-80]
  I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     934:	ldr	r3, [pc, #80]	; (988 <I2S_32::config_i2s()+0xbc>)
     936:	str	r3, [r5, #0]

  // configure receiver (sync'd to transmitter clocks)
  I2S0_RMR = 0;
     938:	str.w	r4, [r5, #204]	; 0xcc
  I2S0_RCR1 = I2S_RCR1_RFW(1);
     93c:	ldr	r4, [pc, #76]	; (98c <I2S_32::config_i2s()+0xc0>)
     93e:	str	r0, [r4, #0]
  I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
    | I2S_RCR2_BCD | I2S_RCR2_DIV(1);
     940:	ldr	r0, [pc, #76]	; (990 <I2S_32::config_i2s()+0xc4>)
     942:	ldr	r4, [pc, #80]	; (994 <I2S_32::config_i2s()+0xc8>)
     944:	str	r4, [r0, #0]
  I2S0_RCR3 = I2S_RCR3_RCE;
     946:	str	r1, [r0, #4]
  I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
    | I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
     948:	ldr	r1, [pc, #76]	; (998 <I2S_32::config_i2s()+0xcc>)
     94a:	str	r2, [r1, #0]
  I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     94c:	ldr	r2, [pc, #76]	; (99c <I2S_32::config_i2s()+0xd0>)
     94e:	str	r3, [r2, #0]

  // configure pin mux for 3 clock signals
  CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     950:	add.w	r2, r2, #114176	; 0x1be00
     954:	add.w	r2, r2, #372	; 0x174
     958:	mov.w	r3, #1536	; 0x600
     95c:	str	r3, [r2, #0]
  CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     95e:	str	r3, [r2, #4]
  CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     960:	str	r3, [r2, #16]
     962:	pop	{r4, r5, pc}
     964:	.word	0x4004803c
     968:	.word	0x40048040
     96c:	.word	0x4002f000
     970:	.word	0x4002f080
     974:	.word	0x4002f100
     978:	.word	0x4002f104
     97c:	.word	0x4002f014
     980:	.word	0x07000001
     984:	.word	0x00011f1b
     988:	.word	0x1f1f1f00
     98c:	.word	0x4002f084
     990:	.word	0x4002f088
     994:	.word	0x47000001
     998:	.word	0x4002f090
     99c:	.word	0x4002f094

000009a0 <I2S_32::begin()>:
uint16_t I2S_32:: block_offset = 0;
bool I2S_32::update_responsibility = false;
DMAChannel I2S_32::dma(false);

void I2S_32::begin(void)
{ 
     9a0:	push	{r3, r4, r5, lr}

  dma.begin(true); // Allocate the DMA channel first
     9a2:	ldr	r4, [pc, #164]	; (a48 <I2S_32::begin()+0xa8>)
     9a4:	movs	r1, #1
uint16_t I2S_32:: block_offset = 0;
bool I2S_32::update_responsibility = false;
DMAChannel I2S_32::dma(false);

void I2S_32::begin(void)
{ 
     9a6:	mov	r5, r0

  dma.begin(true); // Allocate the DMA channel first
     9a8:	mov	r0, r4
     9aa:	bl	9d38 <DMAChannel::begin(bool)>

  config_i2s();
     9ae:	mov	r0, r5
     9b0:	bl	8cc <I2S_32::config_i2s()>

  CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
     9b4:	ldr	r3, [pc, #148]	; (a4c <I2S_32::begin()+0xac>)
  dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0);
  dma.TCD->SOFF = 0;
  dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
  dma.TCD->NBYTES_MLNO = 4;
  dma.TCD->SLAST = 0;
  dma.TCD->DADDR = i2s_rx_buffer_32;
     9b6:	ldr	r0, [pc, #152]	; (a50 <I2S_32::begin()+0xb0>)

  dma.begin(true); // Allocate the DMA channel first

  config_i2s();

  CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
     9b8:	mov.w	r2, #1024	; 0x400
     9bc:	str	r2, [r3, #0]
  
  dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0);
     9be:	ldr	r3, [r4, #0]
     9c0:	ldr	r2, [pc, #144]	; (a54 <I2S_32::begin()+0xb4>)
     9c2:	str	r2, [r3, #0]
  dma.TCD->SOFF = 0;
  dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     9c4:	movw	r1, #514	; 0x202
     9c8:	strh	r1, [r3, #6]
  dma.TCD->NBYTES_MLNO = 4;
     9ca:	movs	r1, #4
  config_i2s();

  CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
  
  dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0);
  dma.TCD->SOFF = 0;
     9cc:	movs	r2, #0
  dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
  dma.TCD->NBYTES_MLNO = 4;
     9ce:	str	r1, [r3, #8]
  dma.TCD->SLAST = 0;
  dma.TCD->DADDR = i2s_rx_buffer_32;
  dma.TCD->DOFF = 4;
     9d0:	strh	r1, [r3, #20]
  dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer_32) / 4;
     9d2:	mov.w	r1, #256	; 0x100
  dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0);
  dma.TCD->SOFF = 0;
  dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
  dma.TCD->NBYTES_MLNO = 4;
  dma.TCD->SLAST = 0;
  dma.TCD->DADDR = i2s_rx_buffer_32;
     9d6:	str	r0, [r3, #16]
  config_i2s();

  CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
  
  dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0);
  dma.TCD->SOFF = 0;
     9d8:	strh	r2, [r3, #4]
  dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
  dma.TCD->NBYTES_MLNO = 4;
  dma.TCD->SLAST = 0;
  dma.TCD->DADDR = i2s_rx_buffer_32;
  dma.TCD->DOFF = 4;
  dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer_32) / 4;
     9da:	strh	r1, [r3, #22]
  dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer_32);
     9dc:	ldr	r0, [pc, #120]	; (a58 <I2S_32::begin()+0xb8>)
  dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer_32) / 4;
     9de:	strh	r1, [r3, #30]
  dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     9e0:	movs	r1, #6
     9e2:	strh	r1, [r3, #28]
  
  dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0);
  dma.TCD->SOFF = 0;
  dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
  dma.TCD->NBYTES_MLNO = 4;
  dma.TCD->SLAST = 0;
     9e4:	str	r2, [r3, #12]
  dma.TCD->DADDR = i2s_rx_buffer_32;
  dma.TCD->DOFF = 4;
  dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer_32) / 4;
  dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer_32);
     9e6:	str	r0, [r3, #24]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     9e8:	ldrb	r3, [r4, #4]
     9ea:	add.w	r3, r3, #1073741824	; 0x40000000
     9ee:	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
     9f2:	strb	r2, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     9f4:	movs	r2, #140	; 0x8c
     9f6:	strb	r2, [r3, #0]
  dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer_32) / 4;
  dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;

  dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
  update_responsibility = update_setup();
     9f8:	bl	a200 <AudioStream::update_setup()>
     9fc:	ldr	r3, [pc, #92]	; (a5c <I2S_32::begin()+0xbc>)
     9fe:	ldrb	r2, [r4, #4]
     a00:	strb	r0, [r3, #0]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     a02:	ldr	r3, [pc, #92]	; (a60 <I2S_32::begin()+0xc0>)

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     a04:	ldr	r0, [pc, #92]	; (a64 <I2S_32::begin()+0xc4>)
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     a06:	strb	r2, [r3, #0]
  dma.enable();

  I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
     a08:	ldr	r2, [pc, #92]	; (a68 <I2S_32::begin()+0xc8>)
     a0a:	ldr	r3, [r2, #0]
     a0c:	orr.w	r3, r3, #2449473536	; 0x92000000
     a10:	orr.w	r3, r3, #1
     a14:	str	r3, [r2, #0]
  I2S0_TCSR |= I2S_TCSR_TE | I2S_TCSR_BCE; // TX clock enable, because sync'd to TX
     a16:	ldr.w	r3, [r2, #-128]
     a1a:	orr.w	r3, r3, #2415919104	; 0x90000000
     a1e:	str.w	r3, [r2, #-128]
     a22:	ldrb	r2, [r4, #4]

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     a24:	ldr	r3, [pc, #68]	; (a6c <I2S_32::begin()+0xcc>)
     a26:	add.w	r1, r2, #16
     a2a:	str.w	r0, [r3, r1, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
     a2e:	asrs	r3, r2, #5
     a30:	lsls	r3, r3, #2
     a32:	add.w	r3, r3, #3758096384	; 0xe0000000
     a36:	add.w	r3, r3, #57600	; 0xe100
     a3a:	and.w	r2, r2, #31
     a3e:	movs	r1, #1
     a40:	lsl.w	r2, r1, r2
     a44:	str	r2, [r3, #0]
     a46:	pop	{r3, r4, r5, pc}
     a48:	.word	0x20019104
     a4c:	.word	0x4004b014
     a50:	.word	0x1fff0200
     a54:	.word	0x4002f0a0
     a58:	.word	0xfffffc00
     a5c:	.word	0x20018f44
     a60:	.word	0x4000801b
     a64:	.word	0x00000475
     a68:	.word	0x4002f080
     a6c:	.word	0x20013400

00000a70 <I2S_dividers(unsigned long*, unsigned long, unsigned long)>:

// ********************************************** following is to change I2S sampling rates ********************
// attempt to generate dividers programmatically
// always better to check
void I2S_dividers(uint32_t *iscl, uint32_t fsamp, uint32_t nbits)
{ // nbits is number of bits / frame
     a70:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     a74:	mov	r7, r0
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     a76:	ldr	r0, [r0, #8]

// ********************************************** following is to change I2S sampling rates ********************
// attempt to generate dividers programmatically
// always better to check
void I2S_dividers(uint32_t *iscl, uint32_t fsamp, uint32_t nbits)
{ // nbits is number of bits / frame
     a78:	vpush	{d8-d9}
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     a7c:	adds	r0, #1

// ********************************************** following is to change I2S sampling rates ********************
// attempt to generate dividers programmatically
// always better to check
void I2S_dividers(uint32_t *iscl, uint32_t fsamp, uint32_t nbits)
{ // nbits is number of bits / frame
     a7e:	vmov	s17, r1
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     a82:	movs	r1, #0

// ********************************************** following is to change I2S sampling rates ********************
// attempt to generate dividers programmatically
// always better to check
void I2S_dividers(uint32_t *iscl, uint32_t fsamp, uint32_t nbits)
{ // nbits is number of bits / frame
     a84:	vmov	s16, r2
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     a88:	bl	afe8 <__aeabi_l2f>
     a8c:	vldr	s14, [pc, #136]	; b18 <I2S_dividers(unsigned long*, unsigned long, unsigned long)+0xa8>
    float mn=1.0; 
    for(int ii=1;ii<=256;ii++) 
    { float xx;
      xx=A*ii-(int32_t)(A*ii);
      if(xx<mn && A*ii<4096.0) { mn=xx; i1=ii; i2=A*ii;} //select first candidate
     a90:	vldr	s18, [pc, #136]	; b1c <I2S_dividers(unsigned long*, unsigned long, unsigned long)+0xac>
{ // nbits is number of bits / frame
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     a94:	vmov	s13, r0
     a98:	vdiv.f32	s15, s14, s13
// attempt to generate dividers programmatically
// always better to check
void I2S_dividers(uint32_t *iscl, uint32_t fsamp, uint32_t nbits)
{ // nbits is number of bits / frame
    int64_t i1 = 1;
    int64_t i2 = 1;
     a9c:	movs	r0, #1
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     a9e:	movs	r4, #1
     aa0:	movs	r5, #0
// ********************************************** following is to change I2S sampling rates ********************
// attempt to generate dividers programmatically
// always better to check
void I2S_dividers(uint32_t *iscl, uint32_t fsamp, uint32_t nbits)
{ // nbits is number of bits / frame
    int64_t i1 = 1;
     aa2:	mov	r6, r0
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
    float mn=1.0; 
    for(int ii=1;ii<=256;ii++) 
     aa4:	movw	r8, #257	; 0x101
     aa8:	mov.w	r9, #0
{ // nbits is number of bits / frame
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     aac:	vcvt.f32.u32	s17, s17
     ab0:	vcvt.f32.u32	s16, s16
    float mn=1.0; 
     ab4:	vmov.f32	s14, #112	; 0x3f800000  1.0
{ // nbits is number of bits / frame
    int64_t i1 = 1;
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
     ab8:	vmul.f32	s16, s16, s17
     abc:	vdiv.f32	s17, s15, s16
    float mn=1.0; 
    for(int ii=1;ii<=256;ii++) 
    { float xx;
      xx=A*ii-(int32_t)(A*ii);
     ac0:	vmov	s15, r4
     ac4:	vcvt.f32.s32	s15, s15
     ac8:	vmul.f32	s15, s15, s17
     acc:	vcvt.s32.f32	s16, s15
     ad0:	vcvt.f32.s32	s16, s16
     ad4:	vsub.f32	s16, s15, s16
      if(xx<mn && A*ii<4096.0) { mn=xx; i1=ii; i2=A*ii;} //select first candidate
     ad8:	vcmpe.f32	s16, s14
     adc:	vmrs	APSR_nzcv, fpscr
     ae0:	bpl.n	afa <I2S_dividers(unsigned long*, unsigned long, unsigned long)+0x8a>
     ae2:	vcmpe.f32	s15, s18
     ae6:	vmrs	APSR_nzcv, fpscr
     aea:	bpl.n	afa <I2S_dividers(unsigned long*, unsigned long, unsigned long)+0x8a>
     aec:	vmov	r0, s15
     af0:	bl	b094 <__aeabi_f2lz>
     af4:	mov	r6, r4
     af6:	vmov.f32	s14, s16
     afa:	adds	r4, #1
     afc:	adc.w	r5, r5, #0
    int64_t i2 = 1;
    int64_t i3 = iscl[2]+1;
//    float A=F_CPU/2.0f/i3/((float)nbits*fsamp);
    float A=F_PLL/2.0f/i3/((float)nbits*fsamp);
    float mn=1.0; 
    for(int ii=1;ii<=256;ii++) 
     b00:	cmp	r5, r9
     b02:	it	eq
     b04:	cmpeq	r4, r8
     b06:	bne.n	ac0 <I2S_dividers(unsigned long*, unsigned long, unsigned long)+0x50>
      if(xx<mn && A*ii<4096.0) { mn=xx; i1=ii; i2=A*ii;} //select first candidate
    }
    iscl[0] = (int) (i1-1);
    iscl[1] = (int) (i2-1);
    iscl[2] = (int) (i3-1);
}
     b08:	vpop	{d8-d9}
    for(int ii=1;ii<=256;ii++) 
    { float xx;
      xx=A*ii-(int32_t)(A*ii);
      if(xx<mn && A*ii<4096.0) { mn=xx; i1=ii; i2=A*ii;} //select first candidate
    }
    iscl[0] = (int) (i1-1);
     b0c:	subs	r6, #1
    iscl[1] = (int) (i2-1);
     b0e:	subs	r0, #1
    for(int ii=1;ii<=256;ii++) 
    { float xx;
      xx=A*ii-(int32_t)(A*ii);
      if(xx<mn && A*ii<4096.0) { mn=xx; i1=ii; i2=A*ii;} //select first candidate
    }
    iscl[0] = (int) (i1-1);
     b10:	str	r6, [r7, #0]
    iscl[1] = (int) (i2-1);
     b12:	str	r0, [r7, #4]
    iscl[2] = (int) (i3-1);
}
     b14:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     b18:	.word	0x4c371b00
     b1c:	.word	0x45800000

00000b20 <I2S_stopClock()>:

void I2S_stopClock(void)
{
      SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     b20:	ldr	r2, [pc, #8]	; (b2c <I2S_stopClock()+0xc>)
     b22:	ldr	r3, [r2, #0]
     b24:	bic.w	r3, r3, #32768	; 0x8000
     b28:	str	r3, [r2, #0]
     b2a:	bx	lr
     b2c:	.word	0x4004803c

00000b30 <I2S_stop()>:
}

void I2S_stop(void)
{
    I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     b30:	ldr	r2, [pc, #8]	; (b3c <I2S_stop()+0xc>)
     b32:	ldr	r3, [r2, #0]
     b34:	bic.w	r3, r3, #2415919104	; 0x90000000
     b38:	str	r3, [r2, #0]
     b3a:	bx	lr
     b3c:	.word	0x4002f080

00000b40 <I2S_modification(unsigned long, unsigned short, int)>:
}

void I2S_modification(uint32_t fsamp, uint16_t nbits, int nch)
{ uint32_t iscl[3];
     b40:	push	{r4, r5, r6, lr}

  if(nch==8)
     b42:	cmp	r2, #8
{
    I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
}

void I2S_modification(uint32_t fsamp, uint16_t nbits, int nch)
{ uint32_t iscl[3];
     b44:	sub	sp, #40	; 0x28

  if(nch==8)
    iscl[2]=0;
     b46:	ite	eq
     b48:	moveq	r3, #0
  else
    iscl[2]=1;
     b4a:	movne	r3, #1
{
    I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
}

void I2S_modification(uint32_t fsamp, uint16_t nbits, int nch)
{ uint32_t iscl[3];
     b4c:	mov	r5, r1
     b4e:	mov	r6, r0
     b50:	mov	r4, r2
  if(nch==8)
    iscl[2]=0;
  else
    iscl[2]=1;
  
  I2S_dividers(iscl, fsamp ,nch*nbits);
     b52:	muls	r2, r1
     b54:	mov	r1, r0
     b56:	add	r0, sp, #28
{ uint32_t iscl[3];

  if(nch==8)
    iscl[2]=0;
  else
    iscl[2]=1;
     b58:	str	r3, [sp, #36]	; 0x24
  
  I2S_dividers(iscl, fsamp ,nch*nbits);
     b5a:	bl	a70 <I2S_dividers(unsigned long*, unsigned long, unsigned long)>
  float fs = (F_CPU * (iscl[0]+1.0f)) / (iscl[1]+1l) / 2 / (iscl[2]+1l) / ((float)nch*nbits);
#if DO_DEBUG>0
  Serial.printf("%d %d %d %d %d %d %d\n\r",
                F_CPU, fsamp, (int)fs, nbits,iscl[0]+1,iscl[1]+1,iscl[2]+1);
     b5e:	vldr	s15, [sp, #28]
    iscl[2]=0;
  else
    iscl[2]=1;
  
  I2S_dividers(iscl, fsamp ,nch*nbits);
  float fs = (F_CPU * (iscl[0]+1.0f)) / (iscl[1]+1l) / 2 / (iscl[2]+1l) / ((float)nch*nbits);
     b62:	ldr	r1, [sp, #32]
     b64:	ldr	r2, [sp, #36]	; 0x24
#if DO_DEBUG>0
  Serial.printf("%d %d %d %d %d %d %d\n\r",
                F_CPU, fsamp, (int)fs, nbits,iscl[0]+1,iscl[1]+1,iscl[2]+1);
     b66:	ldr	r3, [sp, #28]
     b68:	str	r5, [sp, #4]
     b6a:	vcvt.f32.u32	s15, s15
     b6e:	vmov.f32	s14, #112	; 0x3f800000  1.0
     b72:	vadd.f32	s15, s15, s14
     b76:	vldr	s14, [pc, #160]	; c18 <I2S_modification(unsigned long, unsigned short, int)+0xd8>
     b7a:	ldr	r0, [pc, #160]	; (c1c <I2S_modification(unsigned long, unsigned short, int)+0xdc>)
    iscl[2]=0;
  else
    iscl[2]=1;
  
  I2S_dividers(iscl, fsamp ,nch*nbits);
  float fs = (F_CPU * (iscl[0]+1.0f)) / (iscl[1]+1l) / 2 / (iscl[2]+1l) / ((float)nch*nbits);
     b7c:	adds	r1, #1
#if DO_DEBUG>0
  Serial.printf("%d %d %d %d %d %d %d\n\r",
                F_CPU, fsamp, (int)fs, nbits,iscl[0]+1,iscl[1]+1,iscl[2]+1);
     b7e:	vmul.f32	s15, s15, s14
     b82:	vmov	s14, r1
     b86:	vcvt.f32.u32	s14, s14
    iscl[2]=0;
  else
    iscl[2]=1;
  
  I2S_dividers(iscl, fsamp ,nch*nbits);
  float fs = (F_CPU * (iscl[0]+1.0f)) / (iscl[1]+1l) / 2 / (iscl[2]+1l) / ((float)nch*nbits);
     b8a:	adds	r2, #1
#if DO_DEBUG>0
  Serial.printf("%d %d %d %d %d %d %d\n\r",
                F_CPU, fsamp, (int)fs, nbits,iscl[0]+1,iscl[1]+1,iscl[2]+1);
     b8c:	vdiv.f32	s13, s15, s14
     b90:	adds	r3, #1
     b92:	str	r2, [sp, #16]
     b94:	str	r1, [sp, #12]
     b96:	str	r3, [sp, #8]
     b98:	ldr	r1, [pc, #132]	; (c20 <I2S_modification(unsigned long, unsigned short, int)+0xe0>)
     b9a:	mov	r3, r6
     b9c:	vmov	s15, r2
     ba0:	vmov.f32	s14, #96	; 0x3f000000  0.5
     ba4:	vmul.f32	s14, s13, s14
     ba8:	vcvt.f32.u32	s15, s15
     bac:	ldr	r2, [pc, #116]	; (c24 <I2S_modification(unsigned long, unsigned short, int)+0xe4>)
     bae:	vdiv.f32	s13, s14, s15
     bb2:	vmov	s15, r4
     bb6:	vmov	s14, r5
     bba:	vcvt.f32.s32	s15, s15
     bbe:	vcvt.f32.s32	s14, s14
     bc2:	vmul.f32	s15, s15, s14
     bc6:	vdiv.f32	s14, s13, s15
     bca:	vcvt.s32.f32	s14, s14
     bce:	vstr	s14, [sp]
     bd2:	bl	9ef6 <Print::printf(char const*, ...)>
#endif
  // stop I2S
  I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     bd6:	ldr	r1, [pc, #80]	; (c28 <I2S_modification(unsigned long, unsigned short, int)+0xe8>)
     bd8:	ldr	r3, [r1, #0]
     bda:	bic.w	r3, r3, #2415919104	; 0x90000000
     bde:	str	r3, [r1, #0]

  // modify sampling frequency
  I2S0_MDR = I2S_MDR_FRACT(iscl[0]) | I2S_MDR_DIVIDE(iscl[1]);
     be0:	ldr	r3, [sp, #28]
     be2:	lsls	r3, r3, #12
     be4:	and.w	r2, r3, #1044480	; 0xff000
     be8:	ldr	r3, [sp, #32]
     bea:	ubfx	r3, r3, #0, #12
     bee:	orrs	r3, r2
     bf0:	ldr	r2, [pc, #56]	; (c2c <I2S_modification(unsigned long, unsigned short, int)+0xec>)
     bf2:	str	r3, [r2, #0]

  // configure transmitter
  I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
    | I2S_TCR2_BCD | I2S_TCR2_DIV(iscl[2]);
     bf4:	ldrb.w	r3, [sp, #36]	; 0x24
     bf8:	orr.w	r3, r3, #117440512	; 0x7000000
     bfc:	str.w	r3, [r2, #-252]
//  I2S0_TCR4 = I2S_TCR4_FRSZ(nch-1) | I2S_TCR4_SYWD(0) | I2S_TCR4_MF
//    | I2S_TCR4_FSE | I2S_TCR4_FSD;

  // configure receiver (sync'd to transmitter clocks)
  I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
    | I2S_RCR2_BCD | I2S_RCR2_DIV(iscl[2]);
     c00:	ldrb.w	r3, [sp, #36]	; 0x24
     c04:	orr.w	r3, r3, #1191182336	; 0x47000000
     c08:	str.w	r3, [r2, #-124]
//  I2S0_RCR4 = I2S_RCR4_FRSZ(nch-1) | I2S_RCR4_SYWD(0) | I2S_RCR4_MF
//    | I2S_RCR4_FSE | I2S_RCR4_FSD;

  //restart I2S
  I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE;
     c0c:	ldr	r3, [r1, #0]
     c0e:	orr.w	r3, r3, #2415919104	; 0x90000000
     c12:	str	r3, [r1, #0]
}
     c14:	add	sp, #40	; 0x28
     c16:	pop	{r4, r5, r6, pc}
     c18:	.word	0x4cb71b00
     c1c:	.word	0x20013d54
     c20:	.word	0x00012822
     c24:	.word	0x05b8d800
     c28:	.word	0x4002f080
     c2c:	.word	0x4002f104

00000c30 <FsBaseFile::open(char const*, int)>:
   * \param[in] oflag Values for \a oflag are constructed by a
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
     c30:	mov	r3, r2
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
     c32:	ldr	r2, [pc, #28]	; (c50 <FsBaseFile::open(char const*, int)+0x20>)
   * \param[in] oflag Values for \a oflag are constructed by a
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
     c34:	push	{r4}
     c36:	mov	r4, r1
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
     c38:	ldr	r1, [r2, #0]
     c3a:	cbz	r1, c46 <FsBaseFile::open(char const*, int)+0x16>
     c3c:	mov	r2, r4
  }
     c3e:	ldr.w	r4, [sp], #4
   *                  bitwise-inclusive OR of open flags.
   *
   * \return true for success or false for failure.
   */
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
    return FsVolume::m_cwv && open(FsVolume::m_cwv, path, oflag);
     c42:	b.w	7148 <FsBaseFile::open(FsVolume*, char const*, int)>
  }
     c46:	mov	r0, r1
     c48:	ldr.w	r4, [sp], #4
     c4c:	bx	lr
     c4e:	nop
     c50:	.word	0x20019ea4

00000c54 <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     c54:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     c56:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     c58:	cbz	r0, c5e <FsBaseFile::read(void*, unsigned int)+0xa>
     c5a:	b.w	59a4 <FatFile::read(void*, unsigned int)>
     c5e:	ldr	r0, [r3, #60]	; 0x3c
     c60:	cbz	r0, c66 <FsBaseFile::read(void*, unsigned int)+0x12>
     c62:	b.w	3d10 <ExFatFile::read(void*, unsigned int)>
  }
     c66:	mov.w	r0, #4294967295
     c6a:	bx	lr

00000c6c <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     c6c:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     c6e:	movs	r2, #1
     c70:	add.w	r1, sp, #7
     c74:	adds	r0, #16
     c76:	bl	c54 <FsBaseFile::read(void*, unsigned int)>
     c7a:	cmp	r0, #1
     c7c:	ite	eq
     c7e:	ldrbeq.w	r0, [sp, #7]
     c82:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     c86:	add	sp, #12
     c88:	ldr.w	pc, [sp], #4

00000c8c <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     c8c:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c8e:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     c90:	cbz	r4, ca4 <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c92:	cmp	r3, #1
     c94:	it	eq
     c96:	cmpeq	r2, #0
     c98:	bcs.n	cae <FsBaseFile::seekSet(unsigned long long)+0x22>
     c9a:	mov	r0, r4
     c9c:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     c9e:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     ca0:	b.w	5b7e <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     ca4:	ldr	r0, [r0, #60]	; 0x3c
     ca6:	cbz	r0, cae <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     ca8:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     caa:	b.w	3ec0 <ExFatFile::seekSet(unsigned long long)>
  }
     cae:	movs	r0, #0
     cb0:	pop	{r4, r6, r7}
     cb2:	bx	lr

00000cb4 <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     cb4:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     cb6:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     cb8:	cbz	r0, cbe <FsBaseFile::write(void const*, unsigned int)+0xa>
     cba:	b.w	6420 <FatFile::write(void const*, unsigned int)>
     cbe:	ldr	r0, [r3, #60]	; 0x3c
     cc0:	cbz	r0, cc6 <FsBaseFile::write(void const*, unsigned int)+0x12>
     cc2:	b.w	4f9c <ExFatFile::write(void const*, unsigned int)>
  }
     cc6:	bx	lr

00000cc8 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     cc8:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     cca:	adds	r0, #16
     ccc:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
  }
     cd0:	pop	{r3, pc}

00000cd2 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     cd2:	push	{r0, r1, r2, lr}
     cd4:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     cd6:	movs	r2, #1
     cd8:	strb.w	r1, [r3, #-1]!
     cdc:	adds	r0, #16
     cde:	mov	r1, r3
     ce0:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     ce4:	add	sp, #12
     ce6:	ldr.w	pc, [sp], #4
     cea:	Address 0x00000cea is out of bounds.


00000cec <makeFilename(char*)>:
  // Return low time bits in units of 10 ms.
  *ms10 = second() & 1 ? 100 : 0;
}

char *makeFilename(char * prefix)
{ static char filename[40];
     cec:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     cf0:	sub	sp, #24
     cf2:	mov	r5, r0

  sprintf(filename, "%s_%04d_%02d_%02d_%02d_%02d_%02d%s", prefix, 
     cf4:	bl	227c <year()>
     cf8:	mov	r6, r0
     cfa:	bl	2268 <month()>
     cfe:	mov	r7, r0
     d00:	bl	2254 <day()>
     d04:	mov	r8, r0
     d06:	bl	2218 <hour()>
     d0a:	mov	r9, r0
     d0c:	bl	222c <minute()>
     d10:	mov	sl, r0
     d12:	bl	2240 <second()>
                    year(), month(), day(), hour(), minute(), second(), postfix);
     d16:	ldr	r4, [pc, #48]	; (d48 <makeFilename(char*)+0x5c>)
     d18:	ldr	r3, [pc, #48]	; (d4c <makeFilename(char*)+0x60>)
     d1a:	str	r3, [sp, #20]
     d1c:	mov	r2, r5
     d1e:	mov	r3, r6
     d20:	str	r0, [sp, #16]
     d22:	stmia.w	sp, {r7, r8, r9, sl}
     d26:	ldr	r1, [pc, #40]	; (d50 <makeFilename(char*)+0x64>)
     d28:	mov	r0, r4
     d2a:	bl	c038 <sprintf>
  #if DO_DEBUG>0
    Serial.println(filename);
     d2e:	mov	r1, r4
     d30:	ldr	r0, [pc, #32]	; (d54 <makeFilename(char*)+0x68>)
     d32:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  #endif
  #if DO_DEBUG>1
    logFile.println(filename);
     d36:	mov	r1, r4
     d38:	ldr	r0, [pc, #28]	; (d58 <makeFilename(char*)+0x6c>)
     d3a:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  #endif
  return filename;  
}
     d3e:	mov	r0, r4
     d40:	add	sp, #24
     d42:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     d46:	nop
     d48:	.word	0x20018ef4
     d4c:	.word	0x20013938
     d50:	.word	0x00012839
     d54:	.word	0x20013d54
     d58:	.word	0x20019080

00000d5c <wavHeader(unsigned long)>:

	return header;
}

char * wavHeader(uint32_t fileSize)
{
     d5c:	push	{r3, r4, r5, lr}

  int nsamp=(fileSize-44)/(nbytes*nchan);
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
     d5e:	ldr	r4, [pc, #124]	; (ddc <wavHeader(unsigned long)+0x80>)
     d60:	ldr	r1, [pc, #124]	; (de0 <wavHeader(unsigned long)+0x84>)

	return header;
}

char * wavHeader(uint32_t fileSize)
{
     d62:	mov	r5, r0

  int nsamp=(fileSize-44)/(nbytes*nchan);
  //
  static char wheader[48]; // 44 for wav
  //
  strcpy(wheader,"RIFF");
     d64:	mov	r0, r4
     d66:	bl	c1b0 <strcpy>
  strcpy(wheader+8,"WAVE");
     d6a:	ldr	r1, [pc, #120]	; (de4 <wavHeader(unsigned long)+0x88>)
     d6c:	add.w	r0, r4, #8
     d70:	bl	c1b0 <strcpy>
  strcpy(wheader+12,"fmt ");
     d74:	ldr	r1, [pc, #112]	; (de8 <wavHeader(unsigned long)+0x8c>)
     d76:	add.w	r0, r4, #12
     d7a:	bl	c1b0 <strcpy>
  strcpy(wheader+36,"data");
     d7e:	ldr	r1, [pc, #108]	; (dec <wavHeader(unsigned long)+0x90>)
     d80:	add.w	r0, r4, #36	; 0x24
     d84:	bl	c1b0 <strcpy>
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
     d88:	mvn.w	r0, #127	; 0x7f
     d8c:	strb	r0, [r4, #24]
     d8e:	mvn.w	r0, #68	; 0x44
     d92:	strb	r0, [r4, #25]
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
     d94:	movs	r0, #119	; 0x77
     d96:	strb	r0, [r4, #29]
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
     d98:	sub.w	r0, r5, #44	; 0x2c
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
     d9c:	movs	r2, #1
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
     d9e:	bic.w	r0, r0, #1
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
     da2:	movs	r3, #0
     da4:	movs	r1, #16
  *(int16_t*)(wheader+20)= 1; // PCM 
     da6:	strb	r2, [r4, #20]
  *(int16_t*)(wheader+22)=nchan;// numChannels 
     da8:	strb	r2, [r4, #22]
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
     daa:	strb	r2, [r4, #30]
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
     dac:	str	r0, [r4, #40]	; 0x28
  *(int32_t*)(wheader+16)= 16;// chunk_size
  *(int16_t*)(wheader+20)= 1; // PCM 
  *(int16_t*)(wheader+22)=nchan;// numChannels 
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
     dae:	movs	r2, #2
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
  *(int32_t*)(wheader+4)=36+nsamp*nchan*nbytes; 
     db0:	adds	r0, #36	; 0x24
     db2:	str	r0, [r4, #4]
  //
  strcpy(wheader,"RIFF");
  strcpy(wheader+8,"WAVE");
  strcpy(wheader+12,"fmt ");
  strcpy(wheader+36,"data");
  *(int32_t*)(wheader+16)= 16;// chunk_size
     db4:	strb	r1, [r4, #16]
     db6:	strb	r3, [r4, #17]
     db8:	strb	r3, [r4, #18]
     dba:	strb	r3, [r4, #19]
  *(int16_t*)(wheader+20)= 1; // PCM 
     dbc:	strb	r3, [r4, #21]
  *(int16_t*)(wheader+22)=nchan;// numChannels 
     dbe:	strb	r3, [r4, #23]
  *(int32_t*)(wheader+24)= fsamp; // sample rate 
     dc0:	strb	r3, [r4, #26]
     dc2:	strb	r3, [r4, #27]
  *(int32_t*)(wheader+28)= fsamp*nbytes; // byte rate
     dc4:	strb	r3, [r4, #28]
     dc6:	strb	r3, [r4, #31]
  *(int16_t*)(wheader+32)=nchan*nbytes; // block align
     dc8:	strb.w	r2, [r4, #32]
     dcc:	strb.w	r3, [r4, #33]	; 0x21
  *(int16_t*)(wheader+34)=nbits; // bits per sample 
     dd0:	strb.w	r1, [r4, #34]	; 0x22
     dd4:	strb.w	r3, [r4, #35]	; 0x23
  *(int32_t*)(wheader+40)=nsamp*nchan*nbytes; 
  *(int32_t*)(wheader+4)=36+nsamp*nchan*nbytes; 

   return wheader;
}
     dd8:	mov	r0, r4
     dda:	pop	{r3, r4, r5, pc}
     ddc:	.word	0x20018f4c
     de0:	.word	0x0001287a
     de4:	.word	0x0001287f
     de8:	.word	0x00012884
     dec:	.word	0x00012889

00000df0 <c_uSD::init()>:
  nbuf=0;
  state=0;
}
*/
void c_uSD::init()
{
     df0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     df4:	mov	r4, r0
     df6:	sub	sp, #64	; 0x40
  delay(200);
     df8:	movs	r0, #200	; 0xc8
     dfa:	bl	925c <delay>
			} else if (pin == 11) {
				CORE_PIN11_PORTSET = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTSET = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTSET = CORE_PIN13_BITMASK;
     dfe:	ldr.w	r8, [pc, #320]	; f40 <c_uSD::init()+0x150>
			} else if (pin == 11) {
				CORE_PIN11_PORTCLEAR = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTCLEAR = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTCLEAR = CORE_PIN13_BITMASK;
     e02:	ldr.w	r9, [pc, #320]	; f44 <c_uSD::init()+0x154>
  int SD_success = 0;
     e06:	movs	r6, #0
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
     e08:	movs	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
     e0a:	movs	r1, #0
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
     e0c:	add.w	r5, r4, #1168	; 0x490
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
     e10:	strb.w	r3, [r4, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
     e14:	strb.w	r1, [r4, #1212]	; 0x4bc
     e18:	mov	r0, r5
     e1a:	bl	84fc <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
     e1e:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
     e22:	mov	r0, r5
     e24:	bl	7ce8 <SdioCard::errorCode() const>
     e28:	mov	r7, r0
     e2a:	cbz	r0, e66 <c_uSD::init()+0x76>
  char SD_filename[24];

  while (!sd.begin(SD_CONFIG))
  {
     // configure pin 13 for LED      
     pinMode(13,OUTPUT);
     e2c:	movs	r1, #1
     e2e:	movs	r0, #13
     e30:	bl	91bc <pinMode>
			} else if (pin == 11) {
				CORE_PIN11_PORTSET = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTSET = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTSET = CORE_PIN13_BITMASK;
     e34:	movs	r7, #32
     e36:	movs	r5, #8
     e38:	mov	sl, r7
     for(int idx = 0; idx < 8; idx++)
     {
         digitalWriteFast(13,HIGH);
         delay(200);
     e3a:	movs	r0, #200	; 0xc8
     e3c:	str.w	sl, [r8]
     e40:	bl	925c <delay>
			} else if (pin == 11) {
				CORE_PIN11_PORTCLEAR = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTCLEAR = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTCLEAR = CORE_PIN13_BITMASK;
     e44:	str.w	r7, [r9]
         digitalWriteFast(13,LOW);
         delay(200);
     e48:	movs	r0, #200	; 0xc8
     e4a:	bl	925c <delay>

  while (!sd.begin(SD_CONFIG))
  {
     // configure pin 13 for LED      
     pinMode(13,OUTPUT);
     for(int idx = 0; idx < 8; idx++)
     e4e:	subs	r5, #1
     e50:	bne.n	e3a <c_uSD::init()+0x4a>
         digitalWriteFast(13,HIGH);
         delay(200);
         digitalWriteFast(13,LOW);
         delay(200);
     }
     delay(5000);
     e52:	movw	r0, #5000	; 0x1388
     e56:	bl	925c <delay>
     SD_success++;
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
     e5a:	ldr	r3, [pc, #196]	; (f20 <c_uSD::init()+0x130>)
     e5c:	mov.w	r2, #1024	; 0x400
         delay(200);
         digitalWriteFast(13,LOW);
         delay(200);
     }
     delay(5000);
     SD_success++;
     e60:	adds	r6, #1
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
     e62:	str	r2, [r3, #0]
  delay(200);
  int SD_success = 0;
  char text[32];
  char SD_filename[24];

  while (!sd.begin(SD_CONFIG))
     e64:	b.n	e08 <c_uSD::init()+0x18>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
     e66:	ldr.w	r1, [r4, #1164]	; 0x48c
     e6a:	mov	r0, r4
     e6c:	bl	7224 <FsVolume::begin(BlockDeviceInterface*)>
     e70:	cmp	r0, #0
     e72:	beq.n	e2c <c_uSD::init()+0x3c>
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
  }

  sprintf(SD_filename, "SD_s_%s.txt", acqParameters.name);
  file.open(SD_filename, O_CREAT|O_WRITE|O_APPEND);
     e74:	add.w	r5, r4, #1232	; 0x4d0
     SD_success++;
     // reconfigure pin 13 for I2S
     CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
  }

  sprintf(SD_filename, "SD_s_%s.txt", acqParameters.name);
     e78:	ldr	r2, [pc, #168]	; (f24 <c_uSD::init()+0x134>)
     e7a:	ldr	r1, [pc, #172]	; (f28 <c_uSD::init()+0x138>)
     e7c:	add	r0, sp, #8
     e7e:	bl	c038 <sprintf>
  file.open(SD_filename, O_CREAT|O_WRITE|O_APPEND);
     e82:	add	r1, sp, #8
     e84:	movw	r2, #521	; 0x209
     e88:	mov	r0, r5
     e8a:	bl	c30 <FsBaseFile::open(char const*, int)>
    sprintf(text, "%04d_%02d_%02d,", year(), month(), day());  file.write((char*)text, strlen(text));
     e8e:	bl	227c <year()>
     e92:	mov	r8, r0
     e94:	bl	2268 <month()>
     e98:	mov	r9, r0
     e9a:	bl	2254 <day()>
     e9e:	mov	r3, r9
     ea0:	mov	r2, r8
     ea2:	str	r0, [sp, #0]
     ea4:	ldr	r1, [pc, #132]	; (f2c <c_uSD::init()+0x13c>)
     ea6:	add	r0, sp, #32
     ea8:	bl	c038 <sprintf>
     eac:	add	r0, sp, #32
     eae:	bl	c280 <strlen>
     eb2:	add	r1, sp, #32
     eb4:	mov	r2, r0
     eb6:	mov	r0, r5
     eb8:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
    sprintf(text, "%02d_%02d_%02d,", hour(), minute(), second());   file.write((char*)text, strlen(text));
     ebc:	bl	2218 <hour()>
     ec0:	mov	r8, r0
     ec2:	bl	222c <minute()>
     ec6:	mov	r9, r0
     ec8:	bl	2240 <second()>
     ecc:	mov	r3, r9
     ece:	mov	r2, r8
     ed0:	str	r0, [sp, #0]
     ed2:	ldr	r1, [pc, #92]	; (f30 <c_uSD::init()+0x140>)
     ed4:	add	r0, sp, #32
     ed6:	bl	c038 <sprintf>
     eda:	add	r0, sp, #32
     edc:	bl	c280 <strlen>
     ee0:	add	r1, sp, #32
     ee2:	mov	r2, r0
     ee4:	mov	r0, r5
     ee6:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
    sprintf(text, "%10d\r\n", SD_success);          file.write((char*)text, strlen(text));
     eea:	mov	r2, r6
     eec:	ldr	r1, [pc, #68]	; (f34 <c_uSD::init()+0x144>)
     eee:	add	r0, sp, #32
     ef0:	bl	c038 <sprintf>
     ef4:	add	r0, sp, #32
     ef6:	bl	c280 <strlen>
     efa:	add	r1, sp, #32
     efc:	mov	r2, r0
     efe:	mov	r0, r5
     f00:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
  file.close(); 
     f04:	mov	r0, r5
     f06:	bl	7120 <FsBaseFile::close()>
  
  // Set Time callback
  FsDateTime::callback = dateTime;
     f0a:	ldr	r2, [pc, #44]	; (f38 <c_uSD::init()+0x148>)
     f0c:	ldr	r3, [pc, #44]	; (f3c <c_uSD::init()+0x14c>)
  //
  nbuf=0;
     f0e:	strh.w	r7, [r4, #1298]	; 0x512
    sprintf(text, "%02d_%02d_%02d,", hour(), minute(), second());   file.write((char*)text, strlen(text));
    sprintf(text, "%10d\r\n", SD_success);          file.write((char*)text, strlen(text));
  file.close(); 
  
  // Set Time callback
  FsDateTime::callback = dateTime;
     f12:	str	r2, [r3, #0]
  //
  nbuf=0;
  state=0;
     f14:	strh.w	r7, [r4, #1296]	; 0x510
}
     f18:	add	sp, #64	; 0x40
     f1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     f1e:	nop
     f20:	.word	0x4004b014
     f24:	.word	0x20013984
     f28:	.word	0x0001288e
     f2c:	.word	0x0001289a
     f30:	.word	0x000128aa
     f34:	.word	0x000128ba
     f38:	.word	0x00000681
     f3c:	.word	0x20019e98
     f40:	.word	0x400ff084
     f44:	.word	0x400ff088

00000f48 <c_uSD::close()>:
    state=close();
  }
  return state;
}
int16_t c_uSD::close(void)
{   // close file
     f48:	push	{r4, r5, r6, lr}
     f4a:	mov	r4, r0
    file.truncate();
     f4c:	add.w	r6, r0, #1232	; 0x4d0
  /** Truncate a file to the current position.
   *
   * \return true for success or false for failure.
   */
  bool truncate() {
    return m_fFile ? m_fFile->truncate() :
     f50:	ldr.w	r0, [r0, #1288]	; 0x508
           m_xFile ? m_xFile->truncate() : false;
     f54:	cbz	r0, f5c <c_uSD::close()+0x14>
     f56:	bl	63b8 <FatFile::truncate()>
     f5a:	b.n	f66 <c_uSD::close()+0x1e>
     f5c:	ldr.w	r0, [r4, #1292]	; 0x50c
     f60:	cbz	r0, f66 <c_uSD::close()+0x1e>
     f62:	bl	4edc <ExFatFile::truncate()>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     f66:	ldr.w	r3, [r4, #1288]	; 0x508
           m_xFile ? m_xFile->fileSize() : 0;
     f6a:	cbz	r3, f70 <c_uSD::close()+0x28>
     f6c:	ldr	r5, [r3, #28]
     f6e:	b.n	f7c <c_uSD::close()+0x34>
     f70:	ldr.w	r3, [r4, #1292]	; 0x50c
     f74:	cbz	r3, f7a <c_uSD::close()+0x32>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     f76:	ldr	r5, [r3, #16]
     f78:	b.n	f7c <c_uSD::close()+0x34>
     f7a:	movs	r5, #0
    #ifdef GEN_WAV_FILE
       uint32_t fileSize = file.size();
       memcpy(header,wavHeader(fileSize),44);
     f7c:	mov	r0, r5
     f7e:	bl	d5c <wavHeader(unsigned long)>
     f82:	ldr	r3, [pc, #64]	; (fc4 <c_uSD::close()+0x7c>)
     f84:	add.w	r2, r0, #44	; 0x2c
     f88:	ldr.w	r1, [r0], #4
     f8c:	str.w	r1, [r3], #4
     f90:	cmp	r0, r2
     f92:	bne.n	f88 <c_uSD::close()+0x40>
   *
   * \param[in] pos the new file position.
   * \return true for success or false for failure.
   */
  bool seek(PosType pos) {
    return BaseFile::seekSet(pos);
     f94:	movs	r3, #0
     f96:	movs	r2, #0
     f98:	mov	r0, r6
     f9a:	bl	c8c <FsBaseFile::seekSet(unsigned long long)>
       file.seek(0);
       file.write(header,512);
     f9e:	ldr	r1, [pc, #36]	; (fc4 <c_uSD::close()+0x7c>)
     fa0:	mov.w	r2, #512	; 0x200
     fa4:	mov	r0, r6
     fa6:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
     faa:	mov	r2, r5
     fac:	movs	r3, #0
     fae:	mov	r0, r6
     fb0:	bl	c8c <FsBaseFile::seekSet(unsigned long long)>
       file.seek(fileSize);
    #endif
    file.close();
     fb4:	mov	r0, r6
     fb6:	bl	7120 <FsBaseFile::close()>
//#if DO_DEBUG>0
//    Serial.println("file Closed");    
//#endif
    state=0;  // flag to open new file
     fba:	movs	r0, #0
     fbc:	strh.w	r0, [r4, #1296]	; 0x510
    return state;
}
     fc0:	pop	{r4, r5, r6, pc}
     fc2:	nop
     fc4:	.word	0x20014cf4

00000fc8 <c_uSD::storeConfig(unsigned long*, int, long*, int)>:

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
     fc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
     fcc:	add.w	r7, r0, #1232	; 0x4d0
    state=0;  // flag to open new file
    return state;
}

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
     fd0:	sub	sp, #32
     fd2:	mov	r4, r0
     fd4:	mov	r8, r1
     fd6:	mov	r9, r2
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
     fd8:	ldr	r1, [pc, #128]	; (105c <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x94>)
    state=0;  // flag to open new file
    return state;
}

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
     fda:	ldr	r6, [sp, #64]	; 0x40
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
     fdc:	movw	r2, #1537	; 0x601
     fe0:	mov	r0, r7
    state=0;  // flag to open new file
    return state;
}

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
     fe2:	mov	sl, r3
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
     fe4:	bl	c30 <FsBaseFile::open(char const*, int)>
  for(int ii=0; ii<n1; ii++)
     fe8:	movs	r5, #0
     fea:	add.w	r4, r4, #1216	; 0x4c0
     fee:	cmp	r5, r9
     ff0:	blt.n	ff6 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x2e>
     ff2:	movs	r5, #0
     ff4:	b.n	1016 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x4e>
  { sprintf(text,"%10d\r\n",(int) param1[ii]); file.write((uint8_t*)text,strlen(text));
     ff6:	ldr.w	r2, [r8, r5, lsl #2]
     ffa:	ldr	r1, [pc, #100]	; (1060 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x98>)
     ffc:	mov	r0, sp
     ffe:	bl	c038 <sprintf>
    1002:	mov	r0, sp
    1004:	bl	c280 <strlen>
    1008:	mov	r1, sp
    100a:	mov	r2, r0
    100c:	mov	r0, r4
    100e:	bl	cc8 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>
}

void c_uSD::storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{ char text[32];
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
  for(int ii=0; ii<n1; ii++)
    1012:	adds	r5, #1
    1014:	b.n	fee <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x26>
  { sprintf(text,"%10d\r\n",(int) param1[ii]); file.write((uint8_t*)text,strlen(text));
  }
//
  for(int ii=0; ii<n2; ii++)
    1016:	cmp	r5, r6
    1018:	bge.n	103a <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x72>
  { sprintf(text,"%10d\r\n",(int) param2[ii]); file.write((uint8_t*)text,strlen(text));
    101a:	ldr.w	r2, [sl, r5, lsl #2]
    101e:	ldr	r1, [pc, #64]	; (1060 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x98>)
    1020:	mov	r0, sp
    1022:	bl	c038 <sprintf>
    1026:	mov	r0, sp
    1028:	bl	c280 <strlen>
    102c:	mov	r1, sp
    102e:	mov	r2, r0
    1030:	mov	r0, r4
    1032:	bl	cc8 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>
  file.open("Config.txt", O_CREAT|O_WRITE|O_TRUNC);
  for(int ii=0; ii<n1; ii++)
  { sprintf(text,"%10d\r\n",(int) param1[ii]); file.write((uint8_t*)text,strlen(text));
  }
//
  for(int ii=0; ii<n2; ii++)
    1036:	adds	r5, #1
    1038:	b.n	1016 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x4e>
  { sprintf(text,"%10d\r\n",(int) param2[ii]); file.write((uint8_t*)text,strlen(text));
  }
  sprintf(text,"%s\r\n",(char*) &param1[n1]);
    103a:	add.w	r2, r8, r9, lsl #2
    103e:	ldr	r1, [pc, #36]	; (1064 <c_uSD::storeConfig(unsigned long*, int, long*, int)+0x9c>)
    1040:	mov	r0, sp
    1042:	bl	c038 <sprintf>
  file.write((uint8_t *)text,6);
    1046:	movs	r2, #6
    1048:	mov	r1, sp
    104a:	mov	r0, r4
    104c:	bl	cc8 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>

  file.close();
    1050:	mov	r0, r7
    1052:	bl	7120 <FsBaseFile::close()>
  
}
    1056:	add	sp, #32
    1058:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    105c:	.word	0x000128c1
    1060:	.word	0x000128ba
    1064:	.word	0x000128cc

00001068 <c_uSD::loadConfig(unsigned long*, int, long*, int)>:

void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
    1068:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
    106c:	add.w	r4, r0, #1232	; 0x4d0
  file.close();
  
}

void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
    1070:	sub	sp, #36	; 0x24
    1072:	mov	r7, r1
    1074:	mov	r8, r2
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
    1076:	ldr	r1, [pc, #128]	; (10f8 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x90>)
  file.close();
  
}

void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
    1078:	ldr	r6, [sp, #64]	; 0x40
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
    107a:	movs	r2, #0
    107c:	mov	r0, r4
  file.close();
  
}

void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
    107e:	mov	r9, r3
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
    1080:	bl	c30 <FsBaseFile::open(char const*, int)>
    1084:	cbz	r0, 10f2 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x8a>
    1086:	movs	r5, #0
  //
  for(int ii=0; ii<n1; ii++)
    1088:	cmp	r5, r8
    108a:	blt.n	1090 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x28>
    108c:	movs	r5, #0
    108e:	b.n	10ca <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x62>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
    1090:	movs	r2, #12
    1092:	mov	r1, sp
    1094:	mov	r0, r4
    1096:	bl	c54 <FsBaseFile::read(void*, unsigned int)>
    109a:	cmp	r0, #0
    109c:	ble.n	10aa <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x42>
    109e:	add.w	r2, r7, r5, lsl #2
    10a2:	ldr	r1, [pc, #88]	; (10fc <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x94>)
    10a4:	mov	r0, sp
    10a6:	bl	c084 <sscanf>
void c_uSD::loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2)
{
  char text[32];
  if(!file.open("Config.txt",O_RDONLY)) return;
  //
  for(int ii=0; ii<n1; ii++)
    10aa:	adds	r5, #1
    10ac:	b.n	1088 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x20>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
  }
  for(int ii=0; ii<n2; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
    10ae:	movs	r2, #12
    10b0:	mov	r1, sp
    10b2:	mov	r0, r4
    10b4:	bl	c54 <FsBaseFile::read(void*, unsigned int)>
    10b8:	cmp	r0, #0
    10ba:	ble.n	10c8 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x60>
    10bc:	add.w	r2, r9, r5, lsl #2
    10c0:	ldr	r1, [pc, #56]	; (10fc <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x94>)
    10c2:	mov	r0, sp
    10c4:	bl	c084 <sscanf>
  if(!file.open("Config.txt",O_RDONLY)) return;
  //
  for(int ii=0; ii<n1; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d",(int *) &param1[ii]);
  }
  for(int ii=0; ii<n2; ii++)
    10c8:	adds	r5, #1
    10ca:	cmp	r5, r6
    10cc:	blt.n	10ae <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x46>
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
  }
  if(file.read((uint8_t *)text,6))
    10ce:	movs	r2, #6
    10d0:	mov	r1, sp
    10d2:	mov	r0, r4
    10d4:	bl	c54 <FsBaseFile::read(void*, unsigned int)>
    10d8:	cbz	r0, 10ec <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x84>
  { text[5]=0;
    10da:	movs	r3, #0
    sscanf(text,"%s",(char *) &param1[n1]);
    10dc:	add.w	r2, r7, r8, lsl #2
    10e0:	ldr	r1, [pc, #28]	; (1100 <c_uSD::loadConfig(unsigned long*, int, long*, int)+0x98>)
  }
  for(int ii=0; ii<n2; ii++)
  { if(file.read((uint8_t*)text,12)>0) sscanf(text,"%d", (int *)&param2[ii]);
  }
  if(file.read((uint8_t *)text,6))
  { text[5]=0;
    10e2:	strb.w	r3, [sp, #5]
    sscanf(text,"%s",(char *) &param1[n1]);
    10e6:	mov	r0, sp
    10e8:	bl	c084 <sscanf>
  }  
  file.close();
    10ec:	mov	r0, r4
    10ee:	bl	7120 <FsBaseFile::close()>
}
    10f2:	add	sp, #36	; 0x24
    10f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    10f8:	.word	0x000128c1
    10fc:	.word	0x000128d1
    1100:	.word	0x00012859

00001104 <rtcSetup()>:
#define RTC_IER_TAIE_MASK       0x4u
#define RTC_SR_TAF_MASK         0x4u

void rtcSetup(void)
{
   SIM_SCGC6 |= SIM_SCGC6_RTC;// enable RTC clock
    1104:	ldr	r2, [pc, #24]	; (1120 <rtcSetup()+0x1c>)
    1106:	ldr	r3, [r2, #0]
    1108:	orr.w	r3, r3, #536870912	; 0x20000000
    110c:	str	r3, [r2, #0]
   RTC_CR |= RTC_CR_OSCE;// enable RTC
    110e:	sub.w	r2, r2, #45056	; 0xb000
    1112:	subs	r2, #44	; 0x2c
    1114:	ldr	r3, [r2, #0]
    1116:	orr.w	r3, r3, #256	; 0x100
    111a:	str	r3, [r2, #0]
    111c:	bx	lr
    111e:	nop
    1120:	.word	0x4004803c

00001124 <rtcSetAlarm(unsigned long)>:
}

void rtcSetAlarm(uint32_t nsec)
{ // set alarm nsec seconds in the future
   RTC_TAR = RTC_TSR + nsec;
    1124:	ldr	r3, [pc, #20]	; (113c <rtcSetAlarm(unsigned long)+0x18>)
   RTC_IER |= RTC_IER_TAIE_MASK;
    1126:	ldr	r2, [pc, #24]	; (1140 <rtcSetAlarm(unsigned long)+0x1c>)
   RTC_CR |= RTC_CR_OSCE;// enable RTC
}

void rtcSetAlarm(uint32_t nsec)
{ // set alarm nsec seconds in the future
   RTC_TAR = RTC_TSR + nsec;
    1128:	ldr	r3, [r3, #0]
    112a:	add	r0, r3
    112c:	ldr	r3, [pc, #20]	; (1144 <rtcSetAlarm(unsigned long)+0x20>)
    112e:	str	r0, [r3, #0]
   RTC_IER |= RTC_IER_TAIE_MASK;
    1130:	ldr	r3, [r2, #0]
    1132:	orr.w	r3, r3, #4
    1136:	str	r3, [r2, #0]
    1138:	bx	lr
    113a:	nop
    113c:	.word	0x4003d000
    1140:	.word	0x4003d01c
    1144:	.word	0x4003d008

00001148 <setWakeupCallandSleep(unsigned long)>:
   asm volatile( "wfi" );  // WFI instruction will start entry into STOP mode
   // will never return, but wake-up results in call to ResetHandler() in mk20dx128.c
}

void setWakeupCallandSleep(uint32_t nsec)
{  // set alarm to nsec secods in future and go to hibernate
    1148:	push	{r4, r5, r6, lr}
    114a:	mov	r6, r0
   rtcSetup();
    114c:	bl	1104 <rtcSetup()>
    RTC_IER = 0;// clear RTC interrupts
}

static void llwuSetup(void)
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
    1150:	ldr	r1, [pc, #196]	; (1218 <setWakeupCallandSleep(unsigned long)+0xd0>)
    1152:	movs	r0, #21
    1154:	bl	9120 <attachInterruptVector>
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
    1158:	ldr	r3, [pc, #192]	; (121c <setWakeupCallandSleep(unsigned long)+0xd4>)
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
    115a:	ldr	r2, [pc, #196]	; (1220 <setWakeupCallandSleep(unsigned long)+0xd8>)
}

static void llwuSetup(void)
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
    115c:	movs	r5, #32
    115e:	strb	r5, [r3, #0]
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
    1160:	mov.w	r3, #2097152	; 0x200000
    1164:	str	r3, [r2, #0]
  NVIC_ENABLE_IRQ( IRQ_LLWU );
    1166:	sub.w	r2, r2, #384	; 0x180
//
  LLWU_PE1 = 0;
    116a:	movs	r4, #0
{
  attachInterruptVector( IRQ_LLWU, llwuISR );
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
  NVIC_ENABLE_IRQ( IRQ_LLWU );
    116c:	str	r3, [r2, #0]
//
  LLWU_PE1 = 0;
    116e:	ldr	r3, [pc, #180]	; (1224 <setWakeupCallandSleep(unsigned long)+0xdc>)
  LLWU_PE7 = 0;
  LLWU_PE8 = 0;
#endif
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
    1170:	ldr	r2, [pc, #180]	; (1228 <setWakeupCallandSleep(unsigned long)+0xe0>)
  NVIC_SET_PRIORITY( IRQ_LLWU, 2*16 );
//
  NVIC_CLEAR_PENDING( IRQ_LLWU );
  NVIC_ENABLE_IRQ( IRQ_LLWU );
//
  LLWU_PE1 = 0;
    1172:	strb	r4, [r3, #0]
  LLWU_PE2 = 0;
    1174:	strb	r4, [r3, #1]
  LLWU_PE3 = 0;
    1176:	strb	r4, [r3, #2]
  LLWU_PE4 = 0;
    1178:	strb	r4, [r3, #3]
#if defined(HAS_KINETIS_LLWU_32CH)
  LLWU_PE5 = 0;
    117a:	strb	r4, [r3, #4]
  LLWU_PE6 = 0;
    117c:	strb	r4, [r3, #5]
  LLWU_PE7 = 0;
    117e:	strb	r4, [r3, #6]
  LLWU_PE8 = 0;
    1180:	strb	r4, [r3, #7]
#endif
  LLWU_ME  = LLWU_ME_WUME5_MASK; //rtc alarm
    1182:	strb	r5, [r3, #8]
//   
    SIM_SOPT1CFG |= SIM_SOPT1CFG_USSWE;
    1184:	ldr	r3, [r2, #0]
    1186:	orr.w	r3, r3, #67108864	; 0x4000000
    118a:	str	r3, [r2, #0]
    SIM_SOPT1 |= SIM_SOPT1_USBSSTBY;
    118c:	ldr.w	r3, [r2, #-4]
    1190:	orr.w	r3, r3, #1073741824	; 0x40000000
    1194:	str.w	r3, [r2, #-4]
//
    PORTA_PCR0 = PORT_PCR_MUX(0);
    1198:	ldr	r3, [pc, #144]	; (122c <setWakeupCallandSleep(unsigned long)+0xe4>)
    119a:	str	r4, [r3, #0]
    PORTA_PCR1 = PORT_PCR_MUX(0);
    119c:	str	r4, [r3, #4]
    PORTA_PCR2 = PORT_PCR_MUX(0);
    119e:	str	r4, [r3, #8]
    PORTA_PCR3 = PORT_PCR_MUX(0);
    11a0:	str	r4, [r3, #12]
    11a2:	adds	r3, #12

    PORTB_PCR2 = PORT_PCR_MUX(0);
    11a4:	addw	r3, r3, #4092	; 0xffc
    11a8:	str	r4, [r3, #0]

void setWakeupCallandSleep(uint32_t nsec)
{  // set alarm to nsec secods in future and go to hibernate
   rtcSetup();
   llwuSetup();  
   rtcSetAlarm(nsec);
    11aa:	mov	r0, r6
    PORTA_PCR1 = PORT_PCR_MUX(0);
    PORTA_PCR2 = PORT_PCR_MUX(0);
    PORTA_PCR3 = PORT_PCR_MUX(0);

    PORTB_PCR2 = PORT_PCR_MUX(0);
    PORTB_PCR3 = PORT_PCR_MUX(0);
    11ac:	str	r4, [r3, #4]

void setWakeupCallandSleep(uint32_t nsec)
{  // set alarm to nsec secods in future and go to hibernate
   rtcSetup();
   llwuSetup();  
   rtcSetAlarm(nsec);
    11ae:	bl	1124 <rtcSetAlarm(unsigned long)>
   yield();
    11b2:	bl	9c60 <yield>
#if DO_DEBUG>0
   Serial.println(nsec);
    11b6:	mov	r1, r6
    11b8:	ldr	r0, [pc, #116]	; (1230 <setWakeupCallandSleep(unsigned long)+0xe8>)
    11ba:	bl	8b4 <Print::println(unsigned long)>
   pinMode(13,OUTPUT); digitalWriteFast(13,HIGH); delay(1000); digitalWriteFast(13,LOW);
    11be:	movs	r1, #1
    11c0:	movs	r0, #13
    11c2:	bl	91bc <pinMode>
			} else if (pin == 11) {
				CORE_PIN11_PORTSET = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTSET = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTSET = CORE_PIN13_BITMASK;
    11c6:	ldr	r3, [pc, #108]	; (1234 <setWakeupCallandSleep(unsigned long)+0xec>)
    11c8:	mov.w	r0, #1000	; 0x3e8
    11cc:	str	r5, [r3, #0]
    11ce:	bl	925c <delay>
			} else if (pin == 11) {
				CORE_PIN11_PORTCLEAR = CORE_PIN11_BITMASK;
			} else if (pin == 12) {
				CORE_PIN12_PORTCLEAR = CORE_PIN12_BITMASK;
			} else if (pin == 13) {
				CORE_PIN13_PORTCLEAR = CORE_PIN13_BITMASK;
    11d2:	ldr	r3, [pc, #100]	; (1238 <setWakeupCallandSleep(unsigned long)+0xf0>)

#define VLLS_MODE VLLS0
static void gotoSleep(void)
{  
//  /* Make sure clock monitor is off so we don't get spurious reset */
   MCG_C6 &= ~MCG_C6_CME0;
    11d4:	ldr	r2, [pc, #100]	; (123c <setWakeupCallandSleep(unsigned long)+0xf4>)
    11d6:	str	r5, [r3, #0]
    11d8:	ldrb	r3, [r2, #5]
    11da:	and.w	r3, r3, #223	; 0xdf
    11de:	strb	r3, [r2, #5]
// is defined in kinetis.h and mk20dx128c
#if defined(HAS_KINETIS_HSRUN) && (F_CPU > 120000000)
    kinetis_hsrun_disable( );
#endif   
   /* Write to PMPROT to allow all possible power modes */
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
    11e0:	ldr	r3, [pc, #92]	; (1240 <setWakeupCallandSleep(unsigned long)+0xf8>)
    11e2:	movs	r2, #2
    11e4:	strb	r2, [r3, #0]
   /* Set the STOPM field to 0b100 for VLLSx mode */
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
    11e6:	ldrb	r2, [r3, #1]
    11e8:	and.w	r2, r2, #248	; 0xf8
    11ec:	strb	r2, [r3, #1]
   SMC_PMCTRL |= SMC_PMCTRL_STOPM(0x4); // VLLSx
    11ee:	ldrb	r2, [r3, #1]
    11f0:	orr.w	r2, r2, #4
    11f4:	strb	r2, [r3, #1]

   SMC_VLLSCTRL =  SMC_VLLSCTRL_VLLSM(VLLS_MODE);
    11f6:	ldr	r2, [pc, #76]	; (1244 <setWakeupCallandSleep(unsigned long)+0xfc>)
    kinetis_hsrun_disable( );
#endif   
   /* Write to PMPROT to allow all possible power modes */
   SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
   /* Set the STOPM field to 0b100 for VLLSx mode */
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
    11f8:	adds	r3, #1
   SMC_PMCTRL |= SMC_PMCTRL_STOPM(0x4); // VLLSx

   SMC_VLLSCTRL =  SMC_VLLSCTRL_VLLSM(VLLS_MODE);
    11fa:	strb	r4, [r2, #0]
   /*wait for write to complete to SMC before stopping core */
   (void) SMC_PMCTRL;

   SYST_CSR &= ~SYST_CSR_TICKINT;      // disable systick timer interrupt
    11fc:	ldr	r2, [pc, #72]	; (1248 <setWakeupCallandSleep(unsigned long)+0x100>)
   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
   SMC_PMCTRL |= SMC_PMCTRL_STOPM(0x4); // VLLSx

   SMC_VLLSCTRL =  SMC_VLLSCTRL_VLLSM(VLLS_MODE);
   /*wait for write to complete to SMC before stopping core */
   (void) SMC_PMCTRL;
    11fe:	ldrb	r3, [r3, #0]

   SYST_CSR &= ~SYST_CSR_TICKINT;      // disable systick timer interrupt
    1200:	ldr	r3, [r2, #0]
    1202:	bic.w	r3, r3, #2
    1206:	str	r3, [r2, #0]
   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;  // Set the SLEEPDEEP bit to enable deep sleep mode (STOP)
    1208:	ldr.w	r3, [r2, #3328]	; 0xd00
    120c:	orr.w	r3, r3, #4
    1210:	str.w	r3, [r2, #3328]	; 0xd00
   
   asm volatile( "wfi" );  // WFI instruction will start entry into STOP mode
    1214:	wfi
    1216:	pop	{r4, r5, r6, pc}
    1218:	.word	0x00000585
    121c:	.word	0xe000e415
    1220:	.word	0xe000e280
    1224:	.word	0x4007c000
    1228:	.word	0x40047004
    122c:	.word	0x40049000
    1230:	.word	0x20013d54
    1234:	.word	0x400ff084
    1238:	.word	0x400ff088
    123c:	.word	0x40064000
    1240:	.word	0x4007e000
    1244:	.word	0x4007e002
    1248:	.word	0xe000e010

0000124c <checkDutyCycle(ACQ_Parameters_s*, short)>:
  #define ShortSleepDuration 60   // i.e. wake up every 'ShortSleepDuration' seconds
#endif
//
// flag can be 0 file to be open // time to shutdown if required
int32_t checkDutyCycle(ACQ_Parameters_s *acqParameters,int16_t flag)
{	static uint32_t t_start = 0;  // start of actual file
    124c:	push	{r3, r4, r5, r6, r7, lr}
    124e:	mov	r7, r0
    1250:	mov	r5, r1
  static uint16_t recording = 0;  // acquisition has started

  uint32_t tt = now();
    1252:	bl	2194 <now()>
    1256:	mov	r4, r0
  uint16_t to = hour();
    1258:	bl	2218 <hour()>
  
  // check if we should sleep longer
  // sleep time between T2 and T3 and T4 and T1 (values are in hours)
  
  uint16_t T1 = acqParameters->T1;
    125c:	ldrh.w	lr, [r7, #12]
  uint16_t T2 = acqParameters->T2;
  uint16_t T3 = acqParameters->T3;
  uint16_t T4 = acqParameters->T4;
    1260:	ldrh.w	ip, [r7, #24]
  
  // check if we should sleep longer
  // sleep time between T2 and T3 and T4 and T1 (values are in hours)
  
  uint16_t T1 = acqParameters->T1;
  uint16_t T2 = acqParameters->T2;
    1264:	ldrh	r3, [r7, #16]
  uint16_t T3 = acqParameters->T3;
    1266:	ldrh	r1, [r7, #20]
  uint16_t T4 = acqParameters->T4;
  uint16_t doRecording=1;
  if (T4<T1) // e.g. 3-4, 23-1 (work over midnight)
    1268:	cmp	lr, ip
int32_t checkDutyCycle(ACQ_Parameters_s *acqParameters,int16_t flag)
{	static uint32_t t_start = 0;  // start of actual file
  static uint16_t recording = 0;  // acquisition has started

  uint32_t tt = now();
  uint16_t to = hour();
    126a:	uxth	r6, r0
  uint16_t T1 = acqParameters->T1;
  uint16_t T2 = acqParameters->T2;
  uint16_t T3 = acqParameters->T3;
  uint16_t T4 = acqParameters->T4;
  uint16_t doRecording=1;
  if (T4<T1) // e.g. 3-4, 23-1 (work over midnight)
    126c:	bls.n	127e <checkDutyCycle(ACQ_Parameters_s*, short)+0x32>
    doRecording =   ((to>=T3) || (to<T4) || ((to>=T1) && (to<T2)));
    126e:	cmp	r6, r1
    1270:	bcs.n	1294 <checkDutyCycle(ACQ_Parameters_s*, short)+0x48>
    1272:	cmp	r6, ip
    1274:	bcc.n	1294 <checkDutyCycle(ACQ_Parameters_s*, short)+0x48>
    1276:	cmp	r6, lr
    1278:	bcc.n	1298 <checkDutyCycle(ACQ_Parameters_s*, short)+0x4c>
    127a:	cmp	r6, r3
    127c:	b.n	128c <checkDutyCycle(ACQ_Parameters_s*, short)+0x40>
  else		// e.g. 3-4, 23-24
    doRecording = (((to>=T1) && (to<T2)) || ((to>=T3) && (to<T4)));
    127e:	cmp	r6, lr
    1280:	bcc.n	1286 <checkDutyCycle(ACQ_Parameters_s*, short)+0x3a>
    1282:	cmp	r6, r3
    1284:	bcc.n	1294 <checkDutyCycle(ACQ_Parameters_s*, short)+0x48>
    1286:	cmp	r6, r1
    1288:	bcc.n	1298 <checkDutyCycle(ACQ_Parameters_s*, short)+0x4c>
    128a:	cmp	r6, ip
    128c:	ite	cs
    128e:	movcs	r2, #0
    1290:	movcc	r2, #1
    1292:	b.n	129a <checkDutyCycle(ACQ_Parameters_s*, short)+0x4e>
    1294:	movs	r2, #1
    1296:	b.n	129a <checkDutyCycle(ACQ_Parameters_s*, short)+0x4e>
    1298:	movs	r2, #0
    129a:	uxth	r0, r2

  uint32_t nsec=0;
  if (doRecording) // we can record
    129c:	cmp	r0, #0
    129e:	beq.n	130e <checkDutyCycle(ACQ_Parameters_s*, short)+0xc2>
      uint16_t t_on = acqParameters->on;
      uint16_t t_dur = acqParameters->ad;
      uint16_t t_rep = acqParameters->ar;
      uint32_t t_rec = acqParameters->rec;
      
    if(flag>=0)
    12a0:	cmp	r5, #0
    12a2:	blt.n	1368 <checkDutyCycle(ACQ_Parameters_s*, short)+0x11c>
    { 
      if((flag>0) && (tt >= t_start + t_dur)) //we are indeed still recording
    12a4:	beq.n	12ca <checkDutyCycle(ACQ_Parameters_s*, short)+0x7e>
    12a6:	ldr	r5, [pc, #200]	; (1370 <checkDutyCycle(ACQ_Parameters_s*, short)+0x124>)
    12a8:	ldrh	r2, [r7, #4]
    12aa:	ldr	r3, [r5, #0]
    12ac:	add	r3, r2
    12ae:	cmp	r4, r3
    12b0:	bcc.n	1368 <checkDutyCycle(ACQ_Parameters_s*, short)+0x11c>
      { // need to close file
        #if DO_DEBUG>0
            Serial.println("close acquisition");
    12b2:	ldr	r1, [pc, #192]	; (1374 <checkDutyCycle(ACQ_Parameters_s*, short)+0x128>)
    12b4:	ldr	r0, [pc, #192]	; (1378 <checkDutyCycle(ACQ_Parameters_s*, short)+0x12c>)
    12b6:	bl	8a0 <Print::println(__FlashStringHelper const*)>
        #endif
        #if DO_DEBUG>1
            logFile.println("close acquisition");
    12ba:	ldr	r1, [pc, #184]	; (1374 <checkDutyCycle(ACQ_Parameters_s*, short)+0x128>)
    12bc:	ldr	r0, [pc, #188]	; (137c <checkDutyCycle(ACQ_Parameters_s*, short)+0x130>)
    12be:	bl	8a0 <Print::println(__FlashStringHelper const*)>
        #endif
        t_start = tt; // update start time for next file
    12c2:	str	r4, [r5, #0]
        return -1; // flag to close acquisition
    12c4:	mov.w	r0, #4294967295
    12c8:	pop	{r3, r4, r5, r6, r7, pc}
      }
      
      if( flag==0 )  // file is closed new file
      { 
        if(!recording) // we are at the beginning of an acquisition cycle
    12ca:	ldr	r3, [pc, #180]	; (1380 <checkDutyCycle(ACQ_Parameters_s*, short)+0x134>)
    12cc:	ldrh	r2, [r3, #0]
    12ce:	cbnz	r2, 12dc <checkDutyCycle(ACQ_Parameters_s*, short)+0x90>
        {
          { t_rec=tt; 
            acqParameters->rec=t_rec;
            recording=1; 
    12d0:	movs	r2, #1
    12d2:	strh	r2, [r3, #0]
          } 
          // the following is for each new file
          t_start = tt; // beginning of each file
    12d4:	ldr	r3, [pc, #152]	; (1370 <checkDutyCycle(ACQ_Parameters_s*, short)+0x124>)
      if( flag==0 )  // file is closed new file
      { 
        if(!recording) // we are at the beginning of an acquisition cycle
        {
          { t_rec=tt; 
            acqParameters->rec=t_rec;
    12d6:	str	r4, [r7, #28]
            recording=1; 
          } 
          // the following is for each new file
          t_start = tt; // beginning of each file
    12d8:	str	r4, [r3, #0]
    12da:	b.n	136c <checkDutyCycle(ACQ_Parameters_s*, short)+0x120>
        }
        else
        // check is we end acquisition cycle
        if ((t_rep>t_on) && (tt >= t_rec + t_on))
    12dc:	ldrh	r2, [r7, #0]
    12de:	ldrh	r0, [r7, #8]
    12e0:	cmp	r2, r0
    12e2:	bcs.n	136c <checkDutyCycle(ACQ_Parameters_s*, short)+0x120>
  if (doRecording) // we can record
  {
      uint16_t t_on = acqParameters->on;
      uint16_t t_dur = acqParameters->ad;
      uint16_t t_rep = acqParameters->ar;
      uint32_t t_rec = acqParameters->rec;
    12e4:	ldr	r3, [r7, #28]
          // the following is for each new file
          t_start = tt; // beginning of each file
        }
        else
        // check is we end acquisition cycle
        if ((t_rep>t_on) && (tt >= t_rec + t_on))
    12e6:	add	r2, r3
    12e8:	cmp	r4, r2
    12ea:	bcc.n	136c <checkDutyCycle(ACQ_Parameters_s*, short)+0x120>
        { // need to stop
          nsec = (t_rec + t_rep - tt);
    12ec:	add	r0, r3
    12ee:	subs	r4, r0, r4
          #ifdef SLEEP_SHORT
            if(nsec>ShortSleepDuration) nsec=ShortSleepDuration;
          #endif
          #if DO_DEBUG>0
            Serial.println(nsec); 
    12f0:	mov	r1, r4
    12f2:	ldr	r0, [pc, #132]	; (1378 <checkDutyCycle(ACQ_Parameters_s*, short)+0x12c>)
    12f4:	bl	8b4 <Print::println(unsigned long)>
            Serial.println("Hibernate now 1");
    12f8:	ldr	r1, [pc, #136]	; (1384 <checkDutyCycle(ACQ_Parameters_s*, short)+0x138>)
    12fa:	ldr	r0, [pc, #124]	; (1378 <checkDutyCycle(ACQ_Parameters_s*, short)+0x12c>)
    12fc:	bl	8a0 <Print::println(__FlashStringHelper const*)>
          #endif
          #if DO_DEBUG>1
            logFile.println(nsec); 
    1300:	mov	r1, r4
    1302:	ldr	r0, [pc, #120]	; (137c <checkDutyCycle(ACQ_Parameters_s*, short)+0x130>)
    1304:	bl	8b4 <Print::println(unsigned long)>
            logFile.println("Hibernate now 1");
    1308:	ldr	r1, [pc, #120]	; (1384 <checkDutyCycle(ACQ_Parameters_s*, short)+0x138>)
    130a:	ldr	r0, [pc, #112]	; (137c <checkDutyCycle(ACQ_Parameters_s*, short)+0x130>)
    130c:	b.n	1360 <checkDutyCycle(ACQ_Parameters_s*, short)+0x114>
    }
    */
  }
  else
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
    130e:	ldr	r2, [pc, #120]	; (1388 <checkDutyCycle(ACQ_Parameters_s*, short)+0x13c>)
    1310:	udiv	r5, r4, r2
    nsec=0;
    // estimate next start time
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
    1314:	cmp	r6, r3
    }
    */
  }
  else
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
    1316:	mls	r2, r2, r5, r4
    nsec=0;
    // estimate next start time
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
    131a:	bcc.n	132e <checkDutyCycle(ACQ_Parameters_s*, short)+0xe2>
    131c:	cmp	r6, r1
    131e:	bcs.n	132e <checkDutyCycle(ACQ_Parameters_s*, short)+0xe2>
    { if(tto < T3 * 3600) 
    1320:	mov.w	r3, #3600	; 0xe10
    1324:	muls	r3, r1
    1326:	cmp	r2, r3
    1328:	bcs.n	132e <checkDutyCycle(ACQ_Parameters_s*, short)+0xe2>
      nsec = T3 * 3600 - tto;
    132a:	subs	r4, r3, r2
    132c:	b.n	1330 <checkDutyCycle(ACQ_Parameters_s*, short)+0xe4>
    */
  }
  else
  {
    uint32_t tto= tt%(24*3600); // seconds since midnight
    nsec=0;
    132e:	mov	r4, r0
    if ((to >= T2) && (to<T3))  // sleep during the day  //eg: to=10: T1=4; T2=9; T3=16; T4=20
    { if(tto < T3 * 3600) 
      nsec = T3 * 3600 - tto;
    }
    //
    if((to>=T4) && (T4>T1)) // sleep over midnight to T1 //eg: to=21: T1=4; T2=9; T3=16; T4=20
    1330:	cmp	r6, ip
    1332:	bcc.n	1346 <checkDutyCycle(ACQ_Parameters_s*, short)+0xfa>
    1334:	cmp	lr, ip
    {  nsec = (T1+24) * 3600 - tto;
    1336:	itttt	cc
    1338:	addcc.w	r4, lr, #24
    133c:	movcc.w	r3, #3600	; 0xe10
    1340:	mulcc.w	r1, r3, r4
    1344:	subcc	r4, r1, r2
    }
    //
    if(to<T1)                                            //eg: to=2:  T1=4; T2=9; T3=16; T4=20
    1346:	cmp	r6, lr
    { nsec = T1 * 3600 - tto;
    1348:	ittt	cc
    134a:	movcc.w	r3, #3600	; 0xe10
    134e:	mulcc.w	r0, r3, lr
    1352:	subcc	r4, r0, r2
    #ifdef SLEEP_SHORT
            if(nsec>ShortSleepDuration) nsec=ShortSleepDuration;
    #endif
    
#if DO_DEBUG>0
    Serial.println(nsec); 
    1354:	mov	r1, r4
    1356:	ldr	r0, [pc, #32]	; (1378 <checkDutyCycle(ACQ_Parameters_s*, short)+0x12c>)
    1358:	bl	8b4 <Print::println(unsigned long)>
    Serial.println("Hibernate now 3");
    135c:	ldr	r1, [pc, #44]	; (138c <checkDutyCycle(ACQ_Parameters_s*, short)+0x140>)
    135e:	ldr	r0, [pc, #24]	; (1378 <checkDutyCycle(ACQ_Parameters_s*, short)+0x12c>)
    1360:	bl	8a0 <Print::println(__FlashStringHelper const*)>
#endif
    return nsec;
    1364:	mov	r0, r4
    1366:	pop	{r3, r4, r5, r6, r7, pc}
  }
  return 0;
    1368:	movs	r0, #0
    136a:	pop	{r3, r4, r5, r6, r7, pc}
    136c:	mov	r0, r5
}
    136e:	pop	{r3, r4, r5, r6, r7, pc}
    1370:	.word	0x20018f1c
    1374:	.word	0x000128e8
    1378:	.word	0x20013d54
    137c:	.word	0x20019080
    1380:	.word	0x200190e8
    1384:	.word	0x000128fa
    1388:	.word	0x00015180
    138c:	.word	0x0001290a

00001390 <setRTCTime(int, int, int, int, int, int)>:
{
    sprintf(text,"%02d:%02d:%02d",hour(),minute(),second());
    return text;
}

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    1390:	push	{r0, r1, r4, lr}
    1392:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    1394:	strb.w	r0, [sp, #2]
}

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 //it is converted to years since 1970
  if( yr > 99)
    1398:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    139a:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 //it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    139c:	ite	gt
    139e:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    13a2:	addle	r4, #30
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    13a4:	strb.w	r2, [r0, #-8]!
      yr = yr - 1970;
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
    13a8:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
    13ac:	ldr	r4, [sp, #16]
  tm.Day = dy;
    13ae:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    13b2:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    13b6:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    13ba:	bl	2094 <makeTime(tmElements_t const&)>
    13be:	mov	r4, r0

class teensy3_clock_class
{
public:
	static unsigned long get(void) __attribute__((always_inline)) { return rtc_get(); }
	static void set(unsigned long t) __attribute__((always_inline)) { rtc_set(t); }
    13c0:	bl	913c <rtc_set>
  Teensy3Clock.set(tt); // for RTC
  setTime(tt); // local
    13c4:	mov	r0, r4
    13c6:	bl	2154 <setTime(long)>
}
    13ca:	add	sp, #8
    13cc:	pop	{r4, pc}

000013ce <boundaryCheck(int, int, int)>:
    }
}
#define MAX_VAL 1<<17 // maimal input value
int boundaryCheck(int val, int minVal, int maxVal)
{
  if(minVal < maxVal) // standard case
    13ce:	cmp	r1, r2
    13d0:	bge.n	13e2 <boundaryCheck(int, int, int)+0x14>
  {
    if(val<minVal) val=minVal;
    13d2:	cmp	r1, r0
    13d4:	bgt.n	13de <boundaryCheck(int, int, int)+0x10>
    13d6:	cmp	r0, r2
    13d8:	it	ge
    13da:	movge	r0, r2
    13dc:	bx	lr
    13de:	mov	r0, r1
    13e0:	bx	lr
    if(val>maxVal) val=maxVal;
  }
  else // wrap around when checking hours
  {
    if((val>maxVal) && (val<minVal)) val=maxVal;
    13e2:	cmp	r2, r0
    13e4:	bge.n	13ec <boundaryCheck(int, int, int)+0x1e>
    13e6:	cmp	r1, r0
    13e8:	it	gt
    13ea:	movgt	r0, r2
    13ec:	cmp	r0, #24
    13ee:	it	ge
    13f0:	movge	r0, #24
    if((val>24)) val=24;
  }
  return val; 
}
    13f2:	bx	lr

000013f4 <boundaryCheck2(int, int, int, int)>:
int boundaryCheck2(int val, int minVal, int maxVal, int modVal)
{
  if(minVal < maxVal) // standard case
    13f4:	cmp	r1, r2
    if((val>24)) val=24;
  }
  return val; 
}
int boundaryCheck2(int val, int minVal, int maxVal, int modVal)
{
    13f6:	push	{r4, lr}
  if(minVal < maxVal) // standard case
    13f8:	bge.n	140a <boundaryCheck2(int, int, int, int)+0x16>
  {
    if(val<minVal) val=minVal;
    13fa:	cmp	r1, r0
    13fc:	bgt.n	1406 <boundaryCheck2(int, int, int, int)+0x12>
    13fe:	cmp	r0, r2
    1400:	it	ge
    1402:	movge	r0, r2
    1404:	pop	{r4, pc}
    1406:	mov	r0, r1
    1408:	pop	{r4, pc}
    140a:	bic.w	r0, r0, r0, asr #31
    140e:	cmp	r0, r3
    1410:	it	ge
    1412:	movge	r0, r3
  else // wrap around when checking hours
  {
    if(val<0) val=0;
    if(val>modVal) val=modVal;
    // shift data to next good value
    if((val>maxVal) && (val<minVal))
    1414:	cmp	r0, r2
    1416:	ble.n	142c <boundaryCheck2(int, int, int, int)+0x38>
    1418:	cmp	r0, r1
    141a:	bge.n	142c <boundaryCheck2(int, int, int, int)+0x38>
    { if(val>(minVal+maxVal)/2) val = minVal; else val=maxVal;
    141c:	adds	r3, r1, r2
    141e:	movs	r4, #2
    1420:	sdiv	r3, r3, r4
    1424:	cmp	r0, r3
    1426:	ite	gt
    1428:	movgt	r0, r1
    142a:	movle	r0, r2
    }
  }
  return val; 
}
    142c:	pop	{r4, pc}
    142e:	Address 0x0000142e is out of bounds.


00001430 <doMenu()>:
      }
    }  
}

int16_t doMenu(void)
{
    1430:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
extern ACQ_Parameters_s acqParameters;
extern SNIP_Parameters_s snipParameters;

static void printAll(void)
{
  Serial.printf("%c %5d on_time\n\r",     'o',acqParameters.on);
    1434:	ldr	r4, [pc, #624]	; (16a8 <doMenu()+0x278>)
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1436:	bl	8dbc <usb_serial_available>
int16_t doMenu(void)
{
  int16_t ret=0;
  do
  {
    while(!Serial.available());
    143a:	cmp	r0, #0
    143c:	beq.n	1436 <doMenu()+0x6>
        virtual int read() { return usb_serial_getchar(); }
    143e:	bl	8d38 <usb_serial_getchar>
    1442:	uxtb	r5, r0
    char c=Serial.read();
    
    if (strchr("?!xa", c))
    1444:	mov	r1, r5
    1446:	ldr	r0, [pc, #612]	; (16ac <doMenu()+0x27c>)
    1448:	bl	c0e0 <strchr>
    144c:	cmp	r0, #0
    144e:	beq.n	1436 <doMenu()+0x6>
    { switch (c)
    1450:	cmp	r5, #63	; 0x3f
    1452:	beq.n	1476 <doMenu()+0x46>
    1454:	bgt.n	1468 <doMenu()+0x38>
    1456:	cmp	r5, #33	; 0x21
    1458:	bne.n	1436 <doMenu()+0x6>
 */

static void doMenu2(void)
{ // for settings
    uint16_t year,month,day,hour,minutes,seconds;
    int T1=acqParameters.T1;
    145a:	ldr	r7, [r4, #12]
    int T2=acqParameters.T2;
    145c:	ldr.w	r9, [r4, #16]
    int T3=acqParameters.T3;
    1460:	ldr.w	r8, [r4, #20]
    1464:	ldr	r6, [pc, #576]	; (16a8 <doMenu()+0x278>)
    1466:	b.n	14f6 <doMenu()+0xc6>
  {
    while(!Serial.available());
    char c=Serial.read();
    
    if (strchr("?!xa", c))
    { switch (c)
    1468:	cmp	r5, #97	; 0x61
    146a:	beq.w	16c4 <doMenu()+0x294>
    146e:	cmp	r5, #120	; 0x78
    1470:	beq.w	1694 <doMenu()+0x264>
    1474:	b.n	1436 <doMenu()+0x6>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1476:	bl	8dbc <usb_serial_available>
  Serial.println();
}

static void doMenu1(void)
{ // for enquiries
    while(!Serial.available());
    147a:	cmp	r0, #0
    147c:	beq.n	1476 <doMenu()+0x46>
        virtual int read() { return usb_serial_getchar(); }
    147e:	bl	8d38 <usb_serial_getchar>
    1482:	uxtb	r5, r0
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    1484:	mov	r1, r5
    1486:	ldr	r0, [pc, #552]	; (16b0 <doMenu()+0x280>)
    1488:	bl	c0e0 <strchr>
    148c:	cmp	r0, #0
    148e:	beq.n	1436 <doMenu()+0x6>
    { switch (c)
    1490:	cmp	r5, #97	; 0x61
    1492:	beq.n	14d4 <doMenu()+0xa4>
    1494:	bgt.n	14b0 <doMenu()+0x80>
    1496:	cmp	r5, #50	; 0x32
    1498:	beq.n	14e4 <doMenu()+0xb4>
    149a:	bgt.n	14a4 <doMenu()+0x74>
    149c:	cmp	r5, #49	; 0x31
    149e:	bne.n	1436 <doMenu()+0x6>
      {
        case 'o': Serial.printf("%02d\r\n",acqParameters.on); break;
        case 'a': Serial.printf("%02d\r\n",acqParameters.ad); break;
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
        case '1': Serial.printf("%02d\r\n",acqParameters.T1);break;
    14a0:	ldr	r2, [r4, #12]
    14a2:	b.n	14d6 <doMenu()+0xa6>
{ // for enquiries
    while(!Serial.available());
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
    14a4:	cmp	r5, #51	; 0x33
    14a6:	beq.n	14e8 <doMenu()+0xb8>
    14a8:	cmp	r5, #52	; 0x34
    14aa:	bne.n	1436 <doMenu()+0x6>
        case 'a': Serial.printf("%02d\r\n",acqParameters.ad); break;
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
        case '1': Serial.printf("%02d\r\n",acqParameters.T1);break;
        case '2': Serial.printf("%02d\r\n",acqParameters.T2);break;
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
    14ac:	ldr	r2, [r4, #24]
    14ae:	b.n	14d6 <doMenu()+0xa6>
{ // for enquiries
    while(!Serial.available());
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
    14b0:	cmp	r5, #111	; 0x6f
    14b2:	beq.n	14d0 <doMenu()+0xa0>
    14b4:	bgt.n	14c2 <doMenu()+0x92>
    14b6:	cmp	r5, #100	; 0x64
    14b8:	beq.n	14ec <doMenu()+0xbc>
    14ba:	cmp	r5, #110	; 0x6e
    14bc:	bne.n	1436 <doMenu()+0x6>
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
        case '1': Serial.printf("%02d\r\n",acqParameters.T1);break;
        case '2': Serial.printf("%02d\r\n",acqParameters.T2);break;
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
        case 'n': Serial.printf("%s\r\n",acqParameters.name);break; 
    14be:	ldr	r2, [pc, #500]	; (16b4 <doMenu()+0x284>)
    14c0:	b.n	14f2 <doMenu()+0xc2>
{ // for enquiries
    while(!Serial.available());
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
    14c2:	cmp	r5, #114	; 0x72
    14c4:	beq.n	14e0 <doMenu()+0xb0>
    14c6:	cmp	r5, #116	; 0x74
    14c8:	bne.n	1436 <doMenu()+0x6>
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
        case 'n': Serial.printf("%s\r\n",acqParameters.name);break; 
        
        case 'd': Serial.printf("%s\r\n",getDate(text));break;
        case 't': Serial.printf("%s\r\n",getTime(text));break;
    14ca:	bl	7dc <getTime(char*) [clone .constprop.28]>
    14ce:	b.n	14f0 <doMenu()+0xc0>
    char c=Serial.read();
    
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      {
        case 'o': Serial.printf("%02d\r\n",acqParameters.on); break;
    14d0:	ldr	r2, [r4, #0]
    14d2:	b.n	14d6 <doMenu()+0xa6>
        case 'a': Serial.printf("%02d\r\n",acqParameters.ad); break;
    14d4:	ldr	r2, [r4, #4]
    14d6:	ldr	r1, [pc, #480]	; (16b8 <doMenu()+0x288>)
    14d8:	ldr	r0, [pc, #480]	; (16bc <doMenu()+0x28c>)
    14da:	bl	9ef6 <Print::printf(char const*, ...)>
    14de:	b.n	1436 <doMenu()+0x6>
        case 'r': Serial.printf("%02d\r\n",acqParameters.ar); break;
    14e0:	ldr	r2, [r4, #8]
    14e2:	b.n	14d6 <doMenu()+0xa6>
        case '1': Serial.printf("%02d\r\n",acqParameters.T1);break;
        case '2': Serial.printf("%02d\r\n",acqParameters.T2);break;
    14e4:	ldr	r2, [r4, #16]
    14e6:	b.n	14d6 <doMenu()+0xa6>
        case '3': Serial.printf("%02d\r\n",acqParameters.T3);break;
    14e8:	ldr	r2, [r4, #20]
    14ea:	b.n	14d6 <doMenu()+0xa6>
        case '4': Serial.printf("%02d\r\n",acqParameters.T4);break;
        case 'n': Serial.printf("%s\r\n",acqParameters.name);break; 
        
        case 'd': Serial.printf("%s\r\n",getDate(text));break;
    14ec:	bl	80c <getDate(char*) [clone .constprop.29]>
    14f0:	mov	r2, r0
    14f2:	ldr	r1, [pc, #460]	; (16c0 <doMenu()+0x290>)
    14f4:	b.n	14d8 <doMenu()+0xa8>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    14f6:	bl	8dbc <usb_serial_available>
    int T1=acqParameters.T1;
    int T2=acqParameters.T2;
    int T3=acqParameters.T3;
    //int T4=acqParameters.T4; not used
    //
    while(!Serial.available());
    14fa:	cmp	r0, #0
    14fc:	beq.n	14f6 <doMenu()+0xc6>
        virtual int read() { return usb_serial_getchar(); }
    14fe:	bl	8d38 <usb_serial_getchar>
    1502:	uxtb	r5, r0
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    1504:	mov	r1, r5
    1506:	ldr	r0, [pc, #424]	; (16b0 <doMenu()+0x280>)
    1508:	bl	c0e0 <strchr>
    150c:	cmp	r0, #0
    150e:	beq.n	1436 <doMenu()+0x6>
    { switch (c)
    1510:	cmp	r5, #97	; 0x61
    1512:	beq.n	15d2 <doMenu()+0x1a2>
    1514:	bgt.n	1550 <doMenu()+0x120>
    1516:	cmp	r5, #50	; 0x32
    1518:	beq.n	15fa <doMenu()+0x1ca>
    151a:	bgt.n	1532 <doMenu()+0x102>
    151c:	cmp	r5, #49	; 0x31
    151e:	bne.n	1436 <doMenu()+0x6>
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
    1520:	ldr	r0, [pc, #408]	; (16bc <doMenu()+0x28c>)
    1522:	bl	a356 <Stream::parseInt()>
    1526:	movs	r2, #24
    1528:	movs	r1, #0
    152a:	bl	13ce <boundaryCheck(int, int, int)>
    152e:	str	r0, [r6, #12]
    1530:	b.n	1436 <doMenu()+0x6>
    //
    while(!Serial.available());
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
    1532:	cmp	r5, #51	; 0x33
    1534:	beq.n	160c <doMenu()+0x1dc>
    1536:	cmp	r5, #52	; 0x34
    1538:	bne.w	1436 <doMenu()+0x6>
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
    153c:	ldr	r0, [pc, #380]	; (16bc <doMenu()+0x28c>)
    153e:	bl	a356 <Stream::parseInt()>
    1542:	movs	r3, #24
    1544:	mov	r2, r7
    1546:	mov	r1, r8
    1548:	bl	13f4 <boundaryCheck2(int, int, int, int)>
    154c:	str	r0, [r6, #24]
    154e:	b.n	1436 <doMenu()+0x6>
    //
    while(!Serial.available());
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
    1550:	cmp	r5, #111	; 0x6f
    1552:	beq.n	15be <doMenu()+0x18e>
    1554:	bgt.n	1564 <doMenu()+0x134>
    1556:	cmp	r5, #100	; 0x64
    1558:	beq.n	1638 <doMenu()+0x208>
    155a:	cmp	r5, #110	; 0x6e
    155c:	bne.w	1436 <doMenu()+0x6>
    1560:	movs	r5, #0
    1562:	b.n	161e <doMenu()+0x1ee>
    1564:	cmp	r5, #114	; 0x72
    1566:	beq.n	15e6 <doMenu()+0x1b6>
    1568:	cmp	r5, #116	; 0x74
    156a:	bne.w	1436 <doMenu()+0x6>
                  month=  boundaryCheck(Serial.parseInt(),1,12);
                  day=    boundaryCheck(Serial.parseInt(),1,31);
                  setDate(year,month,day);
                  break;
        case 't': 
                  hour=     boundaryCheck(Serial.parseInt(),0,23);
    156e:	ldr	r0, [pc, #332]	; (16bc <doMenu()+0x28c>)
    1570:	bl	a356 <Stream::parseInt()>
    1574:	movs	r2, #23
    1576:	movs	r1, #0
    1578:	bl	13ce <boundaryCheck(int, int, int)>
    157c:	mov	r5, r0
                  minutes=  boundaryCheck(Serial.parseInt(),0,59);
    157e:	ldr	r0, [pc, #316]	; (16bc <doMenu()+0x28c>)
    1580:	bl	a356 <Stream::parseInt()>
    1584:	movs	r2, #59	; 0x3b
    1586:	movs	r1, #0
    1588:	bl	13ce <boundaryCheck(int, int, int)>
    158c:	mov	r6, r0
                  seconds=  boundaryCheck(Serial.parseInt(),0,59);
    158e:	ldr	r0, [pc, #300]	; (16bc <doMenu()+0x28c>)
    1590:	bl	a356 <Stream::parseInt()>
    1594:	movs	r2, #59	; 0x3b
    1596:	movs	r1, #0
    1598:	bl	13ce <boundaryCheck(int, int, int)>
    159c:	mov	r7, r0
    setRTCTime(hour(),minute(),second(),day, month, year);
}

static void setTime(uint16_t hour, uint16_t minutes, uint16_t seconds)
{
    setRTCTime(hour,minutes,seconds,day(),month(),year());
    159e:	bl	2254 <day()>
    15a2:	mov	r8, r0
    15a4:	bl	2268 <month()>
    15a8:	mov	r9, r0
    15aa:	bl	227c <year()>
    15ae:	str.w	r9, [sp]
    15b2:	str	r0, [sp, #4]
    15b4:	mov	r3, r8
    15b6:	uxth	r2, r7
    15b8:	uxth	r1, r6
    15ba:	uxth	r0, r5
    15bc:	b.n	168e <doMenu()+0x25e>
    while(!Serial.available());
    char c=Serial.read();
        
    if (strchr("oar1234ndtchwseikp", c))
    { switch (c)
      { case 'o': acqParameters.on   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    15be:	ldr	r0, [pc, #252]	; (16bc <doMenu()+0x28c>)
    15c0:	bl	a356 <Stream::parseInt()>
    15c4:	mov.w	r2, #131072	; 0x20000
    15c8:	movs	r1, #0
    15ca:	bl	13ce <boundaryCheck(int, int, int)>
    15ce:	str	r0, [r6, #0]
    15d0:	b.n	1436 <doMenu()+0x6>
        case 'a': acqParameters.ad   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    15d2:	ldr	r0, [pc, #232]	; (16bc <doMenu()+0x28c>)
    15d4:	bl	a356 <Stream::parseInt()>
    15d8:	mov.w	r2, #131072	; 0x20000
    15dc:	movs	r1, #0
    15de:	bl	13ce <boundaryCheck(int, int, int)>
    15e2:	str	r0, [r6, #4]
    15e4:	b.n	1436 <doMenu()+0x6>
        case 'r': acqParameters.ar   = boundaryCheck(Serial.parseInt(),0,MAX_VAL); break;
    15e6:	ldr	r0, [pc, #212]	; (16bc <doMenu()+0x28c>)
    15e8:	bl	a356 <Stream::parseInt()>
    15ec:	mov.w	r2, #131072	; 0x20000
    15f0:	movs	r1, #0
    15f2:	bl	13ce <boundaryCheck(int, int, int)>
    15f6:	str	r0, [r6, #8]
    15f8:	b.n	1436 <doMenu()+0x6>
        case '1': acqParameters.T1   = boundaryCheck(Serial.parseInt(),0,24); break;
        case '2': acqParameters.T2   = boundaryCheck(Serial.parseInt(),T1,24); break;
    15fa:	ldr	r0, [pc, #192]	; (16bc <doMenu()+0x28c>)
    15fc:	bl	a356 <Stream::parseInt()>
    1600:	movs	r2, #24
    1602:	mov	r1, r7
    1604:	bl	13ce <boundaryCheck(int, int, int)>
    1608:	str	r0, [r6, #16]
    160a:	b.n	1436 <doMenu()+0x6>
        case '3': acqParameters.T3   = boundaryCheck(Serial.parseInt(),T2,24); break;
    160c:	ldr	r0, [pc, #172]	; (16bc <doMenu()+0x28c>)
    160e:	bl	a356 <Stream::parseInt()>
    1612:	movs	r2, #24
    1614:	mov	r1, r9
    1616:	bl	13ce <boundaryCheck(int, int, int)>
    161a:	str	r0, [r6, #20]
    161c:	b.n	1436 <doMenu()+0x6>
    161e:	bl	8d38 <usb_serial_getchar>
        case '4': acqParameters.T4   = boundaryCheck2(Serial.parseInt(),T3,T1,24); break;
        case 'n': for(int ii=0; ii<4;ii++) acqParameters.name[ii] = Serial.read();
    1622:	adds	r3, r6, r5
    1624:	adds	r5, #1
    1626:	cmp	r5, #4
    1628:	strb.w	r0, [r3, #32]
    162c:	bne.n	161e <doMenu()+0x1ee>
                  acqParameters.name[4]=0; break;
    162e:	ldr	r3, [pc, #120]	; (16a8 <doMenu()+0x278>)
    1630:	movs	r2, #0
    1632:	strb.w	r2, [r3, #36]	; 0x24
    1636:	b.n	1436 <doMenu()+0x6>
        case 'd':     
                  year=   boundaryCheck(Serial.parseInt(),2000,3000);
    1638:	ldr	r0, [pc, #128]	; (16bc <doMenu()+0x28c>)
    163a:	bl	a356 <Stream::parseInt()>
    163e:	movw	r2, #3000	; 0xbb8
    1642:	mov.w	r1, #2000	; 0x7d0
    1646:	bl	13ce <boundaryCheck(int, int, int)>
    164a:	mov	r6, r0
                  month=  boundaryCheck(Serial.parseInt(),1,12);
    164c:	ldr	r0, [pc, #108]	; (16bc <doMenu()+0x28c>)
    164e:	bl	a356 <Stream::parseInt()>
    1652:	movs	r2, #12
    1654:	movs	r1, #1
    1656:	bl	13ce <boundaryCheck(int, int, int)>
    165a:	mov	r5, r0
                  day=    boundaryCheck(Serial.parseInt(),1,31);
    165c:	ldr	r0, [pc, #92]	; (16bc <doMenu()+0x28c>)
    165e:	bl	a356 <Stream::parseInt()>
    1662:	movs	r2, #31
    1664:	movs	r1, #1
    1666:	bl	13ce <boundaryCheck(int, int, int)>
    166a:	mov	r9, r0
  setTime(tt); // local
}

static void setDate(uint16_t year, uint16_t month, uint16_t day)
{
    setRTCTime(hour(),minute(),second(),day, month, year);
    166c:	bl	2218 <hour()>
    1670:	mov	r7, r0
    1672:	bl	222c <minute()>
    1676:	mov	r8, r0
    1678:	bl	2240 <second()>
    167c:	uxth	r6, r6
    167e:	uxth	r5, r5
    1680:	mov	r2, r0
    1682:	str	r6, [sp, #4]
    1684:	str	r5, [sp, #0]
    1686:	uxth.w	r3, r9
    168a:	mov	r1, r8
    168c:	mov	r0, r7
}

static void setTime(uint16_t hour, uint16_t minutes, uint16_t seconds)
{
    setRTCTime(hour,minutes,seconds,day(),month(),year());
    168e:	bl	1390 <setRTCTime(int, int, int, int, int, int)>
    1692:	b.n	1436 <doMenu()+0x6>
    if (strchr("?!xa", c))
    { switch (c)
      {
        case '?': doMenu1(); break;
        case '!': doMenu2(); break;
        case 'x': ret = Serial.parseInt(); break;
    1694:	ldr	r0, [pc, #36]	; (16bc <doMenu()+0x28c>)
    1696:	bl	a356 <Stream::parseInt()>
    169a:	sxth	r0, r0
        case 'a': printAll(); break;
      }
    }
  } while(ret==0);
    169c:	cmp	r0, #0
    169e:	beq.w	1436 <doMenu()+0x6>
  return ret;
}
    16a2:	add	sp, #12
    16a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    16a8:	.word	0x20013964
    16ac:	.word	0x0001291a
    16b0:	.word	0x0001291f
    16b4:	.word	0x20013984
    16b8:	.word	0x00012932
    16bc:	.word	0x20013d54
    16c0:	.word	0x000128cc
extern ACQ_Parameters_s acqParameters;
extern SNIP_Parameters_s snipParameters;

static void printAll(void)
{
  Serial.printf("%c %5d on_time\n\r",     'o',acqParameters.on);
    16c4:	ldr	r3, [r4, #0]
    16c6:	ldr	r1, [pc, #216]	; (17a0 <doMenu()+0x370>)
    16c8:	ldr	r0, [pc, #216]	; (17a4 <doMenu()+0x374>)
    16ca:	movs	r2, #111	; 0x6f
    16cc:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d acq_time\n\r",    'a',acqParameters.ad);
    16d0:	ldr	r3, [r4, #4]
    16d2:	ldr	r1, [pc, #212]	; (17a8 <doMenu()+0x378>)
    16d4:	ldr	r0, [pc, #204]	; (17a4 <doMenu()+0x374>)
    16d6:	mov	r2, r5
    16d8:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d rep_rate\n\r",    'r',acqParameters.ar);
    16dc:	ldr	r3, [r4, #8]
    16de:	ldr	r1, [pc, #204]	; (17ac <doMenu()+0x37c>)
    16e0:	ldr	r0, [pc, #192]	; (17a4 <doMenu()+0x374>)
    16e2:	movs	r2, #114	; 0x72
    16e4:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d first_hour\n\r",  '1',acqParameters.T1);
    16e8:	ldr	r3, [r4, #12]
    16ea:	ldr	r1, [pc, #196]	; (17b0 <doMenu()+0x380>)
    16ec:	ldr	r0, [pc, #180]	; (17a4 <doMenu()+0x374>)
    16ee:	movs	r2, #49	; 0x31
    16f0:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d second_hour\n\r", '2',acqParameters.T2);
    16f4:	ldr	r3, [r4, #16]
    16f6:	ldr	r1, [pc, #188]	; (17b4 <doMenu()+0x384>)
    16f8:	ldr	r0, [pc, #168]	; (17a4 <doMenu()+0x374>)
    16fa:	movs	r2, #50	; 0x32
    16fc:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d third_hour\n\r",  '3',acqParameters.T3);
    1700:	ldr	r3, [r4, #20]
    1702:	ldr	r1, [pc, #180]	; (17b8 <doMenu()+0x388>)
    1704:	ldr	r0, [pc, #156]	; (17a4 <doMenu()+0x374>)
    1706:	movs	r2, #51	; 0x33
    1708:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %5d last_hour\n\r",   '4',acqParameters.T4);
    170c:	ldr	r3, [r4, #24]
    170e:	ldr	r1, [pc, #172]	; (17bc <doMenu()+0x38c>)
    1710:	ldr	r0, [pc, #144]	; (17a4 <doMenu()+0x374>)
    1712:	movs	r2, #52	; 0x34
    1714:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.println();
    1718:	ldr	r0, [pc, #136]	; (17a4 <doMenu()+0x374>)
    171a:	bl	9ec8 <Print::println()>
  Serial.printf("%c %s name\n\r",         'n',acqParameters.name);
    171e:	ldr	r3, [pc, #160]	; (17c0 <doMenu()+0x390>)
    1720:	ldr	r1, [pc, #160]	; (17c4 <doMenu()+0x394>)
    1722:	ldr	r0, [pc, #128]	; (17a4 <doMenu()+0x374>)
    1724:	movs	r2, #110	; 0x6e
    1726:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %s date\n\r",         'd',getDate(text));
    172a:	bl	80c <getDate(char*) [clone .constprop.29]>
    172e:	movs	r2, #100	; 0x64
    1730:	mov	r3, r0
    1732:	ldr	r1, [pc, #148]	; (17c8 <doMenu()+0x398>)
    1734:	ldr	r0, [pc, #108]	; (17a4 <doMenu()+0x374>)
    1736:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.printf("%c %s time\n\r",         't',getTime(text));
    173a:	bl	7dc <getTime(char*) [clone .constprop.28]>
    173e:	movs	r2, #116	; 0x74
    1740:	mov	r3, r0
    1742:	ldr	r1, [pc, #136]	; (17cc <doMenu()+0x39c>)
    1744:	ldr	r0, [pc, #92]	; (17a4 <doMenu()+0x374>)
    1746:	bl	9ef6 <Print::printf(char const*, ...)>
  Serial.println();
    174a:	ldr	r0, [pc, #88]	; (17a4 <doMenu()+0x374>)
    174c:	bl	9ec8 <Print::println()>
  Serial.printf("%c %5d inhibit window\r\n",        'i',snipParameters.inhib);
  Serial.printf("%c %5d noise repetition rate\r\n", 'k',snipParameters.nrep);
  Serial.printf("%c %5d pre trigger delay\r\n",     'p',snipParameters.ndel);
  #endif
  //
  Serial.println();
    1750:	ldr	r0, [pc, #80]	; (17a4 <doMenu()+0x374>)
    1752:	bl	9ec8 <Print::println()>
  Serial.println("exter 'a' to print this");
    1756:	ldr	r1, [pc, #120]	; (17d0 <doMenu()+0x3a0>)
    1758:	ldr	r0, [pc, #72]	; (17a4 <doMenu()+0x374>)
    175a:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("exter '?c' to read value c=(o,a,r,1,2,3,4,n,d,t,c,h,w,s,m,i,k,p)");
    175e:	ldr	r1, [pc, #116]	; (17d4 <doMenu()+0x3a4>)
    1760:	ldr	r0, [pc, #64]	; (17a4 <doMenu()+0x374>)
    1762:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("  e.g.: ?1 will print first hour");
    1766:	ldr	r1, [pc, #112]	; (17d8 <doMenu()+0x3a8>)
    1768:	ldr	r0, [pc, #56]	; (17a4 <doMenu()+0x374>)
    176a:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("exter '!cval' to read value c=(0,a,r,1,2,3,4,n,d,t,c,h,w,s,m,i,k,p) and val is new value");
    176e:	ldr	r1, [pc, #108]	; (17dc <doMenu()+0x3ac>)
    1770:	ldr	r0, [pc, #48]	; (17a4 <doMenu()+0x374>)
    1772:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("  e.g.: !110 will set first hour to 10");
    1776:	ldr	r1, [pc, #104]	; (17e0 <doMenu()+0x3b0>)
    1778:	ldr	r0, [pc, #40]	; (17a4 <doMenu()+0x374>)
    177a:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("exter 'xval' to exit menu (x is delay in minutes, -1 means immediate)");
    177e:	ldr	r1, [pc, #100]	; (17e4 <doMenu()+0x3b4>)
    1780:	ldr	r0, [pc, #32]	; (17a4 <doMenu()+0x374>)
    1782:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("  e.g.: x10 will exit and hibernate for 10 minutes");
    1786:	ldr	r1, [pc, #96]	; (17e8 <doMenu()+0x3b8>)
    1788:	ldr	r0, [pc, #24]	; (17a4 <doMenu()+0x374>)
    178a:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println("        x-1 with exit and start immediately");
    178e:	ldr	r1, [pc, #92]	; (17ec <doMenu()+0x3bc>)
    1790:	ldr	r0, [pc, #16]	; (17a4 <doMenu()+0x374>)
    1792:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  Serial.println();
    1796:	ldr	r0, [pc, #12]	; (17a4 <doMenu()+0x374>)
    1798:	bl	9ec8 <Print::println()>
    179c:	b.n	1436 <doMenu()+0x6>
    179e:	nop
    17a0:	.word	0x00012939
    17a4:	.word	0x20013d54
    17a8:	.word	0x0001294a
    17ac:	.word	0x0001295c
    17b0:	.word	0x0001296e
    17b4:	.word	0x00012982
    17b8:	.word	0x00012997
    17bc:	.word	0x000129ab
    17c0:	.word	0x20013984
    17c4:	.word	0x000129be
    17c8:	.word	0x000129cb
    17cc:	.word	0x000129d8
    17d0:	.word	0x000129e5
    17d4:	.word	0x000129fd
    17d8:	.word	0x00012a3e
    17dc:	.word	0x00012a5f
    17e0:	.word	0x00012ab8
    17e4:	.word	0x00012adf
    17e8:	.word	0x00012b25
    17ec:	.word	0x00012b58

000017f0 <setup>:
//extern void rtc_set(unsigned long t);

time_t getTeensy3Time(){  return Teensy3Clock.get();}
//__________________________General Arduino Routines_____________________________________
//int started=0;
extern "C" void setup() {
    17f0:	push	{r0, r1, r4, r5, r6, lr}
  // put your setup code here, to run once:
  pinMode(3,INPUT_PULLUP); // needed to enter menu if grounded
    17f2:	movs	r1, #2
    17f4:	movs	r0, #3
    17f6:	bl	91bc <pinMode>

  // set the Time library to use Teensy 3.0's RTC to keep time
  setSyncProvider(getTeensy3Time);
    17fa:	ldr	r0, [pc, #280]	; (1914 <setup+0x124>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    17fc:	ldr	r4, [pc, #280]	; (1918 <setup+0x128>)
    17fe:	ldr	r5, [pc, #284]	; (191c <setup+0x12c>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    1800:	ldr	r6, [pc, #284]	; (1920 <setup+0x130>)
    1802:	bl	228c <setSyncProvider(long (*)())>
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1806:	ldrb	r3, [r4, #0]
    1808:	cmp	r3, #0
    180a:	beq.n	1904 <setup+0x114>
    180c:	ldrb	r3, [r5, #0]
    180e:	lsls	r2, r3, #31
    1810:	bpl.n	1904 <setup+0x114>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    1812:	ldr	r2, [pc, #272]	; (1924 <setup+0x134>)
    1814:	ldr	r3, [r6, #0]
    1816:	ldr	r2, [r2, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1818:	subs	r3, r3, r2
    181a:	cmp	r3, #14
    181c:	bls.n	1904 <setup+0x114>

#if DO_DEBUG>0
   while(!Serial && !digitalRead(3));
//  while(!Serial && (millis()<3000)); // use this for testing without menu
   Serial.println("microSoundRecorder");
    181e:	ldr	r1, [pc, #264]	; (1928 <setup+0x138>)
    1820:	ldr	r0, [pc, #264]	; (192c <setup+0x13c>)
    1822:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  // for 16bit resolution
  temperature = -0.0293 * analogRead(70) + 440.5;
*/

#define MAUDIO (MAX_Q+MDEL+50)
	AudioMemory (MAUDIO); // 600 blocks use about 200 kB (requires Teensy 3.6)
    1826:	movw	r1, #549	; 0x225
    182a:	ldr	r0, [pc, #260]	; (1930 <setup+0x140>)
    182c:	bl	9f98 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>

  //
  uSD.init();

  // always load config first
  uSD.loadConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1830:	movs	r5, #8
#define MAUDIO (MAX_Q+MDEL+50)
	AudioMemory (MAUDIO); // 600 blocks use about 200 kB (requires Teensy 3.6)

  // stop I2S early (to be sure)
  #if ((ACQ == _I2S) || (ACQ == _I2S_QUAD) || (ACQ == _I2S_32) || (ACQ == _I2S_32_MONO) || (ACQ == _I2S_TYMPAN) || (ACQ == _I2S_TDM))
    I2S_stop();
    1832:	bl	b30 <I2S_stop()>
//  uint32_t t0=rtc_get();
//  uint32_t t1=(uint32_t)&__rtc_localtime;
//  if((t1-t0)>100) rtc_set(t1);

  //
  uSD.init();
    1836:	ldr	r0, [pc, #252]	; (1934 <setup+0x144>)
    1838:	bl	df0 <c_uSD::init()>

  // always load config first
  uSD.loadConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    183c:	ldr	r3, [pc, #248]	; (1938 <setup+0x148>)
    183e:	str	r5, [sp, #0]
    1840:	mov	r2, r5
    1842:	ldr	r1, [pc, #248]	; (193c <setup+0x14c>)
    1844:	ldr	r0, [pc, #236]	; (1934 <setup+0x144>)
    1846:	bl	1068 <c_uSD::loadConfig(unsigned long*, int, long*, int)>
		} else if (pin == 1) {
			return (CORE_PIN1_PINREG & CORE_PIN1_BITMASK) ? 1 : 0;
		} else if (pin == 2) {
			return (CORE_PIN2_PINREG & CORE_PIN2_BITMASK) ? 1 : 0;
		} else if (pin == 3) {
			return (CORE_PIN3_PINREG & CORE_PIN3_BITMASK) ? 1 : 0;
    184a:	ldr	r3, [pc, #244]	; (1940 <setup+0x150>)
    184c:	ldr	r3, [r3, #0]
    184e:	lsls	r3, r3, #19
    1850:	bmi.n	1874 <setup+0x84>
  }
*/
  // if pin3 is connected to GND enter menu mode
  int ret;
  if(!digitalReadFast(3))
  { ret=doMenu();
    1852:	bl	1430 <doMenu()>
      
    // should here save parameters to disk if modified
    uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1856:	str	r5, [sp, #0]
  }
*/
  // if pin3 is connected to GND enter menu mode
  int ret;
  if(!digitalReadFast(3))
  { ret=doMenu();
    1858:	mov	r4, r0
      
    // should here save parameters to disk if modified
    uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    185a:	ldr	r3, [pc, #220]	; (1938 <setup+0x148>)
    185c:	ldr	r1, [pc, #220]	; (193c <setup+0x14c>)
    185e:	ldr	r0, [pc, #212]	; (1934 <setup+0x144>)
    1860:	mov	r2, r5
    1862:	bl	fc8 <c_uSD::storeConfig(unsigned long*, int, long*, int)>

    if(ret>0) 
    1866:	cmp	r4, #0
    1868:	ble.n	1874 <setup+0x84>
    setWakeupCallandSleep(ret*60);  // should shutdown now and wait for start
    186a:	rsb	r0, r4, r4, lsl #4
    186e:	lsls	r0, r0, #2
    1870:	bl	1148 <setWakeupCallandSleep(unsigned long)>
  }
  //
  #if MDEL<0
    // check if it is our time to record
    int32_t nsec;
    nsec=checkDutyCycle(&acqParameters, -1);
    1874:	mov.w	r1, #4294967295
    1878:	ldr	r0, [pc, #192]	; (193c <setup+0x14c>)
    187a:	bl	124c <checkDutyCycle(ACQ_Parameters_s*, short)>
    if(nsec>0) 
    187e:	cmp	r0, #0
    1880:	ble.n	188a <setup+0x9a>
    { 
      #if ((ACQ == _I2S) || (ACQ == _I2S_QUAD) || (ACQ == _I2S_32) || (ACQ == _I2S_32_MONO) || (ACQ == _I2S_TYMPAN) || (ACQ == _I2S_TDM))
        I2S_stopClock();
    1882:	bl	b20 <I2S_stopClock()>
      #endif
      setWakeupCallandSleep(nsec); // will not return if we should not continue with acquisition 
    1886:	bl	1148 <setWakeupCallandSleep(unsigned long)>
  
  #elif (ACQ == _I2S_QUAD)
    I2S_modification(F_SAMP,16,4); // I2S_Quad not modified for 32 bit (therefore 16 bit)
  
  #elif((ACQ == _I2S_32) || (ACQ == _I2S_32_MONO))
    I2S_modification(F_SAMP,32,2);
    188a:	movs	r2, #2
    188c:	movs	r1, #32
    188e:	movw	r0, #48000	; 0xbb80
    1892:	bl	b40 <I2S_modification(unsigned long, unsigned short, int)>
template <int mq>
void mRecordQueue<mq>::clear(void)
{
	uint16_t t;

	if (userblock) {
    1896:	ldr	r5, [pc, #172]	; (1944 <setup+0x154>)
public:

	I2S_32(void) : AudioStream(0, NULL) {begin();}
  void begin(void);
  virtual void update(void);
  void digitalShift(int16_t val){I2S_32::shift=val;}
    1898:	ldr	r3, [pc, #172]	; (1948 <setup+0x158>)
  state=0;
}

void c_uSD::setPrefix(char *prefix)
{
  strcpy(name,prefix);
    189a:	ldr	r1, [pc, #176]	; (194c <setup+0x15c>)
    189c:	ldr	r0, [pc, #176]	; (1950 <setup+0x160>)
    189e:	movs	r2, #12
    18a0:	strh	r2, [r3, #0]
    18a2:	bl	c1b0 <strcpy>
    18a6:	ldr.w	r0, [r5, #2032]	; 0x7f0
    18aa:	cbz	r0, 18b6 <setup+0xc6>
		release(userblock);
    18ac:	bl	a094 <AudioStream::release(audio_block_struct*)>
		userblock = NULL;
    18b0:	movs	r3, #0
    18b2:	str.w	r3, [r5, #2032]	; 0x7f0
	}
	t = tail;
    18b6:	ldrh.w	r4, [r5, #2038]	; 0x7f6
    18ba:	uxth	r4, r4
	while (t != head) {
    18bc:	ldrh.w	r3, [r5, #2036]	; 0x7f4
    18c0:	ldr	r2, [pc, #128]	; (1944 <setup+0x154>)
    18c2:	uxth	r3, r3
    18c4:	cmp	r4, r3
    18c6:	beq.n	18e2 <setup+0xf2>
		if (++t >= mq) t = 0;
    18c8:	adds	r4, #1
    18ca:	uxth	r4, r4
    18cc:	cmp.w	r4, #500	; 0x1f4
    18d0:	it	cs
    18d2:	movcs	r4, #0
		release(queue[t]);
    18d4:	add.w	r3, r4, #8
    18d8:	ldr.w	r0, [r5, r3, lsl #2]
    18dc:	bl	a094 <AudioStream::release(audio_block_struct*)>
    18e0:	b.n	18bc <setup+0xcc>
{
public:
	mRecordQueue(void) : AudioStream(1, inputQueueArray),
		userblock(NULL), head(0), tail(0), enabled(0) { }
   
	void begin(void) { clear();	enabled = 1;}
    18e2:	movs	r3, #1
	t = tail;
	while (t != head) {
		if (++t >= mq) t = 0;
		release(queue[t]);
	}
	tail = t;
    18e4:	strh.w	r4, [r2, #2038]	; 0x7f6
    process1.begin(&snipParameters); 
  #endif

  for(int ii=0; ii<NCH; ii++) queue[ii].begin();
  //
  Serial.println("End of Setup");
    18e8:	ldr	r1, [pc, #104]	; (1954 <setup+0x164>)
{
public:
	mRecordQueue(void) : AudioStream(1, inputQueueArray),
		userblock(NULL), head(0), tail(0), enabled(0) { }
   
	void begin(void) { clear();	enabled = 1;}
    18ea:	strh.w	r3, [r2, #2040]	; 0x7f8
    18ee:	ldr	r0, [pc, #60]	; (192c <setup+0x13c>)
    18f0:	bl	8a0 <Print::println(__FlashStringHelper const*)>
//  started=0;  
  #if DO_DEBUG>1
    logFile.open("logFile.txt", O_CREAT | O_RDWR | O_APPEND);
    18f4:	movw	r2, #522	; 0x20a
    18f8:	ldr	r1, [pc, #92]	; (1958 <setup+0x168>)
    18fa:	ldr	r0, [pc, #96]	; (195c <setup+0x16c>)
    18fc:	bl	c30 <FsBaseFile::open(char const*, int)>
  #endif
}
    1900:	add	sp, #8
    1902:	pop	{r4, r5, r6, pc}

  // set the Time library to use Teensy 3.0's RTC to keep time
  setSyncProvider(getTeensy3Time);

#if DO_DEBUG>0
   while(!Serial && !digitalRead(3));
    1904:	movs	r0, #3
    1906:	bl	91a0 <digitalRead>
    190a:	cmp	r0, #0
    190c:	beq.w	1806 <setup+0x16>
    1910:	b.n	181e <setup+0x2e>
    1912:	nop
    1914:	.word	0x00000745
    1918:	.word	0x20019fe7
    191c:	.word	0x20019f00
    1920:	.word	0x20019f04
    1924:	.word	0x2001a0e0
    1928:	.word	0x00012b84
    192c:	.word	0x20013d54
    1930:	.word	0x1fff0600
    1934:	.word	0x200147cc
    1938:	.word	0x20013940
    193c:	.word	0x20013964
    1940:	.word	0x400ff010
    1944:	.word	0x2001910c
    1948:	.word	0x2001393e
    194c:	.word	0x20013984
    1950:	.word	0x20014ce2
    1954:	.word	0x00012b97
    1958:	.word	0x00012ba4
    195c:	.word	0x20019090

00001960 <SdBase<FsVolume>::errorHalt(Print*)>:
  //----------------------------------------------------------------------------
  /** %Print error info and halt.
   *
   * \param[in] pr Print destination.
   */
  void errorHalt(print_t* pr) {
    1960:	mov	r5, r0
    1962:	ldr.w	r0, [r0, #1164]	; 0x48c
    1966:	push	{r3, lr}
    1968:	mov	r4, r1
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    196a:	cbnz	r0, 197e <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    196c:	ldr	r1, [pc, #124]	; (19ec <SdBase<FsVolume>::errorHalt(Print*)+0x8c>)
    196e:	mov	r0, r4
    1970:	bl	884 <Print::write(char const*)>
    1974:	ldr.w	r0, [r5, #1164]	; 0x48c
    1978:	cbnz	r0, 1988 <SdBase<FsVolume>::errorHalt(Print*)+0x28>
      return m_card->errorCode();
    }
    return SD_CARD_ERROR_INVALID_CARD_CONFIG;
    197a:	movs	r1, #42	; 0x2a
    197c:	b.n	1990 <SdBase<FsVolume>::errorHalt(Print*)+0x30>
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
      return m_card->errorCode();
    197e:	ldr	r3, [r0, #0]
    1980:	ldr	r3, [r3, #48]	; 0x30
    1982:	blx	r3
  /** %Print error info and halt.
   *
   * \param[in] pr Print destination.
   */
  void errorHalt(print_t* pr) {
    if (sdErrorCode()) {
    1984:	cbz	r0, 19c6 <SdBase<FsVolume>::errorHalt(Print*)+0x66>
    1986:	b.n	196c <SdBase<FsVolume>::errorHalt(Print*)+0xc>
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
      return m_card->errorCode();
    1988:	ldr	r3, [r0, #0]
    198a:	ldr	r3, [r3, #48]	; 0x30
    198c:	blx	r3
    198e:	mov	r1, r0
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1990:	movs	r3, #0
    1992:	movs	r2, #16
    1994:	mov	r0, r4
    1996:	bl	9f10 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    199a:	ldr	r1, [pc, #84]	; (19f0 <SdBase<FsVolume>::errorHalt(Print*)+0x90>)
    199c:	mov	r0, r4
    199e:	bl	884 <Print::write(char const*)>
    19a2:	ldr.w	r0, [r5, #1164]	; 0x48c
    }
    return SD_CARD_ERROR_INVALID_CARD_CONFIG;
  }
  //----------------------------------------------------------------------------
  /** \return SD card error data. */
  uint8_t sdErrorData() {return m_card ? m_card->errorData() : 0;}
    19a6:	cbz	r0, 19b2 <SdBase<FsVolume>::errorHalt(Print*)+0x52>
    19a8:	ldr	r3, [r0, #0]
    19aa:	ldr	r3, [r3, #52]	; 0x34
    19ac:	blx	r3
    19ae:	uxtb	r1, r0
    19b0:	b.n	19b4 <SdBase<FsVolume>::errorHalt(Print*)+0x54>
    19b2:	mov	r1, r0
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    19b4:	movs	r3, #0
    19b6:	movs	r2, #16
    19b8:	mov	r0, r4
    19ba:	bl	9f10 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
    19be:	mov	r0, r4
    19c0:	bl	9ec8 <Print::println()>
    19c4:	b.n	19e4 <SdBase<FsVolume>::errorHalt(Print*)+0x84>
  }
  /** \return Partition type, FAT_TYPE_EXFAT, FAT_TYPE_FAT32,
   *          FAT_TYPE_FAT16, or zero for error.
   */
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
    19c6:	ldr.w	r3, [r5, #1152]	; 0x480
           m_xVol ? m_xVol->fatType() : 0;
    19ca:	cbz	r3, 19d0 <SdBase<FsVolume>::errorHalt(Print*)+0x70>
    19cc:	ldrb	r3, [r3, #7]
    19ce:	b.n	19da <SdBase<FsVolume>::errorHalt(Print*)+0x7a>
    19d0:	ldr.w	r3, [r5, #1156]	; 0x484
    19d4:	cbz	r3, 19dc <SdBase<FsVolume>::errorHalt(Print*)+0x7c>
    19d6:	ldrb.w	r3, [r3, #1092]	; 0x444
    if (sdErrorCode()) {
      pr->print(F("SdError: 0X"));
      pr->print(sdErrorCode(), HEX);
      pr->print(F(",0X"));
      pr->println(sdErrorData(), HEX);
    } else if (!Vol::fatType()) {
    19da:	cbnz	r3, 19e4 <SdBase<FsVolume>::errorHalt(Print*)+0x84>
      pr->println(F("Check SD format."));
    19dc:	ldr	r1, [pc, #20]	; (19f4 <SdBase<FsVolume>::errorHalt(Print*)+0x94>)
    19de:	mov	r0, r4
    19e0:	bl	8a0 <Print::println(__FlashStringHelper const*)>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    19e4:	bl	9c60 <yield>
    19e8:	b.n	19e4 <SdBase<FsVolume>::errorHalt(Print*)+0x84>
    19ea:	nop
    19ec:	.word	0x00012bb0
    19f0:	.word	0x00012bbc
    19f4:	.word	0x00012bc0

000019f8 <SdBase<FsVolume>::errorHalt(char const*)>:
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    19f8:	ldr	r4, [pc, #28]	; (1a18 <SdBase<FsVolume>::errorHalt(char const*)+0x20>)
  //----------------------------------------------------------------------------
  /** %Print error info and halt.
   *
   * \param[in] msg Message to print.
   */
  void errorHalt(const char* msg) {errorHalt(&Serial, msg);}
    19fa:	push	{r3, lr}
    19fc:	mov	r5, r0
    19fe:	mov	r6, r1
    1a00:	mov	r0, r4
    1a02:	ldr	r1, [pc, #24]	; (1a1c <SdBase<FsVolume>::errorHalt(char const*)+0x24>)
    1a04:	bl	884 <Print::write(char const*)>
   * \param[in] pr Print destination.
   * \param[in] msg Message to print.
   */
  void errorHalt(print_t* pr, const char* msg) {
    pr->print(F("error: "));
    pr->println(msg);
    1a08:	mov	r1, r6
    1a0a:	mov	r0, r4
    1a0c:	bl	8a0 <Print::println(__FlashStringHelper const*)>
    errorHalt(pr);
    1a10:	mov	r1, r4
    1a12:	mov	r0, r5
    1a14:	bl	1960 <SdBase<FsVolume>::errorHalt(Print*)>
    1a18:	.word	0x20013d54
    1a1c:	.word	0x00012bd1

00001a20 <c_uSD::write(short*, long)>:
}

int16_t c_uSD::write(int16_t *data, int32_t ndat)
{
  if(state == 0)
    1a20:	ldrsh.w	r3, [r0, #1296]	; 0x510
{
  strcpy(name,prefix);
}

int16_t c_uSD::write(int16_t *data, int32_t ndat)
{
    1a24:	push	{r4, r5, r6, lr}
    1a26:	mov	r4, r0
    1a28:	mov	r6, r1
    1a2a:	mov	r5, r2
  if(state == 0)
    1a2c:	cbnz	r3, 1a96 <c_uSD::write(short*, long)+0x76>
  { // open file
    char *filename = makeFilename(name);
    1a2e:	addw	r0, r0, #1302	; 0x516
    1a32:	bl	cec <makeFilename(char*)>
    if(!filename) {state=-1; return state;} // flag to do not anything
    1a36:	mov	r1, r0
    1a38:	cbnz	r0, 1a48 <c_uSD::write(short*, long)+0x28>
    1a3a:	movw	r3, #65535	; 0xffff
    1a3e:	strh.w	r3, [r4, #1296]	; 0x510
    1a42:	mov.w	r0, #4294967295
    1a46:	pop	{r4, r5, r6, pc}
    //
    if (!file.open(filename, O_CREAT | O_TRUNC |O_RDWR)) sd.errorHalt("file.open failed");
    1a48:	movw	r2, #1538	; 0x602
    1a4c:	add.w	r0, r4, #1232	; 0x4d0
    1a50:	bl	c30 <FsBaseFile::open(char const*, int)>
    1a54:	cbnz	r0, 1a5a <c_uSD::write(short*, long)+0x3a>
    1a56:	ldr	r1, [pc, #164]	; (1afc <c_uSD::write(short*, long)+0xdc>)
    1a58:	b.n	1abc <c_uSD::write(short*, long)+0x9c>
   *
   * \param[in] length size of the file in bytes.
   * \return true for success or false for failure.
   */
  bool preAllocate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->preAllocate(length) :
    1a5a:	ldr.w	r0, [r4, #1288]	; 0x508
           m_xFile ? m_xFile->preAllocate(length) : false;
    1a5e:	cbz	r0, 1a6a <c_uSD::write(short*, long)+0x4a>
   *
   * \param[in] length size of the file in bytes.
   * \return true for success or false for failure.
   */
  bool preAllocate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->preAllocate(length) :
    1a60:	mov.w	r1, #41943040	; 0x2800000
    1a64:	bl	6132 <FatFile::preAllocate(unsigned long)>
    1a68:	b.n	1a7c <c_uSD::write(short*, long)+0x5c>
           m_xFile ? m_xFile->preAllocate(length) : false;
    1a6a:	ldr.w	r0, [r4, #1292]	; 0x50c
    1a6e:	cmp	r0, #0
    1a70:	beq.n	1af6 <c_uSD::write(short*, long)+0xd6>
    1a72:	mov.w	r2, #41943040	; 0x2800000
    1a76:	movs	r3, #0
    1a78:	bl	4ca6 <ExFatFile::preAllocate(unsigned long long)>
    if (!file.preAllocate(PRE_ALLOCATE_SIZE)) sd.errorHalt("file.preAllocate failed");
    1a7c:	cbz	r0, 1af6 <c_uSD::write(short*, long)+0xd6>
    #ifdef  GEN_WAV_FILE // keep first record
          memcpy(header,(const char *)data,512);
    1a7e:	mov.w	r2, #512	; 0x200
    1a82:	mov	r1, r6
    1a84:	ldr	r0, [pc, #120]	; (1b00 <c_uSD::write(short*, long)+0xe0>)
    1a86:	bl	8b4c <memcpy>
    #endif
    state=1; // flag that file is open
    1a8a:	movs	r3, #1
    1a8c:	strh.w	r3, [r4, #1296]	; 0x510
    nbuf=0;
    1a90:	movs	r3, #0
    1a92:	strh.w	r3, [r4, #1298]	; 0x512
  }
  
  if(state == 1 || state == 2)
    1a96:	ldrh.w	r3, [r4, #1296]	; 0x510
    1a9a:	subs	r3, #1
    1a9c:	uxth	r3, r3
    1a9e:	cmp	r3, #1
    1aa0:	bhi.n	1ade <c_uSD::write(short*, long)+0xbe>
  {  // write to disk
    state=2;
    1aa2:	movs	r3, #2
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    1aa4:	lsls	r5, r5, #1
    nbuf=0;
  }
  
  if(state == 1 || state == 2)
  {  // write to disk
    state=2;
    1aa6:	strh.w	r3, [r4, #1296]	; 0x510
    if (2*ndat != (int32_t) file.write((char *) data, 2*ndat)) sd.errorHalt("file.write data failed");
    1aaa:	mov	r2, r5
    1aac:	mov	r1, r6
    1aae:	add.w	r0, r4, #1232	; 0x4d0
    1ab2:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
    1ab6:	cmp	r5, r0
    1ab8:	beq.n	1ac2 <c_uSD::write(short*, long)+0xa2>
    1aba:	ldr	r1, [pc, #72]	; (1b04 <c_uSD::write(short*, long)+0xe4>)
    1abc:	mov	r0, r4
    1abe:	bl	19f8 <SdBase<FsVolume>::errorHalt(char const*)>
    nbuf++;
    1ac2:	ldrh.w	r3, [r4, #1298]	; 0x512
    1ac6:	adds	r3, #1
    1ac8:	strh.w	r3, [r4, #1298]	; 0x512
    if(closing) {closing=0; state=3;}
    1acc:	ldrsh.w	r3, [r4, #1300]	; 0x514
    1ad0:	cbz	r3, 1ade <c_uSD::write(short*, long)+0xbe>
    1ad2:	movs	r3, #0
    1ad4:	strh.w	r3, [r4, #1300]	; 0x514
    1ad8:	movs	r3, #3
    1ada:	strh.w	r3, [r4, #1296]	; 0x510
  }
  
  if(state == 3)
    1ade:	ldrsh.w	r3, [r4, #1296]	; 0x510
    1ae2:	cmp	r3, #3
    1ae4:	bne.n	1af0 <c_uSD::write(short*, long)+0xd0>
  {
    state=close();
    1ae6:	mov	r0, r4
    1ae8:	bl	f48 <c_uSD::close()>
    1aec:	strh.w	r0, [r4, #1296]	; 0x510
  }
  return state;
    1af0:	ldrsh.w	r0, [r4, #1296]	; 0x510
    1af4:	pop	{r4, r5, r6, pc}
  { // open file
    char *filename = makeFilename(name);
    if(!filename) {state=-1; return state;} // flag to do not anything
    //
    if (!file.open(filename, O_CREAT | O_TRUNC |O_RDWR)) sd.errorHalt("file.open failed");
    if (!file.preAllocate(PRE_ALLOCATE_SIZE)) sd.errorHalt("file.preAllocate failed");
    1af6:	ldr	r1, [pc, #16]	; (1b08 <c_uSD::write(short*, long)+0xe8>)
    1af8:	b.n	1abc <c_uSD::write(short*, long)+0x9c>
    1afa:	nop
    1afc:	.word	0x00012bd9
    1b00:	.word	0x20014cf4
    1b04:	.word	0x00012bea
    1b08:	.word	0x00012c01

00001b0c <loop>:
  int16_t mustStore=1;
#else
  int16_t mustStore=0;
#endif

extern "C" void loop() {
    1b0c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
template <int mq>
uint16_t mRecordQueue<mq>::available(void)
{
  uint16_t h, t;

  h = head;
    1b10:	ldr	r4, [pc, #652]	; (1da0 <loop+0x294>)
    1b12:	ldrh.w	r3, [r4, #2036]	; 0x7f4
  t = tail;
    1b16:	ldrh.w	r1, [r4, #2038]	; 0x7f6
template <int mq>
uint16_t mRecordQueue<mq>::available(void)
{
  uint16_t h, t;

  h = head;
    1b1a:	uxth	r3, r3
  t = tail;
    1b1c:	uxth	r1, r1
  if (h >= t) return h - t;
    1b1e:	cmp	r3, r1
  return mq + h - t;
    1b20:	itte	cc
    1b22:	addcc.w	r2, r3, #500	; 0x1f4
    1b26:	subcc	r3, r2, r1
{
  uint16_t h, t;

  h = head;
  t = tail;
  if (h >= t) return h - t;
    1b28:	subcs	r3, r3, r1
    1b2a:	uxth	r3, r3
    1b2c:	sub	sp, #24
  static int16_t state=0; // 0: open new file, -1: last file

  int have_data=1;
  for(int ii=0;ii<NCH;ii++) if(queue[ii].available()==0) have_data=0;

  if(have_data)
    1b2e:	cmp	r3, #0
    1b30:	beq.w	1d04 <loop+0x1f8>
  { // have data on queue
//    started=1; // flag that we have now data
    #if MDEL<0
      int32_t nsec;
      nsec=checkDutyCycle(&acqParameters, state);
    1b34:	ldr	r5, [pc, #620]	; (1da4 <loop+0x298>)
    1b36:	ldr	r0, [pc, #624]	; (1da8 <loop+0x29c>)
    1b38:	ldrsh.w	r1, [r5]
    1b3c:	bl	124c <checkDutyCycle(ACQ_Parameters_s*, short)>
      if(nsec<0) { uSD.setClosing();} // this will be last record in file
    1b40:	subs	r6, r0, #0
    1b42:	bge.n	1b4e <loop+0x42>
  public:
    c_uSD(): state(-1), closing(0) {;}
    void init();
    int16_t write(int16_t * data, int32_t ndat);
    uint16_t getNbuf(void) {return nbuf;}
    void setClosing(void) {closing=1;}
    1b44:	ldr	r3, [pc, #612]	; (1dac <loop+0x2a0>)
    1b46:	movs	r2, #1
    1b48:	strh.w	r2, [r3, #1300]	; 0x514
    1b4c:	b.n	1b60 <loop+0x54>
      if(nsec>0) 
    1b4e:	beq.n	1b60 <loop+0x54>
      { 
        #if ((ACQ == _I2S) || (ACQ == _I2S_QUAD) || (ACQ == _I2S_32) || (ACQ == _I2S_32_MONO) || (ACQ == _I2S_TYMPAN) || (ACQ == _I2S_TDM))
          I2S_stopClock();
    1b50:	bl	b20 <I2S_stopClock()>
        #endif
        #if DO_DEBUG>1
          logFile.close();
    1b54:	ldr	r0, [pc, #600]	; (1db0 <loop+0x2a4>)
    1b56:	bl	7120 <FsBaseFile::close()>
        #endif
        setWakeupCallandSleep(nsec); // file closed sleep now
    1b5a:	mov	r0, r6
    1b5c:	bl	1148 <setWakeupCallandSleep(unsigned long)>
template <int mq>
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
    1b60:	ldr.w	r2, [r4, #2032]	; 0x7f0
    1b64:	ldr	r1, [pc, #568]	; (1da0 <loop+0x294>)
    1b66:	cbnz	r2, 1b98 <loop+0x8c>
	t = tail;
    1b68:	ldrh.w	r3, [r1, #2038]	; 0x7f6
	if (t == head) return NULL;
    1b6c:	ldrh.w	r1, [r1, #2036]	; 0x7f4
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
	t = tail;
    1b70:	uxth	r3, r3
	if (t == head) return NULL;
    1b72:	uxth	r1, r1
    1b74:	cmp	r3, r1
    1b76:	beq.n	1b9c <loop+0x90>
	if (++t >= mq) t = 0;
    1b78:	adds	r3, #1
    1b7a:	uxth	r3, r3
    1b7c:	cmp.w	r3, #500	; 0x1f4
    1b80:	it	cs
    1b82:	movcs	r3, #0
	userblock = queue[t];
    1b84:	add.w	r2, r3, #8
    1b88:	ldr.w	r2, [r4, r2, lsl #2]
    1b8c:	str.w	r2, [r4, #2032]	; 0x7f0
	tail = t;
    1b90:	strh.w	r3, [r4, #2038]	; 0x7f6
	return (void *) userblock->data;
    1b94:	adds	r3, r2, #4
    1b96:	b.n	1b9e <loop+0x92>
template <int mq>
void * mRecordQueue<mq>::readBuffer(void)
{
	uint16_t t;

	if (userblock) return NULL;
    1b98:	movs	r3, #0
    1b9a:	b.n	1b9e <loop+0x92>
    1b9c:	mov	r3, r2
    // fetch data from queues
    int16_t * data[NCH];
    for(int ii=0; ii<NCH; ii++) data[ii] = (int16_t *)queue[ii].readBuffer();
    // multiplex data
    int16_t *tmp = tempBuffer;
    for(int ii=0;ii<AUDIO_BLOCK_SAMPLES;ii++) for(int jj=0; jj<NCH; jj++) *tmp++ = *data[jj]++;
    1b9e:	ldr	r1, [pc, #532]	; (1db4 <loop+0x2a8>)
    1ba0:	movs	r2, #0
    1ba2:	ldrsh.w	r0, [r3, r2, lsl #1]
    1ba6:	strh.w	r0, [r1, r2, lsl #1]
    1baa:	adds	r2, #1
    1bac:	cmp	r2, #128	; 0x80
    1bae:	ldr	r6, [pc, #516]	; (1db4 <loop+0x2a8>)
    1bb0:	bne.n	1ba2 <loop+0x96>
}

template <int mq>
void mRecordQueue<mq>::freeBuffer(void)
{
	if (userblock == NULL) return;
    1bb2:	ldr.w	r0, [r4, #2032]	; 0x7f0
    1bb6:	cbz	r0, 1bc4 <loop+0xb8>
	release(userblock);
    1bb8:	bl	a094 <AudioStream::release(audio_block_struct*)>
	userblock = NULL;
    1bbc:	ldr	r3, [pc, #480]	; (1da0 <loop+0x294>)
    1bbe:	movs	r2, #0
    1bc0:	str.w	r2, [r3, #2032]	; 0x7f0

    #if(MDET)
      mustStore = process1.getSigCount() >  0;
    #endif

    if(mustStore)
    1bc4:	ldr	r3, [pc, #496]	; (1db8 <loop+0x2ac>)
    1bc6:	ldrsh.w	r3, [r3]
    1bca:	cmp	r3, #0
    1bcc:	beq.n	1cca <loop+0x1be>
    {
      if(state==0)
    1bce:	ldrsh.w	r4, [r5]
    1bd2:	ldr	r7, [pc, #488]	; (1dbc <loop+0x2b0>)
    1bd4:	cbnz	r4, 1c12 <loop+0x106>
      { // generate header before file is opened
        #ifdef GEN_WAV_FILE // is declared in audio_logger_if.h
          uint32_t *header=(uint32_t *) wavHeader(0); // call initially with zero filesize
    1bd6:	mov	r0, r4
    1bd8:	bl	d5c <wavHeader(unsigned long)>
          //
          int ndat=outptr-diskBuffer;
    1bdc:	ldr	r1, [r7, #0]
    1bde:	ldr	r2, [pc, #480]	; (1dc0 <loop+0x2b4>)
    1be0:	subs	r3, r1, r2
    1be2:	asrs	r3, r3, #1
          if(ndat>0)
    1be4:	cmp	r3, #0
    1be6:	bgt.n	1bec <loop+0xe0>
    1be8:	movs	r3, #0
    1bea:	b.n	1c00 <loop+0xf4>
    1bec:	sub.w	lr, r2, #2
          { // shift exisiting data after header, which is always at beginnig of file
            for(int ii=0; ii<ndat; ii++) diskBuffer[22+ii]=diskBuffer[ii]; 
    1bf0:	adds	r4, #1
    1bf2:	ldrh.w	ip, [lr, #2]!
    1bf6:	strh.w	ip, [lr, #44]	; 0x2c
    1bfa:	cmp	r3, r4
    1bfc:	bne.n	1bf0 <loop+0xe4>
    1bfe:	b.n	1be8 <loop+0xdc>
          }
          // copy header to disk buffer
          uint32_t *ptr=(uint32_t *) diskBuffer;
          for(int ii=0;ii<11;ii++) ptr[ii] = header[ii];
    1c00:	ldr	r4, [r0, r3]
    1c02:	str	r4, [r2, r3]
    1c04:	adds	r3, #4
    1c06:	cmp	r3, #44	; 0x2c
    1c08:	bne.n	1c00 <loop+0xf4>
          outptr+=22; //(44 bytes)
    1c0a:	adds	r1, #44	; 0x2c
          uint32_t *ptr=(uint32_t *) diskBuffer;
          // copy to disk buffer
          for(int ii=0;ii<128;ii++) ptr[ii] = header[ii];
          outptr+=256; //(512 bytes)
        #endif
        state=1;
    1c0c:	movs	r3, #1
            for(int ii=0; ii<ndat; ii++) diskBuffer[22+ii]=diskBuffer[ii]; 
          }
          // copy header to disk buffer
          uint32_t *ptr=(uint32_t *) diskBuffer;
          for(int ii=0;ii<11;ii++) ptr[ii] = header[ii];
          outptr+=22; //(44 bytes)
    1c0e:	str	r1, [r7, #0]
          uint32_t *ptr=(uint32_t *) diskBuffer;
          // copy to disk buffer
          for(int ii=0;ii<128;ii++) ptr[ii] = header[ii];
          outptr+=256; //(512 bytes)
        #endif
        state=1;
    1c10:	strh	r3, [r5, #0]
      } // state==0
      
      // copy data to disk buffer
      int16_t *ptr=(int16_t *) outptr;
    1c12:	ldr.w	r9, [r7]
      
      // number of data in tempBuffer
      int32_t ndat = AUDIO_BLOCK_SAMPLES*NCH;
      
      // number of free samples on diskbuffer
      int32_t nout = diskBuffer+BUFFERSIZE - outptr;
    1c16:	ldr	r1, [pc, #428]	; (1dc4 <loop+0x2b8>)
    1c18:	rsb	r1, r9, r1
    1c1c:	asrs	r1, r1, #1

      tmp = tempBuffer;
      if (nout>ndat)
    1c1e:	cmp	r1, #128	; 0x80
    1c20:	mov.w	r3, #0
    1c24:	ble.n	1c3a <loop+0x12e>
      { // sufficient space for all data
        for(int ii=0;ii<ndat;ii++) *ptr++ = *tmp++;
    1c26:	ldrsh.w	r2, [r6, r3, lsl #1]
    1c2a:	strh.w	r2, [r9, r3, lsl #1]
    1c2e:	adds	r3, #1
    1c30:	cmp	r3, #128	; 0x80
    1c32:	bne.n	1c26 <loop+0x11a>
    1c34:	add.w	r2, r9, #256	; 0x100
    1c38:	b.n	1caa <loop+0x19e>
      }
      else
      { // fill up disk buffer
        int nbuf=nout;
        if(uSD.isClosing()) nbuf=(nbuf/NCH)*NCH; // is last record of file 
        for(int ii=0;ii<nbuf;ii++) *ptr++ = *tmp++;
    1c3a:	cmp	r3, r1
    1c3c:	bge.n	1c4a <loop+0x13e>
    1c3e:	ldrsh.w	r2, [r6, r3, lsl #1]
    1c42:	strh.w	r2, [r9, r3, lsl #1]
    1c46:	adds	r3, #1
    1c48:	b.n	1c3a <loop+0x12e>
    1c4a:	bic.w	r3, r1, r1, asr #31
    1c4e:	lsls	r4, r3, #1
    1c50:	add.w	r8, r6, r4
        ndat-=nbuf;
    1c54:	rsb	r6, r1, #128	; 0x80
      }
      
      if(nout==0) //buffer has been filled, so write to disk
      { int32_t nbuf=ptr-diskBuffer;
      
        to=micros();
    1c58:	bl	9220 <micros>
        state=uSD.write(diskBuffer,nbuf); // this is blocking
    1c5c:	add.w	r2, r9, r4
    1c60:	ldr	r4, [pc, #348]	; (1dc0 <loop+0x2b4>)
    1c62:	subs	r2, r2, r4
    1c64:	asrs	r2, r2, #1
      }
      
      if(nout==0) //buffer has been filled, so write to disk
      { int32_t nbuf=ptr-diskBuffer;
      
        to=micros();
    1c66:	mov	sl, r0
        state=uSD.write(diskBuffer,nbuf); // this is blocking
    1c68:	mov	r1, r4
    1c6a:	ldr	r0, [pc, #320]	; (1dac <loop+0x2a0>)
    1c6c:	bl	1a20 <c_uSD::write(short*, long)>
    1c70:	strh	r0, [r5, #0]
        t1=micros();
    1c72:	bl	9220 <micros>
        t2=t1-to;
        if(t2<t3) t3=t2; // accumulate some time statistics
    1c76:	ldr	r3, [pc, #336]	; (1dc8 <loop+0x2bc>)
    1c78:	ldr	r2, [r3, #0]
      { int32_t nbuf=ptr-diskBuffer;
      
        to=micros();
        state=uSD.write(diskBuffer,nbuf); // this is blocking
        t1=micros();
        t2=t1-to;
    1c7a:	rsb	r0, sl, r0
        if(t2<t3) t3=t2; // accumulate some time statistics
    1c7e:	cmp	r0, r2
    1c80:	it	cc
    1c82:	strcc	r0, [r3, #0]
        if(t2>t4) t4=t2;
    1c84:	ldr	r3, [pc, #324]	; (1dcc <loop+0x2c0>)
    1c86:	ldr	r2, [r3, #0]
    1c88:	cmp	r0, r2
    1c8a:	it	hi
    1c8c:	strhi	r0, [r3, #0]

        ptr=(int16_t *)diskBuffer;
      }

      if(ndat>0) // save residual data
    1c8e:	cbz	r6, 1ca8 <loop+0x19c>
    1c90:	movs	r3, #0
    1c92:	adds	r0, r3, #1
    1c94:	lsls	r1, r0, #1
    1c96:	adds	r2, r4, r1
      {
        for(int ii=0;ii<ndat;ii++) *ptr++ = *tmp++;
    1c98:	subs	r1, #2
    1c9a:	ldrh.w	r3, [r8, r3, lsl #1]
    1c9e:	strh	r3, [r4, r1]
    1ca0:	cmp	r6, r0
    1ca2:	mov	r3, r0
    1ca4:	bgt.n	1c92 <loop+0x186>
    1ca6:	b.n	1caa <loop+0x19e>
    1ca8:	ldr	r2, [pc, #276]	; (1dc0 <loop+0x2b4>)
      }
      
      // all data are copied
      outptr=(int16_t *)ptr; // save actual write position

      if(!state)
    1caa:	ldrsh.w	r3, [r5]
      {
        for(int ii=0;ii<ndat;ii++) *ptr++ = *tmp++;
      }
      
      // all data are copied
      outptr=(int16_t *)ptr; // save actual write position
    1cae:	str	r2, [r7, #0]

      if(!state)
    1cb0:	cbnz	r3, 1d04 <loop+0x1f8>
      { // store config again if you wanted time of latest file stored
        uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1cb2:	movs	r2, #8
    1cb4:	str	r2, [sp, #0]
    1cb6:	ldr	r3, [pc, #280]	; (1dd0 <loop+0x2c4>)
    1cb8:	ldr	r1, [pc, #236]	; (1da8 <loop+0x29c>)
    1cba:	ldr	r0, [pc, #240]	; (1dac <loop+0x2a0>)
    1cbc:	bl	fc8 <c_uSD::storeConfig(unsigned long*, int, long*, int)>
        #if DO_DEBUG>0
          Serial.println("closed");
    1cc0:	ldr	r1, [pc, #272]	; (1dd4 <loop+0x2c8>)
    1cc2:	ldr	r0, [pc, #276]	; (1dd8 <loop+0x2cc>)
    1cc4:	bl	8a0 <Print::println(__FlashStringHelper const*)>
    1cc8:	b.n	1d04 <loop+0x1f8>
        #endif
      }
    }
    else if(state>0)
    1cca:	ldrsh.w	r3, [r5]
    1cce:	cmp	r3, #0
    1cd0:	ble.n	1d04 <loop+0x1f8>
    { // close file
      // write remaining data to disk and close file
      uint32_t nbuf = (uint32_t)(outptr-diskBuffer);
    1cd2:	ldr	r3, [pc, #232]	; (1dbc <loop+0x2b0>)
    1cd4:	ldr	r4, [pc, #232]	; (1dc0 <loop+0x2b4>)
    1cd6:	ldr	r2, [r3, #0]
    1cd8:	subs	r2, r2, r4
      if(nbuf>0)
    1cda:	asrs	r2, r2, #1
    1cdc:	mov	r6, r3
    1cde:	beq.n	1cec <loop+0x1e0>
      { state=uSD.write(diskBuffer,nbuf); // this is blocking
    1ce0:	mov	r1, r4
    1ce2:	ldr	r0, [pc, #200]	; (1dac <loop+0x2a0>)
    1ce4:	bl	1a20 <c_uSD::write(short*, long)>
    1ce8:	ldr	r3, [pc, #184]	; (1da4 <loop+0x298>)
    1cea:	strh	r0, [r3, #0]
      }
      state=uSD.close();
    1cec:	ldr	r0, [pc, #188]	; (1dac <loop+0x2a0>)
    1cee:	bl	f48 <c_uSD::close()>
      uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1cf2:	movs	r2, #8
      // write remaining data to disk and close file
      uint32_t nbuf = (uint32_t)(outptr-diskBuffer);
      if(nbuf>0)
      { state=uSD.write(diskBuffer,nbuf); // this is blocking
      }
      state=uSD.close();
    1cf4:	strh	r0, [r5, #0]
      uSD.storeConfig((uint32_t *)&acqParameters, 8, (int32_t *)&snipParameters, 8);
    1cf6:	ldr	r3, [pc, #216]	; (1dd0 <loop+0x2c4>)
    1cf8:	str	r2, [sp, #0]
    1cfa:	ldr	r1, [pc, #172]	; (1da8 <loop+0x29c>)
    1cfc:	ldr	r0, [pc, #172]	; (1dac <loop+0x2a0>)
    1cfe:	bl	fc8 <c_uSD::storeConfig(unsigned long*, int, long*, int)>
      outptr = diskBuffer;
    1d02:	str	r4, [r6, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d04:	ldr	r0, [pc, #212]	; (1ddc <loop+0x2d0>)
#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
    1d06:	ldr	r1, [pc, #216]	; (1de0 <loop+0x2d4>)
    1d08:	ldr	r3, [r0, #0]

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d0a:	ldr	r5, [pc, #216]	; (1de4 <loop+0x2d8>)
    1d0c:	str	r3, [sp, #16]
  if(millis()>t0+1000)
    1d0e:	ldr	r3, [r1, #0]

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d10:	ldr	r2, [r5, #0]
	return ret;
    1d12:	ldr	r4, [sp, #16]
  if(millis()>t0+1000)
    1d14:	add.w	r3, r3, #1000	; 0x3e8

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d18:	adds	r2, #1
  if(millis()>t0+1000)
    1d1a:	cmp	r3, r4

#if DO_DEBUG>0
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
    1d1c:	str	r2, [r5, #0]
  if(millis()>t0+1000)
    1d1e:	bcs.n	1d98 <loop+0x28c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d20:	ldr	r3, [r0, #0]
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
    1d22:	ldr	r4, [pc, #164]	; (1dc8 <loop+0x2bc>)
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
    1d24:	ldr	r7, [pc, #192]	; (1de8 <loop+0x2dc>)
    1d26:	str	r3, [sp, #20]
	return ret;
    1d28:	ldr	r3, [sp, #20]
    1d2a:	ldr.w	r9, [pc, #128]	; 1dac <loop+0x2a0>
  // some statistics on progress
  static uint32_t loopCount=0;
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();
    1d2e:	str	r3, [r1, #0]

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
    1d30:	ldrh	r0, [r7, #0]
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
    1d32:	ldr	r1, [r4, #0]
          AudioMemoryUsageMax());
    1d34:	ldr	r6, [pc, #148]	; (1dcc <loop+0x2c0>)
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
    1d36:	ldr.w	r8, [pc, #204]	; 1e04 <loop+0x2f8>
    1d3a:	ldrh.w	r3, [r9, #1298]	; 0x512
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
    1d3e:	str	r0, [sp, #8]
    1d40:	ldr	r0, [r6, #0]
    1d42:	str	r0, [sp, #4]
  static uint32_t t0=0;
  loopCount++;
  if(millis()>t0+1000)
  {  t0=millis();

    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
    1d44:	cmp	r1, r8
    1d46:	it	hi
    1d48:	movhi.w	r1, #4294967295
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
    1d4c:	str	r1, [sp, #0]
    1d4e:	ldr	r0, [pc, #136]	; (1dd8 <loop+0x2cc>)
    1d50:	ldr	r1, [pc, #152]	; (1dec <loop+0x2e0>)
    1d52:	bl	9ef6 <Print::printf(char const*, ...)>
      //
    #if DO_DEBUG>1  
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
    1d56:	ldr	r2, [r4, #0]
            AudioMemoryUsageMax());
    1d58:	ldrh	r1, [r7, #0]
    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
      //
    #if DO_DEBUG>1  
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
    1d5a:	ldrh.w	r3, [r9, #1298]	; 0x512
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    1d5e:	str	r1, [sp, #8]
    1d60:	ldr	r1, [r6, #0]
    1d62:	str	r1, [sp, #4]
    Serial.printf("\tloop: %5d %4d; %5d %5d; %5d",
          loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
          AudioMemoryUsageMax());
      //
    #if DO_DEBUG>1  
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
    1d64:	cmp	r2, r8
    1d66:	it	hi
    1d68:	movhi.w	r2, #4294967295
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    1d6c:	str	r2, [sp, #0]
    1d6e:	ldr	r2, [r5, #0]
    1d70:	ldr	r1, [pc, #124]	; (1df0 <loop+0x2e4>)
    1d72:	ldr	r0, [pc, #128]	; (1df4 <loop+0x2e8>)
    1d74:	bl	9ef6 <Print::printf(char const*, ...)>
    #endif

    AudioMemoryUsageMaxReset();
    1d78:	ldr	r3, [pc, #124]	; (1df8 <loop+0x2ec>)
  #endif

  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    1d7a:	ldr	r0, [pc, #92]	; (1dd8 <loop+0x2cc>)
      logFile.printf("\tloop: %5d %4d; %5d %5d; %5d\n",
            loopCount, uSD.getNbuf(), t3>100000?-1:t3,t4, 
            AudioMemoryUsageMax());
    #endif

    AudioMemoryUsageMaxReset();
    1d7c:	ldrh	r3, [r3, #0]
    1d7e:	strh	r3, [r7, #0]
    t3=1<<31;
    1d80:	mov.w	r3, #2147483648	; 0x80000000
    1d84:	str	r3, [r4, #0]
    t4=0;
    1d86:	movs	r4, #0
    1d88:	str	r4, [r6, #0]
  #endif

  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    1d8a:	bl	9ec8 <Print::println()>
    loopCount=0;
    maxValue=0;
    1d8e:	ldr	r3, [pc, #108]	; (1dfc <loop+0x2f0>)

  #if (ACQ==_ADC_0) | (ACQ==_ADC_D) | (ACQ==_ADC_S)
    Serial.printf("; %5d %5d",PDB0_CNT, PDB0_MOD);
  #endif
    Serial.println();
    loopCount=0;
    1d90:	str	r4, [r5, #0]
    maxValue=0;
    1d92:	str	r4, [r3, #0]
    maxNoise=0;
    1d94:	ldr	r3, [pc, #104]	; (1e00 <loop+0x2f4>)
    1d96:	str	r4, [r3, #0]
  }

#endif

  asm("wfi"); // to save some power switch off idle cpu
    1d98:	wfi
}
    1d9a:	add	sp, #24
    1d9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1da0:	.word	0x2001910c
    1da4:	.word	0x20019910
    1da8:	.word	0x20013964
    1dac:	.word	0x200147cc
    1db0:	.word	0x20019090
    1db4:	.word	0x20018f80
    1db8:	.word	0x20013960
    1dbc:	.word	0x20013934
    1dc0:	.word	0x20014ef4
    1dc4:	.word	0x20018ef4
    1dc8:	.word	0x20014cec
    1dcc:	.word	0x20014cf0
    1dd0:	.word	0x20013940
    1dd4:	.word	0x00012c19
    1dd8:	.word	0x20013d54
    1ddc:	.word	0x20019f04
    1de0:	.word	0x20019914
    1de4:	.word	0x20018f7c
    1de8:	.word	0x2001a004
    1dec:	.word	0x00012c20
    1df0:	.word	0x00012c3d
    1df4:	.word	0x20019080
    1df8:	.word	0x2001a084
    1dfc:	.word	0x2001990c
    1e00:	.word	0x20018f48
    1e04:	.word	0x000186a0

00001e08 <_GLOBAL__sub_I_acqParameters>:
    1e08:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

audio_block_t * I2S_32:: block_left = NULL;
audio_block_t * I2S_32:: block_right = NULL;
uint16_t I2S_32:: block_offset = 0;
bool I2S_32::update_responsibility = false;
DMAChannel I2S_32::dma(false);
    1e0c:	ldr	r7, [pc, #228]	; (1ef4 <_GLOBAL__sub_I_acqParameters+0xec>)

class I2S_32 : public AudioStream
{
public:

	I2S_32(void) : AudioStream(0, NULL) {begin();}
    1e0e:	ldr.w	r8, [pc, #288]	; 1f30 <_GLOBAL__sub_I_acqParameters+0x128>

audio_block_t * I2S_32:: block_left = NULL;
audio_block_t * I2S_32:: block_right = NULL;
uint16_t I2S_32:: block_offset = 0;
bool I2S_32::update_responsibility = false;
DMAChannel I2S_32::dma(false);
    1e12:	ldr	r1, [pc, #228]	; (1ef8 <_GLOBAL__sub_I_acqParameters+0xf0>)
    1e14:	ldr	r0, [pc, #228]	; (1efc <_GLOBAL__sub_I_acqParameters+0xf4>)
template <int mq>
class mRecordQueue : public AudioStream
{
public:
	mRecordQueue(void) : AudioStream(1, inputQueueArray),
		userblock(NULL), head(0), tail(0), enabled(0) { }
    1e16:	ldr	r6, [pc, #232]	; (1f00 <_GLOBAL__sub_I_acqParameters+0xf8>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    1e18:	ldr	r5, [pc, #232]	; (1f04 <_GLOBAL__sub_I_acqParameters+0xfc>)
    1e1a:	mov	r2, r7
    1e1c:	bl	a424 <__aeabi_atexit>

class I2S_32 : public AudioStream
{
public:

	I2S_32(void) : AudioStream(0, NULL) {begin();}
    1e20:	movs	r2, #0
    1e22:	mov	r1, r2
    1e24:	mov	r0, r8
    1e26:	bl	83c <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    1e2a:	ldr	r3, [pc, #220]	; (1f08 <_GLOBAL__sub_I_acqParameters+0x100>)
    1e2c:	str.w	r3, [r8]
    1e30:	mov	r0, r8
    1e32:	bl	9a0 <I2S_32::begin()>
    1e36:	add.w	r2, r6, #28
    1e3a:	movs	r1, #1
    1e3c:	mov	r0, r6
    1e3e:	movs	r4, #0
    1e40:	bl	83c <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    1e44:	ldr	r3, [pc, #196]	; (1f0c <_GLOBAL__sub_I_acqParameters+0x104>)
    1e46:	str	r3, [r6, #0]
    1e48:	strh.w	r4, [r6, #2036]	; 0x7f4
    1e4c:	str.w	r4, [r6, #2032]	; 0x7f0
    1e50:	strh.w	r4, [r6, #2038]	; 0x7f6
		{ isConnected = false;
		  connect(); }
    1e54:	mov	r0, r5
    1e56:	strh.w	r4, [r6, #2040]	; 0x7f8
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    1e5a:	str.w	r8, [r5]
    1e5e:	str	r6, [r5, #4]
    1e60:	strb	r4, [r5, #8]
    1e62:	strb	r4, [r5, #9]
    1e64:	str	r4, [r5, #12]
		{ isConnected = false;
    1e66:	strb	r4, [r5, #16]
		  connect(); }
    1e68:	bl	a126 <AudioConnection::connect()>
    #include "m_delay.h" 
    mDelay<NCH,(MDEL+2)>  delay1(0); // have two buffers more in queue only to be safe 
  #endif 

  #if MDEL<0
      AudioConnection     patchCord2(acq, queue[0]); 
    1e6c:	mov	r2, r7
    1e6e:	ldr	r1, [pc, #160]	; (1f10 <_GLOBAL__sub_I_acqParameters+0x108>)
    1e70:	mov	r0, r5
    1e72:	bl	a424 <__aeabi_atexit>
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    1e76:	ldr	r0, [pc, #156]	; (1f14 <_GLOBAL__sub_I_acqParameters+0x10c>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    1e78:	ldr	r5, [pc, #156]	; (1f18 <_GLOBAL__sub_I_acqParameters+0x110>)
    1e7a:	strb	r4, [r0, #4]
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    1e7c:	mov.w	r6, #1000	; 0x3e8
// rename in SdFat-beta/src the file SdFat.h to SdFat-beta.h
// to avoid confict with stock SD library needed for Audio library
//
#include "SdFat.h" 

FsFile logFile;
    1e80:	mov	r2, r7
    1e82:	str	r6, [r0, #8]
    1e84:	strb	r4, [r0, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    1e86:	str	r4, [r0, #72]	; 0x48
    1e88:	str	r4, [r0, #76]	; 0x4c
    1e8a:	ldr	r1, [pc, #144]	; (1f1c <_GLOBAL__sub_I_acqParameters+0x114>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    1e8c:	str	r5, [r0, #0]
    1e8e:	bl	a424 <__aeabi_atexit>
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    1e92:	ldr	r0, [pc, #140]	; (1f20 <_GLOBAL__sub_I_acqParameters+0x118>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1e94:	ldr	r3, [pc, #140]	; (1f24 <_GLOBAL__sub_I_acqParameters+0x11c>)
    1e96:	str.w	r3, [r0, #1168]	; 0x490
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    1e9a:	ldr	r3, [pc, #140]	; (1f28 <_GLOBAL__sub_I_acqParameters+0x120>)
    1e9c:	str.w	r3, [r0, #1180]	; 0x49c
    1ea0:	movs	r3, #1
    1ea2:	strb.w	r3, [r0, #1193]	; 0x4a9
    1ea6:	movs	r3, #41	; 0x29
    1ea8:	strb.w	r3, [r0, #1195]	; 0x4ab
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    1eac:	strb.w	r4, [r0, #1176]	; 0x498
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1eb0:	strb.w	r4, [r0, #1177]	; 0x499
    1eb4:	strb.w	r4, [r0, #1198]	; 0x4ae
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    1eb8:	strb.w	r4, [r0, #1212]	; 0x4bc
    1ebc:	strb.w	r4, [r0, #1220]	; 0x4c4
    1ec0:	strb.w	r4, [r0, #1228]	; 0x4cc
    1ec4:	str.w	r4, [r0, #1152]	; 0x480
    1ec8:	str.w	r4, [r0, #1156]	; 0x484
    1ecc:	str.w	r6, [r0, #1224]	; 0x4c8
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    1ed0:	str.w	r4, [r0, #1288]	; 0x508
    1ed4:	str.w	r4, [r0, #1292]	; 0x50c
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    1ed8:	str.w	r5, [r0, #1216]	; 0x4c0
  private:
    SdFs sd;
    FsFile file;
    
  public:
    c_uSD(): state(-1), closing(0) {;}
    1edc:	movw	r3, #65535	; 0xffff
    1ee0:	strh.w	r4, [r0, #1300]	; 0x514
  public:
  void loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2);
  void storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2);
  void writeTemperature(float temperature, float pressure, float humidity, uint16_t lux);
};
c_uSD uSD;
    1ee4:	mov	r2, r7
    1ee6:	ldr	r1, [pc, #68]	; (1f2c <_GLOBAL__sub_I_acqParameters+0x124>)
  private:
    SdFs sd;
    FsFile file;
    
  public:
    c_uSD(): state(-1), closing(0) {;}
    1ee8:	strh.w	r3, [r0, #1296]	; 0x510
  }

#endif

  asm("wfi"); // to save some power switch off idle cpu
}
    1eec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  public:
  void loadConfig(uint32_t * param1, int n1, int32_t *param2, int n2);
  void storeConfig(uint32_t * param1, int n1, int32_t *param2, int n2);
  void writeTemperature(float temperature, float pressure, float humidity, uint16_t lux);
};
c_uSD uSD;
    1ef0:	b.w	a424 <__aeabi_atexit>
    1ef4:	.word	0x20013930
    1ef8:	.word	0x00000781
    1efc:	.word	0x20019104
    1f00:	.word	0x2001910c
    1f04:	.word	0x200190f0
    1f08:	.word	0x00012c64
    1f0c:	.word	0x000127b8
    1f10:	.word	0x00000775
    1f14:	.word	0x20019080
    1f18:	.word	0x000127e8
    1f1c:	.word	0x0000071d
    1f20:	.word	0x200147cc
    1f24:	.word	0x0001310c
    1f28:	.word	0x000130ac
    1f2c:	.word	0x00000735
    1f30:	.word	0x200190d0

00001f34 <breakTime(long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1f34:	movs	r3, #60	; 0x3c
// leap year calculator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
    1f36:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1f3a:	udiv	r4, r0, r3
    1f3e:	mls	r2, r3, r4, r0
    1f42:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1f44:	udiv	r2, r4, r3
    1f48:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1f4c:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1f4e:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1f50:	mov.w	r3, #3600	; 0xe10
    1f54:	udiv	r3, r0, r3
    1f58:	udiv	r2, r3, r4
    1f5c:	mls	r3, r4, r2, r3
    1f60:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    1f62:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    1f64:	ldr	r3, [pc, #240]	; (2058 <breakTime(long, tmElements_t&)+0x124>)
    1f66:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    1f6a:	adds	r3, r0, #4
    1f6c:	udiv	r2, r3, r2
    1f70:	rsb	r2, r2, r2, lsl #3
    1f74:	subs	r3, r3, r2
    1f76:	adds	r3, #1
    1f78:	movs	r4, #0
    1f7a:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    1f7c:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    1f7e:	movw	r8, #365	; 0x16d
    1f82:	mov.w	lr, #100	; 0x64
    1f86:	mov.w	ip, #400	; 0x190
    1f8a:	uxtb	r6, r4
    1f8c:	addw	r3, r6, #1970	; 0x7b2
    1f90:	ands.w	r7, r3, #3
    1f94:	bne.n	1fb4 <breakTime(long, tmElements_t&)+0x80>
    1f96:	sdiv	r5, r3, lr
    1f9a:	mls	r5, lr, r5, r3
    1f9e:	cbnz	r5, 1fba <breakTime(long, tmElements_t&)+0x86>
    1fa0:	sdiv	r5, r3, ip
    1fa4:	mls	r5, ip, r5, r3
    1fa8:	cmp	r5, #0
    1faa:	ite	ne
    1fac:	movne	r5, r8
    1fae:	moveq.w	r5, #366	; 0x16e
    1fb2:	b.n	1fbe <breakTime(long, tmElements_t&)+0x8a>
    1fb4:	movw	r5, #365	; 0x16d
    1fb8:	b.n	1fbe <breakTime(long, tmElements_t&)+0x8a>
    1fba:	mov.w	r5, #366	; 0x16e
    1fbe:	add	r2, r5
    1fc0:	cmp	r0, r2
    1fc2:	add.w	r4, r4, #1
    1fc6:	bcs.n	1f8a <breakTime(long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    1fc8:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    1fca:	cbnz	r7, 1ff2 <breakTime(long, tmElements_t&)+0xbe>
    1fcc:	movs	r5, #100	; 0x64
    1fce:	sdiv	r4, r3, r5
    1fd2:	mls	r4, r5, r4, r3
    1fd6:	cbnz	r4, 1ff8 <breakTime(long, tmElements_t&)+0xc4>
    1fd8:	mov.w	r5, #400	; 0x190
    1fdc:	sdiv	r4, r3, r5
    1fe0:	mls	r4, r5, r4, r3
    1fe4:	cmp	r4, #0
    1fe6:	movw	r4, #365	; 0x16d
    1fea:	it	eq
    1fec:	moveq.w	r4, #366	; 0x16e
    1ff0:	b.n	1ffc <breakTime(long, tmElements_t&)+0xc8>
    1ff2:	movw	r4, #365	; 0x16d
    1ff6:	b.n	1ffc <breakTime(long, tmElements_t&)+0xc8>
    1ff8:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    1ffc:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    1ffe:	movs	r6, #100	; 0x64
    2000:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    2004:	ldr.w	lr, [pc, #84]	; 205c <breakTime(long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    2008:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    200a:	sdiv	r2, r3, r6
    200e:	mls	r6, r6, r2, r3
    2012:	sdiv	r2, r3, r4
    2016:	mls	r3, r4, r2, r3
    201a:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    201c:	cmp	r2, #1
    201e:	uxtb	r5, r2
    2020:	bne.n	2030 <breakTime(long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    2022:	cbnz	r7, 2036 <breakTime(long, tmElements_t&)+0x102>
    2024:	cbnz	r6, 203a <breakTime(long, tmElements_t&)+0x106>
        monthLength=29;
    2026:	cmp	r3, #0
    2028:	ite	ne
    202a:	movne	r4, #28
    202c:	moveq	r4, #29
    202e:	b.n	203c <breakTime(long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    2030:	ldrb.w	r4, [r2, lr]
    2034:	b.n	203c <breakTime(long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    2036:	movs	r4, #28
    2038:	b.n	203c <breakTime(long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    203a:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    203c:	cmp	r4, r0
    203e:	bhi.n	204c <breakTime(long, tmElements_t&)+0x118>
    2040:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    2042:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    2044:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    2048:	bne.n	201c <breakTime(long, tmElements_t&)+0xe8>
    204a:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    204c:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    204e:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    2050:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    2052:	strb	r0, [r1, #4]
    2054:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2058:	.word	0x00015180
    205c:	.word	0x00012c68

00002060 <refreshCache(long)>:

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    2060:	push	{r3, r4, r5, lr}
  if (t != cacheTime) {
    2062:	ldr	r4, [pc, #20]	; (2078 <refreshCache(long)+0x18>)
    2064:	ldr	r3, [r4, #0]
    2066:	cmp	r3, r0

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    2068:	mov	r5, r0
  if (t != cacheTime) {
    206a:	beq.n	2074 <refreshCache(long)+0x14>
    breakTime(t, tm); 
    206c:	ldr	r1, [pc, #12]	; (207c <refreshCache(long)+0x1c>)
    206e:	bl	1f34 <breakTime(long, tmElements_t&)>
    cacheTime = t; 
    2072:	str	r5, [r4, #0]
    2074:	pop	{r3, r4, r5, pc}
    2076:	nop
    2078:	.word	0x20019918
    207c:	.word	0x2001991c

00002080 <year(long)>:

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
}

int year(time_t t) { // the year for the given time
    2080:	push	{r3, lr}
  refreshCache(t);
    2082:	bl	2060 <refreshCache(long)>
  return tmYearToCalendar(tm.Year);
    2086:	ldr	r3, [pc, #8]	; (2090 <year(long)+0x10>)
    2088:	ldrb	r0, [r3, #6]
}
    208a:	addw	r0, r0, #1970	; 0x7b2
    208e:	pop	{r3, pc}
    2090:	.word	0x2001991c

00002094 <makeTime(tmElements_t const&)>:
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
}

time_t makeTime(const tmElements_t &tm){   
    2094:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    2096:	ldr	r3, [pc, #176]	; (2148 <makeTime(tmElements_t const&)+0xb4>)
    2098:	ldrb	r2, [r0, #6]
    209a:	movw	r1, #1970	; 0x7b2
    209e:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    20a0:	movs	r5, #100	; 0x64
    20a2:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    20a6:	subw	r4, r1, #1970	; 0x7b2
    20aa:	cmp	r2, r4
    20ac:	ble.n	20d2 <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    20ae:	lsls	r4, r1, #30
    20b0:	bne.n	20ce <makeTime(tmElements_t const&)+0x3a>
    20b2:	sdiv	r4, r1, r5
    20b6:	mls	r4, r5, r4, r1
    20ba:	cbnz	r4, 20c6 <makeTime(tmElements_t const&)+0x32>
    20bc:	sdiv	r4, r1, r6
    20c0:	mls	r4, r6, r4, r1
    20c4:	cbnz	r4, 20ce <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    20c6:	add.w	r3, r3, #86016	; 0x15000
    20ca:	add.w	r3, r3, #384	; 0x180
    20ce:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    20d0:	b.n	20a6 <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    20d2:	addw	r2, r2, #1970	; 0x7b2
    20d6:	movs	r4, #100	; 0x64
    20d8:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    20dc:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    20de:	ldr	r7, [pc, #108]	; (214c <makeTime(tmElements_t const&)+0xb8>)
    20e0:	ldr.w	lr, [pc, #108]	; 2150 <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    20e4:	sdiv	r1, r2, r4
    20e8:	mls	r4, r4, r1, r2
    20ec:	sdiv	r1, r2, r5
    20f0:	mls	r5, r5, r1, r2
    20f4:	movs	r1, #1
    20f6:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    20fa:	cmp	r6, r1
    20fc:	ble.n	2122 <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    20fe:	cmp	r1, #2
    2100:	bne.n	2112 <makeTime(tmElements_t const&)+0x7e>
    2102:	cbnz	r2, 2112 <makeTime(tmElements_t const&)+0x7e>
    2104:	cbnz	r4, 2108 <makeTime(tmElements_t const&)+0x74>
    2106:	cbnz	r5, 2112 <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    2108:	add.w	r3, r3, #2490368	; 0x260000
    210c:	add.w	r3, r3, #15232	; 0x3b80
    2110:	b.n	211e <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    2112:	add.w	ip, r7, r1
    2116:	ldrb.w	ip, [ip, #-1]
    211a:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    211e:	adds	r1, #1
    2120:	b.n	20fa <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return (time_t)seconds; 
    2122:	ldrb	r2, [r0, #1]
    2124:	ldrb	r1, [r0, #2]
    2126:	rsb	r2, r2, r2, lsl #4
    212a:	mov.w	r4, #3600	; 0xe10
    212e:	lsls	r2, r2, #2
    2130:	mla	r2, r4, r1, r2
    2134:	ldrb	r1, [r0, #0]
    2136:	add	r2, r1
    2138:	ldrb	r1, [r0, #4]
    213a:	ldr	r0, [pc, #20]	; (2150 <makeTime(tmElements_t const&)+0xbc>)
    213c:	subs	r1, #1
    213e:	mla	r0, r0, r1, r2
}
    2142:	add	r0, r3
    2144:	pop	{r4, r5, r6, r7, pc}
    2146:	nop
    2148:	.word	0x01e13380
    214c:	.word	0x00012c68
    2150:	.word	0x00015180

00002154 <setTime(long)>:
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    2154:	ldr	r3, [pc, #36]	; (217c <setTime(long)+0x28>)
    2156:	str	r0, [r3, #0]
  nextSyncTime = (uint32_t)t + syncInterval;
    2158:	ldr	r3, [pc, #36]	; (2180 <setTime(long)+0x2c>)
    215a:	ldr	r3, [r3, #0]
    215c:	add	r0, r3
    215e:	ldr	r3, [pc, #36]	; (2184 <setTime(long)+0x30>)
    2160:	str	r0, [r3, #0]
  Status = timeSet;
    2162:	ldr	r3, [pc, #36]	; (2188 <setTime(long)+0x34>)
    2164:	movs	r2, #2
    2166:	strb	r2, [r3, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2168:	ldr	r3, [pc, #32]	; (218c <setTime(long)+0x38>)
    }
  }  
  return (time_t)sysTime;
}

void setTime(time_t t) { 
    216a:	sub	sp, #8
    216c:	ldr	r3, [r3, #0]
    216e:	str	r3, [sp, #4]
	return ret;
    2170:	ldr	r2, [sp, #4]
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
  Status = timeSet;
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    2172:	ldr	r3, [pc, #28]	; (2190 <setTime(long)+0x3c>)
    2174:	str	r2, [r3, #0]
} 
    2176:	add	sp, #8
    2178:	bx	lr
    217a:	nop
    217c:	.word	0x20019924
    2180:	.word	0x2001398c
    2184:	.word	0x20019934
    2188:	.word	0x20019928
    218c:	.word	0x20019f04
    2190:	.word	0x20019930

00002194 <now()>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    2194:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2196:	ldr	r3, [pc, #100]	; (21fc <now()+0x68>)
    2198:	ldr	r4, [pc, #100]	; (2200 <now()+0x6c>)
    219a:	ldr	r2, [r3, #0]
    219c:	ldr	r1, [r4, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    219e:	ldr	r7, [pc, #100]	; (2204 <now()+0x70>)
    21a0:	movs	r5, #0
    21a2:	ldr	r0, [r7, #0]
    21a4:	str	r0, [sp, #4]
	return ret;
    21a6:	ldr	r0, [sp, #4]
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    21a8:	subs	r0, r0, r2
    21aa:	cmp.w	r0, #1000	; 0x3e8
    21ae:	add.w	r6, r1, #1
    21b2:	bcc.n	21be <now()+0x2a>
		// millis() and prevMillis are both unsigned ints thus the subtraction will always be the absolute value of the difference
    sysTime++;
    prevMillis += 1000;	
    21b4:	add.w	r2, r2, #1000	; 0x3e8
    21b8:	movs	r5, #1
#endif


time_t now() {
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    21ba:	mov	r1, r6
    21bc:	b.n	21a2 <now()+0xe>
    21be:	cbz	r5, 21c4 <now()+0x30>
    21c0:	str	r1, [r4, #0]
    21c2:	str	r2, [r3, #0]
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif
  }
  if (nextSyncTime <= sysTime) {
    21c4:	ldr	r5, [pc, #64]	; (2208 <now()+0x74>)
    21c6:	ldr	r3, [r4, #0]
    21c8:	ldr	r2, [r5, #0]
    21ca:	cmp	r2, r3
    21cc:	bhi.n	21f6 <now()+0x62>
    if (getTimePtr != 0) {
    21ce:	ldr	r3, [pc, #60]	; (220c <now()+0x78>)
    21d0:	ldr	r3, [r3, #0]
    21d2:	cbz	r3, 21f6 <now()+0x62>
      time_t t = getTimePtr();
    21d4:	blx	r3
      if (t != 0) {
    21d6:	cbz	r0, 21de <now()+0x4a>
        setTime(t);
    21d8:	bl	2154 <setTime(long)>
    21dc:	b.n	21f6 <now()+0x62>
      } else {
        nextSyncTime = sysTime + syncInterval;
    21de:	ldr	r3, [pc, #32]	; (2200 <now()+0x6c>)
    21e0:	ldr	r2, [r3, #0]
    21e2:	ldr	r3, [pc, #44]	; (2210 <now()+0x7c>)
    21e4:	ldr	r3, [r3, #0]
    21e6:	add	r3, r2
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    21e8:	ldr	r2, [pc, #40]	; (2214 <now()+0x80>)
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    21ea:	str	r3, [r5, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    21ec:	ldrb	r3, [r2, #0]
    21ee:	adds	r3, #0
    21f0:	it	ne
    21f2:	movne	r3, #1
    21f4:	strb	r3, [r2, #0]
      }
    }
  }  
  return (time_t)sysTime;
}
    21f6:	ldr	r0, [r4, #0]
    21f8:	add	sp, #12
    21fa:	pop	{r4, r5, r6, r7, pc}
    21fc:	.word	0x20019930
    2200:	.word	0x20019924
    2204:	.word	0x20019f04
    2208:	.word	0x20019934
    220c:	.word	0x2001992c
    2210:	.word	0x2001398c
    2214:	.word	0x20019928

00002218 <hour()>:
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour() { // the hour now 
    2218:	push	{r3, lr}
  return hour(now()); 
    221a:	bl	2194 <now()>
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
    221e:	bl	2060 <refreshCache(long)>
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    2222:	ldr	r3, [pc, #4]	; (2228 <hour()+0x10>)
    2224:	ldrb	r0, [r3, #2]
    2226:	pop	{r3, pc}
    2228:	.word	0x2001991c

0000222c <minute()>:

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
    222c:	push	{r3, lr}
  return minute(now()); 
    222e:	bl	2194 <now()>
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
    2232:	bl	2060 <refreshCache(long)>
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    2236:	ldr	r3, [pc, #4]	; (223c <minute()+0x10>)
    2238:	ldrb	r0, [r3, #1]
    223a:	pop	{r3, pc}
    223c:	.word	0x2001991c

00002240 <second()>:
int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second() {
    2240:	push	{r3, lr}
  return second(now()); 
    2242:	bl	2194 <now()>
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
    2246:	bl	2060 <refreshCache(long)>
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    224a:	ldr	r3, [pc, #4]	; (2250 <second()+0x10>)
    224c:	ldrb	r0, [r3, #0]
    224e:	pop	{r3, pc}
    2250:	.word	0x2001991c

00002254 <day()>:
int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(){
    2254:	push	{r3, lr}
  return(day(now())); 
    2256:	bl	2194 <now()>
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
    225a:	bl	2060 <refreshCache(long)>
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    225e:	ldr	r3, [pc, #4]	; (2264 <day()+0x10>)
    2260:	ldrb	r0, [r3, #4]
    2262:	pop	{r3, pc}
    2264:	.word	0x2001991c

00002268 <month()>:
int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
    2268:	push	{r3, lr}
  return month(now()); 
    226a:	bl	2194 <now()>
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
    226e:	bl	2060 <refreshCache(long)>
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    2272:	ldr	r3, [pc, #4]	; (2278 <month()+0x10>)
    2274:	ldrb	r0, [r3, #5]
    2276:	pop	{r3, pc}
    2278:	.word	0x2001991c

0000227c <year()>:
int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
    227c:	push	{r3, lr}
  return year(now()); 
    227e:	bl	2194 <now()>
}
    2282:	ldmia.w	sp!, {r3, lr}
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    2286:	b.w	2080 <year(long)>
    228a:	Address 0x0000228a is out of bounds.


0000228c <setSyncProvider(long (*)())>:
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    228c:	ldr	r3, [pc, #12]	; (229c <setSyncProvider(long (*)())+0x10>)
    228e:	str	r0, [r3, #0]
  nextSyncTime = sysTime;
    2290:	ldr	r3, [pc, #12]	; (22a0 <setSyncProvider(long (*)())+0x14>)
    2292:	ldr	r2, [r3, #0]
    2294:	ldr	r3, [pc, #12]	; (22a4 <setSyncProvider(long (*)())+0x18>)
    2296:	str	r2, [r3, #0]
  now(); // this will sync the clock
    2298:	b.w	2194 <now()>
    229c:	.word	0x2001992c
    22a0:	.word	0x20019924
    22a4:	.word	0x20019934

000022a8 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE>:
audio_block_t * AudioOutputPWM::block_2nd = NULL;
uint32_t  AudioOutputPWM::block_offset = 0;
uint8_t AudioOutputPWM::interrupt_count = 0;

DMAMEM uint32_t pwm_dma_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputPWM::dma(false);
    22a8:	ldr	r2, [pc, #8]	; (22b4 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0xc>)
    22aa:	ldr	r1, [pc, #12]	; (22b8 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x10>)
    22ac:	ldr	r0, [pc, #12]	; (22bc <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x14>)
    22ae:	b.w	a424 <__aeabi_atexit>
    22b2:	nop
    22b4:	.word	0x20013930
    22b8:	.word	0x00000781
    22bc:	.word	0x20019938

000022c0 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
    22c0:	ldr	r2, [pc, #8]	; (22cc <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
    22c2:	ldr	r1, [pc, #12]	; (22d0 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
    22c4:	ldr	r0, [pc, #12]	; (22d4 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
    22c6:	b.w	a424 <__aeabi_atexit>
    22ca:	nop
    22cc:	.word	0x20013930
    22d0:	.word	0x00000781
    22d4:	.word	0x20019940

000022d8 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
    22d8:	ldr	r2, [pc, #8]	; (22e4 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
    22da:	ldr	r1, [pc, #12]	; (22e8 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
    22dc:	ldr	r0, [pc, #12]	; (22ec <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
    22de:	b.w	a424 <__aeabi_atexit>
    22e2:	nop
    22e4:	.word	0x20013930
    22e8:	.word	0x00000781
    22ec:	.word	0x20019948

000022f0 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE>:
bool AudioOutputADAT::update_responsibility = false;
//uint32_t  AudioOutputADAT::vucp = VUCP_VALID;

DMAMEM __attribute__((aligned(32))) static uint32_t ADAT_tx_buffer[AUDIO_BLOCK_SAMPLES * 8]; //4 KB, AUDIO_BLOCK_SAMPLES is usually 128

DMAChannel AudioOutputADAT::dma(false);
    22f0:	ldr	r2, [pc, #8]	; (22fc <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0xc>)
    22f2:	ldr	r1, [pc, #12]	; (2300 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x10>)
    22f4:	ldr	r0, [pc, #12]	; (2304 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x14>)
    22f6:	b.w	a424 <__aeabi_atexit>
    22fa:	nop
    22fc:	.word	0x20013930
    2300:	.word	0x00000781
    2304:	.word	0x20019950

00002308 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE>:
uint16_t AudioInputAnalog::block_offset = 0;
int32_t AudioInputAnalog::hpf_y1 = 0;
int32_t AudioInputAnalog::hpf_x1 = 0;

bool AudioInputAnalog::update_responsibility = false;
DMAChannel AudioInputAnalog::dma(false);
    2308:	ldr	r2, [pc, #8]	; (2314 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0xc>)
    230a:	ldr	r1, [pc, #12]	; (2318 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x10>)
    230c:	ldr	r0, [pc, #12]	; (231c <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x14>)
    230e:	b.w	a424 <__aeabi_atexit>
    2312:	nop
    2314:	.word	0x20013930
    2318:	.word	0x00000781
    231c:	.word	0x20019958

00002320 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE>:

DMAMEM __attribute__((aligned(32))) static uint16_t dac_buffer[AUDIO_BLOCK_SAMPLES*2];
audio_block_t * AudioOutputAnalog::block_left_1st = NULL;
audio_block_t * AudioOutputAnalog::block_left_2nd = NULL;
bool AudioOutputAnalog::update_responsibility = false;
DMAChannel AudioOutputAnalog::dma(false);
    2320:	ldr	r2, [pc, #8]	; (232c <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0xc>)
    2322:	ldr	r1, [pc, #12]	; (2330 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x10>)
    2324:	ldr	r0, [pc, #12]	; (2334 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x14>)
    2326:	b.w	a424 <__aeabi_atexit>
    232a:	nop
    232c:	.word	0x20013930
    2330:	.word	0x00000781
    2334:	.word	0x20019960

00002338 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE>:
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    2338:	push	{r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_left = 0;
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
    233a:	ldr	r5, [pc, #28]	; (2358 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x20>)
    233c:	ldr	r4, [pc, #28]	; (235c <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x24>)
    233e:	ldr	r0, [pc, #32]	; (2360 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x28>)
    2340:	mov	r2, r5
    2342:	mov	r1, r4
    2344:	bl	a424 <__aeabi_atexit>
DMAChannel AudioInputAnalogStereo::dma1(false);
    2348:	mov	r2, r5
    234a:	mov	r1, r4
    234c:	ldr	r0, [pc, #20]	; (2364 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x2c>)
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    234e:	ldmia.w	sp!, {r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
DMAChannel AudioInputAnalogStereo::dma1(false);
    2352:	b.w	a424 <__aeabi_atexit>
    2356:	nop
    2358:	.word	0x20013930
    235c:	.word	0x00000781
    2360:	.word	0x20019968
    2364:	.word	0x20019970

00002368 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
    2368:	ldr	r2, [pc, #8]	; (2374 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
    236a:	ldr	r1, [pc, #12]	; (2378 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
    236c:	ldr	r0, [pc, #12]	; (237c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
    236e:	b.w	a424 <__aeabi_atexit>
    2372:	nop
    2374:	.word	0x20013930
    2378:	.word	0x00000781
    237c:	.word	0x20019978

00002380 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE>:
audio_block_t * AudioOutputAnalogStereo::block_left_2nd = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_1st = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_2nd = NULL;
audio_block_t AudioOutputAnalogStereo::block_silent;
bool AudioOutputAnalogStereo::update_responsibility = false;
DMAChannel AudioOutputAnalogStereo::dma(false);
    2380:	ldr	r2, [pc, #8]	; (238c <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0xc>)
    2382:	ldr	r1, [pc, #12]	; (2390 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x10>)
    2384:	ldr	r0, [pc, #12]	; (2394 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x14>)
    2386:	b.w	a424 <__aeabi_atexit>
    238a:	nop
    238c:	.word	0x20013930
    2390:	.word	0x00000781
    2394:	.word	0x20019980

00002398 <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
    2398:	ldr	r0, [r0, #16]
    239a:	cbz	r0, 23a2 <File::write(unsigned char const*, unsigned int)+0xa>
    239c:	ldr	r3, [r0, #0]
    239e:	ldr	r3, [r3, #12]
    23a0:	bx	r3
	}
    23a2:	bx	lr

000023a4 <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
    23a4:	ldr	r0, [r0, #16]
    23a6:	cbz	r0, 23ae <File::available()+0xa>
    23a8:	ldr	r3, [r0, #0]
    23aa:	ldr	r3, [r3, #16]
    23ac:	bx	r3
	}
    23ae:	bx	lr

000023b0 <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
    23b0:	ldr	r0, [r0, #16]
    23b2:	cbz	r0, 23ba <File::peek()+0xa>
    23b4:	ldr	r3, [r0, #0]
    23b6:	ldr	r3, [r3, #20]
    23b8:	bx	r3
	}
    23ba:	mov.w	r0, #4294967295
    23be:	bx	lr

000023c0 <File::flush()>:
	void flush() {
		if (f) f->flush();
    23c0:	ldr	r0, [r0, #16]
    23c2:	cbz	r0, 23ca <File::flush()+0xa>
    23c4:	ldr	r3, [r0, #0]
    23c6:	ldr	r3, [r3, #24]
    23c8:	bx	r3
    23ca:	bx	lr

000023cc <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
    23cc:	push	{r0, r1, r2, lr}
		if (!f) return -1;
    23ce:	ldr	r0, [r0, #16]
    23d0:	cbnz	r0, 23d8 <File::read()+0xc>
    23d2:	mov.w	r0, #4294967295
    23d6:	b.n	23ec <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
    23d8:	ldr	r3, [r0, #0]
    23da:	movs	r2, #1
    23dc:	ldr	r3, [r3, #8]
    23de:	add.w	r1, sp, #7
    23e2:	blx	r3
    23e4:	cmp	r0, #0
    23e6:	beq.n	23d2 <File::read()+0x6>
		return b;
    23e8:	ldrb.w	r0, [sp, #7]
	}
    23ec:	add	sp, #12
    23ee:	ldr.w	pc, [sp], #4

000023f2 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
    23f2:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
    23f4:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
    23f6:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
    23fa:	cbz	r0, 2408 <File::write(unsigned char)+0x16>
    23fc:	ldr	r3, [r0, #0]
    23fe:	movs	r2, #1
    2400:	ldr	r3, [r3, #12]
    2402:	add.w	r1, sp, #7
    2406:	blx	r3
	}
    2408:	add	sp, #12
    240a:	ldr.w	pc, [sp], #4

0000240e <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
    240e:	push	{r0, r1, r4, lr}
    2410:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
    2412:	ldr	r0, [r0, #80]	; 0x50
    2414:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
    2416:	cbz	r0, 2424 <SDFile::getCreateTime(DateTimeFields&)+0x16>
    2418:	add.w	r2, sp, #6
    241c:	add	r1, sp, #4
    241e:	bl	5f4e <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
    2422:	b.n	2436 <SDFile::getCreateTime(DateTimeFields&)+0x28>
    2424:	ldr	r0, [r3, #84]	; 0x54
    2426:	cbnz	r0, 242c <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
    2428:	movs	r0, #0
    242a:	b.n	2470 <SDFile::getCreateTime(DateTimeFields&)+0x62>
    242c:	add.w	r2, sp, #6
    2430:	add	r1, sp, #4
    2432:	bl	3c2e <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
    2436:	cmp	r0, #0
    2438:	beq.n	2428 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
    243a:	ldrh.w	r3, [sp, #4]
    243e:	ldrh.w	r2, [sp, #6]
    2442:	cbnz	r3, 2448 <SDFile::getCreateTime(DateTimeFields&)+0x3a>
    2444:	cmp	r2, #0
    2446:	beq.n	2428 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
    2448:	and.w	r1, r2, #31
    244c:	lsls	r1, r1, #1
    244e:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
    2450:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
    2454:	asrs	r2, r2, #11
    2456:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
    2458:	and.w	r2, r3, #31
    245c:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
    245e:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
    2462:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
    2464:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
    2466:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
    246a:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
    246c:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
    246e:	strb	r3, [r4, #6]
		return true;
	}
    2470:	add	sp, #8
    2472:	pop	{r4, pc}

00002474 <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
    2474:	push	{r0, r1, r4, lr}
    2476:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
    2478:	ldr	r0, [r0, #80]	; 0x50
    247a:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
    247c:	cbz	r0, 248a <SDFile::getModifyTime(DateTimeFields&)+0x16>
    247e:	add.w	r2, sp, #6
    2482:	add	r1, sp, #4
    2484:	bl	5f6e <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
    2488:	b.n	249c <SDFile::getModifyTime(DateTimeFields&)+0x28>
    248a:	ldr	r0, [r3, #84]	; 0x54
    248c:	cbnz	r0, 2492 <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
    248e:	movs	r0, #0
    2490:	b.n	24d6 <SDFile::getModifyTime(DateTimeFields&)+0x62>
    2492:	add.w	r2, sp, #6
    2496:	add	r1, sp, #4
    2498:	bl	3c4e <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
    249c:	cmp	r0, #0
    249e:	beq.n	248e <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
    24a0:	ldrh.w	r3, [sp, #4]
    24a4:	ldrh.w	r2, [sp, #6]
    24a8:	cbnz	r3, 24ae <SDFile::getModifyTime(DateTimeFields&)+0x3a>
    24aa:	cmp	r2, #0
    24ac:	beq.n	248e <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
    24ae:	and.w	r1, r2, #31
    24b2:	lsls	r1, r1, #1
    24b4:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
    24b6:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
    24ba:	asrs	r2, r2, #11
    24bc:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
    24be:	and.w	r2, r3, #31
    24c2:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
    24c4:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
    24c8:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
    24ca:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
    24cc:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
    24d0:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
    24d2:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
    24d4:	strb	r3, [r4, #6]
		return true;
	}
    24d6:	add	sp, #8
    24d8:	pop	{r4, pc}
    24da:	Address 0x000024da is out of bounds.


000024dc <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
    24dc:	push	{r3, r4, r5, lr}
		if (!filename) {
    24de:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
    24e0:	mov	r4, r0
		if (!filename) {
    24e2:	cbnz	r5, 2514 <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
    24e4:	mov.w	r0, #256	; 0x100
    24e8:	bl	b4a4 <malloc>
    24ec:	mov	r1, r0
    24ee:	str	r0, [r4, #88]	; 0x58
			if (filename) {
    24f0:	cbz	r0, 2510 <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    24f2:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
    24f4:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
    24f6:	cbz	r0, 2502 <SDFile::name()+0x26>
    24f8:	mov.w	r2, #256	; 0x100
    24fc:	bl	583c <FatFile::getName(char*, unsigned int)>
    2500:	b.n	2514 <SDFile::name()+0x38>
    2502:	ldr	r0, [r4, #84]	; 0x54
    2504:	cbz	r0, 2514 <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
    2506:	mov.w	r2, #256	; 0x100
    250a:	bl	3ad0 <ExFatFile::getName8(char*, unsigned int)>
    250e:	b.n	2514 <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
    2510:	ldr	r3, [pc, #4]	; (2518 <SDFile::name()+0x3c>)
    2512:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
    2514:	ldr	r0, [r4, #88]	; 0x58
    2516:	pop	{r3, r4, r5, pc}
    2518:	.word	0x20019988

0000251c <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
    251c:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
    251e:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
    2520:	cbz	r4, 253e <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
    2522:	cmp	r3, #1
    2524:	it	eq
    2526:	cmpeq	r2, #0
    2528:	bcs.n	2554 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
    252a:	mov	r1, r2
    252c:	mov	r0, r4
    252e:	bl	5b7e <FatFile::seekSet(unsigned long)>
    2532:	cbz	r0, 2554 <SDFile::truncate(unsigned long long)+0x38>
    2534:	mov	r0, r4
    2536:	bl	63b8 <FatFile::truncate()>
    253a:	cbz	r0, 2554 <SDFile::truncate(unsigned long long)+0x38>
    253c:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
    253e:	ldr	r4, [r0, #84]	; 0x54
    2540:	cbz	r4, 2554 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    2542:	mov	r0, r4
    2544:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>
    2548:	cbz	r0, 2554 <SDFile::truncate(unsigned long long)+0x38>
    254a:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
    254c:	ldmia.w	sp!, {r4, r6, r7, lr}
    2550:	b.w	4edc <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
    2554:	movs	r0, #0
    2556:	pop	{r4, r6, r7, pc}

00002558 <File::dec_refcount() [clone .isra.16]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    2558:	push	{r4, lr}
    255a:	mov	r4, r0
		if (--(f->refcount) == 0) {
    255c:	ldr	r0, [r0, #0]
    255e:	ldr	r3, [r0, #4]
    2560:	subs	r3, #1
    2562:	str	r3, [r0, #4]
    2564:	cbnz	r3, 2576 <File::dec_refcount() [clone .isra.16]+0x1e>
			f->close();
    2566:	ldr	r3, [r0, #0]
    2568:	ldr	r3, [r3, #44]	; 0x2c
    256a:	blx	r3
			delete f;
    256c:	ldr	r0, [r4, #0]
    256e:	cbz	r0, 2576 <File::dec_refcount() [clone .isra.16]+0x1e>
    2570:	ldr	r3, [r0, #0]
    2572:	ldr	r3, [r3, #4]
    2574:	blx	r3
		}
		f = nullptr;
    2576:	movs	r3, #0
    2578:	str	r3, [r4, #0]
    257a:	pop	{r4, pc}

0000257c <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
    257c:	ldr	r3, [pc, #20]	; (2594 <File::~File()+0x18>)
    257e:	push	{r4, lr}
    2580:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
    2582:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
    2584:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
    2586:	cbz	r3, 258e <File::~File()+0x12>
    2588:	adds	r0, #16
    258a:	bl	2558 <File::dec_refcount() [clone .isra.16]>
	}
    258e:	mov	r0, r4
    2590:	pop	{r4, pc}
    2592:	nop
    2594:	.word	0x00012ca0

00002598 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
    2598:	push	{r4, lr}
    259a:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
    259c:	bl	257c <File::~File()>
    25a0:	mov	r0, r4
    25a2:	movs	r1, #20
    25a4:	bl	a362 <operator delete(void*, unsigned int)>
    25a8:	mov	r0, r4
    25aa:	pop	{r4, pc}

000025ac <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
    25ac:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
    25ae:	cbz	r3, 25b6 <SDFile::size()+0xa>
    25b0:	ldr	r0, [r3, #28]
    25b2:	movs	r1, #0
    25b4:	bx	lr
    25b6:	ldr	r3, [r0, #84]	; 0x54
    25b8:	cbz	r3, 25c0 <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
    25ba:	ldr	r0, [r3, #16]
    25bc:	ldr	r1, [r3, #20]
    25be:	bx	lr
    25c0:	mov	r0, r3
    25c2:	b.n	25b2 <SDFile::size()+0x6>

000025c4 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
    25c4:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
    25c6:	cbz	r3, 25ce <SDFile::position()+0xa>
    25c8:	ldr	r0, [r3, #20]
    25ca:	movs	r1, #0
    25cc:	bx	lr
    25ce:	ldr	r3, [r0, #84]	; 0x54
    25d0:	cbz	r3, 25d8 <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
    25d2:	ldmia.w	r3, {r0, r1}
    25d6:	bx	lr
    25d8:	mov	r0, r3
    25da:	b.n	25ca <SDFile::position()+0x6>

000025dc <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
    25dc:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    25de:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
    25e0:	cbz	r2, 25fc <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
    25e2:	ldrb	r3, [r2, #0]
    25e4:	and.w	r3, r3, #8
    25e8:	and.w	r0, r3, #255	; 0xff
    25ec:	cbz	r3, 262e <FsBaseFile::available() const+0x52>
    25ee:	ldr	r3, [r2, #28]
    25f0:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
    25f2:	subs	r0, r3, r0
    25f4:	bpl.n	262e <FsBaseFile::available() const+0x52>
    25f6:	mvn.w	r0, #2147483648	; 0x80000000
    25fa:	b.n	262e <FsBaseFile::available() const+0x52>
    25fc:	ldr	r0, [r0, #60]	; 0x3c
    25fe:	cbz	r0, 262e <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
    2600:	ldrb.w	r3, [r0, #49]	; 0x31
    2604:	lsls	r3, r3, #28
    2606:	bpl.n	2618 <FsBaseFile::available() const+0x3c>
    2608:	ldrd	r4, r5, [r0, #16]
    260c:	ldrd	r2, r3, [r0]
    2610:	subs	r0, r4, r2
    2612:	sbc.w	r1, r5, r3
    2616:	b.n	261c <FsBaseFile::available() const+0x40>
    2618:	movs	r0, #0
    261a:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
    261c:	movs	r3, #0
    261e:	mvn.w	r2, #2147483648	; 0x80000000
    2622:	cmp	r3, r1
    2624:	it	eq
    2626:	cmpeq	r2, r0
    2628:	bcs.n	262e <FsBaseFile::available() const+0x52>
    262a:	mov	r0, r2
    262c:	pop	{r4, r5, pc}
  }
    262e:	pop	{r4, r5, pc}

00002630 <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
    2630:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
    2632:	adds	r0, #24
    2634:	bl	25dc <FsBaseFile::available() const>
		return sdfatfile.available();
	}
    2638:	pop	{r3, pc}

0000263a <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
    263a:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
    263c:	cbz	r3, 2646 <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
    263e:	ldrb	r3, [r3, #0]
    2640:	tst.w	r3, #112	; 0x70
    2644:	b.n	2652 <FsBaseFile::isDir() const+0x18>
    2646:	ldr	r0, [r0, #60]	; 0x3c
    2648:	cbz	r0, 2658 <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
    264a:	ldrb.w	r3, [r0, #49]	; 0x31
    264e:	tst.w	r3, #80	; 0x50
    2652:	ite	ne
    2654:	movne	r0, #1
    2656:	moveq	r0, #0
  }
    2658:	bx	lr

0000265a <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
    265a:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
    265c:	adds	r0, #24
    265e:	bl	263a <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
    2662:	pop	{r3, pc}

00002664 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
    2664:	push	{r4, lr}
    2666:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
    2668:	adds	r0, #24
    266a:	bl	263a <FsBaseFile::isDir() const>
    266e:	cbz	r0, 268a <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
    2670:	ldr	r0, [r4, #80]	; 0x50
    2672:	cbz	r0, 267a <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    2674:	movs	r1, #0
    2676:	bl	5b7e <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
    267a:	ldr	r0, [r4, #84]	; 0x54
    267c:	cbz	r0, 268a <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    267e:	movs	r2, #0
    2680:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
    2682:	ldmia.w	sp!, {r4, lr}
    2686:	b.w	3ec0 <ExFatFile::seekSet(unsigned long long)>
    268a:	pop	{r4, pc}

0000268c <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    268c:	ldr	r3, [r0, #56]	; 0x38
    268e:	cbnz	r3, 269a <FsBaseFile::isOpen() const+0xe>
    2690:	ldr	r0, [r0, #60]	; 0x3c
    2692:	adds	r0, #0
    2694:	it	ne
    2696:	movne	r0, #1
    2698:	bx	lr
    269a:	movs	r0, #1
    269c:	bx	lr

0000269e <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
    269e:	push	{r3, lr}
		return sdfatfile.isOpen();
    26a0:	adds	r0, #24
    26a2:	bl	268c <FsBaseFile::isOpen() const>
	}
    26a6:	pop	{r3, pc}

000026a8 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
    26a8:	push	{r4, lr}
    26aa:	mov	r4, r0
		if (filename) {
    26ac:	ldr	r0, [r0, #88]	; 0x58
    26ae:	cbz	r0, 26b8 <SDFile::close()+0x10>
			free(filename);
    26b0:	bl	b4b4 <free>
			filename = nullptr;
    26b4:	movs	r3, #0
    26b6:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
    26b8:	adds	r4, #24
    26ba:	mov	r0, r4
    26bc:	bl	268c <FsBaseFile::isOpen() const>
    26c0:	cbz	r0, 26cc <SDFile::close()+0x24>
			sdfatfile.close();
    26c2:	mov	r0, r4
		}
	}
    26c4:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
    26c8:	b.w	7120 <FsBaseFile::close()>
    26cc:	pop	{r4, pc}
    26ce:	Address 0x000026ce is out of bounds.


000026d0 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
    26d0:	push	{r4, lr}
    26d2:	ldr	r3, [pc, #24]	; (26ec <SDFile::~SDFile()+0x1c>)
    26d4:	str	r3, [r0, #0]
    26d6:	mov	r4, r0
		close();
    26d8:	bl	26a8 <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
    26dc:	ldr	r3, [pc, #16]	; (26f0 <SDFile::~SDFile()+0x20>)
    26de:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    26e0:	add.w	r0, r4, #24
    26e4:	bl	7120 <FsBaseFile::close()>
	}
    26e8:	mov	r0, r4
    26ea:	pop	{r4, pc}
    26ec:	.word	0x00012ccc
    26f0:	.word	0x000127c4

000026f4 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
    26f4:	push	{r4, lr}
    26f6:	mov	r4, r0
		close();
	}
    26f8:	bl	26d0 <SDFile::~SDFile()>
    26fc:	mov	r0, r4
    26fe:	movs	r1, #92	; 0x5c
    2700:	bl	a362 <operator delete(void*, unsigned int)>
    2704:	mov	r0, r4
    2706:	pop	{r4, pc}

00002708 <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    2708:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
    270a:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
    270c:	cbz	r0, 2712 <FsBaseFile::peek()+0xa>
    270e:	b.w	5b1c <FatFile::peek()>
    2712:	ldr	r0, [r3, #60]	; 0x3c
    2714:	cbz	r0, 271a <FsBaseFile::peek()+0x12>
    2716:	b.w	3e94 <ExFatFile::peek()>
  }
    271a:	mov.w	r0, #4294967295
    271e:	bx	lr

00002720 <SDFile::peek()>:
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
    2720:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
    2722:	adds	r0, #24
    2724:	bl	2708 <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
    2728:	pop	{r3, pc}

0000272a <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
    272a:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
    272c:	adds	r0, #24
    272e:	bl	c54 <FsBaseFile::read(void*, unsigned int)>
	}
    2732:	pop	{r3, pc}

00002734 <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
    2734:	push	{r3, r4, r5, lr}
    2736:	mov	r1, r0
    2738:	ldr	r0, [sp, #16]
    273a:	mov	r4, r2
    273c:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
    273e:	cbnz	r0, 2746 <SDFile::seek(unsigned long long, int)+0x12>
    2740:	add.w	r0, r1, #24
    2744:	b.n	2782 <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
    2746:	cmp	r0, #1
    2748:	bne.n	2760 <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
    274a:	ldr	r3, [r1, #80]	; 0x50
    274c:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
    2750:	cbz	r3, 2756 <SDFile::seek(unsigned long long, int)+0x22>
    2752:	ldr	r2, [r3, #20]
    2754:	b.n	277c <SDFile::seek(unsigned long long, int)+0x48>
    2756:	ldr	r3, [r1, #84]	; 0x54
    2758:	cbz	r3, 277a <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
    275a:	ldrd	r2, r3, [r3]
    275e:	b.n	277e <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
    2760:	cmp	r0, #2
    2762:	bne.n	2788 <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
    2764:	ldr	r3, [r1, #80]	; 0x50
    2766:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
    276a:	cbz	r3, 2770 <SDFile::seek(unsigned long long, int)+0x3c>
    276c:	ldr	r2, [r3, #28]
    276e:	b.n	277c <SDFile::seek(unsigned long long, int)+0x48>
    2770:	ldr	r3, [r1, #84]	; 0x54
    2772:	cbz	r3, 277a <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
    2774:	ldrd	r2, r3, [r3, #16]
    2778:	b.n	277e <SDFile::seek(unsigned long long, int)+0x4a>
    277a:	movs	r2, #0
    277c:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
    277e:	adds	r2, r2, r4
    2780:	adcs	r3, r5
    2782:	bl	c8c <FsBaseFile::seekSet(unsigned long long)>
    2786:	pop	{r3, r4, r5, pc}
		return false;
    2788:	movs	r0, #0
	}
    278a:	pop	{r3, r4, r5, pc}

0000278c <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    278c:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
    278e:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
    2790:	cbz	r0, 2796 <FsBaseFile::sync()+0xa>
    2792:	b.w	5dd4 <FatFile::sync()>
    2796:	ldr	r0, [r3, #60]	; 0x3c
    2798:	cbz	r0, 279e <FsBaseFile::sync()+0x12>
    279a:	b.w	4a84 <ExFatFile::sync()>
  }
    279e:	bx	lr

000027a0 <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
    27a0:	push	{r3, lr}
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    BaseFile::sync();
    27a2:	adds	r0, #24
    27a4:	bl	278c <FsBaseFile::sync()>
    27a8:	pop	{r3, pc}

000027aa <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
    27aa:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
    27ac:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
    27b0:	ldrb.w	r4, [sp, #20]
    27b4:	ldrb.w	r5, [sp, #24]
    27b8:	ldrb.w	r6, [sp, #28]
    27bc:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
    27c0:	cmp.w	lr, #0
    27c4:	beq.n	27d8 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
    27c6:	str	r7, [sp, #32]
    27c8:	str	r6, [sp, #28]
    27ca:	str	r5, [sp, #24]
    27cc:	str	r4, [sp, #20]
    27ce:	mov	r0, lr
  }
    27d0:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
    27d4:	b.w	630a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
    27d8:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
    27da:	cbz	r0, 27ec <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
    27dc:	str	r7, [sp, #32]
    27de:	str	r6, [sp, #28]
    27e0:	str	r5, [sp, #24]
    27e2:	str	r4, [sp, #20]
  }
    27e4:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
    27e8:	b.w	4dca <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
    27ec:	pop	{r4, r5, r6, r7, pc}

000027ee <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
    27ee:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
    27f0:	ldrb	r2, [r1, #6]
    27f2:	sub.w	r3, r2, #80	; 0x50
    27f6:	lsls	r3, r3, #24
    27f8:	bmi.n	281e <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
    27fa:	ldrb	r4, [r1, #0]
    27fc:	ldrb	r3, [r1, #5]
    27fe:	str	r4, [sp, #12]
    2800:	ldrb	r4, [r1, #1]
    2802:	str	r4, [sp, #8]
    2804:	ldrb	r4, [r1, #2]
    2806:	str	r4, [sp, #4]
    2808:	ldrb	r1, [r1, #4]
    280a:	str	r1, [sp, #0]
    280c:	adds	r3, #1
    280e:	uxtb	r3, r3
    2810:	addw	r2, r2, #1900	; 0x76c
    2814:	movs	r1, #4
    2816:	adds	r0, #24
    2818:	bl	27aa <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
    281c:	b.n	2820 <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
    281e:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
    2820:	add	sp, #16
    2822:	pop	{r4, pc}

00002824 <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
    2824:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
    2826:	ldrb	r2, [r1, #6]
    2828:	sub.w	r3, r2, #80	; 0x50
    282c:	lsls	r3, r3, #24
    282e:	bmi.n	2854 <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
    2830:	ldrb	r4, [r1, #0]
    2832:	ldrb	r3, [r1, #5]
    2834:	str	r4, [sp, #12]
    2836:	ldrb	r4, [r1, #1]
    2838:	str	r4, [sp, #8]
    283a:	ldrb	r4, [r1, #2]
    283c:	str	r4, [sp, #4]
    283e:	ldrb	r1, [r1, #4]
    2840:	str	r1, [sp, #0]
    2842:	adds	r3, #1
    2844:	uxtb	r3, r3
    2846:	addw	r2, r2, #1900	; 0x76c
    284a:	movs	r1, #2
    284c:	adds	r0, #24
    284e:	bl	27aa <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
    2852:	b.n	2856 <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
    2854:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
    2856:	add	sp, #16
    2858:	pop	{r4, pc}

0000285a <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
    285a:	push	{r3, lr}
		return sdfatfile.write(buf, size);
    285c:	adds	r0, #24
    285e:	bl	cb4 <FsBaseFile::write(void const*, unsigned int)>
	}
    2862:	pop	{r3, pc}

00002864 <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
    2864:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
    2866:	movs	r5, #0
    2868:	ldr	r3, [pc, #40]	; (2894 <SDFile::SDFile(FsFile const&)+0x30>)
    286a:	str	r5, [r0, #4]
    286c:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    286e:	ldrb	r3, [r1, #4]
    2870:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    2872:	ldr	r3, [pc, #36]	; (2898 <SDFile::SDFile(FsFile const&)+0x34>)
    2874:	str	r3, [r0, #8]
    2876:	ldr	r3, [r1, #8]
    2878:	str	r3, [r0, #16]
    287a:	ldrb	r3, [r1, #12]
    287c:	strb	r3, [r0, #20]
    287e:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
    2880:	adds	r1, #16
    2882:	adds	r0, #24
    2884:	bl	70be <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    2888:	ldr	r3, [pc, #16]	; (289c <SDFile::SDFile(FsFile const&)+0x38>)
    288a:	str	r3, [r4, #8]
    288c:	str	r5, [r4, #88]	; 0x58
    288e:	mov	r0, r4
    2890:	pop	{r3, r4, r5, pc}
    2892:	nop
    2894:	.word	0x00012ccc
    2898:	.word	0x00012c7c
    289c:	.word	0x000127e8

000028a0 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
    28a0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    28a4:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
    28a6:	movs	r5, #0
    28a8:	add.w	r8, sp, #80	; 0x50
    28ac:	ldr	r3, [pc, #108]	; (291c <SDFile::openNextFile(unsigned char)+0x7c>)
    28ae:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
    28b2:	mov	r2, r5
    28b4:	adds	r1, #24
    28b6:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    28b8:	mov.w	r6, #1000	; 0x3e8
    28bc:	add	r0, sp, #16
    28be:	strb.w	r5, [sp, #4]
    28c2:	str	r6, [sp, #8]
    28c4:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    28c8:	str	r5, [sp, #72]	; 0x48
    28ca:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
    28cc:	bl	71c6 <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
    28d0:	add	r0, sp, #16
    28d2:	bl	268c <FsBaseFile::isOpen() const>
    28d6:	ldr.w	r9, [pc, #76]	; 2924 <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
    28da:	cbz	r0, 28fe <SDFile::openNextFile(unsigned char)+0x5e>
    28dc:	movs	r0, #92	; 0x5c
    28de:	bl	a35e <operator new(unsigned int)>
    28e2:	mov	r7, r0
    28e4:	mov	r1, r8
    28e6:	bl	2864 <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
    28ea:	ldr	r3, [r7, #4]
    28ec:	strb	r5, [r4, #4]
    28ee:	adds	r3, #1
    28f0:	str	r6, [r4, #8]
    28f2:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    28f4:	str.w	r9, [r4]
		f = file;
    28f8:	str	r7, [r4, #16]
		if (f) f->refcount++;
    28fa:	str	r3, [r7, #4]
    28fc:	b.n	290a <SDFile::openNextFile(unsigned char)+0x6a>
    28fe:	strb	r0, [r4, #4]
    2900:	str	r6, [r4, #8]
    2902:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
    2904:	str.w	r9, [r4]
    2908:	str	r0, [r4, #16]
    290a:	ldr	r3, [pc, #20]	; (2920 <SDFile::openNextFile(unsigned char)+0x80>)
    290c:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    290e:	add	r0, sp, #16
    2910:	bl	7120 <FsBaseFile::close()>
		return File();
	}
    2914:	mov	r0, r4
    2916:	add	sp, #84	; 0x54
    2918:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    291c:	.word	0x000127e8
    2920:	.word	0x000127c4
    2924:	.word	0x00012ca0

00002928 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
    2928:	ldr	r2, [pc, #8]	; (2934 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
    292a:	ldr	r1, [pc, #12]	; (2938 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
    292c:	ldr	r0, [pc, #12]	; (293c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
    292e:	b.w	a424 <__aeabi_atexit>
    2932:	nop
    2934:	.word	0x20013930
    2938:	.word	0x00000781
    293c:	.word	0x2001998c

00002940 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
    2940:	ldr	r2, [pc, #8]	; (294c <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0xc>)
    2942:	ldr	r1, [pc, #12]	; (2950 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x10>)
    2944:	ldr	r0, [pc, #12]	; (2954 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x14>)
    2946:	b.w	a424 <__aeabi_atexit>
    294a:	nop
    294c:	.word	0x20013930
    2950:	.word	0x00000781
    2954:	.word	0x20019994

00002958 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
    2958:	ldr	r2, [pc, #8]	; (2964 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
    295a:	ldr	r1, [pc, #12]	; (2968 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
    295c:	ldr	r0, [pc, #12]	; (296c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
    295e:	b.w	a424 <__aeabi_atexit>
    2962:	nop
    2964:	.word	0x20013930
    2968:	.word	0x00000781
    296c:	.word	0x2001999c

00002970 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
    2970:	ldr	r2, [pc, #8]	; (297c <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
    2972:	ldr	r1, [pc, #12]	; (2980 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
    2974:	ldr	r0, [pc, #12]	; (2984 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
    2976:	b.w	a424 <__aeabi_atexit>
    297a:	nop
    297c:	.word	0x20013930
    2980:	.word	0x00000781
    2984:	.word	0x200199a4

00002988 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
    2988:	ldr	r2, [pc, #8]	; (2994 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0xc>)
    298a:	ldr	r1, [pc, #12]	; (2998 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x10>)
    298c:	ldr	r0, [pc, #12]	; (299c <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x14>)
    298e:	b.w	a424 <__aeabi_atexit>
    2992:	nop
    2994:	.word	0x20013930
    2998:	.word	0x00000781
    299c:	.word	0x200199ac

000029a0 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE>:
#if defined(__IMXRT1062__) || defined(KINETISK)
DMAMEM __attribute__((aligned(32))) static uint32_t pdm_buffer[AUDIO_BLOCK_SAMPLES*4];
static uint32_t leftover[14];
audio_block_t * AudioInputPDM::block_left = NULL;
bool AudioInputPDM::update_responsibility = false;
DMAChannel AudioInputPDM::dma(false);
    29a0:	ldr	r2, [pc, #8]	; (29ac <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0xc>)
    29a2:	ldr	r1, [pc, #12]	; (29b0 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x10>)
    29a4:	ldr	r0, [pc, #12]	; (29b4 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x14>)
    29a6:	b.w	a424 <__aeabi_atexit>
    29aa:	nop
    29ac:	.word	0x20013930
    29b0:	.word	0x00000781
    29b4:	.word	0x200199b4

000029b8 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
    29b8:	ldr	r2, [pc, #8]	; (29c4 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
    29ba:	ldr	r1, [pc, #12]	; (29c8 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
    29bc:	ldr	r0, [pc, #12]	; (29cc <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
    29be:	b.w	a424 <__aeabi_atexit>
    29c2:	nop
    29c4:	.word	0x20013930
    29c8:	.word	0x00000781
    29cc:	.word	0x200199bc

000029d0 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
    29d0:	ldr	r2, [pc, #8]	; (29dc <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
    29d2:	ldr	r1, [pc, #12]	; (29e0 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
    29d4:	ldr	r0, [pc, #12]	; (29e4 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
    29d6:	b.w	a424 <__aeabi_atexit>
    29da:	nop
    29dc:	.word	0x20013930
    29e0:	.word	0x00000781
    29e4:	.word	0x200199c4

000029e8 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    29e8:	ldrb.w	r2, [r0, #161]	; 0xa1
    29ec:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    29f0:	subs	r0, r2, r0
    29f2:	bx	lr

000029f4 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    29f4:	ldrb.w	r3, [r0, #160]	; 0xa0
    29f8:	ldrb.w	r2, [r0, #161]	; 0xa1
    29fc:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    29fe:	itttt	hi
    2a00:	addhi	r2, r3, #1
    2a02:	addhi	r3, r3, r0
    2a04:	strbhi.w	r2, [r0, #160]	; 0xa0
    2a08:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2a0a:	it	ls
    2a0c:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    2a10:	bx	lr

00002a12 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2a12:	ldrb.w	r3, [r0, #160]	; 0xa0
    2a16:	ldrb.w	r2, [r0, #161]	; 0xa1
    2a1a:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    2a1c:	itte	hi
    2a1e:	addhi	r3, r3, r0
    2a20:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2a22:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    2a26:	bx	lr

00002a28 <TwoWire::flush()>:
	virtual void flush(void) {
    2a28:	bx	lr

00002a2a <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    2a2a:	ldrh.w	r3, [r0, #302]	; 0x12e
    2a2e:	cbz	r3, 2a3c <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    2a30:	ldrb.w	r3, [r0, #301]	; 0x12d
    2a34:	cmp	r3, #136	; 0x88
    2a36:	bls.n	2a40 <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    2a38:	movs	r3, #1
    2a3a:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    2a3c:	movs	r0, #0
    2a3e:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    2a40:	adds	r2, r3, #1
    2a42:	add	r3, r0
    2a44:	strb.w	r2, [r0, #301]	; 0x12d
    2a48:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    2a4c:	movs	r0, #1
    2a4e:	bx	lr

00002a50 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2a50:	push	{r3, r4, r5, lr}
    2a52:	mov	r4, r0
	if (transmitting || slave_mode) {
    2a54:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2a58:	mov	r5, r2
	if (transmitting || slave_mode) {
    2a5a:	cbz	r0, 2a86 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    2a5c:	ldrb.w	r3, [r4, #301]	; 0x12d
    2a60:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    2a64:	cmp	r5, r2
    2a66:	ittt	hi
    2a68:	movhi	r0, #1
    2a6a:	movhi	r5, r2
    2a6c:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    2a6e:	add.w	r0, r4, #163	; 0xa3
    2a72:	add	r0, r3
    2a74:	mov	r2, r5
    2a76:	bl	8b4c <memcpy>
		txBufferLength += quantity;
    2a7a:	ldrb.w	r3, [r4, #301]	; 0x12d
    2a7e:	add	r3, r5
    2a80:	strb.w	r3, [r4, #301]	; 0x12d
    2a84:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    2a86:	pop	{r3, r4, r5, pc}

00002a88 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    2a88:	push	{r3, r4, r5, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2a8a:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    2a8c:	ldrb	r5, [r2, #3]
    2a8e:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    2a90:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    2a94:	mov	r4, r0
    2a96:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    2a9a:	bne.n	2aa4 <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    2a9c:	and.w	r1, r3, #255	; 0xff
    2aa0:	cbnz	r3, 2aae <TwoWire::isr()+0x26>
    2aa2:	b.n	2afc <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    2aa4:	movs	r1, #16
    2aa6:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    2aa8:	cmp	r3, #0
    2aaa:	bne.n	2a9c <TwoWire::isr()+0x14>
    2aac:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    2aae:	and.w	r5, r5, #4
    2ab2:	and.w	r2, r5, #255	; 0xff
    2ab6:	ldr	r3, [pc, #224]	; (2b98 <TwoWire::isr()+0x110>)
    2ab8:	cbz	r5, 2af0 <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    2aba:	movs	r2, #0
    2abc:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    2abe:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    2ac2:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    2ac6:	cbz	r3, 2aca <TwoWire::isr()+0x42>
				user_onRequest();
    2ac8:	blx	r3
			}
			if (txBufferLength == 0) {
    2aca:	ldrb.w	r3, [r4, #301]	; 0x12d
    2ace:	cbnz	r3, 2ada <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    2ad0:	movs	r2, #1
    2ad2:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    2ad6:	strb.w	r3, [r4, #163]	; 0xa3
    2ada:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2adc:	movs	r2, #208	; 0xd0
    2ade:	strb	r2, [r3, #2]
    2ae0:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    2ae2:	ldrb.w	r2, [r4, #163]	; 0xa3
    2ae6:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    2ae8:	movs	r3, #1
    2aea:	strb.w	r3, [r4, #300]	; 0x12c
    2aee:	b.n	2b8e <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    2af0:	movs	r1, #1
    2af2:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    2af4:	strb.w	r2, [r4, #161]	; 0xa1
    2af8:	ldr	r3, [r4, #16]
    2afa:	b.n	2b5a <TwoWire::isr()+0xd2>
    2afc:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    2afe:	ldrb	r3, [r2, #6]
    2b00:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    2b02:	and.w	r0, r3, #96	; 0x60
    2b06:	cmp	r0, #96	; 0x60
    2b08:	bne.n	2b20 <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    2b0a:	and.w	r3, r3, #223	; 0xdf
    2b0e:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    2b10:	ldr.w	r3, [r4, #312]	; 0x138
    2b14:	cbz	r3, 2b20 <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    2b16:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    2b1a:	ldrb.w	r0, [r4, #161]	; 0xa1
    2b1e:	blx	r3
    2b20:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    2b22:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    2b24:	and.w	r2, r2, #16
    2b28:	and.w	r1, r2, #255	; 0xff
    2b2c:	cbz	r2, 2b64 <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    2b2e:	ands.w	r5, r5, #1
    2b32:	bne.n	2b5a <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    2b34:	ldrb.w	r2, [r4, #300]	; 0x12c
    2b38:	ldrb.w	r1, [r4, #301]	; 0x12d
    2b3c:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    2b3e:	itttt	hi
    2b40:	addhi	r1, r2, #1
    2b42:	addhi	r2, r2, r4
    2b44:	strbhi.w	r1, [r4, #300]	; 0x12c
    2b48:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    2b4c:	ite	hi
    2b4e:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    2b50:	strbls	r5, [r3, #4]
    2b52:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2b54:	movs	r2, #208	; 0xd0
    2b56:	strb	r2, [r3, #2]
    2b58:	b.n	2b8e <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    2b5a:	movs	r2, #192	; 0xc0
    2b5c:	strb	r2, [r3, #2]
    2b5e:	ldr	r3, [r4, #16]
			data = port().D;
    2b60:	ldrb	r3, [r3, #4]
    2b62:	b.n	2b8e <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    2b64:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    2b68:	ldrb	r2, [r3, #6]
    2b6a:	orr.w	r2, r2, #32
    2b6e:	strb	r2, [r3, #6]
    2b70:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    2b72:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    2b74:	ldrb.w	r3, [r4, #161]	; 0xa1
    2b78:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    2b7a:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    2b7c:	bhi.n	2b8e <TwoWire::isr()+0x106>
    2b7e:	ldr	r1, [pc, #24]	; (2b98 <TwoWire::isr()+0x110>)
    2b80:	ldrb	r1, [r1, #0]
    2b82:	cbz	r1, 2b8e <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    2b84:	adds	r1, r3, #1
    2b86:	add	r3, r4
    2b88:	strb.w	r1, [r4, #161]	; 0xa1
    2b8c:	strb	r2, [r3, #24]
    2b8e:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    2b90:	movs	r2, #2
    2b92:	strb	r2, [r3, #3]
    2b94:	pop	{r3, r4, r5, pc}
    2b96:	nop
    2b98:	.word	0x200199cc

00002b9c <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    2b9c:	ldr	r0, [pc, #4]	; (2ba4 <i2c0_isr+0x8>)
    2b9e:	b.w	2a88 <TwoWire::isr()>
    2ba2:	nop
    2ba4:	.word	0x20013acc

00002ba8 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    2ba8:	ldr	r0, [pc, #4]	; (2bb0 <i2c1_isr+0x8>)
    2baa:	b.w	2a88 <TwoWire::isr()>
    2bae:	nop
    2bb0:	.word	0x20013c08

00002bb4 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    2bb4:	ldr	r0, [pc, #4]	; (2bbc <i2c2_isr+0x8>)
    2bb6:	b.w	2a88 <TwoWire::isr()>
    2bba:	nop
    2bbc:	.word	0x20013990

00002bc0 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    2bc0:	bx	lr

00002bc2 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    2bc2:	push	{lr}
    2bc4:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    2bc6:	ldr.w	r1, [r0, #1156]	; 0x484
    2bca:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    2bcc:	cbz	r1, 2be4 <SDClass::exists(char const*)+0x22>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    2bce:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    2bd0:	mov	r0, sp
    2bd2:	strb.w	r3, [sp]
    2bd6:	strb.w	r3, [sp, #1]
    2bda:	strb.w	r3, [sp, #2]
    2bde:	bl	5f0c <FatFile::open(FatVolume*, char const*, int)>
    2be2:	b.n	2c00 <SDClass::exists(char const*)+0x3e>
    2be4:	ldr.w	r0, [r0, #1160]	; 0x488
    2be8:	cbz	r0, 2c00 <SDClass::exists(char const*)+0x3e>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    2bea:	strb.w	r1, [sp, #49]	; 0x31
    2bee:	strb.w	r1, [sp, #50]	; 0x32
    2bf2:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    2bf6:	mov	r3, r1
    2bf8:	mov	r1, r0
    2bfa:	mov	r0, sp
    2bfc:	bl	439a <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    2c00:	add	sp, #60	; 0x3c
    2c02:	ldr.w	pc, [sp], #4

00002c06 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    2c06:	push	{lr}
    2c08:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    2c0a:	ldr.w	r1, [r0, #1156]	; 0x484
    2c0e:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    2c10:	cbz	r1, 2c30 <SDClass::rmdir(char const*)+0x2a>
    2c12:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    2c14:	mov	r0, sp
    2c16:	strb.w	r3, [sp]
    2c1a:	strb.w	r3, [sp, #1]
    2c1e:	strb.w	r3, [sp, #2]
    2c22:	bl	5f0c <FatFile::open(FatVolume*, char const*, int)>
    2c26:	cbz	r0, 2c54 <SDClass::rmdir(char const*)+0x4e>
    2c28:	mov	r0, sp
    2c2a:	bl	5d84 <FatFile::rmdir()>
    2c2e:	b.n	2c54 <SDClass::rmdir(char const*)+0x4e>
    2c30:	ldr.w	r0, [r0, #1160]	; 0x488
    2c34:	cbz	r0, 2c54 <SDClass::rmdir(char const*)+0x4e>
    2c36:	strb.w	r1, [sp, #49]	; 0x31
    2c3a:	strb.w	r1, [sp, #50]	; 0x32
    2c3e:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    2c42:	mov	r3, r1
    2c44:	mov	r1, r0
    2c46:	mov	r0, sp
    2c48:	bl	439a <ExFatFile::open(ExFatVolume*, char const*, int)>
    2c4c:	cbz	r0, 2c54 <SDClass::rmdir(char const*)+0x4e>
    2c4e:	mov	r0, sp
    2c50:	bl	4950 <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    2c54:	add	sp, #60	; 0x3c
    2c56:	ldr.w	pc, [sp], #4

00002c5a <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    2c5a:	push	{lr}
    2c5c:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    2c5e:	ldr.w	r1, [r0, #1156]	; 0x484
    2c62:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    2c64:	cbz	r1, 2c86 <SDClass::remove(char const*)+0x2c>
    2c66:	movs	r3, #0
    2c68:	strb.w	r3, [sp]
    2c6c:	strb.w	r3, [sp, #1]
    2c70:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    2c74:	mov	r0, sp
    2c76:	movs	r3, #1
    2c78:	bl	5f0c <FatFile::open(FatVolume*, char const*, int)>
    2c7c:	cbz	r0, 2caa <SDClass::remove(char const*)+0x50>
    2c7e:	mov	r0, sp
    2c80:	bl	700c <FatFile::remove()>
    2c84:	b.n	2caa <SDClass::remove(char const*)+0x50>
    2c86:	ldr.w	r0, [r0, #1160]	; 0x488
    2c8a:	cbz	r0, 2caa <SDClass::remove(char const*)+0x50>
    2c8c:	strb.w	r1, [sp, #49]	; 0x31
    2c90:	strb.w	r1, [sp, #50]	; 0x32
    2c94:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    2c98:	movs	r3, #1
    2c9a:	mov	r1, r0
    2c9c:	mov	r0, sp
    2c9e:	bl	439a <ExFatFile::open(ExFatVolume*, char const*, int)>
    2ca2:	cbz	r0, 2caa <SDClass::remove(char const*)+0x50>
    2ca4:	mov	r0, sp
    2ca6:	bl	48ca <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    2caa:	add	sp, #60	; 0x3c
    2cac:	ldr.w	pc, [sp], #4

00002cb0 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    2cb0:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    2cb2:	ldr.w	r4, [r0, #1156]	; 0x484
    2cb6:	sub	sp, #56	; 0x38
    2cb8:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    2cba:	cbz	r4, 2cd8 <SDClass::mkdir(char const*)+0x28>
    2cbc:	movs	r3, #0
    2cbe:	strb.w	r3, [sp]
    2cc2:	strb.w	r3, [sp, #1]
    2cc6:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2cca:	add.w	r1, r4, #1096	; 0x448
    2cce:	movs	r3, #1
    2cd0:	mov	r0, sp
    2cd2:	bl	6088 <FatFile::mkdir(FatFile*, char const*, bool)>
    2cd6:	b.n	2cfa <SDClass::mkdir(char const*)+0x4a>
    2cd8:	ldr.w	r1, [r0, #1160]	; 0x488
    2cdc:	cbz	r1, 2cf8 <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2cde:	movs	r3, #1
    2ce0:	add.w	r1, r1, #1096	; 0x448
    2ce4:	mov	r0, sp
    2ce6:	strb.w	r4, [sp, #49]	; 0x31
    2cea:	strb.w	r4, [sp, #50]	; 0x32
    2cee:	strb.w	r4, [sp, #51]	; 0x33
    2cf2:	bl	4be8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    2cf6:	b.n	2cfa <SDClass::mkdir(char const*)+0x4a>
    2cf8:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    2cfa:	add	sp, #56	; 0x38
    2cfc:	pop	{r4, pc}

00002cfe <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    2cfe:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    2d00:	ldr.w	r3, [r0, #1156]	; 0x484
    2d04:	sub	sp, #60	; 0x3c
    2d06:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    2d08:	cbz	r3, 2d36 <SDClass::rename(char const*, char const*)+0x38>
    2d0a:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    2d0c:	add.w	r4, r3, #1096	; 0x448
    2d10:	strb.w	r2, [sp]
    2d14:	strb.w	r2, [sp, #1]
    2d18:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    2d1c:	mov	r3, r2
    2d1e:	mov	r0, sp
    2d20:	mov	r2, r1
    2d22:	mov	r1, r4
    2d24:	bl	5e64 <FatFile::open(FatFile*, char const*, int)>
    2d28:	cbz	r0, 2d62 <SDClass::rename(char const*, char const*)+0x64>
    2d2a:	mov	r2, r5
    2d2c:	mov	r1, r4
    2d2e:	mov	r0, sp
    2d30:	bl	6174 <FatFile::rename(FatFile*, char const*)>
    2d34:	b.n	2d62 <SDClass::rename(char const*, char const*)+0x64>
    2d36:	ldr.w	r0, [r0, #1160]	; 0x488
    2d3a:	cbz	r0, 2d62 <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    2d3c:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    2d40:	mov	r2, r1
    2d42:	mov	r0, sp
    2d44:	mov	r1, r4
    2d46:	strb.w	r3, [sp, #49]	; 0x31
    2d4a:	strb.w	r3, [sp, #50]	; 0x32
    2d4e:	strb.w	r3, [sp, #51]	; 0x33
    2d52:	bl	42e0 <ExFatFile::open(ExFatFile*, char const*, int)>
    2d56:	cbz	r0, 2d62 <SDClass::rename(char const*, char const*)+0x64>
    2d58:	mov	r2, r5
    2d5a:	mov	r1, r4
    2d5c:	mov	r0, sp
    2d5e:	bl	4d24 <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    2d62:	add	sp, #60	; 0x3c
    2d64:	pop	{r4, r5, pc}

00002d66 <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    2d66:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    2d6a:	cbz	r3, 2d7a <FsVolume::bytesPerCluster() const+0x14>
    2d6c:	ldrb	r0, [r3, #6]
    2d6e:	mov.w	r3, #512	; 0x200
    2d72:	lsl.w	r0, r3, r0
    2d76:	uxth	r0, r0
    2d78:	bx	lr
    2d7a:	ldr.w	r0, [r0, #1156]	; 0x484
    2d7e:	cbz	r0, 2d84 <FsVolume::bytesPerCluster() const+0x1e>
    2d80:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    2d84:	bx	lr

00002d86 <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    2d86:	mov	r3, r0
    2d88:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    2d8a:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    2d8e:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    2d90:	cbz	r2, 2d98 <SDClass::totalSize()+0x12>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    2d92:	ldr	r4, [r2, #28]
    2d94:	subs	r4, #1
    2d96:	b.n	2da2 <SDClass::totalSize()+0x1c>
    2d98:	ldr.w	r4, [r3, #1160]	; 0x488
    2d9c:	cbz	r4, 2da2 <SDClass::totalSize()+0x1c>
    2d9e:	ldr.w	r4, [r4, #1072]	; 0x430
    2da2:	bl	2d66 <FsVolume::bytesPerCluster() const>
	}
    2da6:	umull	r0, r1, r4, r0
    2daa:	pop	{r4, pc}

00002dac <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    2dac:	push	{r3, r4, r5, lr}
    2dae:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    2db0:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    2db2:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    2db6:	cbz	r0, 2dc2 <SDClass::usedSize()+0x16>
    2db8:	ldr	r4, [r0, #28]
    2dba:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    2dbc:	bl	6878 <FatPartition::freeClusterCount()>
    2dc0:	b.n	2dd4 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    2dc2:	ldr.w	r0, [r3, #1160]	; 0x488
    2dc6:	cbz	r0, 2dd2 <SDClass::usedSize()+0x26>
    2dc8:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    2dcc:	bl	469c <ExFatPartition::freeClusterCount()>
    2dd0:	b.n	2dd4 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    2dd2:	mov	r4, r0
    2dd4:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    2dd6:	mov	r0, r5
    2dd8:	bl	2d66 <FsVolume::bytesPerCluster() const>
	}
    2ddc:	umull	r0, r1, r4, r0
    2de0:	pop	{r3, r4, r5, pc}
    2de2:	Address 0x00002de2 is out of bounds.


00002de4 <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    2de4:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    2de6:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    2de8:	sub	sp, #80	; 0x50
    2dea:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    2dec:	beq.n	2dfa <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
    2dee:	cmp	r3, #2
    2df0:	movw	r3, #514	; 0x202
    2df4:	it	ne
    2df6:	movne	r3, #0
    2df8:	b.n	2dfe <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    2dfa:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    2dfe:	adds	r1, #4
    2e00:	mov	r0, sp
    2e02:	bl	72e0 <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
    2e06:	add	r0, sp, #16
    2e08:	bl	268c <FsBaseFile::isOpen() const>
    2e0c:	ldr	r6, [pc, #68]	; (2e54 <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
    2e0e:	cbz	r0, 2e36 <SDClass::open(char const*, unsigned char)+0x52>
    2e10:	movs	r0, #92	; 0x5c
    2e12:	bl	a35e <operator new(unsigned int)>
    2e16:	mov	r1, sp
    2e18:	mov	r5, r0
    2e1a:	bl	2864 <SDFile::SDFile(FsFile const&)>
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    2e1e:	movs	r3, #0
    2e20:	strb	r3, [r4, #4]
    2e22:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
    2e24:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    2e26:	str	r6, [r4, #0]
    2e28:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
    2e2c:	adds	r3, #1
    2e2e:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
    2e30:	str	r5, [r4, #16]
		if (f) f->refcount++;
    2e32:	str	r3, [r5, #4]
    2e34:	b.n	2e44 <SDClass::open(char const*, unsigned char)+0x60>
    2e36:	mov.w	r3, #1000	; 0x3e8
    2e3a:	strb	r0, [r4, #4]
    2e3c:	str	r3, [r4, #8]
    2e3e:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
    2e40:	str	r6, [r4, #0]
    2e42:	str	r0, [r4, #16]
    2e44:	ldr	r3, [pc, #16]	; (2e58 <SDClass::open(char const*, unsigned char)+0x74>)
    2e46:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    2e48:	add	r0, sp, #16
    2e4a:	bl	7120 <FsBaseFile::close()>
		return File();
	}
    2e4e:	mov	r0, r4
    2e50:	add	sp, #80	; 0x50
    2e52:	pop	{r4, r5, r6, pc}
    2e54:	.word	0x00012ca0
    2e58:	.word	0x000127c4

00002e5c <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    2e5c:	push	{r3, r4, r5, lr}
    2e5e:	add.w	r5, r0, #1168	; 0x490
    2e62:	mov	r4, r0
    spiConfigBackupPin = 255;
    2e64:	movs	r3, #255	; 0xff
    2e66:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    2e6a:	strb.w	r1, [r0, #1212]	; 0x4bc
    2e6e:	mov	r0, r5
    2e70:	bl	84fc <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    2e74:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    2e78:	mov	r0, r5
    2e7a:	bl	7ce8 <SdioCard::errorCode() const>
    2e7e:	cbnz	r0, 2e8e <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    2e80:	ldr.w	r1, [r4, #1164]	; 0x48c
    2e84:	mov	r0, r4
  }
    2e86:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    2e8a:	b.w	7224 <FsVolume::begin(BlockDeviceInterface*)>
  }
    2e8e:	movs	r0, #0
    2e90:	pop	{r3, r4, r5, pc}

00002e92 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    2e92:	push	{r4, r5, r6, lr}
    2e94:	sub	sp, #32
    2e96:	mov	r6, r0
    2e98:	add	r0, sp, #4
    2e9a:	stmia.w	r0, {r1, r2, r3}
    2e9e:	ldmia	r0, {r0, r1, r2}
    2ea0:	add	r5, sp, #20
    2ea2:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    2ea6:	addw	r4, r6, #1180	; 0x49c
    2eaa:	ldmia.w	r5, {r1, r2, r3}
    2eae:	mov	r0, r4
    2eb0:	bl	7658 <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    2eb4:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    2eb8:	cbz	r4, 2ec6 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    2eba:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    2ebe:	clz	r0, r0
    2ec2:	lsrs	r0, r0, #5
    2ec4:	b.n	2ec8 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    2ec6:	mov	r0, r4
  }
    2ec8:	add	sp, #32
    2eca:	pop	{r4, r5, r6, pc}

00002ecc <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    2ecc:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    2ece:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    2ed2:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    2ed4:	sub	sp, #20
    2ed6:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    2ed8:	bne.n	2ee4 <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    2eda:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    2ede:	bl	2e5c <SdBase<FsVolume>::begin(SdioConfig)>
    2ee2:	b.n	2f18 <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    2ee4:	ldr.w	r1, [r0, #1204]	; 0x4b4
    2ee8:	ldr.w	r2, [r0, #1208]	; 0x4b8
    2eec:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    2ef0:	strb.w	r3, [sp, #4]
    2ef4:	strb.w	r5, [sp, #5]
    2ef8:	str	r1, [sp, #8]
    2efa:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    2efc:	add	r3, sp, #16
    2efe:	ldmdb	r3, {r1, r2, r3}
    2f02:	bl	2e92 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    2f06:	cbz	r0, 2f18 <SdBase<FsVolume>::restart()+0x4c>
    2f08:	ldr.w	r1, [r4, #1164]	; 0x48c
    2f0c:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    2f0e:	add	sp, #20
    2f10:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    2f14:	b.w	7224 <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    2f18:	add	sp, #20
    2f1a:	pop	{r4, r5, pc}

00002f1c <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    2f1c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2f20:	ldr.w	r4, [r0, #1168]	; 0x490
    2f24:	sub	sp, #48	; 0x30
    2f26:	mov	r6, r0
    2f28:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    2f2a:	cbnz	r4, 2f30 <SDClass::format(int, char, Print&)+0x14>
    2f2c:	movs	r0, #0
    2f2e:	b.n	2f7a <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    2f30:	ldr	r3, [r4, #0]
    2f32:	mov	r0, r4
    2f34:	ldr	r3, [r3, #24]
    2f36:	blx	r3
	if (sectors <= 12288) return false; // card too small
    2f38:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    2f3c:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    2f3e:	bls.n	2f2c <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    2f40:	mov.w	r0, #512	; 0x200
    2f44:	bl	b4a4 <malloc>
	if (!buf) return false; // unable to allocate memory
    2f48:	mov	r5, r0
    2f4a:	cmp	r0, #0
    2f4c:	beq.n	2f2c <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    2f4e:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    2f52:	mov	r2, r0
    2f54:	mov	r3, r7
    2f56:	mov	r1, r4
    2f58:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    2f5a:	bls.n	2f62 <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    2f5c:	bl	362c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    2f60:	b.n	2f66 <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    2f62:	bl	55e0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    2f66:	mov	r4, r0
	}
	free(buf);
    2f68:	mov	r0, r5
    2f6a:	bl	b4b4 <free>
	if (ret) {
    2f6e:	cmp	r4, #0
    2f70:	beq.n	2f2c <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    2f72:	adds	r0, r6, #4
    2f74:	bl	2ecc <SdBase<FsVolume>::restart()>
    2f78:	movs	r0, #1
	}
	return ret;
}
    2f7a:	add	sp, #48	; 0x30
    2f7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002f80 <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    2f80:	push	{r4, r5, lr}
    2f82:	ldr.w	r4, [r0, #1168]	; 0x490
    2f86:	sub	sp, #20
    2f88:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    2f8a:	cbz	r4, 2fca <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    2f8c:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    2f90:	cbz	r3, 2fc2 <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    2f92:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    2f96:	cmp	r3, #254	; 0xfe
    2f98:	beq.n	2fa6 <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    2f9a:	ldr	r3, [r4, #0]
    2f9c:	mov	r1, sp
    2f9e:	ldr	r3, [r3, #56]	; 0x38
    2fa0:	mov	r0, r4
    2fa2:	blx	r3
    2fa4:	b.n	2fcc <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    2fa6:	ldr	r3, [r4, #0]
    2fa8:	mov	r0, r4
    2faa:	ldr	r3, [r3, #28]
    2fac:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    2fae:	ldr	r3, [r4, #0]
    2fb0:	mov	r0, r4
    2fb2:	ldr	r3, [r3, #68]	; 0x44
    2fb4:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    2fb6:	adds	r3, r0, #1
    2fb8:	beq.n	2f9a <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    2fba:	adds	r0, #0
    2fbc:	it	ne
    2fbe:	movne	r0, #1
    2fc0:	b.n	2fcc <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    2fc2:	adds	r0, #4
    2fc4:	bl	2ecc <SdBase<FsVolume>::restart()>
    2fc8:	b.n	2fcc <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    2fca:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    2fcc:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    2fd0:	add	sp, #20
    2fd2:	pop	{r4, r5, pc}

00002fd4 <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    2fd4:	ldr	r0, [pc, #72]	; (3020 <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2fd6:	ldr	r2, [pc, #76]	; (3024 <_GLOBAL__sub_I_SD+0x50>)
    2fd8:	str.w	r2, [r0, #1172]	; 0x494
    2fdc:	ldr	r2, [pc, #72]	; (3028 <_GLOBAL__sub_I_SD+0x54>)
    2fde:	ldr	r3, [pc, #76]	; (302c <_GLOBAL__sub_I_SD+0x58>)
    2fe0:	str.w	r2, [r0, #1184]	; 0x4a0
    2fe4:	movs	r2, #1
    2fe6:	str	r3, [r0, #0]
    2fe8:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    2fec:	movs	r3, #0
    2fee:	movs	r2, #41	; 0x29
    2ff0:	str.w	r3, [r0, #1156]	; 0x484
    2ff4:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2ff8:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2ffc:	strb.w	r3, [r0, #1181]	; 0x49d
    3000:	strb.w	r2, [r0, #1199]	; 0x4af
    3004:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3008:	strb.w	r3, [r0, #1216]	; 0x4c0
    300c:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    3010:	ldr	r2, [pc, #28]	; (3030 <_GLOBAL__sub_I_SD+0x5c>)
    3012:	ldr	r1, [pc, #32]	; (3034 <_GLOBAL__sub_I_SD+0x60>)
    3014:	movs	r3, #255	; 0xff
    3016:	strb.w	r3, [r0, #1221]	; 0x4c5
    301a:	b.w	a424 <__aeabi_atexit>
    301e:	nop
    3020:	.word	0x200199d0
    3024:	.word	0x0001310c
    3028:	.word	0x000130ac
    302c:	.word	0x00012dac
    3030:	.word	0x20013930
    3034:	.word	0x00002bc1

00003038 <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    3038:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    303a:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    303e:	bhi.n	304a <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    3040:	cmp	r2, #0
    3042:	beq.n	30c4 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    3044:	strb	r0, [r1, #0]
    3046:	adds	r0, r1, #1
    3048:	bx	lr
    } else if (cp < 0X800) {
    304a:	cmp.w	r0, #2048	; 0x800
    304e:	bcs.n	306c <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    3050:	cmp	r2, #1
    3052:	bls.n	30c8 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    3054:	lsrs	r3, r0, #6
    3056:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3058:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    305c:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3060:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    3064:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3068:	strb	r0, [r1, #1]
    306a:	b.n	30c4 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    306c:	cmp.w	r0, #65536	; 0x10000
    3070:	bcs.n	3096 <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    3072:	cmp	r2, #2
    3074:	bls.n	30c8 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    3076:	lsrs	r3, r0, #12
    3078:	orn	r3, r3, #31
    307c:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    307e:	ubfx	r3, r0, #6, #6
    3082:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3086:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    308a:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    308c:	orn	r3, r0, #127	; 0x7f
    3090:	strb	r3, [r1, #2]
    3092:	adds	r0, r1, #3
    3094:	bx	lr
    } else {
       if (n < 4) goto fail;
    3096:	cmp	r2, #3
    3098:	bls.n	30c8 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    309a:	lsrs	r3, r0, #18
    309c:	orn	r3, r3, #15
    30a0:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    30a2:	ubfx	r3, r0, #12, #6
    30a6:	orn	r3, r3, #127	; 0x7f
    30aa:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    30ac:	ubfx	r3, r0, #6, #6
    30b0:	orn	r3, r3, #127	; 0x7f
    30b4:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    30b6:	and.w	r3, r0, #63	; 0x3f
    30ba:	orn	r3, r3, #127	; 0x7f
    30be:	strb	r3, [r1, #3]
    30c0:	adds	r0, r1, #4
    30c2:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    30c4:	mov	r0, r2
    30c6:	bx	lr
    30c8:	movs	r0, #0
  }
    30ca:	bx	lr

000030cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    30cc:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    30ce:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    30d0:	bcs.n	3140 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    30d2:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    30d4:	lsls	r4, r3, #24
    30d6:	bmi.n	30de <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    30d8:	str	r3, [r2, #0]
      return str + 1;
    30da:	adds	r4, r0, #1
    30dc:	b.n	3146 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    30de:	and.w	r4, r3, #224	; 0xe0
    30e2:	cmp	r4, #192	; 0xc0
    30e4:	bne.n	30ee <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    30e6:	and.w	r3, r3, #31
      n = 2;
    30ea:	movs	r4, #2
    30ec:	b.n	310c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    30ee:	and.w	r4, r3, #240	; 0xf0
    30f2:	cmp	r4, #224	; 0xe0
    30f4:	bne.n	30fe <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    30f6:	and.w	r3, r3, #15
      n = 3;
    30fa:	movs	r4, #3
    30fc:	b.n	310c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    30fe:	and.w	r4, r3, #248	; 0xf8
    3102:	cmp	r4, #240	; 0xf0
    3104:	bne.n	3140 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    3106:	and.w	r3, r3, #7
      n = 4;
    310a:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    310c:	add	r4, r0
    310e:	cmp	r1, r4
    3110:	bcc.n	3140 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    3112:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    3114:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    3118:	and.w	r5, r1, #192	; 0xc0
    311c:	cmp	r5, #128	; 0x80
    311e:	bne.n	3140 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    3120:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    3124:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    3126:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    312a:	bne.n	3114 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    312c:	ldr	r1, [pc, #28]	; (314c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    312e:	sub.w	r0, r3, #128	; 0x80
    3132:	cmp	r0, r1
    3134:	bhi.n	3140 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    3136:	sub.w	r1, r3, #55296	; 0xd800
    313a:	cmp.w	r1, #2048	; 0x800
    313e:	bcs.n	3144 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    3140:	movs	r4, #0
    3142:	b.n	3146 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    3144:	str	r3, [r2, #0]
    return str + n;
  }
    3146:	mov	r0, r4
    3148:	pop	{r4, r5, pc}
    314a:	nop
    314c:	.word	0x0010ff7f

00003150 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    3150:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3154:	add	r6, sp, #48	; 0x30
    3156:	mov	r5, r0
    3158:	mov	r4, r2
    315a:	mov	sl, r3
    315c:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    3160:	str	r1, [sp, #4]
    3162:	cbnz	r1, 3168 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    3164:	movs	r0, #0
    3166:	b.n	32f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    3168:	cmp.w	sl, #0
    316c:	beq.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    316e:	ldr	r3, [r0, #0]
    3170:	movs	r1, #0
    3172:	ldr	r3, [r3, #12]
    3174:	blx	r3
    3176:	cmp	r0, #0
    3178:	beq.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    317a:	ldr	r3, [sp, #4]
    317c:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    3180:	ldrb.w	r3, [r4, #450]	; 0x1c2
    3184:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    3186:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    318a:	bne.n	320c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    318c:	ldr	r3, [r5, #0]
    318e:	mov	r2, r4
    3190:	ldr	r3, [r3, #12]
    3192:	movs	r1, #1
    3194:	mov	r0, r5
    3196:	blx	r3
    3198:	cmp	r0, #0
    319a:	beq.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    319c:	movs	r2, #8
    319e:	ldr	r1, [pc, #344]	; (32f8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    31a0:	mov	r0, r4
    31a2:	bl	bb00 <memcmp>
    31a6:	cmp	r0, #0
    31a8:	bne.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    31aa:	ldr	r3, [r4, #80]	; 0x50
    31ac:	cmp	r9, r3
    31ae:	bhi.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    31b0:	mov.w	r1, r9, asr #2
    31b4:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    31b6:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    31ba:	cbz	r7, 31be <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    31bc:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    31be:	cmp.w	r8, #0
    31c2:	beq.n	31c8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    31c4:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    31c8:	ldr	r3, [r5, #0]
    31ca:	mov	r2, r4
    31cc:	ldr	r3, [r3, #12]
    31ce:	mov	r0, r5
    31d0:	blx	r3
    31d2:	cmp	r0, #0
    31d4:	beq.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    31d6:	mov.w	r0, r9, lsl #7
    31da:	add.w	r3, r0, #32
    31de:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    31e0:	add.w	r3, r0, #40	; 0x28
    31e4:	ldr	r3, [r4, r3]
    31e6:	adds	r3, #1
    31e8:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    31ea:	cbnz	r2, 31f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    31ec:	cmp	r3, #1
    31ee:	beq.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    31f0:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    31f4:	cbz	r6, 31f8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    31f6:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    31f8:	movs	r2, #16
    31fa:	ldr	r1, [pc, #256]	; (32fc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    31fc:	add	r0, r4
    31fe:	bl	bb00 <memcmp>
    3202:	cmp	r0, #0
    3204:	ite	eq
    3206:	moveq	r0, #3
    3208:	movne	r0, #4
    320a:	b.n	32f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    320c:	cmp.w	r9, #3
    3210:	bhi.n	3252 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    3212:	add.w	r3, r4, r9, lsl #4
    3216:	ldrb.w	r2, [r3, #446]	; 0x1be
    321a:	lsls	r2, r2, #25
    321c:	bne.n	3252 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    321e:	ldrb.w	r3, [r3, #450]	; 0x1c2
    3222:	cbz	r3, 3252 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    3224:	cmp	r3, #15
    3226:	beq.n	3252 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    3228:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    322c:	add.w	r4, r4, r3, lsl #4
    3230:	ldr.w	r3, [r4, #6]
    3234:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    3238:	cbz	r6, 3240 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    323a:	ldr.w	r3, [r4, #10]
    323e:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    3240:	cbz	r7, 3246 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    3242:	movs	r3, #0
    3244:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    3246:	cmp.w	r8, #0
    324a:	beq.n	3280 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    324c:	strb.w	r9, [r8]
    3250:	b.n	3280 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    3252:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    3254:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    3256:	ldrb.w	r0, [r1, #446]	; 0x1be
    325a:	lsls	r0, r0, #25
    325c:	uxtb	r2, r3
    325e:	bne.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    3260:	ldrb.w	r0, [r1, #450]	; 0x1c2
    3264:	cmp	r0, #0
    3266:	beq.w	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    326a:	cmp	r9, r2
    326c:	bcc.w	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    3270:	cmp	r0, #15
    3272:	beq.n	3284 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    3274:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    3276:	cmp	r3, #4
    3278:	add.w	r1, r1, #16
    327c:	bne.n	3256 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    327e:	b.n	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    3280:	movs	r0, #1
    3282:	b.n	32f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    3284:	add.w	r3, r4, r3, lsl #4
    3288:	adds	r2, #1
    328a:	ldr.w	r9, [r3, #454]	; 0x1c6
    328e:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    3292:	ldr	r3, [r5, #0]
    3294:	mov	r2, r4
    3296:	ldr	r3, [r3, #12]
    3298:	mov	r1, r9
    329a:	mov	r0, r5
    329c:	blx	r3
    329e:	cmp	r0, #0
    32a0:	beq.w	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    32a4:	ldr	r3, [sp, #4]
    32a6:	cmp	r3, fp
    32a8:	beq.n	32ca <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    32aa:	ldrb.w	r2, [r4, #466]	; 0x1d2
    32ae:	ldr.w	r3, [r4, #470]	; 0x1d6
    32b2:	cmp	r2, #5
    32b4:	bne.w	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    32b8:	add.w	r2, fp, #1
    32bc:	uxtb.w	fp, r2
    32c0:	cmp	r3, #0
    32c2:	beq.w	3164 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    32c6:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    32c8:	b.n	3292 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    32ca:	ldr.w	r3, [r4, #454]	; 0x1c6
    32ce:	add	r3, r9
    32d0:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    32d4:	cbz	r6, 32dc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    32d6:	ldr.w	r3, [r4, #458]	; 0x1ca
    32da:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    32dc:	cbz	r7, 32e2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    32de:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    32e2:	cmp.w	r8, #0
    32e6:	beq.n	32ee <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    32e8:	movs	r3, #0
    32ea:	strb.w	r3, [r8]
    return EXT_VOL;
    32ee:	movs	r0, #2
  }
    32f0:	add	sp, #12
    32f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    32f6:	nop
    32f8:	.word	0x00012de4
    32fc:	.word	0x00012dd4

00003300 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3300:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    3304:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3306:	bhi.n	3316 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    3308:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    330a:	mov.w	r4, #32
  if (capacityMB <= 16) {
    330e:	bls.n	333a <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    3310:	cmp	r1, #32
    3312:	bls.n	333e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    3314:	b.n	3318 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3316:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    3318:	cmp	r1, #128	; 0x80
    331a:	bls.n	3342 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    331c:	cmp.w	r1, #504	; 0x1f8
    3320:	bls.n	3346 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    3322:	cmp.w	r1, #1008	; 0x3f0
    3326:	bls.n	334a <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    3328:	cmp.w	r1, #2016	; 0x7e0
    332c:	bls.n	334e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    332e:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    3332:	ite	ls
    3334:	movls	r3, #128	; 0x80
    3336:	movhi	r3, #255	; 0xff
    3338:	b.n	3350 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    333a:	movs	r3, #2
    333c:	b.n	3350 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    333e:	movs	r3, #4
    3340:	b.n	3350 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    3342:	movs	r3, #8
    3344:	b.n	3350 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    3346:	movs	r3, #16
    3348:	b.n	3350 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    334a:	movs	r3, #32
    334c:	b.n	3350 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    334e:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    3350:	smulbb	r3, r3, r4
    3354:	udiv	r5, r2, r3
  if (c <= 1023) {
    3358:	cmp.w	r5, #1024	; 0x400
    335c:	bcs.n	3376 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    335e:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3362:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    3366:	mls	r2, r4, r1, r2
    336a:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    336c:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    3370:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3372:	uxtb	r3, r3
    3374:	b.n	337e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    3376:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    3378:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    337a:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    337e:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    3380:	lsrs	r3, r5, #2
    3382:	bic.w	r3, r3, #63	; 0x3f
    3386:	orrs	r2, r3
    3388:	strb	r2, [r0, #1]
  chs[2] = c;
    338a:	strb	r5, [r0, #2]
    338c:	pop	{r4, r5, pc}

0000338e <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    338e:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    3390:	ldrb	r3, [r0, #0]
    3392:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3394:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    3396:	bpl.n	33d4 <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    3398:	ldr	r0, [r0, #4]
    339a:	ldr	r1, [r4, #12]
    339c:	ldr	r3, [r0, #0]
    339e:	add.w	r6, r4, #16
    33a2:	ldr	r3, [r3, #32]
    33a4:	mov	r2, r6
    33a6:	blx	r3
    33a8:	mov	r5, r0
    33aa:	cbnz	r0, 33b0 <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    33ac:	movs	r5, #0
    33ae:	b.n	33d6 <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    33b0:	ldrb	r3, [r4, #0]
    33b2:	lsls	r3, r3, #30
    33b4:	bmi.n	33c0 <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    33b6:	ldrb	r3, [r4, #0]
    33b8:	bic.w	r3, r3, #1
    33bc:	strb	r3, [r4, #0]
    33be:	b.n	33d6 <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    33c0:	adds	r0, r4, #4
    33c2:	ldmia	r0, {r0, r1, r7}
    33c4:	ldr	r3, [r0, #0]
    33c6:	mov	r2, r6
    33c8:	ldr	r3, [r3, #32]
    33ca:	add	r1, r7
    33cc:	blx	r3
    33ce:	cmp	r0, #0
    33d0:	bne.n	33b6 <FsCache::sync()+0x28>
    33d2:	b.n	33ac <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    33d4:	movs	r5, #1

 fail:
  return false;
}
    33d6:	mov	r0, r5
    33d8:	pop	{r3, r4, r5, r6, r7, pc}

000033da <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    33da:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    33dc:	push	{r4, r5, r6, lr}
    33de:	mov	r4, r0
    33e0:	mov	r6, r1
    33e2:	mov	r5, r2
  if (!m_blockDev) {
    33e4:	cbnz	r3, 33ea <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    33e6:	movs	r0, #0
    33e8:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    33ea:	ldr	r3, [r0, #12]
    33ec:	cmp	r3, r1
    33ee:	beq.n	3418 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    33f0:	bl	338e <FsCache::sync()>
    33f4:	cmp	r0, #0
    33f6:	beq.n	33e6 <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    33f8:	lsls	r3, r5, #29
    33fa:	bpl.n	3404 <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    33fc:	movs	r3, #0
    33fe:	strb	r3, [r4, #0]
    m_sector = sector;
    3400:	str	r6, [r4, #12]
    3402:	b.n	3418 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    3404:	ldr	r0, [r4, #4]
    3406:	ldr	r3, [r0, #0]
    3408:	add.w	r2, r4, #16
    340c:	ldr	r3, [r3, #12]
    340e:	mov	r1, r6
    3410:	blx	r3
    3412:	cmp	r0, #0
    3414:	bne.n	33fc <FsCache::get(unsigned long, unsigned char)+0x22>
    3416:	b.n	33e6 <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    3418:	ldrb	r3, [r4, #0]
    341a:	mov	r0, r4
    341c:	and.w	r5, r5, #3
    3420:	orrs	r5, r3
    3422:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    3426:	pop	{r4, r5, r6, pc}

00003428 <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    3428:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    342a:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    342c:	bhi.n	343c <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    342e:	sub.w	r3, r0, #97	; 0x61
    3432:	cmp	r3, #25
    3434:	ite	hi
    3436:	movhi	r3, #0
    3438:	movls	r3, #32
    343a:	b.n	347e <toUpcase(unsigned short)+0x56>
    343c:	ldr	r5, [pc, #132]	; (34c4 <toUpcase(unsigned short)+0x9c>)
    343e:	movs	r4, #53	; 0x35
    3440:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    3442:	subs	r2, r4, r3
    3444:	cmp	r2, #1
    3446:	ldr	r1, [pc, #124]	; (34c4 <toUpcase(unsigned short)+0x9c>)
    3448:	bls.n	345c <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    344a:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    344e:	ldrh.w	r1, [r5, r2, lsl #2]
    3452:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    3454:	ite	hi
    3456:	movhi	r4, r2
    3458:	movls	r3, r2
    345a:	b.n	3442 <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    345c:	uxth	r2, r3
    345e:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    3462:	cmp	r0, r3
    3464:	bcc.n	3492 <toUpcase(unsigned short)+0x6a>
    3466:	add.w	r2, r1, r2, lsl #2
    346a:	subs	r3, r0, r3
    346c:	ldrb	r1, [r2, #3]
    346e:	cmp	r3, r1
    3470:	bge.n	3492 <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    3472:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    3476:	cmp	r2, #1
    3478:	bne.n	3482 <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    347a:	and.w	r3, r3, #1
    347e:	subs	r0, r0, r3
    3480:	b.n	348e <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    3482:	cbz	r2, 3488 <toUpcase(unsigned short)+0x60>
    3484:	uxth	r2, r2
    3486:	b.n	348c <toUpcase(unsigned short)+0x64>
    3488:	movw	r2, #58272	; 0xe3a0
    348c:	add	r0, r2
    348e:	uxth	r0, r0
    3490:	pop	{r4, r5, pc}
    3492:	ldr	r5, [pc, #52]	; (34c8 <toUpcase(unsigned short)+0xa0>)
    3494:	movs	r4, #75	; 0x4b
    3496:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    3498:	subs	r2, r4, r3
    349a:	cmp	r2, #1
    349c:	ldr	r1, [pc, #40]	; (34c8 <toUpcase(unsigned short)+0xa0>)
    349e:	bls.n	34b2 <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    34a0:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    34a4:	ldrh.w	r1, [r5, r2, lsl #2]
    34a8:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    34aa:	ite	hi
    34ac:	movhi	r4, r2
    34ae:	movls	r3, r2
    34b0:	b.n	3498 <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    34b2:	uxth	r3, r3
    34b4:	ldrh.w	r2, [r1, r3, lsl #2]
    34b8:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    34ba:	itt	eq
    34bc:	addeq.w	r3, r1, r3, lsl #2
    34c0:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    34c2:	pop	{r4, r5, pc}
    34c4:	.word	0x00012f1a
    34c8:	.word	0x00012dee

000034cc <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    34cc:	push	{r0, r1, r4, lr}
    34ce:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    34d0:	ldrh	r0, [r0, #12]
    34d2:	cbz	r0, 34da <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    34d4:	movs	r3, #0
    34d6:	strh	r3, [r4, #12]
    34d8:	b.n	3510 <FsName::get16()+0x44>
  } else if (next >= end) {
    34da:	ldr	r3, [r4, #4]
    34dc:	ldr	r1, [r4, #8]
    34de:	cmp	r3, r1
    34e0:	bcs.n	3510 <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    34e2:	add	r2, sp, #4
    34e4:	mov	r0, r3
    34e6:	bl	30cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    34ea:	cbz	r0, 350c <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    34ec:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    34ee:	ldr	r0, [sp, #4]
    34f0:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    34f4:	itttt	cs
    34f6:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    34fa:	lsrcs	r0, r0, #10
    34fc:	subcs.w	r3, r3, #9216	; 0x2400
    3500:	subcs.w	r0, r0, #10304	; 0x2840
    3504:	it	cs
    3506:	strhcs	r3, [r4, #12]
    3508:	uxth	r0, r0
    350a:	b.n	3510 <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    350c:	movw	r0, #65535	; 0xffff
}
    3510:	add	sp, #8
    3512:	pop	{r4, pc}

00003514 <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    3514:	ldr	r3, [r0, #8]
    3516:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    351a:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    351c:	cbz	r3, 3538 <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    351e:	movs	r0, #0
    3520:	ldr	r2, [r1, #16]
    3522:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    3524:	adds	r3, #1
    3526:	cmp.w	r3, #512	; 0x200
    352a:	bne.n	3520 <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    352c:	ldr	r0, [r1, #12]
    352e:	ldr	r2, [r1, #16]
    3530:	ldr	r3, [r0, #0]
    3532:	ldr	r1, [r1, #0]
    3534:	ldr	r3, [r3, #32]
    3536:	bx	r3
}
    3538:	movs	r0, #1
    353a:	bx	lr

0000353c <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    353c:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    353e:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    3540:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    3544:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    3546:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    3548:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    354a:	ldr	r0, [r3, #4]
    354c:	add.w	r1, r1, r0, ror #1
    3550:	str	r1, [r3, #4]
  m_upcaseSize++;
    3552:	ldr	r1, [r3, #8]
    3554:	adds	r1, #1
    3556:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    3558:	movw	r1, #511	; 0x1ff
    355c:	cmp	r2, r1
    355e:	bne.n	3576 <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3560:	ldr	r0, [r3, #12]
    3562:	ldr	r1, [r3, #0]
    3564:	ldr	r2, [r0, #0]
    3566:	ldr	r4, [r2, #32]
    3568:	adds	r2, r1, #1
    356a:	str	r2, [r3, #0]
    356c:	ldr	r2, [r3, #16]
    356e:	mov	r3, r4
  }
  return true;
}
    3570:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3574:	bx	r3
  }
  return true;
}
    3576:	movs	r0, #1
    3578:	ldr.w	r4, [sp], #4
    357c:	bx	lr

0000357e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    357e:	push	{r3, r4, r5, lr}
    3580:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3582:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3584:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3586:	bl	353c <ExFatFormatter::writeUpcaseByte(unsigned char)>
    358a:	cbz	r0, 3598 <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    358c:	lsrs	r1, r4, #8
    358e:	mov	r0, r5
}
    3590:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3594:	b.w	353c <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    3598:	pop	{r3, r4, r5, pc}

0000359a <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    359a:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    359c:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    359e:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    35a2:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    35a4:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    35a6:	uxth	r0, r4
    35a8:	bl	3428 <toUpcase(unsigned short)>
    if (uc != ch) {
    35ac:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    35ae:	mov	r6, r0
    if (uc != ch) {
    35b0:	beq.n	35c8 <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    35b2:	mov	r1, r0
    35b4:	mov	r0, r7
    35b6:	bl	357e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    35ba:	cbz	r0, 3626 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    35bc:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    35be:	cmp.w	r5, #65536	; 0x10000
    35c2:	bcs.n	35dc <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    35c4:	mov	r4, r5
    35c6:	b.n	35a6 <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    35c8:	adds	r5, r4, #1
    35ca:	cmp.w	r5, #65536	; 0x10000
    35ce:	bcs.n	35e6 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    35d0:	uxth	r0, r5
    35d2:	bl	3428 <toUpcase(unsigned short)>
    35d6:	cmp	r5, r0
    35d8:	bne.n	35e6 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    35da:	b.n	3622 <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    35dc:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    35de:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    35e2:	b.w	3514 <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    35e6:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    35e8:	cmp.w	r4, #512	; 0x200
    35ec:	bcc.n	3608 <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    35ee:	movw	r1, #65535	; 0xffff
    35f2:	mov	r0, r7
    35f4:	bl	357e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    35f8:	cbz	r0, 3626 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    35fa:	uxth	r1, r4
    35fc:	mov	r0, r7
    35fe:	bl	357e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3602:	cmp	r0, #0
    3604:	bne.n	35be <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    3606:	b.n	3626 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3608:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    360a:	cmp	r5, r4
    360c:	bhi.n	3612 <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    360e:	mov	r5, r4
    3610:	b.n	35be <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    3612:	uxth	r1, r4
    3614:	mov	r0, r7
    3616:	bl	357e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    361a:	adds	r4, #1
    361c:	cmp	r0, #0
    361e:	bne.n	360a <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    3620:	b.n	3626 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3622:	adds	r5, #1
    3624:	b.n	35ca <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    3626:	movs	r0, #0
    3628:	pop	{r3, r4, r5, r6, r7, pc}
    362a:	Address 0x0000362a is out of bounds.


0000362c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    362c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3630:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3632:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3634:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3636:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    3638:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    363a:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    363c:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    363e:	ldr	r3, [r3, #24]
    3640:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3642:	mov	r5, r1
    3644:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3646:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3648:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    364c:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    364e:	bcs.n	3660 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    3650:	cmp	r7, #0
    3652:	beq.w	387a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3656:	ldr	r1, [pc, #584]	; (38a0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    3658:	mov	r0, r7
    365a:	bl	884 <Print::write(char const*)>
    365e:	b.n	3872 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    3660:	movs	r6, #0
    3662:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    3664:	adds	r6, #1
    3666:	uxtb	r6, r6
    3668:	cmp	r6, #32
    366a:	mov.w	r3, r3, lsl #1
    366e:	beq.n	367c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3670:	cmp	r9, r3
    3672:	bhi.n	3664 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3674:	cmp	r6, #28
    3676:	bhi.n	367c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3678:	movs	r3, #8
    367a:	b.n	3684 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    367c:	sub.w	r8, r6, #11
    3680:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3684:	cmp	r6, #26
    3686:	it	hi
    3688:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    368a:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    368c:	ittte	hi
    368e:	asrhi	r6, r6, #1
    3690:	movhi	r3, #1
    3692:	lslhi	r3, r6
    3694:	movls.w	r3, #8192	; 0x2000
    3698:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    369a:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    369c:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    369e:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    36a0:	lsls	r3, r3, #2
    36a2:	rsb	sl, r3, r9
    36a6:	str	r3, [sp, #16]
    36a8:	ldr	r3, [sp, #8]
    36aa:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    36ae:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    36b2:	movs	r1, #0
    36b4:	mov.w	r2, #512	; 0x200
    36b8:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    36ba:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    36bc:	bl	8cf4 <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    36c0:	movs	r3, #7
    36c2:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    36c6:	movs	r3, #254	; 0xfe
    36c8:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    36cc:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    36d0:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    36d2:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    36d6:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    36da:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    36de:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    36e2:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    36e6:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    36ea:	movw	r3, #43605	; 0xaa55
    36ee:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    36f2:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    36f4:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    36f8:	add	sl, r6
    36fa:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    36fe:	ldr	r3, [r3, #32]
    3700:	mov	r2, r4
    3702:	mov	r1, r8
    3704:	mov	r0, r5
    3706:	blx	r3
    3708:	cmp	r0, #0
    370a:	beq.w	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    370e:	mov.w	r2, #512	; 0x200
    3712:	mov	r1, r8
    3714:	mov	r0, r4
    3716:	bl	8cf4 <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    371a:	movs	r3, #235	; 0xeb
    371c:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    371e:	movs	r3, #118	; 0x76
    3720:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    3722:	movs	r3, #144	; 0x90
    3724:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    3726:	movs	r3, #69	; 0x45
    3728:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    372a:	movs	r3, #88	; 0x58
    372c:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    372e:	movs	r3, #70	; 0x46
    3730:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    3732:	movs	r3, #65	; 0x41
    3734:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    3736:	movs	r3, #84	; 0x54
    3738:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    373a:	movs	r3, #32
    373c:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    373e:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    3740:	strb	r3, [r4, #10]
    3742:	ldr	r3, [sp, #0]
    3744:	str	r3, [r4, #80]	; 0x50
    3746:	str	r3, [r4, #84]	; 0x54
    3748:	ldr	r3, [sp, #12]
    374a:	str	r3, [r4, #92]	; 0x5c
    374c:	movs	r3, #4
    374e:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3750:	mov.w	r3, #256	; 0x100
    3754:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    3758:	movs	r3, #9
    375a:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    375e:	ldrb.w	r3, [sp, #8]
    3762:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    3766:	movs	r3, #128	; 0x80
    3768:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    376c:	str	r6, [r4, #64]	; 0x40
    376e:	str.w	r8, [r4, #68]	; 0x44
    3772:	str.w	sl, [r4, #72]	; 0x48
    3776:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    377a:	str	r6, [r4, #88]	; 0x58
    377c:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3780:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    3784:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3788:	strb.w	r8, [r4, #112]	; 0x70
    378c:	add.w	r3, r4, #119	; 0x77
    3790:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    3794:	movs	r1, #244	; 0xf4
    3796:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    379a:	cmp	r3, r2
    379c:	bne.n	3796 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    379e:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    37a2:	mov.w	r9, #0
    37a6:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    37aa:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    37ac:	sub.w	r3, r9, #106	; 0x6a
    37b0:	cmp	r3, #1
    37b2:	bls.n	37c2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    37b4:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    37b8:	itt	ne
    37ba:	ldrbne.w	r3, [r4, r9]
    37be:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    37c2:	add.w	r9, r9, #1
    37c6:	cmp.w	r9, #512	; 0x200
    37ca:	bne.n	37ac <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    37cc:	ldr	r3, [r5, #0]
    37ce:	mov	r2, r4
    37d0:	ldr	r3, [r3, #32]
    37d2:	mov	r1, r6
    37d4:	mov	r0, r5
    37d6:	blx	r3
    37d8:	cmp	r0, #0
    37da:	beq.n	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    37dc:	ldr	r3, [r5, #0]
    37de:	mov	r2, r4
    37e0:	ldr	r3, [r3, #32]
    37e2:	add.w	r1, r6, #12
    37e6:	mov	r0, r5
    37e8:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    37ea:	cmp	r0, #0
    37ec:	beq.n	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    37ee:	mov	r2, r9
    37f0:	movs	r1, #0
    37f2:	mov	r0, r4
    37f4:	bl	8cf4 <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    37f8:	movw	r3, #43605	; 0xaa55
    37fc:	strh.w	r3, [r4, #510]	; 0x1fe
    3800:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    3802:	add.w	sl, r6, #1
    3806:	add.w	r9, r6, #9
    380a:	str	r3, [sp, #20]
    380c:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3810:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3812:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3816:	cmp	fp, r3
    3818:	add.w	r8, r2, r8, ror #1
    381c:	bne.n	3812 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    381e:	ldr	r3, [r5, #0]
    3820:	mov	r2, r4
    3822:	ldr	r3, [r3, #32]
    3824:	mov	r1, sl
    3826:	mov	r0, r5
    3828:	blx	r3
    382a:	cbz	r0, 3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    382c:	ldr	r3, [r5, #0]
    382e:	mov	r2, r4
    3830:	ldr	r3, [r3, #32]
    3832:	add.w	r1, sl, #12
    3836:	mov	r0, r5
    3838:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    383a:	cbz	r0, 3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    383c:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    3840:	cmp	sl, r9
    3842:	bne.n	3810 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3844:	mov.w	r2, #512	; 0x200
    3848:	movs	r1, #0
    384a:	mov	r0, r4
    384c:	bl	8cf4 <memset>
    3850:	add.w	sl, r6, #11
    3854:	ldr	r3, [sp, #20]
    3856:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    385a:	cmp	fp, r3
    385c:	add.w	r8, r2, r8, ror #1
    3860:	bne.n	3856 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3862:	ldr	r3, [r5, #0]
    3864:	mov	r2, r4
    3866:	ldr	r3, [r3, #32]
    3868:	mov	r1, r9
    386a:	mov	r0, r5
    386c:	blx	r3
    386e:	cbnz	r0, 3880 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    3870:	cbz	r7, 387a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3872:	ldr	r1, [pc, #48]	; (38a4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    3874:	mov	r0, r7
    3876:	bl	884 <Print::write(char const*)>
  return false;
    387a:	mov.w	sl, #0
    387e:	b.n	3a64 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3880:	ldr	r3, [r5, #0]
    3882:	mov	r2, r4
    3884:	ldr	r3, [r3, #32]
    3886:	add.w	r1, r9, #12
    388a:	mov	r0, r5
    388c:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    388e:	cmp	r0, #0
    3890:	beq.n	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3892:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    3896:	cmp	r3, sl
    3898:	beq.n	38a8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    389a:	mov	r9, r3
    389c:	b.n	3854 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    389e:	nop
    38a0:	.word	0x00012fee
    38a4:	.word	0x00013045
    38a8:	subs	r3, r4, #4
    38aa:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    38ae:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    38b2:	cmp	r2, r3
    38b4:	bne.n	38ae <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    38b6:	ldr	r3, [r5, #0]
    38b8:	mov	r2, r4
    38ba:	ldr	r3, [r3, #32]
    38bc:	mov	r1, sl
    38be:	mov	r0, r5
    38c0:	blx	r3
    38c2:	cmp	r0, #0
    38c4:	beq.n	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    38c6:	ldr	r3, [r5, #0]
    38c8:	mov	r2, r4
    38ca:	ldr	r3, [r3, #32]
    38cc:	add.w	r1, r9, #13
    38d0:	mov	r0, r5
    38d2:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    38d4:	cmp	r0, #0
    38d6:	beq.n	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    38d8:	cbz	r7, 38e2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    38da:	ldr	r1, [pc, #400]	; (3a6c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    38dc:	mov	r0, r7
    38de:	bl	884 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    38e2:	ldr	r3, [sp, #0]
    38e4:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    38e6:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    38e8:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    38ec:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    38f0:	movs	r1, #0
    38f2:	mov	r0, r4
    38f4:	bl	8cf4 <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    38f8:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    38fc:	movs	r3, #248	; 0xf8
    38fe:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3900:	mov.w	sl, r9, lsr #9
    3904:	mov	r3, r4
    3906:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    390a:	movs	r1, #255	; 0xff
    390c:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    3910:	cmp	r2, r3
    3912:	bne.n	390c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    3914:	mov.w	r9, r9, lsr #14
    3918:	mov.w	r8, #0
    391c:	udiv	r3, r8, r9
    3920:	mls	r3, r9, r3, r8
    3924:	cbnz	r3, 3930 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    3926:	cbz	r7, 3930 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    3928:	ldr	r1, [pc, #324]	; (3a70 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    392a:	mov	r0, r7
    392c:	bl	884 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    3930:	ldr	r3, [r5, #0]
    3932:	mov	r2, r4
    3934:	ldr	r3, [r3, #32]
    3936:	add.w	r1, r6, r8
    393a:	mov	r0, r5
    393c:	blx	r3
    393e:	cmp	r0, #0
    3940:	beq.n	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3942:	cmp.w	r8, #0
    3946:	bne.n	3954 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3948:	mov.w	r2, #512	; 0x200
    394c:	mov	r1, r8
    394e:	mov	r0, r4
    3950:	bl	8cf4 <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    3954:	add.w	r8, r8, #1
    3958:	cmp	sl, r8
    395a:	bne.n	391c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    395c:	cbz	r7, 3966 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    395e:	ldr	r1, [pc, #276]	; (3a74 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    3960:	mov	r0, r7
    3962:	bl	884 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    3966:	ldr	r3, [sp, #8]
    3968:	mov.w	r8, #1
    396c:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    3970:	ldr	r3, [sp, #12]
    3972:	add.w	sl, r3, #7
    3976:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    397a:	addw	fp, sl, #511	; 0x1ff
    397e:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    3982:	cmp	r8, fp
    3984:	bcc.w	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3988:	mov.w	r2, #512	; 0x200
    398c:	movs	r1, #0
    398e:	mov	r0, r4
    3990:	bl	8cf4 <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    3994:	movs	r3, #7
    3996:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3998:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    399c:	ldr	r3, [r5, #0]
    399e:	ldr	r1, [sp, #16]
    39a0:	ldr	r3, [r3, #32]
    39a2:	mov	r2, r4
    39a4:	add	r1, r9
    39a6:	mov	r0, r5
    39a8:	blx	r3
    39aa:	cmp	r0, #0
    39ac:	beq.w	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    39b0:	cmp.w	r9, #0
    39b4:	bne.n	39ba <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    39b6:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    39ba:	add.w	r9, r9, #1
    39be:	cmp	fp, r9
    39c0:	bne.n	399c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    39c2:	cbz	r7, 39cc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    39c4:	ldr	r1, [pc, #176]	; (3a78 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    39c6:	mov	r0, r7
    39c8:	bl	884 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    39cc:	ldr	r3, [sp, #0]
    39ce:	ldr	r0, [sp, #4]
    39d0:	add	r3, r6
    39d2:	add.w	r9, r3, r8
    39d6:	mov	r1, r9
    39d8:	bl	359a <ExFatFormatter::writeUpcase(unsigned long)>
    39dc:	cmp	r0, #0
    39de:	beq.w	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    39e2:	ldr	r3, [sp, #4]
    39e4:	ldr	r3, [r3, #8]
    39e6:	cmp.w	r3, r8, lsl #9
    39ea:	bhi.w	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    39ee:	cbz	r7, 39f8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    39f0:	ldr	r1, [pc, #136]	; (3a7c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    39f2:	mov	r0, r7
    39f4:	bl	884 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    39f8:	mov.w	r2, #512	; 0x200
    39fc:	movs	r1, #0
    39fe:	mov	r0, r4
    3a00:	bl	8cf4 <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    3a04:	movs	r2, #129	; 0x81
    3a06:	strb.w	r2, [r4, #32]
    3a0a:	movs	r2, #2
    3a0c:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3a0e:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3a10:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3a12:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    3a16:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3a18:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    3a1a:	ldr	r2, [r2, #4]
    3a1c:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3a1e:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3a20:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3a22:	ldr	r3, [r3, #8]
    3a24:	str.w	sl, [r4, #56]	; 0x38
    3a28:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    3a2a:	add	r9, r8
    3a2c:	str	r3, [r4, #88]	; 0x58
    3a2e:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    3a30:	ldr	r3, [r5, #0]
    3a32:	mov	r2, r4
    3a34:	ldr	r3, [r3, #32]
    3a36:	add.w	r1, r6, r9
    3a3a:	mov	r0, r5
    3a3c:	blx	r3
    3a3e:	mov	sl, r0
    3a40:	cmp	r0, #0
    3a42:	beq.w	3870 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3a46:	cbnz	r6, 3a54 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3a48:	mov.w	r2, #512	; 0x200
    3a4c:	mov	r1, r6
    3a4e:	mov	r0, r4
    3a50:	bl	8cf4 <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    3a54:	adds	r6, #1
    3a56:	cmp	r8, r6
    3a58:	bne.n	3a30 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    3a5a:	cbz	r7, 3a64 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    3a5c:	ldr	r1, [pc, #32]	; (3a80 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    3a5e:	mov	r0, r7
    3a60:	bl	884 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    3a64:	mov	r0, sl
    3a66:	add	sp, #28
    3a68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3a6c:	.word	0x00013004
    3a70:	.word	0x00012bcf
    3a74:	.word	0x00013081
    3a78:	.word	0x00013011
    3a7c:	.word	0x00013028
    3a80:	.word	0x00013037

00003a84 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    3a84:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3a88:	mov	r5, r2
    3a8a:	mov	r6, r1
    3a8c:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3a90:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3a92:	ldrh.w	r4, [r6, #2]!
    3a96:	cbnz	r3, 3aaa <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3a98:	ldr	r2, [r5, #4]
    3a9a:	ldr	r3, [r5, #8]
    3a9c:	cmp	r2, r3
    3a9e:	bne.n	3aaa <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    3aa0:	clz	r0, r4
    3aa4:	lsrs	r0, r0, #5
    3aa6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3aaa:	mov	r0, r5
    3aac:	bl	34cc <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    3ab0:	bl	3428 <toUpcase(unsigned short)>
    3ab4:	mov	r7, r0
    3ab6:	mov	r0, r4
    3ab8:	bl	3428 <toUpcase(unsigned short)>
    3abc:	cmp	r7, r0
    3abe:	bne.n	3aca <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    3ac0:	cmp	r6, r8
    3ac2:	bne.n	3a90 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    3ac4:	movs	r0, #1
    3ac6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3aca:	movs	r0, #0
    3acc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003ad0 <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3ad0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3ad4:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3ad8:	mov	sl, r0
    3ada:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3adc:	cmp	r3, #0
    3ade:	beq.n	3b70 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3ae0:	add.w	r8, r2, #4294967295
    3ae4:	mov	r5, r1
    3ae6:	movs	r7, #2
    3ae8:	movs	r4, #0
    3aea:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3aec:	ldrb.w	r3, [sl, #48]	; 0x30
    3af0:	cmp	r3, r7
    3af2:	bcc.n	3b64 <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    3af4:	movs	r2, #0
    3af6:	mov	r1, r7
    3af8:	mov	r0, sl
    3afa:	bl	3be2 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    3afe:	cbz	r0, 3b70 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3b00:	ldrb	r3, [r0, #0]
    3b02:	cmp	r3, #193	; 0xc1
    3b04:	bne.n	3b70 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3b06:	mov	r6, r0
    3b08:	add.w	fp, r0, #30
    3b0c:	mov	r3, r4
    3b0e:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    3b12:	cbz	r3, 3b32 <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    3b14:	add.w	r2, r4, #9216	; 0x2400
    3b18:	uxth	r2, r2
    3b1a:	cmp.w	r2, #1024	; 0x400
    3b1e:	bcs.n	3b70 <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    3b20:	ldr	r0, [pc, #88]	; (3b7c <ExFatFile::getName8(char*, unsigned int)+0xac>)
    3b22:	lsls	r3, r3, #10
    3b24:	ands	r0, r3
    3b26:	ubfx	r4, r4, #0, #10
    3b2a:	orrs	r4, r0
    3b2c:	add.w	r0, r4, #65536	; 0x10000
    3b30:	b.n	3b4c <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    3b32:	add.w	r3, r4, #10240	; 0x2800
    3b36:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    3b38:	cmp.w	r3, #2048	; 0x800
    3b3c:	bcc.n	3b44 <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    3b3e:	cbz	r4, 3b64 <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    3b40:	mov	r0, r4
    3b42:	b.n	3b4c <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    3b44:	cmp.w	r3, #1024	; 0x400
    3b48:	bcc.n	3b5a <ExFatFile::getName8(char*, unsigned int)+0x8a>
    3b4a:	b.n	3b70 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3b4c:	mov	r2, r8
    3b4e:	mov	r1, r5
    3b50:	bl	3038 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    3b54:	cbz	r0, 3b64 <ExFatFile::getName8(char*, unsigned int)+0x94>
    3b56:	mov	r5, r0
    3b58:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    3b5a:	cmp	fp, r6
    3b5c:	bne.n	3b0c <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3b5e:	adds	r7, #1
    3b60:	uxtb	r7, r7
    3b62:	b.n	3aec <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    3b64:	movs	r3, #0
    3b66:	strb	r3, [r5, #0]
  return str - name;
    3b68:	rsb	r0, r9, r5
    3b6c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    3b70:	movs	r0, #0
    3b72:	strb.w	r0, [r9]
  return 0;
}
    3b76:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3b7a:	nop
    3b7c:	.word	0x000ffc00

00003b80 <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    3b80:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    3b82:	ldr	r3, [r1, #0]
    3b84:	str	r3, [r1, #4]
    ls = 0;
    3b86:	movs	r4, #0
    3b88:	mov	r5, r1
    3b8a:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    3b8c:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    3b8e:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3b92:	ldrh	r3, [r5, #12]
    3b94:	cbnz	r3, 3b9e <ExFatFile::hashName(ExName_t*)+0x1e>
    3b96:	ldr	r2, [r5, #4]
    3b98:	ldr	r3, [r5, #8]
    3b9a:	cmp	r2, r3
    3b9c:	beq.n	3bd2 <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    3b9e:	mov	r0, r5
    3ba0:	bl	34cc <FsName::get16()>
    if (u == 0XFFFF) {
    3ba4:	cmp	r0, r6
    3ba6:	beq.n	3bce <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    3ba8:	bl	3428 <toUpcase(unsigned short)>
    3bac:	lsls	r3, r4, #15
    3bae:	orr.w	r4, r3, r4, lsr #1
    3bb2:	uxtab	r4, r4, r0
    3bb6:	ubfx	r3, r4, #1, #15
    3bba:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3bbe:	asrs	r4, r0, #8
    3bc0:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3bc4:	ldr	r3, [r5, #16]
    3bc6:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3bc8:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3bca:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    3bcc:	b.n	3b92 <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    3bce:	movs	r0, #0
    3bd0:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    3bd2:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    3bd4:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    3bd6:	subs	r0, #1
    3bd8:	cmp	r0, #254	; 0xfe
    3bda:	ite	hi
    3bdc:	movhi	r0, #0
    3bde:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    3be0:	pop	{r4, r5, r6, pc}

00003be2 <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3be2:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    3be4:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3be8:	mov	r5, r0
    3bea:	mov	r7, r1
    3bec:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    3bee:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3bf2:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    3bf4:	add	r4, sp, #4
    3bf6:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    3bfa:	lsls	r2, r7, #5
    3bfc:	mov	r1, r4
    3bfe:	ldr	r0, [r5, #32]
    3c00:	bl	45c0 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    3c04:	cmp	r0, #1
    3c06:	bne.n	3c14 <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    3c08:	mov	r2, r6
    3c0a:	mov	r1, r4
    3c0c:	ldr	r0, [r5, #32]
    3c0e:	bl	4522 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    3c12:	b.n	3c16 <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    3c14:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    3c16:	add	sp, #20
    3c18:	pop	{r4, r5, r6, r7, pc}

00003c1a <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    3c1a:	push	{r4, lr}
    3c1c:	mov	r4, r0
  bool rtn = sync();
    3c1e:	bl	4a84 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    3c22:	movs	r3, #0
    3c24:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    3c28:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    3c2c:	pop	{r4, pc}

00003c2e <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    3c2e:	push	{r3, r4, r5, lr}
    3c30:	mov	r5, r1
    3c32:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    3c34:	add.w	r1, r0, #36	; 0x24
    3c38:	movs	r2, #0
    3c3a:	ldr	r0, [r0, #32]
    3c3c:	bl	4522 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    3c40:	cbz	r0, 3c4c <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    3c42:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    3c44:	strh	r3, [r5, #0]
    3c46:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    3c48:	strh	r3, [r4, #0]
  return true;
    3c4a:	movs	r0, #1

 fail:
  return false;
}
    3c4c:	pop	{r3, r4, r5, pc}

00003c4e <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    3c4e:	push	{r3, r4, r5, lr}
    3c50:	mov	r5, r1
    3c52:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    3c54:	add.w	r1, r0, #36	; 0x24
    3c58:	movs	r2, #0
    3c5a:	ldr	r0, [r0, #32]
    3c5c:	bl	4522 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    3c60:	cbz	r0, 3c6c <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    3c62:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    3c64:	strh	r3, [r5, #0]
    3c66:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    3c68:	strh	r3, [r4, #0]
  return true;
    3c6a:	movs	r0, #1

 fail:
  return false;
}
    3c6c:	pop	{r3, r4, r5, pc}

00003c6e <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    3c6e:	push	{r3, r4, r5, lr}
    3c70:	mov	r5, r1
  if (isOpen()) {
    3c72:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    3c76:	mov	r4, r0
  if (isOpen()) {
    3c78:	cbnz	r1, 3c90 <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    3c7a:	movs	r2, #56	; 0x38
    3c7c:	bl	8cf4 <memset>
  m_attributes = FILE_ATTR_ROOT;
    3c80:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    3c82:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    3c84:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    3c88:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    3c8c:	str	r5, [r4, #32]
    3c8e:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    3c90:	movs	r0, #0
}
    3c92:	pop	{r3, r4, r5, pc}

00003c94 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    3c94:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    3c96:	ldrb	r4, [r1, #0]
    3c98:	cmp	r4, #32
    3c9a:	add.w	r5, r1, #1
    3c9e:	bne.n	3ca4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    3ca0:	mov	r1, r5
    3ca2:	b.n	3c96 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    3ca4:	ldr	r7, [pc, #100]	; (3d0c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    3ca6:	str	r1, [r2, #0]
  fname->end = path;
    3ca8:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    3caa:	mov	r5, r1
    3cac:	mov	r6, r1
    3cae:	ldrb.w	r4, [r5], #1
    3cb2:	cbz	r4, 3cec <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    3cb4:	cmp	r4, #47	; 0x2f
    3cb6:	beq.n	3ce0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    3cb8:	cmp	r4, #31
    3cba:	bls.n	3d06 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    3cbc:	sub.w	r1, r4, #34	; 0x22
    3cc0:	uxtb	r1, r1
    3cc2:	cmp	r1, #29
    3cc4:	bhi.n	3cce <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    3cc6:	lsr.w	r1, r7, r1
    3cca:	lsls	r1, r1, #31
    3ccc:	bmi.n	3d06 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    3cce:	and.w	r1, r4, #191	; 0xbf
    3cd2:	cmp	r1, #60	; 0x3c
    3cd4:	beq.n	3d06 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    3cd6:	cmp	r4, #92	; 0x5c
    3cd8:	bne.n	3cf6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    3cda:	b.n	3d06 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    3cdc:	cmp	r4, #47	; 0x2f
    3cde:	bne.n	3cec <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    3ce0:	mov	r6, r1
    3ce2:	ldrb.w	r4, [r1], #1
    3ce6:	cmp	r4, #32
    3ce8:	bne.n	3cdc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    3cea:	b.n	3ce0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    3cec:	str	r6, [r3, #0]
  return hashName(fname);
    3cee:	mov	r1, r2

 fail:
  return false;
}
    3cf0:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    3cf2:	b.w	3b80 <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    3cf6:	cmp	r4, #46	; 0x2e
    3cf8:	bne.n	3cfe <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    3cfa:	mov	r1, r5
    3cfc:	b.n	3caa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    3cfe:	cmp	r4, #32
    3d00:	beq.n	3cfa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    3d02:	str	r5, [r2, #8]
    3d04:	b.n	3cfa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    3d06:	movs	r0, #0
    3d08:	pop	{r4, r5, r6, r7}
    3d0a:	bx	lr
    3d0c:	.word	0x31000101

00003d10 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    3d10:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3d14:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    3d18:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    3d1a:	mov	r4, r0
    3d1c:	mov	r6, r1
    3d1e:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    3d20:	bpl.n	3e12 <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    3d22:	lsls	r0, r3, #25
    3d24:	bmi.n	3d2e <ExFatFile::read(void*, unsigned int)+0x1e>
    3d26:	ldrb.w	r3, [r4, #49]	; 0x31
    3d2a:	lsls	r1, r3, #28
    3d2c:	bpl.n	3d48 <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    3d2e:	ldrd	r0, r1, [r4]
    3d32:	ldrd	r2, r3, [r4, #16]
    3d36:	adds.w	r8, r0, r5
    3d3a:	adc.w	r9, r1, #0
    3d3e:	cmp	r3, r9
    3d40:	it	eq
    3d42:	cmpeq	r2, r8
    3d44:	bcs.n	3d48 <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    3d46:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    3d48:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    3d4a:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    3d4e:	cmp.w	r9, #0
    3d52:	beq.n	3ddc <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    3d54:	ldr	r0, [r4, #32]
    3d56:	ldrd	r2, r3, [r4]
    3d5a:	ldr.w	r1, [r0, #1080]	; 0x438
    3d5e:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    3d62:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    3d66:	cmp.w	r8, #0
    3d6a:	bne.n	3daa <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    3d6c:	orrs	r3, r2
    3d6e:	bne.n	3d80 <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    3d70:	ldrb.w	r3, [r4, #49]	; 0x31
    3d74:	lsls	r2, r3, #25
    3d76:	ite	mi
    3d78:	ldrmi.w	r3, [r0, #1076]	; 0x434
    3d7c:	ldrpl	r3, [r4, #28]
    3d7e:	b.n	3d8c <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    3d80:	ldrb.w	r3, [r4, #51]	; 0x33
    3d84:	lsls	r3, r3, #25
    3d86:	bpl.n	3d90 <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    3d88:	ldr	r3, [r4, #24]
    3d8a:	adds	r3, #1
    3d8c:	str	r3, [r4, #24]
    3d8e:	b.n	3daa <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    3d90:	mov	r2, sl
    3d92:	ldr	r1, [r4, #24]
    3d94:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    3d98:	cmp	r0, #0
    3d9a:	blt.n	3e12 <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    3d9c:	bne.n	3daa <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    3d9e:	ldrb.w	r3, [r4, #49]	; 0x31
    3da2:	tst.w	r3, #80	; 0x50
    3da6:	bne.n	3ddc <ExFatFile::read(void*, unsigned int)+0xcc>
    3da8:	b.n	3e12 <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    3daa:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    3dac:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    3dae:	ldrb.w	lr, [r7, #1093]	; 0x445
    3db2:	ldr.w	r0, [r7, #1068]	; 0x42c
    3db6:	subs	r1, #2
    3db8:	lsl.w	r1, r1, lr
    3dbc:	mov.w	r2, r8, lsr #9
    3dc0:	add	r1, r0
    3dc2:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    3dc6:	cmp.w	fp, #0
    3dca:	bne.n	3e6c <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    3dcc:	cmp.w	r9, #512	; 0x200
    3dd0:	bcc.n	3e6c <ExFatFile::read(void*, unsigned int)+0x15c>
    3dd2:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    3dd6:	cmp	r8, r1
    3dd8:	bne.n	3de4 <ExFatFile::read(void*, unsigned int)+0xd4>
    3dda:	b.n	3e6c <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    3ddc:	rsb	r0, r9, r5
    3de0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    3de4:	cmp.w	r9, #1024	; 0x400
    3de8:	bcc.n	3e40 <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    3dea:	movs	r3, #1
    3dec:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    3df0:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    3df4:	subs	r2, r3, r2
    3df6:	cmp	fp, r2
    3df8:	it	cs
    3dfa:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    3dfc:	cmp	r8, r1
    3dfe:	bhi.n	3e26 <ExFatFile::read(void*, unsigned int)+0x116>
    3e00:	add.w	r3, fp, r8
    3e04:	cmp	r1, r3
    3e06:	bcs.n	3e26 <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    3e08:	add.w	r0, r7, #528	; 0x210
    3e0c:	bl	338e <FsCache::sync()>
    3e10:	cbnz	r0, 3e26 <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    3e12:	ldrb.w	r3, [r4, #50]	; 0x32
    3e16:	orr.w	r3, r3, #2
    3e1a:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    3e1e:	mov.w	r0, #4294967295
    3e22:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    3e26:	ldr.w	r0, [r7, #532]	; 0x214
    3e2a:	ldr	r3, [r0, #0]
    3e2c:	mov	r2, r6
    3e2e:	ldr	r7, [r3, #16]
    3e30:	mov	r1, r8
    3e32:	mov	r3, fp
    3e34:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    3e36:	cmp	r0, #0
    3e38:	beq.n	3e12 <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    3e3a:	mov.w	r7, fp, lsl #9
    3e3e:	b.n	3e56 <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    3e40:	ldr.w	r0, [r7, #532]	; 0x214
    3e44:	ldr	r3, [r0, #0]
    3e46:	mov	r2, r6
    3e48:	ldr	r3, [r3, #12]
    3e4a:	mov	r1, r8
    3e4c:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    3e4e:	cmp	r0, #0
    3e50:	beq.n	3e12 <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    3e52:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    3e56:	ldrd	r2, r3, [r4]
    3e5a:	adds	r2, r2, r7
    3e5c:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    3e60:	add	r6, r7
    m_curPosition += n;
    3e62:	strd	r2, r3, [r4]
    toRead -= n;
    3e66:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    3e6a:	b.n	3d4e <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    3e6c:	movs	r2, #0
    3e6e:	mov	r1, r8
    3e70:	add.w	r0, r7, #528	; 0x210
    3e74:	bl	33da <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    3e78:	cmp	r0, #0
    3e7a:	beq.n	3e12 <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    3e7c:	rsb	r7, fp, #512	; 0x200
    3e80:	cmp	r7, r9
    3e82:	it	cs
    3e84:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    3e86:	add.w	r1, r0, fp
    3e8a:	mov	r2, r7
    3e8c:	mov	r0, r6
    3e8e:	bl	8b4c <memcpy>
    3e92:	b.n	3e56 <ExFatFile::read(void*, unsigned int)+0x146>

00003e94 <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    3e94:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    3e96:	movs	r2, #1
    3e98:	add.w	r1, sp, #7
    3e9c:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    3e9e:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    3ea2:	ldr	r5, [r0, #24]
    3ea4:	bl	3d10 <ExFatFile::read(void*, unsigned int)>
    3ea8:	cmp	r0, #1
    3eaa:	it	eq
    3eac:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    3eb0:	str	r5, [r4, #24]
    3eb2:	it	ne
    3eb4:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    3eb8:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    3ebc:	add	sp, #12
    3ebe:	pop	{r4, r5, r6, r7, pc}

00003ec0 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    3ec0:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3ec4:	ldrb.w	fp, [r0, #49]	; 0x31
    3ec8:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    3eca:	ldr	r3, [r0, #24]
    3ecc:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    3ece:	mov	r4, r0
    3ed0:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    3ed2:	cmp.w	fp, #0
    3ed6:	beq.n	3f80 <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    3ed8:	ldrd	r8, r9, [r0]
    3edc:	cmp	r9, r7
    3ede:	it	eq
    3ee0:	cmpeq	r8, r2
    3ee2:	beq.n	3f88 <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    3ee4:	orrs.w	r3, r6, r7
    3ee8:	bne.n	3ef0 <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    3eea:	movs	r3, #0
    3eec:	str	r3, [r0, #24]
    goto done;
    3eee:	b.n	3f7a <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    3ef0:	tst.w	fp, #8
    3ef4:	beq.n	3f02 <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    3ef6:	ldrd	r0, r1, [r0, #16]
    3efa:	cmp	r1, r7
    3efc:	it	eq
    3efe:	cmpeq	r0, r2
    3f00:	bcc.n	3f80 <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    3f02:	ldr	r3, [r4, #32]
    3f04:	str	r3, [sp, #0]
    3f06:	ldrb.w	sl, [r3, #1093]	; 0x445
    3f0a:	add.w	sl, sl, #9
    3f0e:	adds.w	r0, r6, #4294967295
    3f12:	uxtb.w	sl, sl
    3f16:	mov	r2, sl
    3f18:	adc.w	r1, r7, #4294967295
    3f1c:	bl	a430 <__aeabi_llsr>
  if (isContiguous()) {
    3f20:	ldrb.w	r2, [r4, #51]	; 0x33
    3f24:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    3f26:	mov	r5, r0
  if (isContiguous()) {
    3f28:	bpl.n	3f32 <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    3f2a:	ldr	r3, [r4, #28]
    3f2c:	add	r5, r3
    3f2e:	str	r5, [r4, #24]
    goto done;
    3f30:	b.n	3f7a <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    3f32:	adds.w	r0, r8, #4294967295
    3f36:	adc.w	r1, r9, #4294967295
    3f3a:	mov	r2, sl
    3f3c:	bl	a430 <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    3f40:	cmp	r5, r0
    3f42:	bcc.n	3f4a <ExFatFile::seekSet(unsigned long long)+0x8a>
    3f44:	orrs.w	r3, r8, r9
    3f48:	bne.n	3f60 <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    3f4a:	tst.w	fp, #64	; 0x40
    3f4e:	itet	ne
    3f50:	ldrne	r3, [sp, #0]
    3f52:	ldreq	r3, [r4, #28]
    3f54:	ldrne.w	r3, [r3, #1076]	; 0x434
    3f58:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    3f5a:	add.w	r8, r4, #24
    3f5e:	b.n	3f76 <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    3f60:	subs	r5, r5, r0
    3f62:	b.n	3f5a <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    3f64:	mov	r2, r8
    3f66:	ldr	r1, [r4, #24]
    3f68:	ldr	r0, [r4, #32]
    3f6a:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    3f6e:	cmp	r0, #0
    3f70:	add.w	r5, r5, #4294967295
    3f74:	ble.n	3f80 <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    3f76:	cmp	r5, #0
    3f78:	bne.n	3f64 <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    3f7a:	strd	r6, r7, [r4]
    3f7e:	b.n	3f88 <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    3f80:	ldr	r3, [sp, #4]
    3f82:	str	r3, [r4, #24]
  return false;
    3f84:	movs	r0, #0
    3f86:	b.n	3f8a <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    3f88:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    3f8a:	add	sp, #12
    3f8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003f90 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    3f90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f94:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    3f96:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    3f9a:	sub	sp, #52	; 0x34
    3f9c:	mov	r4, r0
    3f9e:	mov	r6, r1
    3fa0:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    3fa2:	cbnz	r3, 4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3fa4:	ldrb.w	r3, [r1, #49]	; 0x31
    3fa8:	tst.w	r3, #80	; 0x50
    3fac:	beq.n	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    3fae:	and.w	r3, sl, #3
    3fb2:	cmp	r3, #1
    3fb4:	beq.w	42bc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    3fb8:	cmp	r3, #2
    3fba:	bne.w	42b2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    3fbe:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    3fc0:	and.w	r9, sl, #8
    3fc4:	orr.w	r9, r9, r3

  if (fname) {
    3fc8:	cbz	r5, 400e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    3fca:	ldr	r3, [r5, #16]
    3fcc:	mov.w	r8, #15
    3fd0:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    3fd2:	movs	r2, #0
    3fd4:	udiv	r8, r3, r8
    3fd8:	mov	r0, r6
    3fda:	add.w	r8, r8, #2
    3fde:	movs	r3, #0
    3fe0:	uxtb.w	r8, r8
    3fe4:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    3fe8:	mov.w	fp, #0
    3fec:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    3fee:	movs	r2, #32
    3ff0:	add	r1, sp, #16
    3ff2:	mov	r0, r6
    3ff4:	bl	3d10 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    3ff8:	cmp	r0, #0
    3ffa:	beq.w	4176 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    3ffe:	cmp	r0, #32
    4000:	beq.n	4014 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    4002:	movs	r0, #0
    4004:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    4008:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    400c:	b.n	42d4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    400e:	mov.w	r8, #3
    4012:	b.n	3fe8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    4014:	ldrb.w	r2, [sp, #16]
    4018:	lsls	r1, r2, #24
    401a:	bmi.n	4040 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    401c:	cbnz	r7, 4028 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    401e:	ldr	r3, [r6, #0]
    4020:	subs	r3, #32
    4022:	str	r3, [sp, #4]
    4024:	ldr	r3, [r6, #24]
    4026:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    4028:	cmp	r7, r8
        freeCount++;
    402a:	itt	cc
    402c:	addcc	r7, #1
    402e:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    4030:	cbz	r2, 4038 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    4032:	mov.w	fp, #0
    4036:	b.n	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    4038:	cmp	r5, #0
    403a:	bne.w	4176 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    403e:	b.n	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    4040:	cmp.w	fp, #0
    4044:	bne.n	4096 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    4046:	cmp	r7, r8
    4048:	it	cc
    404a:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    404c:	cmp	r2, #133	; 0x85
    404e:	bne.n	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    4050:	movs	r2, #56	; 0x38
    4052:	mov	r1, fp
    4054:	mov	r0, r4
    4056:	bl	8cf4 <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    405a:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    405e:	ldrb.w	r3, [sp, #17]
    4062:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    4066:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    406a:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    406c:	it	pl
    406e:	orrpl.w	r3, r3, #8
    4072:	strb.w	r3, [r4, #49]	; 0x31
    4076:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    4078:	str	r3, [r4, #32]
    407a:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    407c:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    407e:	ldr	r3, [r6, #0]
    4080:	subs	r3, #32
    4082:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    4084:	ldrb.w	r3, [r6, #51]	; 0x33
    4088:	ubfx	r3, r3, #6, #1
    408c:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    4090:	mov.w	fp, #1
    4094:	b.n	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    4096:	cmp	r2, #192	; 0xc0
    4098:	bne.n	40f2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    409a:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    409e:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    40a2:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    40a4:	itt	mi
    40a6:	orrmi.w	r3, r9, #64	; 0x40
    40aa:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    40ae:	ldrd	r2, r3, [sp, #24]
    40b2:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    40b6:	ldr	r3, [sp, #36]	; 0x24
    40b8:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    40ba:	ldrd	r2, r3, [sp, #40]	; 0x28
    40be:	strd	r2, r3, [r4, #8]
      if (!fname) {
    40c2:	cbnz	r5, 40cc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    40c4:	tst.w	sl, #2048	; 0x800
    40c8:	bne.n	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    40ca:	b.n	411a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    40cc:	ldr	r3, [r5, #0]
    40ce:	str	r3, [r5, #4]
    ls = 0;
    40d0:	mov.w	r3, #0
    40d4:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    40d6:	ldr	r2, [r5, #16]
    40d8:	ldrb.w	r3, [sp, #19]
    40dc:	cmp	r2, r3
    40de:	bne.n	4032 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    40e0:	ldrh.w	r2, [sp, #20]
    40e4:	ldrh	r3, [r5, #20]
    40e6:	subs	r1, r2, r3
    40e8:	rsbs	fp, r1, #0
    40ec:	adc.w	fp, fp, r1
    40f0:	b.n	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    40f2:	cmp	r2, #193	; 0xc1
    40f4:	bne.n	4032 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    40f6:	mov	r2, r5
    40f8:	add	r1, sp, #16
    40fa:	mov	r0, r4
    40fc:	bl	3a84 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    4100:	cbnz	r0, 4106 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    4102:	mov	fp, r0
    4104:	b.n	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    4106:	ldrh	r2, [r5, #12]
    4108:	cmp	r2, #0
    410a:	bne.w	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    410e:	ldr	r1, [r5, #4]
    4110:	ldr	r2, [r5, #8]
    4112:	cmp	r1, r2
    4114:	bne.w	3fee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    4118:	b.n	40c4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    411a:	tst.w	sl, #17408	; 0x4400
    411e:	bne.n	4128 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    4120:	ldrb.w	r3, [r4, #51]	; 0x33
    4124:	lsls	r2, r3, #30
    4126:	bpl.n	4134 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    4128:	ldrb.w	r3, [r4, #49]	; 0x31
    412c:	tst.w	r3, #17
    4130:	bne.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    4134:	tst.w	sl, #1024	; 0x400
    4138:	beq.n	415c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    413a:	ldrb.w	r3, [r4, #51]	; 0x33
    413e:	lsls	r3, r3, #30
    4140:	bpl.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    4144:	movs	r2, #0
    4146:	movs	r3, #0
    4148:	mov	r0, r4
    414a:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>
    414e:	cmp	r0, #0
    4150:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4154:	mov	r0, r4
    4156:	bl	4edc <ExFatFile::truncate()>
    415a:	b.n	416e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    415c:	tst.w	sl, #16384	; 0x4000
    4160:	beq.w	42c0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    4164:	ldrd	r2, r3, [r4, #16]
    4168:	mov	r0, r4
    416a:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>
    416e:	cmp	r0, #0
    4170:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4174:	b.n	42c0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    4176:	tst.w	sl, #512	; 0x200
    417a:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    417e:	tst.w	r9, #2
    4182:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4186:	cmp	r5, #0
    4188:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    418c:	cmp	r7, r8
    418e:	bcs.n	41ca <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    4190:	movs	r2, #32
    4192:	add	r1, sp, #16
    4194:	mov	r0, r6
    4196:	bl	3d10 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    419a:	cbnz	r0, 41b2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    419c:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    419e:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    41a2:	bl	4ac2 <ExFatFile::addDirCluster()>
    41a6:	cmp	r0, #0
    41a8:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    41ac:	str.w	sl, [r6, #24]
      continue;
    41b0:	b.n	418c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    41b2:	cmp	r0, #32
    41b4:	bne.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    41b8:	cbnz	r7, 41c4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    41ba:	ldr	r3, [r6, #0]
    41bc:	subs	r3, #32
    41be:	str	r3, [sp, #4]
    41c0:	ldr	r3, [r6, #24]
    41c2:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    41c4:	adds	r7, #1
    41c6:	uxtb	r7, r7
    41c8:	b.n	418c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    41ca:	movs	r2, #56	; 0x38
    41cc:	movs	r1, #0
    41ce:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    41d0:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    41d4:	bl	8cf4 <memset>
    41d8:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    41da:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    41dc:	movs	r3, #8
    41de:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    41e2:	ldr	r3, [sp, #0]
    41e4:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    41e6:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    41ea:	ldr	r3, [sp, #4]
    41ec:	strb.w	r7, [r4, #44]	; 0x2c
    41f0:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    41f2:	ldr	r3, [r5, #0]
    41f4:	str	r3, [r5, #4]
    ls = 0;
    41f6:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    41f8:	add.w	sl, r8, #4294967295
    41fc:	strh	r7, [r5, #12]
    41fe:	uxtb.w	sl, sl
    4202:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    4206:	cmp	fp, r8
    4208:	bcs.n	42aa <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    420a:	movs	r2, #1
    420c:	mov	r1, fp
    420e:	mov	r0, r4
    4210:	bl	3be2 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    4214:	mov	r6, r0
    4216:	cmp	r0, #0
    4218:	beq.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    421c:	ldrsb.w	r2, [r0]
    4220:	cmp	r2, #0
    4222:	blt.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    4226:	movs	r2, #32
    4228:	movs	r1, #0
    422a:	bl	8cf4 <memset>
    if (i == 0) {
    422e:	cmp.w	fp, #0
    4232:	bne.n	4272 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    4234:	movs	r3, #133	; 0x85
    4236:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    4238:	ldr	r3, [pc, #160]	; (42dc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    423a:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    423e:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    4242:	ldr	r3, [r3, #0]
    4244:	cbz	r3, 4266 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    4246:	add.w	r2, sp, #11
    424a:	add.w	r1, sp, #14
    424e:	add	r0, sp, #12
    4250:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4252:	ldrh.w	r3, [sp, #12]
    4256:	strh	r3, [r6, #10]
    4258:	ldrh.w	r3, [sp, #14]
    425c:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    425e:	ldrb.w	r3, [sp, #11]
    4262:	strb	r3, [r6, #20]
    4264:	b.n	42a6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    4266:	movw	r3, #21537	; 0x5421
    426a:	strh	r3, [r6, #10]
    426c:	strh	r3, [r6, #14]
    426e:	strh	r3, [r6, #18]
    4270:	b.n	42a6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    4272:	cmp.w	fp, #1
    4276:	bne.n	4292 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4278:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    427c:	movs	r2, #192	; 0xc0
    427e:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    4280:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4284:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    4288:	ldr	r3, [r5, #16]
    428a:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    428c:	ldrh	r3, [r5, #20]
    428e:	strh	r3, [r6, #4]
    4290:	b.n	42a6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    4292:	movs	r3, #193	; 0xc1
    4294:	strb	r3, [r6, #0]
    4296:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    429a:	ldrh	r2, [r5, #12]
    429c:	cbnz	r2, 42c4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    429e:	ldr	r1, [r5, #4]
    42a0:	ldr	r2, [r5, #8]
    42a2:	cmp	r1, r2
    42a4:	bne.n	42c4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    42a6:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    42a8:	b.n	4202 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    42aa:	mov	r0, r4
    42ac:	bl	4a84 <ExFatFile::sync()>
    42b0:	b.n	42d4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    42b2:	cmp	r3, #0
    42b4:	bne.w	4002 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    42b8:	movs	r3, #1
    42ba:	b.n	3fc0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    42bc:	movs	r3, #2
    42be:	b.n	3fc0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    42c0:	movs	r0, #1
    42c2:	b.n	42d4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    42c4:	mov	r0, r5
    42c6:	bl	34cc <FsName::get16()>
    42ca:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    42ce:	cmp	r6, fp
    42d0:	bne.n	429a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    42d2:	b.n	42a6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    42d4:	add	sp, #52	; 0x34
    42d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    42da:	nop
    42dc:	.word	0x20019e98

000042e0 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    42e0:	push	{r4, r5, r6, r7, lr}
    42e2:	sub	sp, #92	; 0x5c
    42e4:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    42e6:	movs	r3, #0
    42e8:	strb.w	r3, [sp, #81]	; 0x51
    42ec:	strb.w	r3, [sp, #82]	; 0x52
    42f0:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    42f4:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    42f8:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    42fc:	str	r2, [sp, #4]
    42fe:	mov	r5, r0
    4300:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4302:	cbz	r3, 4308 <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    4304:	movs	r0, #0
    4306:	b.n	4396 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4308:	ldrb.w	r3, [r1, #49]	; 0x31
    430c:	tst.w	r3, #80	; 0x50
    4310:	beq.n	4304 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    4312:	ldrb	r3, [r2, #0]
    4314:	cmp	r3, #47	; 0x2f
    4316:	bne.n	433e <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    4318:	ldr	r3, [sp, #4]
    431a:	ldrb	r2, [r3, #0]
    431c:	cmp	r2, #47	; 0x2f
    431e:	bne.n	4326 <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    4320:	adds	r3, #1
    4322:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    4324:	b.n	4318 <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    4326:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    4328:	cbnz	r2, 4332 <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    432a:	mov	r0, r5
    432c:	bl	3c6e <ExFatFile::openRoot(ExFatVolume*)>
    4330:	b.n	4396 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    4332:	add	r0, sp, #32
    4334:	bl	3c6e <ExFatFile::openRoot(ExFatVolume*)>
    4338:	cmp	r0, #0
    433a:	beq.n	4304 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    433c:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    433e:	add	r3, sp, #4
    4340:	add	r2, sp, #8
    4342:	ldr	r1, [sp, #4]
    4344:	mov	r0, r5
    4346:	bl	3c94 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    434a:	cmp	r0, #0
    434c:	beq.n	4304 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    434e:	ldr	r3, [sp, #4]
    4350:	ldrb	r3, [r3, #0]
    4352:	cbz	r3, 438a <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    4354:	movs	r3, #0
    4356:	add	r2, sp, #8
    4358:	mov	r1, r4
    435a:	mov	r0, r5
    435c:	bl	3f90 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    4360:	cmp	r0, #0
    4362:	beq.n	4304 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    4364:	add	r2, sp, #32
    4366:	mov	r3, r5
    4368:	add.w	lr, r5, #48	; 0x30
    436c:	mov	r4, r2
    436e:	ldr	r0, [r3, #0]
    4370:	ldr	r1, [r3, #4]
    4372:	mov	r6, r2
    4374:	stmia	r6!, {r0, r1}
    4376:	adds	r3, #8
    4378:	cmp	r3, lr
    437a:	mov	r2, r6
    437c:	bne.n	436e <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    437e:	ldr	r0, [r3, #0]
    4380:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    4382:	mov	r0, r5
    4384:	bl	3c1a <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    4388:	b.n	433e <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    438a:	mov	r3, r7
    438c:	add	r2, sp, #8
    438e:	mov	r1, r4
    4390:	mov	r0, r5
    4392:	bl	3f90 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4396:	add	sp, #92	; 0x5c
    4398:	pop	{r4, r5, r6, r7, pc}

0000439a <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    439a:	cbz	r1, 43a4 <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    439c:	add.w	r1, r1, #1096	; 0x448
    43a0:	b.w	42e0 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    43a4:	mov	r0, r1
    43a6:	bx	lr

000043a8 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    43a8:	push	{r4, r5}
    43aa:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    43ac:	ldrb.w	r2, [r0, #49]	; 0x31
    43b0:	cbnz	r2, 43d0 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    43b2:	ldrb.w	r5, [r1, #49]	; 0x31
    43b6:	tst.w	r5, #80	; 0x50
    43ba:	beq.n	43d0 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    43bc:	ldrd	r4, r5, [r1]
    43c0:	movs	r5, #0
    43c2:	and.w	r4, r4, #31
    43c6:	orrs	r4, r5
    43c8:	bne.n	43d0 <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    43ca:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    43cc:	b.w	3f90 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    43d0:	movs	r0, #0
    43d2:	pop	{r4, r5}
    43d4:	bx	lr

000043d6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    43d6:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43da:	mov	r8, r0
    43dc:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    43de:	mov	r9, r1
    43e0:	cbz	r1, 43e6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    43e2:	subs	r4, r1, #2
    43e4:	b.n	43ea <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    43e6:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    43ea:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    43ee:	cmp	r4, r3
    43f0:	it	cs
    43f2:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    43f4:	and.w	r7, r4, #7
    43f8:	movs	r3, #1
    43fa:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    43fe:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    4402:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    4404:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    4406:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    4408:	ldr.w	r1, [r8, #1068]	; 0x42c
    440c:	movs	r2, #0
    440e:	add.w	r1, r1, r5, lsr #12
    4412:	mov	r0, r8
    4414:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    4418:	cbz	r0, 4478 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    441a:	mov	r3, r7
    441c:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    441e:	ldrb	r7, [r0, r1]
    4420:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    4422:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    4426:	bne.n	4444 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    4428:	subs	r2, r5, r6
    442a:	cmp	r2, sl
    442c:	bne.n	4446 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    442e:	cmp.w	r9, #0
    4432:	bne.n	443e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    4434:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    4438:	it	eq
    443a:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    443e:	adds	r0, r6, #2
    4440:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    4444:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    4446:	cmp	r4, r5
    4448:	beq.n	4476 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    444a:	ldr.w	r2, [r8, #1072]	; 0x430
    444e:	cmp	r5, r2
    4450:	bcs.n	445c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    4452:	lsls	r3, r3, #1
    4454:	ands.w	r3, r3, #255	; 0xff
    4458:	bne.n	4420 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    445a:	b.n	4464 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    445c:	movs	r6, #0
          i = sectorSize;
    445e:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    4462:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4464:	adds	r1, #1
    4466:	movs	r3, #1
    4468:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    446c:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    4470:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4472:	bcc.n	441e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    4474:	b.n	4408 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    4476:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    4478:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000447c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    447c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4480:	mov	r7, r2
    4482:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    4484:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4486:	ldr.w	r0, [r0, #1072]	; 0x430
    448a:	adds	r1, r2, r7
    448c:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    448e:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4490:	bhi.n	4516 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    4492:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    4496:	cmp.w	r8, #0
    449a:	beq.n	44b0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    449c:	cmp	r2, r3
    449e:	bhi.n	44b8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    44a0:	cmp	r1, r3
    44a2:	bls.n	44b8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    44a4:	cmp	r1, r0
    44a6:	it	cs
    44a8:	movcs	r1, #0
    44aa:	str.w	r1, [r6, #1056]	; 0x420
    44ae:	b.n	44b8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    44b0:	cmp	r2, r3
      m_bitmapStart = start;
    44b2:	it	cc
    44b4:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    44b8:	and.w	r5, r2, #7
    44bc:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    44be:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    44c2:	lsl.w	r5, r3, r5
    44c6:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    44c8:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    44cc:	ubfx	r4, r2, #3, #9
    44d0:	movs	r2, #1
    44d2:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    44d4:	add.w	r9, r1, #1
    44d8:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    44dc:	cbz	r0, 4516 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    44de:	adds	r3, r0, r4
    44e0:	mov	r2, r5
    44e2:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    44e6:	ldrb	r1, [r3, #0]
    44e8:	tst	r1, r2
    44ea:	ite	ne
    44ec:	movne	r4, #1
    44ee:	moveq	r4, #0
    44f0:	cmp	r4, r8
    44f2:	beq.n	4516 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    44f4:	eors	r1, r2
        if (--count == 0) {
    44f6:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    44f8:	strb	r1, [r3, #0]
        if (--count == 0) {
    44fa:	beq.n	451c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    44fc:	lsls	r2, r2, #1
    44fe:	ands.w	r2, r2, #255	; 0xff
    4502:	bne.n	44e6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    4504:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    4506:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4508:	cmp	r0, r3
    450a:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    450e:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    4510:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4512:	bne.n	44e6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    4514:	b.n	44d0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    4516:	movs	r0, #0
    4518:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    451c:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    451e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00004522 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    4522:	push	{r3, r4, r5, lr}
    4524:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    4526:	ldr.w	r1, [r0, #1080]	; 0x438
    452a:	ldr	r3, [r5, #4]
    452c:	ands	r1, r3
    452e:	ldr	r3, [r5, #0]
    4530:	subs	r4, r3, #2
    4532:	ldrb.w	r3, [r0, #1093]	; 0x445
    4536:	lsl.w	r3, r4, r3
    453a:	add.w	r3, r3, r1, lsr #9
    453e:	ldr.w	r1, [r0, #1068]	; 0x42c
    4542:	add.w	r0, r0, #528	; 0x210
    4546:	add	r1, r3
    4548:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    454c:	cbz	r0, 4556 <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    454e:	ldr	r3, [r5, #4]
    4550:	ubfx	r3, r3, #0, #9
    4554:	add	r0, r3
}
    4556:	pop	{r3, r4, r5, pc}

00004558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    4558:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    455a:	ldr.w	r3, [r0, #1072]	; 0x430
    455e:	adds	r3, #1
    4560:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    4562:	mov	r4, r1
    4564:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4566:	bcs.n	456e <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    4568:	mov.w	r0, #4294967295
    456c:	pop	{r3, r4, r5, pc}
    456e:	ldr.w	r1, [r0, #1060]	; 0x424
    4572:	movs	r2, #0
    4574:	add.w	r1, r1, r4, lsr #7
    4578:	add.w	r0, r0, #528	; 0x210
    457c:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4580:	cmp	r0, #0
    4582:	beq.n	4568 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4584:	lsls	r4, r4, #2
    4586:	ubfx	r4, r4, #0, #9
    458a:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    458c:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    458e:	adds	r0, #1
    4590:	it	ne
    4592:	movne	r0, #1
}
    4594:	pop	{r3, r4, r5, pc}

00004596 <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    4596:	push	{r0, r1, r4, r5, r6, lr}
    4598:	add	r5, sp, #8
    459a:	mov	r6, r0
    459c:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    45a0:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    45a2:	mov	r2, r5
    45a4:	ldr	r1, [sp, #4]
    45a6:	mov	r0, r6
    45a8:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    45ac:	cmp	r0, #0
    45ae:	blt.n	45ba <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    45b0:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    45b4:	bne.n	45a2 <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    45b6:	mov	r0, r4
    45b8:	b.n	45bc <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    45ba:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    45bc:	add	sp, #8
    45be:	pop	{r4, r5, r6, pc}

000045c0 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    45c0:	push	{r4, r5, r6, lr}
    45c2:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    45c4:	ldr.w	r4, [r0, #1080]	; 0x438
    45c8:	ldr	r1, [r1, #4]
    45ca:	ands	r4, r1
    45cc:	adds	r3, r4, r2
  pos->position += offset;
    45ce:	add	r2, r1
    45d0:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    45d2:	ldrb.w	r4, [r0, #1093]	; 0x445
    45d6:	adds	r4, #9
    45d8:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    45da:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    45dc:	lsr.w	r4, r3, r4
  while (tmp--) {
    45e0:	cbz	r4, 4600 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    45e2:	ldrb	r3, [r5, #8]
    45e4:	cbz	r3, 45f0 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    45e6:	ldr	r3, [r5, #0]
    45e8:	adds	r3, #1
    45ea:	str	r3, [r5, #0]
    45ec:	subs	r4, #1
    45ee:	b.n	45e0 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    45f0:	mov	r2, r5
    45f2:	ldr	r1, [r5, #0]
    45f4:	mov	r0, r6
    45f6:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    45fa:	cmp	r0, #1
    45fc:	beq.n	45ec <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    45fe:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    4600:	movs	r0, #1
}
    4602:	pop	{r4, r5, r6, pc}

00004604 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4604:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4606:	push	{r3, r4, r5, lr}
    4608:	mov	r4, r1
    460a:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    460c:	bhi.n	4612 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    460e:	movs	r0, #0
    4610:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4612:	ldr.w	r3, [r0, #1072]	; 0x430
    4616:	adds	r3, #1
    4618:	cmp	r1, r3
    461a:	bhi.n	460e <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    461c:	ldr.w	r1, [r0, #1060]	; 0x424
    4620:	movs	r2, #1
    4622:	add.w	r1, r1, r4, lsr #7
    4626:	add.w	r0, r0, #528	; 0x210
    462a:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    462e:	cmp	r0, #0
    4630:	beq.n	460e <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4632:	lsls	r4, r4, #2
    4634:	ubfx	r4, r4, #0, #9
    4638:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    463a:	movs	r0, #1

 fail:
  return false;
}
    463c:	pop	{r3, r4, r5, pc}

0000463e <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    463e:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4642:	mov	r7, r0
    4644:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    4646:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    4648:	add	r2, sp, #4
    464a:	mov	r1, r4
    464c:	mov	r0, r7
    464e:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    4652:	subs.w	r8, r0, #0
    4656:	bge.n	465c <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    4658:	movs	r5, #0
    465a:	b.n	4694 <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    465c:	movs	r2, #0
    465e:	mov	r1, r4
    4660:	mov	r0, r7
    4662:	bl	4604 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4666:	mov	r5, r0
    4668:	cmp	r0, #0
    466a:	beq.n	4658 <ExFatPartition::freeChain(unsigned long)+0x1a>
    466c:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    466e:	cmp.w	r8, #0
    4672:	beq.n	467a <ExFatPartition::freeChain(unsigned long)+0x3c>
    4674:	ldr	r3, [sp, #4]
    4676:	cmp	r2, r3
    4678:	beq.n	468c <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    467a:	movs	r3, #0
    467c:	subs	r2, r2, r6
    467e:	mov	r1, r6
    4680:	mov	r0, r7
    4682:	bl	447c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4686:	cmp	r0, #0
    4688:	beq.n	4658 <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    468a:	ldr	r6, [sp, #4]
    }
    cluster = next;
    468c:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    468e:	cmp.w	r8, #0
    4692:	bne.n	4648 <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    4694:	mov	r0, r5
    4696:	add	sp, #8
    4698:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000469c <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    469c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    46a0:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    46a4:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    46a6:	mov	r6, r0
  uint32_t nc = 0;
    46a8:	mov	r5, r4
    46aa:	add.w	r7, r0, #528	; 0x210
    46ae:	movs	r2, #0
    46b0:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    46b2:	add.w	r8, r1, #1
    46b6:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    46ba:	cbz	r0, 46fc <ExFatPartition::freeClusterCount()+0x60>
    46bc:	add.w	lr, r0, #4294967295
    46c0:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    46c4:	ldrb.w	r1, [lr, #1]!
    46c8:	cmp	r1, #255	; 0xff
    46ca:	bne.n	46d0 <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    46cc:	adds	r4, #8
    46ce:	b.n	46e4 <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    46d0:	cbz	r1, 46e4 <ExFatPartition::freeClusterCount()+0x48>
    46d2:	movs	r2, #8
    46d4:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    46d6:	tst	r1, r3
            usedCount++;
    46d8:	it	ne
    46da:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    46dc:	lsls	r3, r3, #1
    46de:	subs	r2, #1
    46e0:	uxtb	r3, r3
    46e2:	bne.n	46d6 <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    46e4:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    46e8:	adds	r5, #8
      if (nc >= m_clusterCount) {
    46ea:	cmp	r5, r0
    46ec:	bcc.n	46f4 <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    46ee:	subs	r0, r0, r4
    46f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    46f4:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    46f6:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    46f8:	bne.n	46c4 <ExFatPartition::freeClusterCount()+0x28>
    46fa:	b.n	46ae <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    46fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004700 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4700:	push	{r4, r5, r6, r7, lr}
    4702:	mov	r4, r0
    4704:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4706:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4708:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    470a:	mov.w	r3, #4294967295
    470e:	mov	r1, r2
    4710:	str	r3, [r4, #12]
    4712:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4716:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    471a:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    471e:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4720:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4722:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4726:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    472a:	str	r5, [sp, #8]
    472c:	str	r5, [sp, #4]
    472e:	str	r5, [sp, #0]
    4730:	add	r3, sp, #20
    4732:	add.w	r2, r4, #544	; 0x220
    4736:	bl	3150 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    473a:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    473e:	add.w	r7, r4, #528	; 0x210
    4742:	bne.n	4748 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    4744:	movs	r0, #0
    4746:	b.n	47c2 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    4748:	ldr	r6, [sp, #20]
    474a:	mov	r2, r5
    474c:	mov	r1, r6
    474e:	mov	r0, r7
    4750:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4754:	mov	r5, r0
    4756:	cmp	r0, #0
    4758:	beq.n	4744 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    475a:	ldr	r1, [pc, #108]	; (47c8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    475c:	movs	r2, #5
    475e:	adds	r0, #3
    4760:	bl	c35c <strncmp>
    4764:	mov	r1, r0
    4766:	cmp	r0, #0
    4768:	bne.n	4744 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    476a:	ldrb.w	r3, [r5, #108]	; 0x6c
    476e:	cmp	r3, #9
    4770:	bne.n	4744 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    4772:	ldr	r3, [r5, #80]	; 0x50
    4774:	add	r3, r6
    4776:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    477a:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    477c:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4780:	ldr	r3, [r5, #88]	; 0x58
    4782:	add	r6, r3
    4784:	str.w	r6, [r4, #1068]	; 0x42c
    4788:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    478a:	str.w	r3, [r4, #1072]	; 0x430
    478e:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4790:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4794:	ldrb.w	r3, [r5, #109]	; 0x6d
    4798:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    479c:	movs	r5, #1
    479e:	adds	r3, #9
    47a0:	lsl.w	r3, r5, r3
    47a4:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    47a8:	subs	r3, #1
    47aa:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    47ae:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    47b2:	mov	r2, r5
    47b4:	mov	r0, r4
    47b6:	bl	43d6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    47ba:	movs	r3, #64	; 0x40
    47bc:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    47c0:	mov	r0, r5

 fail:
  return false;
}
    47c2:	add	sp, #28
    47c4:	pop	{r4, r5, r6, r7, pc}
    47c6:	nop
    47c8:	.word	0x00013055

000047cc <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    47cc:	push	{r4, lr}
    47ce:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    47d0:	ldr.w	r1, [r0, #1076]	; 0x434
    47d4:	bl	4596 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    47d8:	ldrb.w	r3, [r4, #1093]	; 0x445
    47dc:	adds	r3, #9
    47de:	uxtb	r3, r3
}
    47e0:	lsls	r0, r3
    47e2:	pop	{r4, pc}

000047e4 <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    47e4:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    47e6:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    47e8:	movs	r3, #0
    47ea:	lsls	r2, r1, #15
    47ec:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    47f0:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    47f2:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    47f4:	uxtah	r1, r2, r1
    47f8:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    47fa:	bne.n	4806 <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    47fc:	cmp	r4, #133	; 0x85
    47fe:	ite	ne
    4800:	movne	r2, #1
    4802:	moveq	r2, #3
    4804:	b.n	4808 <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    4806:	movs	r2, #1
    4808:	add	r3, r2
    480a:	cmp	r3, #31
    480c:	bls.n	47ea <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    480e:	mov	r0, r1
    4810:	pop	{r4, pc}

00004812 <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    4812:	push	{r4, lr}
    4814:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4816:	bl	338e <FsCache::sync()>
    481a:	cbz	r0, 4834 <ExFatPartition::cacheSync()+0x22>
    481c:	add.w	r0, r4, #528	; 0x210
    4820:	bl	338e <FsCache::sync()>
    4824:	cbz	r0, 4834 <ExFatPartition::cacheSync()+0x22>
    4826:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    482a:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    482c:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4830:	ldr	r3, [r3, #28]
    4832:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4834:	movs	r0, #0
    4836:	pop	{r4, pc}

00004838 <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4838:	push	{r3, r4, r5, r6, r7, lr}
    483a:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    483c:	ldr	r0, [r0, #32]
    483e:	ldr	r1, [r4, #24]
    4840:	cbz	r1, 4844 <ExFatFile::addCluster()+0xc>
    4842:	adds	r1, #1
    4844:	movs	r2, #1
    4846:	bl	43d6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    484a:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    484c:	mov	r5, r0
  if (find < 2) {
    484e:	bhi.n	4854 <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    4850:	movs	r6, #0
    4852:	b.n	48c6 <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4854:	movs	r3, #1
    4856:	mov	r1, r0
    4858:	mov	r2, r3
    485a:	ldr	r0, [r4, #32]
    485c:	bl	447c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4860:	mov	r6, r0
    4862:	cmp	r0, #0
    4864:	beq.n	4850 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4866:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4868:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    486c:	cbnz	r2, 4878 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    486e:	orr.w	r3, r3, #64	; 0x40
    4872:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4876:	b.n	48c4 <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4878:	lsls	r1, r3, #25
    487a:	bpl.n	48a4 <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    487c:	adds	r2, #1
    487e:	cmp	r5, r2
    4880:	beq.n	48c4 <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4882:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4886:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4888:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    488c:	ldr	r3, [r4, #24]
    488e:	cmp	r1, r3
    4890:	bcs.n	48a4 <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    4892:	adds	r7, r1, #1
    4894:	mov	r2, r7
    4896:	ldr	r0, [r4, #32]
    4898:	bl	4604 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    489c:	cmp	r0, #0
    489e:	beq.n	4850 <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    48a0:	mov	r1, r7
    48a2:	b.n	488c <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    48a4:	mov.w	r2, #4294967295
    48a8:	mov	r1, r5
    48aa:	ldr	r0, [r4, #32]
    48ac:	bl	4604 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    48b0:	cmp	r0, #0
    48b2:	beq.n	4850 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    48b4:	ldr	r1, [r4, #24]
    48b6:	cbz	r1, 48c4 <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    48b8:	mov	r2, r5
    48ba:	ldr	r0, [r4, #32]
    48bc:	bl	4604 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    48c0:	cmp	r0, #0
    48c2:	beq.n	4850 <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    48c4:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    48c6:	mov	r0, r6
    48c8:	pop	{r3, r4, r5, r6, r7, pc}

000048ca <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    48ca:	push	{r4, r5, r6, lr}
    48cc:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    48d0:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    48d2:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    48d4:	bmi.n	48da <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    48d6:	movs	r0, #0
    48d8:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    48da:	ldr	r5, [r0, #28]
    48dc:	cbnz	r5, 48e2 <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    48de:	movs	r5, #0
    48e0:	b.n	4934 <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    48e2:	lsls	r3, r3, #25
    48e4:	bpl.n	4910 <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    48e6:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    48e8:	ldrd	r0, r1, [r0, #8]
    48ec:	ldrb.w	r2, [r6, #1093]	; 0x445
    48f0:	adds.w	r0, r0, #4294967295
    48f4:	add.w	r2, r2, #9
    48f8:	uxtb	r2, r2
    48fa:	adc.w	r1, r1, #4294967295
    48fe:	bl	a430 <__aeabi_llsr>
    4902:	movs	r3, #0
    4904:	adds	r2, r0, #1
    4906:	mov	r1, r5
    4908:	mov	r0, r6
    490a:	bl	447c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    490e:	b.n	4918 <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    4910:	mov	r1, r5
    4912:	ldr	r0, [r0, #32]
    4914:	bl	463e <ExFatPartition::freeChain(unsigned long)>
    4918:	cmp	r0, #0
    491a:	bne.n	48de <ExFatFile::remove()+0x14>
    491c:	b.n	48d6 <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    491e:	movs	r2, #1
    4920:	mov	r0, r4
    4922:	bl	3be2 <ExFatFile::dirCache(unsigned char, unsigned char)>
    4926:	adds	r5, #1
    if (!cache) {
    4928:	cmp	r0, #0
    492a:	beq.n	48d6 <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    492c:	ldrb	r3, [r0, #0]
    492e:	and.w	r3, r3, #127	; 0x7f
    4932:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4934:	ldrb.w	r3, [r4, #48]	; 0x30
    4938:	uxtb	r1, r5
    493a:	cmp	r3, r1
    493c:	bcs.n	491e <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    493e:	movs	r3, #0
    4940:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4944:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4948:	ldr	r0, [r4, #32]
    494a:	bl	4812 <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    494e:	pop	{r4, r5, r6, pc}

00004950 <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4950:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4952:	ldrb.w	r3, [r0, #49]	; 0x31
    4956:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4958:	sub	sp, #32
    495a:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    495c:	bmi.n	4962 <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    495e:	movs	r0, #0
    4960:	b.n	499e <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4962:	movs	r2, #0
    4964:	movs	r3, #0
    4966:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    496a:	movs	r2, #32
    496c:	mov	r1, sp
    496e:	mov	r0, r4
    4970:	bl	3d10 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4974:	cbz	r0, 4986 <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4976:	cmp	r0, #32
    4978:	bne.n	495e <ExFatFile::rmdir()+0xe>
    497a:	ldrb.w	r3, [sp]
    497e:	lsls	r2, r3, #24
    4980:	bmi.n	495e <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    4982:	cmp	r3, #0
    4984:	bne.n	496a <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4986:	movs	r3, #8
    4988:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    498c:	ldrb.w	r3, [r4, #51]	; 0x33
    4990:	orr.w	r3, r3, #2
    4994:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4998:	mov	r0, r4
    499a:	bl	48ca <ExFatFile::remove()>

 fail:
  return false;
}
    499e:	add	sp, #32
    49a0:	pop	{r4, pc}
    49a2:	Address 0x000049a2 is out of bounds.


000049a4 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    49a4:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    49a8:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    49aa:	ldr.w	r8, [pc, #212]	; 4a80 <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    49ae:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    49b0:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    49b2:	ldrb.w	r3, [r5, #48]	; 0x30
    49b6:	uxtb	r1, r6
    49b8:	cmp	r3, r1
    49ba:	bcc.n	4a52 <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    49bc:	movs	r2, #0
    49be:	mov	r0, r5
    49c0:	bl	3be2 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    49c4:	mov	r4, r0
    49c6:	cmp	r0, #0
    49c8:	beq.n	4a6a <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    49ca:	ldrb	r3, [r0, #0]
    49cc:	cmp	r3, #192	; 0xc0
    49ce:	beq.n	4a0c <ExFatFile::syncDir()+0x68>
    49d0:	cmp	r3, #193	; 0xc1
    49d2:	beq.n	4a44 <ExFatFile::syncDir()+0xa0>
    49d4:	cmp	r3, #133	; 0x85
    49d6:	bne.n	4a6a <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    49d8:	ldrb.w	r3, [r5, #49]	; 0x31
    49dc:	and.w	r3, r3, #55	; 0x37
    49e0:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    49e2:	ldr.w	r3, [r8]
    49e6:	cbz	r3, 4a36 <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    49e8:	add.w	r2, sp, #3
    49ec:	add.w	r1, sp, #6
    49f0:	add	r0, sp, #4
    49f2:	blx	r3
          df->modifyTimeMs = ms10;
    49f4:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    49f8:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    49fc:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    49fe:	ldrh.w	r3, [sp, #4]
    4a02:	strh	r2, [r4, #12]
    4a04:	strh	r3, [r4, #14]
    4a06:	strh	r2, [r4, #16]
    4a08:	strh	r3, [r4, #18]
    4a0a:	b.n	4a36 <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    4a0c:	ldrb.w	r3, [r5, #51]	; 0x33
    4a10:	tst.w	r3, #64	; 0x40
    4a14:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4a16:	ite	ne
    4a18:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    4a1c:	biceq.w	r3, r3, #2
    4a20:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    4a22:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4a26:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    4a2a:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4a2c:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    4a2e:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4a32:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4a36:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4a38:	ldrb.w	r3, [r2, #528]	; 0x210
    4a3c:	orr.w	r3, r3, #1
    4a40:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4a44:	mov	r1, r7
    4a46:	mov	r0, r4
    4a48:	bl	47e4 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4a4c:	adds	r6, #1
    4a4e:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4a50:	b.n	49b2 <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4a52:	movs	r2, #1
    4a54:	add.w	r1, r5, #36	; 0x24
    4a58:	ldr	r0, [r5, #32]
    4a5a:	bl	4522 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4a5e:	cbz	r0, 4a6a <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4a60:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4a62:	ldr	r0, [r5, #32]
    4a64:	bl	4812 <ExFatPartition::cacheSync()>
    4a68:	cbnz	r0, 4a78 <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4a6a:	ldrb.w	r3, [r5, #50]	; 0x32
    4a6e:	orr.w	r3, r3, #1
    4a72:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4a76:	movs	r0, #0
}
    4a78:	add	sp, #8
    4a7a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4a7e:	nop
    4a80:	.word	0x20019e98

00004a84 <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4a84:	push	{r4, lr}
  if (!isOpen()) {
    4a86:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4a8a:	mov	r4, r0
  if (!isOpen()) {
    4a8c:	cbnz	r3, 4a92 <ExFatFile::sync()+0xe>
    return true;
    4a8e:	movs	r0, #1
    4a90:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    4a92:	ldrb.w	r3, [r0, #51]	; 0x33
    4a96:	lsls	r2, r3, #24
    4a98:	bpl.n	4aaa <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    4a9a:	and.w	r3, r3, #127	; 0x7f
    4a9e:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    4aa2:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    4aa6:	b.w	49a4 <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    4aaa:	ldr	r0, [r0, #32]
    4aac:	bl	4812 <ExFatPartition::cacheSync()>
    4ab0:	cmp	r0, #0
    4ab2:	bne.n	4a8e <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4ab4:	ldrb.w	r3, [r4, #50]	; 0x32
    4ab8:	orr.w	r3, r3, #1
    4abc:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    4ac0:	pop	{r4, pc}

00004ac2 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4ac2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4ac6:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4aca:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4acc:	lsls	r0, r3, #25
    4ace:	bpl.n	4ad8 <ExFatFile::addDirCluster()+0x16>
    4ad0:	ldr	r0, [r4, #32]
    4ad2:	bl	47cc <ExFatPartition::rootLength()>
    4ad6:	b.n	4ada <ExFatFile::addDirCluster()+0x18>
    4ad8:	ldr	r0, [r4, #8]
    4ada:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    4adc:	ldr.w	r3, [r3, #1084]	; 0x43c
    4ae0:	add	r0, r3
    4ae2:	cmp.w	r0, #67108864	; 0x4000000
    4ae6:	bcs.n	4b9a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    4ae8:	mov	r0, r4
    4aea:	bl	4838 <ExFatFile::addCluster()>
    4aee:	cmp	r0, #0
    4af0:	beq.n	4b9a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    4af2:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    4af4:	ldrb.w	r3, [r5, #528]	; 0x210
    4af8:	lsls	r1, r3, #31
    4afa:	bpl.n	4b08 <ExFatFile::addDirCluster()+0x46>
    4afc:	add.w	r0, r5, #528	; 0x210
    4b00:	bl	338e <FsCache::sync()>
    4b04:	cmp	r0, #0
    4b06:	beq.n	4b9a <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4b08:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4b0c:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    4b0e:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4b12:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4b16:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    4b1a:	mov.w	r2, #512	; 0x200
    4b1e:	mov	r1, r6
    4b20:	mov	r0, r5
    4b22:	bl	8cf4 <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    4b26:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4b28:	ldr	r3, [r4, #24]
    4b2a:	ldrb.w	r1, [r2, #1093]	; 0x445
    4b2e:	ldr.w	r7, [r2, #1068]	; 0x42c
    4b32:	subs	r3, #2
    4b34:	lsls	r3, r1
    4b36:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4b38:	mov.w	r8, #1
    4b3c:	ldr	r3, [r4, #32]
    4b3e:	ldrb.w	r2, [r3, #1093]	; 0x445
    4b42:	lsl.w	r2, r8, r2
    4b46:	cmp	r2, r6
    4b48:	bls.n	4b5e <ExFatFile::addDirCluster()+0x9c>
    4b4a:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    4b4e:	ldr	r3, [r0, #0]
    4b50:	mov	r2, r5
    4b52:	ldr	r3, [r3, #32]
    4b54:	adds	r1, r7, r6
    4b56:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    4b58:	cbz	r0, 4b9a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4b5a:	adds	r6, #1
    4b5c:	b.n	4b3c <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    4b5e:	ldrb.w	r2, [r4, #49]	; 0x31
    4b62:	lsls	r2, r2, #25
    4b64:	bmi.n	4b90 <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4b66:	ldrb.w	r2, [r4, #51]	; 0x33
    4b6a:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    4b6e:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4b72:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    4b76:	ldr.w	r2, [r3, #1084]	; 0x43c
    4b7a:	movs	r3, #0
    4b7c:	adds	r0, r0, r2
    4b7e:	adcs	r1, r3
    4b80:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    4b84:	ldrd	r0, r1, [r4, #16]
    4b88:	adds	r2, r2, r0
    4b8a:	adcs	r3, r1
    4b8c:	strd	r2, r3, [r4, #16]
  }
  return sync();
    4b90:	mov	r0, r4

 fail:
  return false;
}
    4b92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    4b96:	b.w	4a84 <ExFatFile::sync()>

 fail:
  return false;
}
    4b9a:	movs	r0, #0
    4b9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004ba0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    4ba0:	push	{r4, lr}
  if (!parent->isDir()) {
    4ba2:	ldrb.w	r3, [r1, #49]	; 0x31
    4ba6:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    4baa:	mov	r4, r0
  if (!parent->isDir()) {
    4bac:	beq.n	4be4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    4bae:	movw	r3, #2562	; 0xa02
    4bb2:	bl	3f90 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    4bb6:	cbz	r0, 4be4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    4bb8:	movs	r3, #16
    4bba:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    4bbe:	mov	r0, r4
    4bc0:	bl	4ac2 <ExFatFile::addDirCluster()>
    4bc4:	cbz	r0, 4be4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    4bc6:	ldr	r3, [r4, #24]
    4bc8:	str	r3, [r4, #28]
    4bca:	mov	r0, r4
    4bcc:	movs	r3, #0
    4bce:	movs	r2, #0
    4bd0:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    4bd4:	movs	r3, #193	; 0xc1
    4bd6:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    4bda:	mov	r0, r4

 fail:
  return false;
}
    4bdc:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    4be0:	b.w	4a84 <ExFatFile::sync()>

 fail:
  return false;
}
    4be4:	movs	r0, #0
    4be6:	pop	{r4, pc}

00004be8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    4be8:	push	{r4, r5, r6, r7, lr}
    4bea:	sub	sp, #92	; 0x5c
    4bec:	mov	r7, r3
    4bee:	movs	r3, #0
    4bf0:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    4bf4:	strb.w	r3, [sp, #81]	; 0x51
    4bf8:	strb.w	r3, [sp, #82]	; 0x52
    4bfc:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    4c00:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    4c04:	str	r2, [sp, #4]
    4c06:	mov	r5, r0
    4c08:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    4c0a:	cmp	r3, #0
    4c0c:	bne.n	4ca0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    4c0e:	ldrb.w	r3, [r1, #49]	; 0x31
    4c12:	tst.w	r3, #80	; 0x50
    4c16:	beq.n	4ca0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    4c18:	ldrb	r3, [r2, #0]
    4c1a:	cmp	r3, #47	; 0x2f
    4c1c:	bne.n	4c3a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    4c1e:	ldr	r3, [sp, #4]
    4c20:	ldrb	r2, [r3, #0]
    4c22:	cmp	r2, #47	; 0x2f
    4c24:	bne.n	4c2c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    4c26:	adds	r3, #1
    4c28:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    4c2a:	b.n	4c1e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    4c2c:	ldr	r1, [r4, #32]
    4c2e:	add	r0, sp, #32
    4c30:	bl	3c6e <ExFatFile::openRoot(ExFatVolume*)>
    4c34:	cmp	r0, #0
    4c36:	beq.n	4ca0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    4c38:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    4c3a:	add	r3, sp, #4
    4c3c:	add	r2, sp, #8
    4c3e:	ldr	r1, [sp, #4]
    4c40:	mov	r0, r5
    4c42:	bl	3c94 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    4c46:	cbz	r0, 4ca0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    4c48:	ldr	r3, [sp, #4]
    4c4a:	ldrb	r3, [r3, #0]
    4c4c:	cbz	r3, 4c94 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    4c4e:	movs	r3, #0
    4c50:	add	r2, sp, #8
    4c52:	mov	r1, r4
    4c54:	mov	r0, r5
    4c56:	bl	3f90 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    4c5a:	cbz	r0, 4c82 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    4c5c:	add	r2, sp, #32
    4c5e:	mov	r3, r5
    4c60:	add.w	lr, r5, #48	; 0x30
    4c64:	mov	r4, r2
    4c66:	ldr	r0, [r3, #0]
    4c68:	ldr	r1, [r3, #4]
    4c6a:	mov	r6, r2
    4c6c:	stmia	r6!, {r0, r1}
    4c6e:	adds	r3, #8
    4c70:	cmp	r3, lr
    4c72:	mov	r2, r6
    4c74:	bne.n	4c66 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    4c76:	ldr	r0, [r3, #0]
    4c78:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    4c7a:	mov	r0, r5
    4c7c:	bl	3c1a <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    4c80:	b.n	4c3a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    4c82:	cbz	r7, 4ca0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    4c84:	add	r2, sp, #8
    4c86:	mov	r1, r4
    4c88:	mov	r0, r5
    4c8a:	bl	4ba0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    4c8e:	cmp	r0, #0
    4c90:	bne.n	4c5c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    4c92:	b.n	4ca0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    4c94:	add	r2, sp, #8
    4c96:	mov	r1, r4
    4c98:	mov	r0, r5
    4c9a:	bl	4ba0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    4c9e:	b.n	4ca2 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    4ca0:	movs	r0, #0
}
    4ca2:	add	sp, #92	; 0x5c
    4ca4:	pop	{r4, r5, r6, r7, pc}

00004ca6 <ExFatFile::preAllocate(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::preAllocate(uint64_t length) {
    4ca6:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4caa:	mov	r6, r2
    4cac:	mov	r7, r3
  uint32_t find;
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    4cae:	orrs.w	r3, r6, r7

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::preAllocate(uint64_t length) {
    4cb2:	mov	r4, r0
  uint32_t find;
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    4cb4:	beq.n	4d1e <ExFatFile::preAllocate(unsigned long long)+0x78>
    4cb6:	ldrb.w	r3, [r0, #51]	; 0x33
    4cba:	lsls	r3, r3, #30
    4cbc:	bpl.n	4d1e <ExFatFile::preAllocate(unsigned long long)+0x78>
    4cbe:	ldr.w	r8, [r0, #28]
    4cc2:	cmp.w	r8, #0
    4cc6:	bne.n	4d1e <ExFatFile::preAllocate(unsigned long long)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  need = 1 + ((length - 1) >> m_vol->bytesPerClusterShift());
    4cc8:	ldr	r5, [r0, #32]
    4cca:	ldrb.w	r2, [r5, #1093]	; 0x445
    4cce:	adds.w	r0, r6, #4294967295
    4cd2:	add.w	r2, r2, #9
    4cd6:	adc.w	r1, r7, #4294967295
    4cda:	uxtb	r2, r2
    4cdc:	bl	a430 <__aeabi_llsr>
    4ce0:	add.w	r9, r0, #1
  find = m_vol->bitmapFind(0, need);
    4ce4:	mov	r2, r9
    4ce6:	mov	r0, r5
    4ce8:	mov	r1, r8
    4cea:	bl	43d6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    4cee:	cmp	r0, #1
  if (!length || !isWritable() || m_firstCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  need = 1 + ((length - 1) >> m_vol->bytesPerClusterShift());
  find = m_vol->bitmapFind(0, need);
    4cf0:	mov	r5, r0
  if (find < 2) {
    4cf2:	bls.n	4d1e <ExFatFile::preAllocate(unsigned long long)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, need, 1)) {
    4cf4:	movs	r3, #1
    4cf6:	mov	r2, r9
    4cf8:	mov	r1, r5
    4cfa:	ldr	r0, [r4, #32]
    4cfc:	bl	447c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4d00:	cbz	r0, 4d1e <ExFatFile::preAllocate(unsigned long long)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_dataLength = length;
  m_firstCluster = find;
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
    4d02:	ldrb.w	r3, [r4, #51]	; 0x33
  if (!m_vol->bitmapModify(find, need, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_dataLength = length;
  m_firstCluster = find;
    4d06:	str	r5, [r4, #28]
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
    4d08:	orn	r3, r3, #63	; 0x3f
    4d0c:	strb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, need, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_dataLength = length;
    4d10:	strd	r6, r7, [r4, #8]
  m_firstCluster = find;
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
  if (!sync()) {
    4d14:	mov	r0, r4
  }
  return true;

 fail:
  return false;
}
    4d16:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    goto fail;
  }
  m_dataLength = length;
  m_firstCluster = find;
  m_flags |= FILE_FLAG_DIR_DIRTY | FILE_FLAG_CONTIGUOUS;
  if (!sync()) {
    4d1a:	b.w	4a84 <ExFatFile::sync()>
  }
  return true;

 fail:
  return false;
}
    4d1e:	movs	r0, #0
    4d20:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00004d24 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    4d24:	push	{r4, r5, r6, r7, lr}
    4d26:	sub	sp, #116	; 0x74
    4d28:	movs	r3, #0
    4d2a:	strb.w	r3, [sp, #49]	; 0x31
    4d2e:	strb.w	r3, [sp, #50]	; 0x32
    4d32:	strb.w	r3, [sp, #51]	; 0x33
    4d36:	strb.w	r3, [sp, #105]	; 0x69
    4d3a:	strb.w	r3, [sp, #106]	; 0x6a
    4d3e:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    4d42:	ldrb.w	r3, [r0, #49]	; 0x31
    4d46:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    4d4a:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    4d4c:	bne.n	4d52 <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    4d4e:	movs	r0, #0
    4d50:	b.n	4dc6 <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    4d52:	ldr	r0, [r0, #32]
    4d54:	ldr	r3, [r1, #32]
    4d56:	cmp	r0, r3
    4d58:	bne.n	4d4e <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    4d5a:	movw	r3, #2561	; 0xa01
    4d5e:	mov	r0, sp
    4d60:	bl	42e0 <ExFatFile::open(ExFatFile*, char const*, int)>
    4d64:	cmp	r0, #0
    4d66:	beq.n	4d4e <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    4d68:	add	r2, sp, #56	; 0x38
    4d6a:	mov	r3, r4
    4d6c:	add.w	r7, r4, #48	; 0x30
    4d70:	mov	r6, r2
    4d72:	ldr	r0, [r3, #0]
    4d74:	ldr	r1, [r3, #4]
    4d76:	mov	r5, r2
    4d78:	stmia	r5!, {r0, r1}
    4d7a:	adds	r3, #8
    4d7c:	cmp	r3, r7
    4d7e:	mov	r2, r5
    4d80:	bne.n	4d72 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    4d82:	ldr	r0, [r3, #0]
    4d84:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    4d86:	add	r2, sp, #36	; 0x24
    4d88:	ldmia	r2, {r0, r1, r2}
    4d8a:	add.w	r3, r4, #36	; 0x24
    4d8e:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    4d92:	ldrb.w	r3, [sp, #48]	; 0x30
    4d96:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    4d9a:	ldrb.w	r3, [r4, #51]	; 0x33
    4d9e:	orn	r3, r3, #127	; 0x7f
    4da2:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    4da6:	mov	r0, r4
    4da8:	bl	4a84 <ExFatFile::sync()>
    4dac:	cmp	r0, #0
    4dae:	beq.n	4d4e <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    4db0:	movs	r3, #0
    4db2:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    4db4:	movs	r3, #2
    4db6:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    4dba:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    4dbc:	movs	r3, #8
    4dbe:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    4dc2:	bl	48ca <ExFatFile::remove()>

 fail:
  return false;
}
    4dc6:	add	sp, #116	; 0x74
    4dc8:	pop	{r4, r5, r6, r7, pc}

00004dca <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4dca:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4dce:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4dd0:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4dd4:	ldrb.w	fp, [sp, #40]	; 0x28
    4dd8:	ldrb.w	sl, [sp, #44]	; 0x2c
    4ddc:	ldrb.w	r5, [sp, #48]	; 0x30
    4de0:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4de4:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4de6:	mov	r6, r0
    4de8:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4dea:	bpl.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    4dec:	subw	r2, r2, #1980	; 0x7bc
    4df0:	uxth	r7, r2
    4df2:	cmp	r7, #127	; 0x7f
    4df4:	bhi.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    4df6:	subs	r3, r4, #1
    4df8:	cmp	r3, #11
    4dfa:	bhi.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    4dfc:	add.w	r3, fp, #4294967295
    4e00:	cmp	r3, #30
    4e02:	bhi.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    4e04:	cmp.w	sl, #23
    4e08:	bhi.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    4e0a:	cmp	r5, #59	; 0x3b
    4e0c:	bhi.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    4e0e:	cmp.w	r9, #59	; 0x3b
    4e12:	bhi.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    4e14:	bl	4a84 <ExFatFile::sync()>
    4e18:	cbz	r0, 4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4e1a:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4e1e:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4e22:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4e26:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4e2a:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    4e2e:	tst.w	r9, #1
    4e32:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4e36:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4e38:	uxth	r5, r5
    4e3a:	ite	eq
    4e3c:	moveq.w	r9, #0
    4e40:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    4e44:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    4e46:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4e4a:	ldrb.w	r3, [r6, #48]	; 0x30
    4e4e:	uxtb	r1, r7
    4e50:	cmp	r3, r1
    4e52:	bcc.n	4ebe <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4e54:	movs	r2, #0
    4e56:	mov	r0, r6
    4e58:	bl	3be2 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4e5c:	cbnz	r0, 4e64 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    4e5e:	movs	r0, #0
    4e60:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4e64:	ldrb	r3, [r0, #0]
    4e66:	cmp	r3, #133	; 0x85
    4e68:	beq.n	4e74 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    4e6a:	bcc.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4e6c:	subs	r3, #192	; 0xc0
    4e6e:	cmp	r3, #1
    4e70:	bls.n	4eb2 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    4e72:	b.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4e74:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    4e78:	ldr	r2, [r6, #32]
    4e7a:	and.w	r3, r3, #55	; 0x37
    4e7e:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4e80:	ldrb.w	r3, [r2, #528]	; 0x210
    4e84:	orr.w	r3, r3, #1
    4e88:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    4e8c:	cmp.w	sl, #0
    4e90:	beq.n	4e96 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    4e92:	strh	r5, [r0, #16]
    4e94:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    4e96:	tst.w	r8, #2
          df->createTimeMs = ms10;
    4e9a:	ittt	ne
    4e9c:	strbne.w	r9, [r0, #20]
    4ea0:	strhne	r5, [r0, #8]
    4ea2:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    4ea4:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    4ea8:	ittt	ne
    4eaa:	strbne.w	r9, [r0, #21]
    4eae:	strhne	r5, [r0, #12]
    4eb0:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4eb2:	mov	r1, fp
    4eb4:	bl	47e4 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4eb8:	adds	r7, #1
    4eba:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4ebc:	b.n	4e4a <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4ebe:	movs	r2, #1
    4ec0:	add.w	r1, r6, #36	; 0x24
    4ec4:	ldr	r0, [r6, #32]
    4ec6:	bl	4522 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4eca:	cmp	r0, #0
    4ecc:	beq.n	4e5e <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4ece:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4ed2:	ldr	r0, [r6, #32]
    4ed4:	bl	4812 <ExFatPartition::cacheSync()>
    4ed8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004edc <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    4edc:	push	{r0, r1, r4, r5, r6, lr}
    4ede:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    4ee2:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    4ee4:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    4ee6:	bmi.n	4eec <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    4ee8:	movs	r0, #0
    4eea:	b.n	4f96 <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    4eec:	ldr	r5, [r0, #28]
    4eee:	cmp	r5, #0
    4ef0:	beq.n	4f74 <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    4ef2:	and.w	r3, r3, #64	; 0x40
    4ef6:	and.w	r1, r3, #255	; 0xff
    4efa:	ldr	r6, [r0, #24]
    4efc:	cbz	r3, 4f3c <ExFatFile::truncate()+0x60>
    4efe:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4f00:	ldrd	r0, r1, [r0, #8]
    4f04:	ldrb.w	r2, [r3, #1093]	; 0x445
    4f08:	adds.w	r0, r0, #4294967295
    4f0c:	add.w	r2, r2, #9
    4f10:	uxtb	r2, r2
    4f12:	adc.w	r1, r1, #4294967295
    4f16:	bl	a430 <__aeabi_llsr>
    4f1a:	adds	r2, r0, #1
    if (m_curCluster) {
    4f1c:	cbz	r6, 4f2a <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    4f1e:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    4f20:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    4f22:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    4f24:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    4f26:	add	r2, r5
    4f28:	b.n	4f2e <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    4f2a:	str	r5, [sp, #4]
      m_firstCluster = 0;
    4f2c:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    4f2e:	cbz	r2, 4f78 <ExFatFile::truncate()+0x9c>
    4f30:	movs	r3, #0
    4f32:	ldr	r1, [sp, #4]
    4f34:	ldr	r0, [r4, #32]
    4f36:	bl	447c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4f3a:	b.n	4f70 <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    4f3c:	cbz	r6, 4f62 <ExFatFile::truncate()+0x86>
      toFree = 0;
    4f3e:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    4f40:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    4f42:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    4f46:	mov	r1, r6
    4f48:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    4f4c:	cmp	r0, #0
    4f4e:	blt.n	4ee8 <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    4f50:	beq.n	4f66 <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    4f52:	mov.w	r2, #4294967295
    4f56:	ldr	r1, [r4, #24]
    4f58:	ldr	r0, [r4, #32]
    4f5a:	bl	4604 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4f5e:	cbnz	r0, 4f66 <ExFatFile::truncate()+0x8a>
    4f60:	b.n	4ee8 <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    4f62:	str	r5, [sp, #4]
      m_firstCluster = 0;
    4f64:	str	r6, [r0, #28]
    }
    if (toFree) {
    4f66:	ldr	r1, [sp, #4]
    4f68:	cbz	r1, 4f78 <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    4f6a:	ldr	r0, [r4, #32]
    4f6c:	bl	463e <ExFatPartition::freeChain(unsigned long)>
    4f70:	cbnz	r0, 4f78 <ExFatFile::truncate()+0x9c>
    4f72:	b.n	4ee8 <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    4f74:	movs	r0, #1
    4f76:	b.n	4f96 <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    4f78:	ldrd	r2, r3, [r4]
    4f7c:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    4f80:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    4f84:	ldrb.w	r3, [r4, #51]	; 0x33
    4f88:	orn	r3, r3, #127	; 0x7f
    4f8c:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    4f90:	mov	r0, r4
    4f92:	bl	4a84 <ExFatFile::sync()>

 fail:
  return false;
}
    4f96:	add	sp, #8
    4f98:	pop	{r4, r5, r6, pc}
    4f9a:	Address 0x00004f9a is out of bounds.


00004f9c <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4f9c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4fa0:	ldrb.w	r3, [r0, #51]	; 0x33
    4fa4:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    4fa6:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4fa8:	mov	r4, r0
    4faa:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    4fac:	bpl.w	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    4fb0:	lsls	r2, r3, #28
    4fb2:	bmi.n	4fc2 <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4fb4:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4fb8:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4fba:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    4fbc:	mov.w	fp, #1
    4fc0:	b.n	5088 <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    4fc2:	ldrd	r2, r3, [r0, #16]
    4fc6:	bl	3ec0 <ExFatFile::seekSet(unsigned long long)>
    4fca:	cmp	r0, #0
    4fcc:	bne.n	4fb4 <ExFatFile::write(void const*, unsigned int)+0x18>
    4fce:	b.n	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    4fd0:	ldr	r0, [r4, #32]
    4fd2:	ldr	r6, [r4, #0]
    4fd4:	ldr.w	r3, [r0, #1080]	; 0x438
    4fd8:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    4fda:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    4fde:	cmp	r6, #0
    4fe0:	beq.n	5090 <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    4fe2:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    4fe6:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4fe8:	ldrb.w	r2, [lr, #1093]	; 0x445
    4fec:	ldr.w	r3, [lr, #1068]	; 0x42c
    4ff0:	subs	r1, #2
    4ff2:	lsls	r1, r2
    4ff4:	lsrs	r6, r6, #9
    4ff6:	add	r1, r3
    4ff8:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    4ffa:	cmp	r5, #0
    4ffc:	bne.n	50f8 <ExFatFile::write(void const*, unsigned int)+0x15c>
    4ffe:	cmp.w	r8, #512	; 0x200
    5002:	bcs.w	513a <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    5006:	ldrd	r2, r3, [r4, #16]
    500a:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    500e:	cmp	r7, r3
    5010:	it	eq
    5012:	cmpeq	r6, r2
    5014:	ite	cc
    5016:	movcc	r2, #1
    5018:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    501a:	add.w	r0, lr, #528	; 0x210
    501e:	bl	33da <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    5022:	cmp	r0, #0
    5024:	beq.n	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    5026:	rsb	r6, r5, #512	; 0x200
    502a:	cmp	r6, r8
    502c:	it	cs
    502e:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    5030:	add	r0, r5
    5032:	mov	r2, r6
    5034:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    5036:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    5038:	bl	8b4c <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    503c:	cmp.w	r5, #512	; 0x200
    5040:	bne.n	5050 <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    5042:	ldr	r0, [r4, #32]
    5044:	add.w	r0, r0, #528	; 0x210
    5048:	bl	338e <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    504c:	cmp	r0, #0
    504e:	beq.n	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    5050:	ldrd	r0, r1, [r4]
    5054:	adds	r2, r0, r6
    5056:	adc.w	r3, r1, #0
    505a:	mov	r0, r2
    505c:	mov	r1, r3
    505e:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    5062:	ldrd	r2, r3, [r4, #16]
    5066:	cmp	r3, r1
    5068:	it	eq
    506a:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    506c:	add	r9, r6
    toWrite -= n;
    506e:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    5072:	bcs.n	5088 <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    5074:	ldrb.w	r3, [r4, #51]	; 0x33
    5078:	orn	r3, r3, #127	; 0x7f
    507c:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    5080:	mov	r2, r0
    5082:	mov	r3, r1
    5084:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    5088:	cmp.w	r8, #0
    508c:	bne.n	4fd0 <ExFatFile::write(void const*, unsigned int)+0x34>
    508e:	b.n	50fc <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    5090:	ldr	r7, [r4, #24]
    5092:	cbz	r7, 50e2 <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    5094:	ldrb.w	r3, [r4, #51]	; 0x33
    5098:	lsls	r3, r3, #25
    509a:	bpl.n	50d2 <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    509c:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    50a0:	ldr	r3, [r4, #28]
    50a2:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    50a4:	ldrd	r0, r1, [r4, #8]
    50a8:	adds	r2, #9
    50aa:	adds.w	r0, r0, #4294967295
    50ae:	adc.w	r1, r1, #4294967295
    50b2:	uxtb	r2, r2
    50b4:	bl	a430 <__aeabi_llsr>
    50b8:	ldr	r3, [sp, #4]
    50ba:	add	r0, r3
    50bc:	cmp	r7, r0
    50be:	bcc.n	50cc <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    50c0:	mov	r0, r4
    50c2:	bl	4838 <ExFatFile::addCluster()>
    50c6:	cmp	r0, #0
    50c8:	bne.n	4fe2 <ExFatFile::write(void const*, unsigned int)+0x46>
    50ca:	b.n	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    50cc:	adds	r7, #1
    50ce:	str	r7, [r4, #24]
    50d0:	b.n	4fe2 <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    50d2:	ldr	r2, [sp, #0]
    50d4:	mov	r1, r7
    50d6:	bl	4558 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    50da:	cmp	r0, #0
    50dc:	blt.n	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    50de:	bne.n	4fe2 <ExFatFile::write(void const*, unsigned int)+0x46>
    50e0:	b.n	50c0 <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    50e2:	ldr	r3, [r4, #28]
    50e4:	cbnz	r3, 50f4 <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    50e6:	mov	r0, r4
    50e8:	bl	4838 <ExFatFile::addCluster()>
    50ec:	cbz	r0, 5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    50ee:	ldr	r3, [r4, #24]
    50f0:	str	r3, [r4, #28]
    50f2:	b.n	4fe2 <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    50f4:	str	r3, [r4, #24]
    50f6:	b.n	4fe2 <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    50f8:	movs	r2, #1
    50fa:	b.n	501a <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    50fc:	ldrd	r0, r1, [r4]
    5100:	ldrd	r2, r3, [r4, #8]
    5104:	cmp	r3, r1
    5106:	it	eq
    5108:	cmpeq	r2, r0
    510a:	bcs.n	5112 <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    510c:	strd	r0, r1, [r4, #8]
    5110:	b.n	5118 <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    5112:	ldr	r3, [pc, #148]	; (51a8 <ExFatFile::write(void const*, unsigned int)+0x20c>)
    5114:	ldr	r3, [r3, #0]
    5116:	cbz	r3, 5136 <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5118:	ldrb.w	r3, [r4, #51]	; 0x33
    511c:	orn	r3, r3, #127	; 0x7f
    5120:	strb.w	r3, [r4, #51]	; 0x33
    5124:	b.n	5136 <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    5126:	ldrb.w	r3, [r4, #50]	; 0x32
    512a:	orr.w	r3, r3, #1
    512e:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    5132:	movs	r0, #0
    5134:	b.n	51a2 <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    5136:	mov	r0, sl
    5138:	b.n	51a2 <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    513a:	cmp.w	r8, #1024	; 0x400
    513e:	ldr.w	r7, [lr, #540]	; 0x21c
    5142:	ldr.w	r0, [lr, #532]	; 0x214
    5146:	bcc.n	5172 <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    5148:	lsl.w	r3, fp, r2
    514c:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    514e:	mov.w	ip, r8, lsr #9
    5152:	cmp	ip, r6
    5154:	mov	r3, ip
    5156:	it	cs
    5158:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    515a:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    515c:	mov.w	r6, r3, lsl #9
    5160:	bhi.n	5168 <ExFatFile::write(void const*, unsigned int)+0x1cc>
    5162:	adds	r2, r1, r3
    5164:	cmp	r7, r2
    5166:	bcc.n	5194 <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    5168:	ldr	r2, [r0, #0]
    516a:	ldr	r5, [r2, #36]	; 0x24
    516c:	mov	r2, r9
    516e:	blx	r5
    5170:	b.n	504c <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    5172:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    5174:	ittt	eq
    5176:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    517a:	moveq.w	r3, #4294967295
    517e:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    5182:	ldr	r3, [r0, #0]
    5184:	mov	r2, r9
    5186:	ldr	r3, [r3, #32]
    5188:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    518a:	cmp	r0, #0
    518c:	beq.n	5126 <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    518e:	mov.w	r6, #512	; 0x200
    5192:	b.n	5050 <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    5194:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    5198:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    519c:	str.w	r2, [lr, #540]	; 0x21c
    51a0:	b.n	5168 <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    51a2:	add	sp, #12
    51a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    51a8:	.word	0x20019e98

000051ac <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    51ac:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    51ae:	push	{r4, lr}
    51b0:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    51b2:	cbz	r0, 51cc <initFatDirCallback(unsigned long, void*)+0x20>
    51b4:	ldrh	r3, [r1, #8]
    51b6:	ldrh	r2, [r1, #10]
    51b8:	adds	r3, #1
    51ba:	uxth	r3, r3
    51bc:	cmp	r2, r3
    51be:	strh	r3, [r1, #8]
    51c0:	bhi.n	51cc <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    51c2:	ldr	r1, [pc, #12]	; (51d0 <initFatDirCallback(unsigned long, void*)+0x24>)
    51c4:	bl	884 <Print::write(char const*)>
    state->count = 0;
    51c8:	movs	r3, #0
    51ca:	strh	r3, [r4, #8]
  }
  return state->buffer;
    51cc:	ldr	r0, [r4, #0]
}
    51ce:	pop	{r4, pc}
    51d0:	.word	0x00012bcf

000051d4 <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    51d4:	push	{r4, r5, r6, r7, lr}
    51d6:	mov	r4, r0
    51d8:	sub	sp, #28
    51da:	mov	r6, r1
    51dc:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    51de:	movs	r1, #0
    51e0:	mov.w	r2, #512	; 0x200
    51e4:	ldr	r0, [r0, #36]	; 0x24
    51e6:	bl	8cf4 <memset>
  writeMsg("Writing FAT ");
    51ea:	ldr	r0, [r4, #32]
    51ec:	cbz	r0, 51f4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    51ee:	ldr	r1, [pc, #128]	; (5270 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    51f0:	bl	884 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    51f4:	ldr	r3, [r4, #36]	; 0x24
    51f6:	str	r3, [sp, #12]
  state.pr = m_pr;
    51f8:	ldr	r3, [r4, #32]
    51fa:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    51fc:	ldr	r0, [r4, #28]
    51fe:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    5200:	movs	r3, #0
    5202:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    5206:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5208:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    520a:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    520e:	ldr	r3, [r0, #0]
    5210:	str	r2, [sp, #0]
    5212:	ldr	r7, [r3, #40]	; 0x28
    5214:	ldr	r3, [pc, #92]	; (5274 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    5216:	subs	r2, r5, #1
    5218:	adds	r1, #1
    521a:	blx	r7
    521c:	cbnz	r0, 5222 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    521e:	movs	r0, #0
    5220:	b.n	526a <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    5222:	ldr	r0, [r4, #32]
    5224:	cbz	r0, 522c <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    5226:	ldr	r1, [pc, #80]	; (5278 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    5228:	bl	884 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    522c:	ldr	r3, [r4, #36]	; 0x24
    522e:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    5230:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    5232:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    5234:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    5238:	ite	eq
    523a:	moveq	r2, #4
    523c:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    523e:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    5240:	ldr	r1, [r4, #36]	; 0x24
    5242:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    5244:	adds	r3, #1
    5246:	cmp	r2, r3
    5248:	bne.n	5240 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    524a:	ldr	r0, [r4, #28]
    524c:	ldr	r2, [r4, #36]	; 0x24
    524e:	ldr	r3, [r0, #0]
    5250:	ldr	r1, [r4, #12]
    5252:	ldr	r3, [r3, #32]
    5254:	blx	r3
    5256:	cmp	r0, #0
    5258:	beq.n	521e <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    525a:	ldr	r0, [r4, #28]
    525c:	ldr	r5, [r4, #12]
    525e:	ldr	r1, [r4, #8]
    5260:	ldr	r3, [r0, #0]
    5262:	ldr	r2, [r4, #36]	; 0x24
    5264:	ldr	r3, [r3, #32]
    5266:	add	r1, r5
    5268:	blx	r3
}
    526a:	add	sp, #28
    526c:	pop	{r4, r5, r6, r7, pc}
    526e:	nop
    5270:	.word	0x00013004
    5274:	.word	0x000051ad
    5278:	.word	0x00013081

0000527c <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    527c:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    527e:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5280:	mov.w	r2, #512	; 0x200
    5284:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    5286:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5288:	mov	r0, r4
    528a:	bl	8cf4 <memset>
  pbs->jmpInstruction[0] = 0XEB;
    528e:	movs	r3, #235	; 0xeb
    5290:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    5292:	movs	r3, #118	; 0x76
    5294:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    5296:	mov	r3, r4
    5298:	movs	r2, #144	; 0x90
    529a:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    529e:	movs	r1, #32
    52a0:	add.w	r2, r4, #10
    52a4:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    52a8:	cmp	r3, r2
    52aa:	bne.n	52a4 <FatFormatter::initPbs()+0x28>
    52ac:	mov.w	r3, #512	; 0x200
    52b0:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    52b4:	ldrb.w	r3, [r5, #43]	; 0x2b
    52b8:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    52ba:	ldrh	r3, [r5, #40]	; 0x28
    52bc:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    52be:	movs	r3, #2
    52c0:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    52c2:	movs	r3, #248	; 0xf8
    52c4:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    52c6:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    52c8:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    52ca:	ldr	r3, [r5, #24]
    52cc:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    52ce:	movw	r3, #43605	; 0xaa55
    52d2:	strh.w	r3, [r4, #510]	; 0x1fe
    52d6:	pop	{r3, r4, r5, pc}

000052d8 <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    52d8:	push	{r4, r5, r6, lr}
    52da:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    52dc:	mov.w	r2, #512	; 0x200
    52e0:	movs	r1, #0
    52e2:	ldr	r0, [r0, #36]	; 0x24
    52e4:	bl	8cf4 <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    52e8:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    52ea:	ldr	r2, [r4, #16]
    52ec:	ldr	r1, [r4, #0]
    52ee:	addw	r0, r5, #447	; 0x1bf
    52f2:	bl	3300 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    52f6:	ldr	r3, [r4, #24]
    52f8:	ldr	r2, [r4, #16]
    52fa:	ldr	r1, [r4, #0]
    52fc:	add	r2, r3
    52fe:	addw	r0, r5, #451	; 0x1c3
    5302:	subs	r2, #1
    5304:	bl	3300 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    5308:	ldrb.w	r3, [r4, #42]	; 0x2a
    530c:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    5310:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5312:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    5316:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    5318:	ldr	r0, [r4, #28]
    531a:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    531e:	movw	r3, #43605	; 0xaa55
    5322:	strh.w	r3, [r5, #510]	; 0x1fe
    5326:	ldr	r3, [r0, #0]
    5328:	ldr	r2, [r4, #36]	; 0x24
    532a:	ldr	r3, [r3, #32]
    532c:	movs	r1, #0
}
    532e:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    5332:	bx	r3

00005334 <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    5334:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5336:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    533a:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    533c:	ldr.w	lr, [r0, #20]
    5340:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5344:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    5346:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    5348:	ldr	r3, [r4, #4]
    534a:	rsb	r1, r3, lr
    534e:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    5352:	addw	r6, r1, #257	; 0x101
    5356:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    5358:	lsls	r0, r6, #1
    535a:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    535e:	cmp	r3, r7
    5360:	bcc.n	5378 <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    5362:	subs	r3, r3, r7
    5364:	str	r6, [r4, #8]
    5366:	add.w	r6, r3, #128	; 0x80
    536a:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    536c:	subw	r6, r1, #4085	; 0xff5
    5370:	cmp.w	r6, #61440	; 0xf000
    5374:	bcs.n	537e <FatFormatter::makeFat16()+0x4a>
    5376:	b.n	538c <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5378:	adds	r3, #128	; 0x80
    537a:	str	r3, [r4, #4]
    537c:	b.n	5348 <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    537e:	ldr	r0, [r4, #32]
    5380:	cmp	r0, #0
    5382:	beq.n	542c <FatFormatter::makeFat16()+0xf8>
    5384:	ldr	r1, [pc, #168]	; (5430 <FatFormatter::makeFat16()+0xfc>)
    5386:	bl	884 <Print::write(char const*)>
    538a:	b.n	542c <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    538c:	adds	r3, #129	; 0x81
    538e:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    5390:	add.w	r3, r0, #33	; 0x21
    5394:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    5398:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    539c:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    539e:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    53a2:	ite	cc
    53a4:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    53a6:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    53a8:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    53aa:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    53ae:	mov	r0, r4
    53b0:	bl	52d8 <FatFormatter::writeMbr()>
    53b4:	cmp	r0, #0
    53b6:	beq.n	542c <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    53b8:	mov	r0, r4
    53ba:	bl	527c <FatFormatter::initPbs()>
    53be:	mov.w	r3, #512	; 0x200
    53c2:	strh.w	r3, [r5, #17]
    53c6:	ldr	r3, [r4, #8]
    53c8:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    53ca:	movs	r3, #128	; 0x80
    53cc:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    53d0:	movs	r3, #41	; 0x29
    53d2:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    53d6:	ldr	r3, [pc, #92]	; (5434 <FatFormatter::makeFat16()+0x100>)
    53d8:	str.w	r3, [r5, #39]	; 0x27
    53dc:	add.w	r2, r5, #53	; 0x35
    53e0:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    53e4:	movs	r1, #32
    53e6:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    53ea:	cmp	r3, r2
    53ec:	bne.n	53e6 <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    53ee:	movs	r3, #70	; 0x46
    53f0:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    53f4:	movs	r3, #65	; 0x41
    53f6:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    53fa:	movs	r3, #84	; 0x54
    53fc:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    5400:	movs	r3, #49	; 0x31
    5402:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    5406:	movs	r3, #54	; 0x36
    5408:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    540c:	ldr	r0, [r4, #28]
    540e:	ldr	r2, [r4, #36]	; 0x24
    5410:	ldr	r3, [r0, #0]
    5412:	ldr	r1, [r4, #16]
    5414:	ldr	r3, [r3, #32]
    5416:	blx	r3
    5418:	cbz	r0, 542c <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    541a:	ldr	r2, [r4, #4]
    541c:	ldr	r3, [r4, #12]
    541e:	mov	r0, r4
    5420:	subs	r2, r2, r3
    5422:	movs	r1, #16
}
    5424:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    5428:	b.w	51d4 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    542c:	movs	r0, #0
    542e:	pop	{r3, r4, r5, r6, r7, pc}
    5430:	.word	0x0001305b
    5434:	.word	0x0012d687

00005438 <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    5438:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    543a:	mov.w	r3, #8192	; 0x2000
    543e:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    5440:	mov.w	r3, #16384	; 0x4000
    5444:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    5446:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    5448:	ldr	r3, [r0, #20]
    544a:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    544e:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    5450:	ldr	r2, [r4, #4]
    5452:	subs	r0, r3, r2
    5454:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    5458:	add.w	r6, r0, #129	; 0x81
    545c:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    545e:	mov.w	lr, r6, lsl #1
    5462:	add.w	r7, lr, #8192	; 0x2000
    5466:	adds	r7, #9
    5468:	cmp	r2, r7
    546a:	bcs.n	5474 <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    546c:	add.w	r2, r2, #8192	; 0x2000
    5470:	str	r2, [r4, #4]
    5472:	b.n	5450 <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    5474:	movw	r3, #65524	; 0xfff4
    5478:	cmp	r0, r3
    547a:	str	r6, [r4, #8]
    547c:	bhi.n	548e <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    547e:	ldr	r0, [r4, #32]
    5480:	cmp	r0, #0
    5482:	beq.w	55c6 <FatFormatter::makeFat32()+0x18e>
    5486:	ldr	r1, [pc, #324]	; (55cc <FatFormatter::makeFat32()+0x194>)
    5488:	bl	884 <Print::write(char const*)>
    548c:	b.n	55c6 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    548e:	sub.w	r3, r2, #8192	; 0x2000
    5492:	rsb	r3, lr, r3
    5496:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5498:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    549c:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    549e:	add.w	r3, r3, #8192	; 0x2000
    54a2:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    54a4:	sub.w	r3, r2, #8192	; 0x2000
    54a8:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    54aa:	ldr	r3, [pc, #292]	; (55d0 <FatFormatter::makeFat32()+0x198>)
    54ac:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    54ae:	ite	ls
    54b0:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    54b2:	movhi	r3, #12
    54b4:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    54b8:	mov	r0, r4
    54ba:	bl	52d8 <FatFormatter::writeMbr()>
    54be:	cmp	r0, #0
    54c0:	beq.w	55c6 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    54c4:	mov	r0, r4
    54c6:	bl	527c <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    54ca:	ldr	r3, [r4, #8]
    54cc:	str	r3, [r5, #36]	; 0x24
    54ce:	movs	r3, #2
    54d0:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    54d2:	movs	r3, #1
    54d4:	strh	r3, [r5, #48]	; 0x30
    54d6:	movs	r3, #6
    54d8:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    54da:	movs	r3, #128	; 0x80
    54dc:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    54e0:	movs	r3, #41	; 0x29
    54e2:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    54e6:	ldr	r3, [pc, #236]	; (55d4 <FatFormatter::makeFat32()+0x19c>)
    54e8:	str.w	r3, [r5, #67]	; 0x43
    54ec:	add.w	r2, r5, #81	; 0x51
    54f0:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    54f4:	movs	r1, #32
    54f6:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    54fa:	cmp	r3, r2
    54fc:	bne.n	54f6 <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    54fe:	movs	r3, #70	; 0x46
    5500:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    5504:	movs	r3, #65	; 0x41
    5506:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    550a:	movs	r3, #84	; 0x54
    550c:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    5510:	movs	r3, #51	; 0x33
    5512:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    5516:	movs	r3, #50	; 0x32
    5518:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    551c:	ldr	r0, [r4, #28]
    551e:	ldr	r2, [r4, #36]	; 0x24
    5520:	ldr	r3, [r0, #0]
    5522:	ldr	r1, [r4, #16]
    5524:	ldr	r3, [r3, #32]
    5526:	blx	r3
    5528:	cmp	r0, #0
    552a:	beq.n	55c6 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    552c:	ldr	r0, [r4, #28]
    552e:	ldr	r1, [r4, #16]
    5530:	ldr	r3, [r0, #0]
    5532:	ldr	r2, [r4, #36]	; 0x24
    5534:	ldr	r3, [r3, #32]
    5536:	adds	r1, #6
    5538:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    553a:	cmp	r0, #0
    553c:	beq.n	55c6 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    553e:	mov.w	r2, #512	; 0x200
    5542:	movs	r1, #0
    5544:	ldr	r0, [r4, #36]	; 0x24
    5546:	bl	8cf4 <memset>
    554a:	ldr	r3, [pc, #140]	; (55d8 <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    554c:	ldr	r0, [r4, #28]
    554e:	str.w	r3, [r5, #508]	; 0x1fc
    5552:	ldr	r1, [r4, #16]
    5554:	ldr	r3, [r0, #0]
    5556:	ldr	r2, [r4, #36]	; 0x24
    5558:	ldr	r3, [r3, #32]
    555a:	adds	r1, #2
    555c:	blx	r3
    555e:	cmp	r0, #0
    5560:	beq.n	55c6 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    5562:	ldr	r0, [r4, #28]
    5564:	ldr	r1, [r4, #16]
    5566:	ldr	r3, [r0, #0]
    5568:	ldr	r2, [r4, #36]	; 0x24
    556a:	ldr	r3, [r3, #32]
    556c:	adds	r1, #8
    556e:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    5570:	cbz	r0, 55c6 <FatFormatter::makeFat32()+0x18e>
    5572:	ldr	r3, [pc, #104]	; (55dc <FatFormatter::makeFat32()+0x1a4>)
    5574:	str	r3, [r5, #0]
    5576:	add.w	r3, r3, #534773760	; 0x1fe00000
    557a:	add.w	r3, r3, #8192	; 0x2000
    557e:	adds	r3, #32
    5580:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    5584:	ldr	r0, [r4, #28]
    5586:	ldr	r2, [r4, #36]	; 0x24
    5588:	mov.w	r3, #4294967295
    558c:	str.w	r3, [r5, #488]	; 0x1e8
    5590:	str.w	r3, [r5, #492]	; 0x1ec
    5594:	ldr	r1, [r4, #16]
    5596:	ldr	r3, [r0, #0]
    5598:	adds	r1, #1
    559a:	ldr	r3, [r3, #32]
    559c:	blx	r3
    559e:	cbz	r0, 55c6 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    55a0:	ldr	r0, [r4, #28]
    55a2:	ldr	r1, [r4, #16]
    55a4:	ldr	r3, [r0, #0]
    55a6:	ldr	r2, [r4, #36]	; 0x24
    55a8:	ldr	r3, [r3, #32]
    55aa:	adds	r1, #7
    55ac:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    55ae:	cbz	r0, 55c6 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    55b0:	ldr	r2, [r4, #8]
    55b2:	ldrb.w	r3, [r4, #43]	; 0x2b
    55b6:	mov	r0, r4
    55b8:	add.w	r2, r3, r2, lsl #1
    55bc:	movs	r1, #32
}
    55be:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    55c2:	b.w	51d4 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    55c6:	movs	r0, #0
    55c8:	pop	{r3, r4, r5, r6, r7, pc}
    55ca:	nop
    55cc:	.word	0x0001305b
    55d0:	.word	0x00fb0400
    55d4:	.word	0x0012d687
    55d8:	.word	0xaa550000
    55dc:	.word	0x41615252

000055e0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    55e0:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    55e2:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    55e4:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    55e6:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    55e8:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    55ea:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    55ec:	ldr	r3, [r3, #24]
    55ee:	mov	r0, r1
    55f0:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    55f2:	addw	r3, r0, #2047	; 0x7ff
    55f6:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    55f8:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    55fa:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    55fc:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    55fe:	bhi.n	560e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    5600:	ldr	r0, [r4, #32]
    5602:	cbz	r0, 560a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5604:	ldr	r1, [pc, #108]	; (5674 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    5606:	bl	884 <Print::write(char const*)>
    return false;
    560a:	movs	r0, #0
    560c:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    560e:	cmp	r3, #16
    5610:	bhi.n	5616 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    5612:	movs	r3, #2
    5614:	b.n	5642 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    5616:	cmp	r3, #32
    5618:	bhi.n	561e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    561a:	movs	r3, #4
    561c:	b.n	5642 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    561e:	cmp	r3, #64	; 0x40
    5620:	bhi.n	5626 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    5622:	movs	r3, #8
    5624:	b.n	5642 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    5626:	cmp	r3, #128	; 0x80
    5628:	bhi.n	562e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    562a:	movs	r3, #16
    562c:	b.n	5642 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    562e:	cmp.w	r3, #1024	; 0x400
    5632:	bhi.n	5638 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    5634:	movs	r3, #32
    5636:	b.n	5642 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    5638:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    563c:	ite	ls
    563e:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5640:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5642:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5646:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    564a:	mov	r0, r4
    564c:	bcs.n	5654 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    564e:	bl	5334 <FatFormatter::makeFat16()>
    5652:	b.n	5658 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    5654:	bl	5438 <FatFormatter::makeFat32()>
    5658:	mov	r5, r0
    565a:	ldr	r0, [r4, #32]
  if (rtn) {
    565c:	cbz	r5, 5668 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    565e:	cbz	r0, 5670 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    5660:	ldr	r1, [pc, #20]	; (5678 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    5662:	bl	884 <Print::write(char const*)>
    5666:	b.n	5670 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    5668:	cmp	r0, #0
    566a:	beq.n	560a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    566c:	ldr	r1, [pc, #12]	; (567c <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    566e:	b.n	5606 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    5670:	movs	r0, #1
  }
  return rtn;
}
    5672:	pop	{r3, r4, r5, pc}
    5674:	.word	0x0001306f
    5678:	.word	0x00013084
    567c:	.word	0x00013092

00005680 <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5680:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5682:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5684:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5686:	bl	5b7e <FatFile::seekSet(unsigned long)>
    568a:	cbz	r0, 5698 <FatFile::cacheDir(unsigned short)+0x18>
    568c:	mov	r0, r4
    568e:	movs	r1, #0
  }
    5690:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5694:	b.w	5b44 <FatFile::readDirCache(bool)>
  }
    5698:	pop	{r4, pc}

0000569a <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    569a:	cmp	r2, #4
    569c:	bhi.n	56a8 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    569e:	add.w	r1, r1, r2, lsl #1
    56a2:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    56a6:	bx	lr
  } else if (i < 11) {
    56a8:	cmp	r2, #10
    56aa:	bhi.n	56b4 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    56ac:	add.w	r1, r1, r2, lsl #1
    56b0:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    56b2:	bx	lr
  } else if (i < 13) {
    56b4:	cmp	r2, #12
    56b6:	itte	ls
    56b8:	addls.w	r1, r1, r2, lsl #1
    56bc:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    56be:	movhi	r0, #0
}
    56c0:	bx	lr

000056c2 <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    56c2:	push	{r3, r4, r5, r6, r7, lr}
    56c4:	mov	r6, r1
    56c6:	ldrb	r1, [r0, #0]
    56c8:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    56ca:	cbz	r1, 5744 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    56cc:	ands.w	r4, r1, #96	; 0x60
    56d0:	beq.n	56e2 <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    56d2:	cmp	r2, #1
    56d4:	bls.n	5744 <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    56d6:	movs	r3, #47	; 0x2f
    56d8:	strb	r3, [r6, #0]
    name[1] = '\0';
    56da:	movs	r3, #0
    56dc:	strb	r3, [r6, #1]
    return 1;
    56de:	movs	r0, #1
    56e0:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    56e2:	mov	r1, r4
    56e4:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    56e8:	cbz	r0, 5744 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    56ea:	mov	r5, r0
    56ec:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    56ee:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    56f0:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    56f2:	cmp	r1, #8
    56f4:	ldrb	r4, [r5, #0]
    56f6:	bne.n	5702 <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    56f8:	cmp	r4, #32
    56fa:	beq.n	573c <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    56fc:	movs	r2, #16
      c = '.';
    56fe:	movs	r4, #46	; 0x2e
    5700:	b.n	5724 <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5702:	sub.w	lr, r4, #65	; 0x41
    5706:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    570a:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    570e:	bhi.n	5720 <FatFile::getSFN(char*, unsigned int)+0x5e>
    5710:	ldrb.w	lr, [r0, #12]
    5714:	tst.w	r2, lr
    5718:	beq.n	5724 <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    571a:	adds	r4, #32
    571c:	uxtb	r4, r4
    571e:	b.n	5724 <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    5720:	cmp	r4, #32
    5722:	beq.n	5736 <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    5724:	add.w	lr, r3, #1
    5728:	cmp	r7, lr
    572a:	mov	ip, r3
    572c:	beq.n	573c <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    572e:	strb.w	r4, [r6, ip]
    5732:	uxtb.w	r3, lr
    5736:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    5738:	cmp	r1, #12
    573a:	bne.n	56f2 <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    573c:	movs	r2, #0
    573e:	strb	r2, [r6, r3]
  return j;
    5740:	mov	r0, r3
    5742:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    5744:	movs	r0, #0
    5746:	strb	r0, [r6, #0]
  return 0;
}
    5748:	pop	{r3, r4, r5, r6, r7, pc}
    574a:	Address 0x0000574a is out of bounds.


0000574c <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    574c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5750:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5752:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5754:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5756:	mov	r7, r0
    5758:	mov	r9, r1
    575a:	mov	r8, r2
    575c:	strb.w	r4, [sp, #4]
    5760:	strb.w	r4, [sp, #5]
    5764:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5768:	cmp	r3, #0
    576a:	beq.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    576c:	ldrb	r3, [r0, #3]
    576e:	cbnz	r3, 5776 <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    5770:	bl	56c2 <FatFile::getSFN(char*, unsigned int)>
    5774:	b.n	5832 <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    5776:	mov	r1, r0
    5778:	add	r0, sp, #4
    577a:	bl	5976 <FatFile::openCluster(FatFile*)>
    577e:	cmp	r0, #0
    5780:	beq.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5782:	add.w	r8, r8, #4294967295
    5786:	mov	r5, r9
    5788:	movs	r6, #1
    578a:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    578c:	ldrb	r3, [r7, #3]
    578e:	cmp	r3, r6
    5790:	bcc.n	5822 <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    5792:	ldrh	r1, [r7, #4]
    5794:	subs	r1, r1, r6
    5796:	uxth	r1, r1
    5798:	add	r0, sp, #4
    579a:	bl	5680 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    579e:	mov	fp, r0
    57a0:	cmp	r0, #0
    57a2:	beq.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    57a4:	ldrb	r3, [r0, #11]
    57a6:	cmp	r3, #15
    57a8:	bne.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
    57aa:	ldrb	r3, [r0, #0]
    57ac:	and.w	r3, r3, #31
    57b0:	cmp	r6, r3
    57b2:	bne.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
    57b4:	mov	r3, r4
    57b6:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    57ba:	uxtb.w	r2, sl
    57be:	mov	r1, fp
    57c0:	mov	r0, r7
    57c2:	bl	569a <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    57c6:	mov	r4, r0
      if (hs) {
    57c8:	cbz	r3, 57e8 <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    57ca:	add.w	r2, r0, #9216	; 0x2400
    57ce:	uxth	r2, r2
    57d0:	cmp.w	r2, #1024	; 0x400
    57d4:	bcs.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    57d6:	ldr	r0, [pc, #96]	; (5838 <FatFile::getName8(char*, unsigned int)+0xec>)
    57d8:	lsls	r3, r3, #10
    57da:	ands	r0, r3
    57dc:	ubfx	r4, r4, #0, #10
    57e0:	orrs	r4, r0
    57e2:	add.w	r0, r4, #65536	; 0x10000
    57e6:	b.n	5800 <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    57e8:	add.w	r3, r0, #10240	; 0x2800
    57ec:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    57ee:	cmp.w	r3, #2048	; 0x800
    57f2:	bcc.n	57f8 <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    57f4:	cbnz	r0, 5800 <FatFile::getName8(char*, unsigned int)+0xb4>
    57f6:	b.n	5822 <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    57f8:	cmp.w	r3, #1024	; 0x400
    57fc:	bcc.n	580e <FatFile::getName8(char*, unsigned int)+0xc2>
    57fe:	b.n	582c <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5800:	mov	r2, r8
    5802:	mov	r1, r5
    5804:	bl	3038 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5808:	cbz	r0, 5822 <FatFile::getName8(char*, unsigned int)+0xd6>
    580a:	mov	r5, r0
    580c:	movs	r4, #0
    580e:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    5812:	cmp.w	sl, #13
    5816:	beq.n	581c <FatFile::getName8(char*, unsigned int)+0xd0>
    5818:	mov	r3, r4
    581a:	b.n	57ba <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    581c:	adds	r6, #1
    581e:	uxtb	r6, r6
    5820:	b.n	578c <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    5822:	movs	r3, #0
    5824:	strb	r3, [r5, #0]
  return str - name;
    5826:	rsb	r0, r9, r5
    582a:	b.n	5832 <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    582c:	movs	r0, #0
    582e:	strb.w	r0, [r9]
  return 0;
}
    5832:	add	sp, #44	; 0x2c
    5834:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5838:	.word	0x000ffc00

0000583c <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    583c:	b.w	574c <FatFile::getName8(char*, unsigned int)>

00005840 <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    5840:	push	{r4, lr}
    5842:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5844:	adds	r0, #40	; 0x28
    5846:	bl	338e <FsCache::sync()>
    584a:	cbz	r0, 5862 <FatPartition::cacheSync()+0x22>
    584c:	add.w	r0, r4, #568	; 0x238
    5850:	bl	338e <FsCache::sync()>
    5854:	cbz	r0, 5862 <FatPartition::cacheSync()+0x22>
    5856:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5858:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    585a:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    585e:	ldr	r3, [r3, #28]
    5860:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5862:	movs	r0, #0
    5864:	pop	{r4, pc}

00005866 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5866:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5868:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    586a:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    586e:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    5870:	mov	r1, r5
    5872:	ldr	r0, [r0, #8]
    5874:	bl	67b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    5878:	cbz	r0, 589a <FatFile::addCluster()+0x34>
    587a:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    587c:	cbnz	r5, 5884 <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    587e:	orr.w	r3, r3, #64	; 0x40
    5882:	b.n	5890 <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    5884:	ldr	r2, [r4, #16]
    5886:	adds	r5, #1
    5888:	cmp	r2, r5
    588a:	beq.n	5892 <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    588c:	bic.w	r3, r3, #64	; 0x40
    5890:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5892:	ldrb	r3, [r4, #2]
    5894:	orn	r3, r3, #127	; 0x7f
    5898:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    589a:	pop	{r3, r4, r5, pc}

0000589c <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    589c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    58a0:	ldrb	r3, [r0, #0]
    58a2:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    58a6:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    58a8:	and.w	r5, r3, #255	; 0xff
    58ac:	cbz	r3, 58b2 <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    58ae:	movs	r6, #0
    58b0:	b.n	591c <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    58b2:	ldr	r2, [r0, #20]
    58b4:	ldr	r3, [pc, #108]	; (5924 <FatFile::addDirCluster()+0x88>)
    58b6:	cmp	r2, r3
    58b8:	bhi.n	58ae <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    58ba:	bl	5866 <FatFile::addCluster()>
    58be:	mov	r6, r0
    58c0:	cmp	r0, #0
    58c2:	beq.n	58ae <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    58c4:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    58c6:	ldr	r1, [r4, #16]
    58c8:	ldrb	r3, [r0, #6]
    58ca:	ldr	r7, [r0, #20]
    58cc:	subs	r1, #2
    58ce:	lsls	r1, r3
    58d0:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    58d2:	movs	r2, #5
    58d4:	mov	r1, r7
    58d6:	adds	r0, #40	; 0x28
    58d8:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    58dc:	mov	r8, r0
    58de:	cmp	r0, #0
    58e0:	beq.n	58ae <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    58e2:	mov	r1, r5
    58e4:	mov.w	r2, #512	; 0x200
    58e8:	bl	8cf4 <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    58ec:	movs	r5, #1
    58ee:	ldr	r3, [r4, #8]
    58f0:	ldrb	r2, [r3, #4]
    58f2:	cmp	r2, r5
    58f4:	bls.n	590c <FatFile::addDirCluster()+0x70>
    58f6:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    58f8:	ldr	r3, [r0, #0]
    58fa:	mov	r2, r8
    58fc:	ldr	r3, [r3, #32]
    58fe:	adds	r1, r5, r7
    5900:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5902:	cmp	r0, #0
    5904:	beq.n	58ae <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5906:	adds	r5, #1
    5908:	uxtb	r5, r5
    590a:	b.n	58ee <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    590c:	ldrb	r2, [r3, #6]
    590e:	mov.w	r3, #512	; 0x200
    5912:	lsls	r3, r2
    5914:	ldr	r2, [r4, #20]
    5916:	uxtah	r3, r2, r3
    591a:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    591c:	mov	r0, r6
    591e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5922:	nop
    5924:	.word	0x001ffdff

00005928 <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5928:	push	{r4, lr}
    592a:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    592c:	ldr	r0, [r0, #8]
    592e:	mov	r2, r1
    5930:	adds	r0, #40	; 0x28
    5932:	ldr	r1, [r4, #24]
    5934:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    5938:	cbz	r0, 5944 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    593a:	ldrh	r3, [r4, #4]
    593c:	and.w	r3, r3, #15
    5940:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    5944:	pop	{r4, pc}

00005946 <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5946:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    5948:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    594a:	mov	r5, r0
    594c:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    594e:	cbnz	r4, 5972 <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    5950:	movs	r2, #36	; 0x24
    5952:	mov	r1, r4
    5954:	bl	8cf4 <memset>

  m_vol = vol;
    5958:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    595a:	ldrb	r3, [r6, #7]
    595c:	cmp	r3, #16
    595e:	beq.n	5968 <FatFile::openRoot(FatVolume*)+0x22>
    5960:	cmp	r3, #32
    5962:	bne.n	5972 <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5964:	movs	r3, #64	; 0x40
    5966:	b.n	596a <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5968:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    596a:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    596c:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    596e:	strb	r0, [r5, #2]
    5970:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    5972:	movs	r0, #0
    5974:	pop	{r4, r5, r6, pc}

00005976 <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5976:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    5978:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    597a:	mov	r4, r0
    597c:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    597e:	cbnz	r3, 598a <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    5980:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    5982:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    5986:	b.w	5946 <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    598a:	movs	r2, #36	; 0x24
    598c:	movs	r1, #0
    598e:	bl	8cf4 <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    5992:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5994:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5996:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5998:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    599a:	ldr	r3, [r5, #8]
    599c:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    599e:	ldr	r3, [r5, #12]
    59a0:	str	r3, [r4, #32]
  return true;
}
    59a2:	pop	{r3, r4, r5, pc}

000059a4 <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    59a4:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    59a8:	ldrb	r3, [r0, #2]
    59aa:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    59ac:	mov	r4, r0
    59ae:	mov	r9, r1
    59b0:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    59b2:	bpl.n	5aa4 <FatFile::read(void*, unsigned int)+0x100>
    59b4:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    59b6:	lsls	r0, r3, #28
    59b8:	bpl.n	59c2 <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    59ba:	ldr	r3, [r4, #28]
    59bc:	ldr	r2, [r4, #20]
    59be:	subs	r3, r3, r2
    59c0:	b.n	59d2 <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    59c2:	lsls	r1, r3, #26
    59c4:	bpl.n	59d8 <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    59c6:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    59c8:	ldrh	r2, [r3, #8]
    59ca:	ldr	r3, [r4, #20]
    59cc:	rsb	r3, r3, r2, lsl #5
    59d0:	uxth	r3, r3
    59d2:	cmp	r6, r3
    59d4:	it	cs
    59d6:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    59d8:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    59da:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    59de:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    59e2:	cmp	r7, #0
    59e4:	beq.n	5a6a <FatFile::read(void*, unsigned int)+0xc6>
    59e6:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    59e8:	ldr	r2, [r4, #20]
    59ea:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    59ec:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    59f0:	ubfx	r5, r2, #0, #9
    59f4:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    59f8:	beq.n	5a00 <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    59fa:	ldr	r3, [r0, #32]
    59fc:	add	r1, r3
    59fe:	b.n	5a4a <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    5a00:	ldrb.w	r8, [r0, #5]
    5a04:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5a08:	cbnz	r5, 5a3a <FatFile::read(void*, unsigned int)+0x96>
    5a0a:	cmp.w	r8, #0
    5a0e:	bne.n	5a3a <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    5a10:	cbnz	r2, 5a1c <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5a12:	lsls	r2, r3, #25
    5a14:	ite	mi
    5a16:	ldrmi	r3, [r0, #32]
    5a18:	ldrpl	r3, [r4, #32]
    5a1a:	b.n	5ab2 <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    5a1c:	lsls	r3, r3, #28
    5a1e:	bpl.n	5a2c <FatFile::read(void*, unsigned int)+0x88>
    5a20:	ldrb	r3, [r4, #2]
    5a22:	lsls	r1, r3, #25
    5a24:	bpl.n	5a2c <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    5a26:	ldr	r3, [r4, #16]
    5a28:	adds	r3, #1
    5a2a:	b.n	5ab2 <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5a2c:	mov	r2, sl
    5a2e:	ldr	r1, [r4, #16]
    5a30:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    5a34:	cmp	r0, #0
    5a36:	blt.n	5aa4 <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    5a38:	beq.n	5a62 <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    5a3a:	ldr	r3, [r4, #8]
    5a3c:	ldr	r1, [r4, #16]
    5a3e:	ldrb	r2, [r3, #6]
    5a40:	ldr	r3, [r3, #20]
    5a42:	subs	r1, #2
    5a44:	lsls	r1, r2
    5a46:	add	r1, r3
    5a48:	add	r1, r8
    5a4a:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    5a4e:	cmp	r5, #0
    5a50:	bne.n	5af2 <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    5a52:	cmp.w	r7, #512	; 0x200
    5a56:	bcc.n	5af2 <FatFile::read(void*, unsigned int)+0x14e>
    5a58:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    5a5c:	cmp	r1, r3
    5a5e:	bne.n	5a6e <FatFile::read(void*, unsigned int)+0xca>
    5a60:	b.n	5af2 <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    5a62:	ldrb	r3, [r4, #0]
    5a64:	tst.w	r3, #112	; 0x70
    5a68:	beq.n	5aa4 <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    5a6a:	subs	r0, r6, r7
    5a6c:	b.n	5b16 <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    5a6e:	cmp.w	r7, #1024	; 0x400
    5a72:	bcc.n	5ad0 <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    5a74:	ldrb	r2, [r4, #0]
    5a76:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    5a78:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    5a7c:	bmi.n	5a8c <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    5a7e:	ldrb.w	r2, [fp, #4]
    5a82:	rsb	r2, r8, r2
    5a86:	cmp	r5, r2
    5a88:	it	cs
    5a8a:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5a8c:	cmp	r1, r3
    5a8e:	bhi.n	5ab6 <FatFile::read(void*, unsigned int)+0x112>
    5a90:	adds	r2, r1, r5
    5a92:	cmp	r3, r2
    5a94:	bcs.n	5ab6 <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5a96:	add.w	r0, fp, #40	; 0x28
    5a9a:	str	r1, [sp, #4]
    5a9c:	bl	338e <FsCache::sync()>
    5aa0:	ldr	r1, [sp, #4]
    5aa2:	cbnz	r0, 5ab6 <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5aa4:	ldrb	r3, [r4, #1]
    5aa6:	orr.w	r3, r3, #2
    5aaa:	strb	r3, [r4, #1]
  return -1;
    5aac:	mov.w	r0, #4294967295
    5ab0:	b.n	5b16 <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    5ab2:	str	r3, [r4, #16]
    5ab4:	b.n	5a3a <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5ab6:	ldr.w	r0, [fp, #44]	; 0x2c
    5aba:	ldr	r3, [r0, #0]
    5abc:	mov	r2, r9
    5abe:	ldr.w	fp, [r3, #16]
    5ac2:	mov	r3, r5
    5ac4:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5ac6:	cmp	r0, #0
    5ac8:	beq.n	5aa4 <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5aca:	mov.w	fp, r5, lsl #9
    5ace:	b.n	5ae4 <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    5ad0:	ldr.w	r0, [fp, #44]	; 0x2c
    5ad4:	ldr	r3, [r0, #0]
    5ad6:	mov	r2, r9
    5ad8:	ldr	r3, [r3, #12]
    5ada:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    5adc:	cmp	r0, #0
    5ade:	beq.n	5aa4 <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    5ae0:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5ae4:	ldr	r3, [r4, #20]
    5ae6:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5ae8:	add	r9, fp
    m_curPosition += n;
    5aea:	str	r3, [r4, #20]
    toRead -= n;
    5aec:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5af0:	b.n	59e2 <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5af2:	movs	r2, #0
    5af4:	add.w	r0, fp, #40	; 0x28
    5af8:	bl	33da <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    5afc:	cmp	r0, #0
    5afe:	beq.n	5aa4 <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    5b00:	rsb	fp, r5, #512	; 0x200
    5b04:	cmp	fp, r7
    5b06:	it	cs
    5b08:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    5b0a:	adds	r1, r0, r5
    5b0c:	mov	r2, fp
    5b0e:	mov	r0, r9
    5b10:	bl	8b4c <memcpy>
    5b14:	b.n	5ae4 <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5b16:	add	sp, #12
    5b18:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005b1c <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    5b1c:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    5b1e:	movs	r2, #1
    5b20:	add.w	r1, sp, #7
    5b24:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    5b26:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    5b28:	ldr	r5, [r0, #16]
    5b2a:	bl	59a4 <FatFile::read(void*, unsigned int)>
    5b2e:	cmp	r0, #1
    5b30:	it	eq
    5b32:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    5b36:	str	r6, [r4, #20]
    5b38:	it	ne
    5b3a:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    5b3e:	str	r5, [r4, #16]
  return c;
}
    5b40:	add	sp, #8
    5b42:	pop	{r4, r5, r6, pc}

00005b44 <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5b44:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5b46:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5b48:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5b4c:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    5b4e:	cbz	r5, 5b52 <FatFile::readDirCache(bool)+0xe>
    5b50:	cbnz	r1, 5b6e <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    5b52:	movs	r2, #1
    5b54:	add.w	r1, sp, #7
    5b58:	mov	r0, r4
    5b5a:	bl	59a4 <FatFile::read(void*, unsigned int)>
    5b5e:	sxtb	r0, r0
    if  (n != 1) {
    5b60:	cmp	r0, #1
    5b62:	beq.n	5b68 <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    5b64:	movs	r0, #0
    5b66:	b.n	5b7a <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    5b68:	ldr	r3, [r4, #20]
    5b6a:	adds	r3, #31
    5b6c:	b.n	5b70 <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    5b6e:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    5b70:	ldr	r0, [r4, #8]
    5b72:	str	r3, [r4, #20]
    5b74:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    5b76:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    5b7a:	add	sp, #12
    5b7c:	pop	{r4, r5, pc}

00005b7e <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5b7e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5b82:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    5b84:	ldr	r7, [r0, #16]
    5b86:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5b88:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    5b8a:	cmp	r0, #0
    5b8c:	beq.n	5c1c <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    5b8e:	ldr	r5, [r4, #20]
    5b90:	cmp	r5, r1
    5b92:	beq.n	5c24 <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    5b94:	cbnz	r1, 5b9a <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    5b96:	str	r1, [r4, #16]
    goto done;
    5b98:	b.n	5c10 <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    5b9a:	lsls	r2, r0, #28
    5b9c:	bpl.n	5ba6 <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    5b9e:	ldr	r3, [r4, #28]
    5ba0:	cmp	r1, r3
    5ba2:	bhi.n	5c1c <FatFile::seekSet(unsigned long)+0x9e>
    5ba4:	b.n	5bb6 <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    5ba6:	lsls	r3, r0, #26
    5ba8:	bpl.n	5bb6 <FatFile::seekSet(unsigned long)+0x38>
    5baa:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    5bac:	ldrh	r3, [r3, #8]
    5bae:	cmp.w	r1, r3, lsl #5
    5bb2:	bhi.n	5c1c <FatFile::seekSet(unsigned long)+0x9e>
    5bb4:	b.n	5c10 <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5bb6:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5bba:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5bbc:	ldrb.w	r2, [lr, #6]
    5bc0:	adds	r2, #9
    5bc2:	uxtb	r2, r2
    5bc4:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5bc6:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5bc8:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5bcc:	bpl.n	5bd6 <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    5bce:	ldr	r2, [r4, #32]
    5bd0:	add	r3, r2
    5bd2:	str	r3, [r4, #16]
    goto done;
    5bd4:	b.n	5c10 <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    5bd6:	subs	r1, r5, #1
    5bd8:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    5bdc:	cmp	r3, r2
    5bde:	bcc.n	5be2 <FatFile::seekSet(unsigned long)+0x64>
    5be0:	cbnz	r5, 5bf6 <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5be2:	lsls	r2, r0, #25
    5be4:	ite	mi
    5be6:	ldrmi.w	r2, [lr, #32]
    5bea:	ldrpl	r2, [r4, #32]
    5bec:	str	r2, [r4, #16]
    5bee:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    5bf0:	add.w	r8, r4, #16
    5bf4:	b.n	5c0c <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    5bf6:	subs	r3, r3, r2
    5bf8:	b.n	5bee <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    5bfa:	mov	r2, r8
    5bfc:	ldr	r1, [r4, #16]
    5bfe:	ldr	r0, [r4, #8]
    5c00:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
    5c04:	cmp	r0, #0
    5c06:	add.w	r5, r5, #4294967295
    5c0a:	ble.n	5c1c <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    5c0c:	cmp	r5, #0
    5c0e:	bne.n	5bfa <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5c10:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    5c12:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5c14:	bic.w	r3, r3, #32
    5c18:	strb	r3, [r4, #2]
    5c1a:	b.n	5c24 <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    5c1c:	str	r7, [r4, #16]
  return false;
    5c1e:	movs	r0, #0
    5c20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    5c24:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    5c26:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005c2a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    5c2a:	push	{r3, r4, r5, r6, r7, lr}
    5c2c:	mov	r7, r1
    5c2e:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    5c30:	movs	r1, #0
    5c32:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    5c34:	mov	r4, r0
    5c36:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    5c38:	bl	8cf4 <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    5c3c:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    5c3e:	strh	r6, [r4, #4]
    5c40:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    5c44:	and.w	r6, r6, #15
    5c48:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    5c4c:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    5c4e:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    5c50:	str	r3, [r4, #12]
    5c52:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    5c54:	lsls	r6, r1, #28
    5c56:	bmi.n	5cd6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    5c58:	and.w	r1, r1, #23
    5c5c:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    5c5e:	ldrb	r3, [r2, #11]
    5c60:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    5c64:	ldrb.w	r3, [sp, #24]
    5c68:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    5c6a:	it	eq
    5c6c:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    5c70:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    5c74:	it	eq
    5c76:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    5c78:	cmp	r3, #1
    5c7a:	beq.n	5c8e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    5c7c:	cmp	r3, #2
    5c7e:	beq.n	5c8a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    5c80:	cbnz	r3, 5cd6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    5c82:	lsls	r3, r5, #21
    5c84:	bmi.n	5cd6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    5c86:	movs	r3, #1
    5c88:	b.n	5c90 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    5c8a:	movs	r3, #3
    5c8c:	b.n	5c90 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    5c8e:	movs	r3, #2
    5c90:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    5c92:	ldrb	r3, [r4, #2]
    5c94:	lsls	r7, r3, #30
    5c96:	bpl.n	5ca0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    5c98:	ldrb	r1, [r4, #0]
    5c9a:	tst.w	r1, #17
    5c9e:	bne.n	5cd6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    5ca0:	and.w	r1, r5, #8
    5ca4:	orrs	r3, r1
    5ca6:	strb	r3, [r4, #2]
    5ca8:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    5caa:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    5cac:	ldrh	r1, [r2, #20]
    5cae:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    5cb0:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    5cb2:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    5cb6:	bpl.n	5cc2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    5cb8:	cbz	r1, 5cde <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    5cba:	bl	6830 <FatPartition::freeChain(unsigned long)>
    5cbe:	cbnz	r0, 5cde <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    5cc0:	b.n	5cd6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    5cc2:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    5cc4:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    5cc6:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    5cc8:	lsls	r3, r5, #17
    5cca:	bpl.n	5ce8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    5ccc:	ldr	r1, [r4, #28]
    5cce:	mov	r0, r4
    5cd0:	bl	5b7e <FatFile::seekSet(unsigned long)>
    5cd4:	cbnz	r0, 5ce8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    5cd6:	movs	r0, #0
    5cd8:	strb	r0, [r4, #0]
  m_flags = 0;
    5cda:	strb	r0, [r4, #2]
  return false;
    5cdc:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5cde:	ldrb	r3, [r4, #2]
    5ce0:	orn	r3, r3, #127	; 0x7f
    5ce4:	strb	r3, [r4, #2]
    5ce6:	b.n	5cc8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    5ce8:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    5cea:	pop	{r3, r4, r5, r6, r7, pc}

00005cec <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    5cec:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    5cf0:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    5cf2:	mov	r6, r0
    5cf4:	mov	r5, r1
    5cf6:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    5cf8:	cbnz	r3, 5d6a <FatFile::openNext(FatFile*, int)+0x7e>
    5cfa:	ldrb	r3, [r1, #0]
    5cfc:	tst.w	r3, #112	; 0x70
    5d00:	beq.n	5d6a <FatFile::openNext(FatFile*, int)+0x7e>
    5d02:	ldr	r4, [r1, #20]
    5d04:	ands.w	r4, r4, #31
    5d08:	bne.n	5d6a <FatFile::openNext(FatFile*, int)+0x7e>
    5d0a:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    5d0c:	movs	r1, #0
    5d0e:	mov	r0, r5
    5d10:	ldr.w	r8, [r5, #20]
    5d14:	bl	5b44 <FatFile::readDirCache(bool)>
    if (!dir) {
    5d18:	cbz	r0, 5d6a <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    5d1a:	ldrb	r3, [r0, #0]
    5d1c:	cbz	r3, 5d6a <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    5d1e:	cmp	r3, #46	; 0x2e
    5d20:	bne.n	5d26 <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    5d22:	movs	r4, #0
    5d24:	b.n	5d0c <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    5d26:	cmp	r3, #229	; 0xe5
    5d28:	beq.n	5d22 <FatFile::openNext(FatFile*, int)+0x36>
    5d2a:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    5d2c:	and.w	lr, r2, #8
    5d30:	and.w	r1, lr, #255	; 0xff
    5d34:	cmp.w	lr, #0
    5d38:	bne.n	5d5a <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    5d3a:	cbz	r4, 5d6e <FatFile::openNext(FatFile*, int)+0x82>
    5d3c:	subs	r2, r0, #1
    5d3e:	adds	r0, #10
    5d40:	lsls	r3, r1, #7
    5d42:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    5d46:	ldrb.w	r3, [r2, #1]!
    5d4a:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    5d4e:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    5d50:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    5d52:	bne.n	5d40 <FatFile::openNext(FatFile*, int)+0x54>
    5d54:	cmp	r7, r1
    5d56:	bne.n	5d6a <FatFile::openNext(FatFile*, int)+0x7e>
    5d58:	b.n	5d6e <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    5d5a:	cmp	r2, #15
    5d5c:	bne.n	5d22 <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    5d5e:	lsls	r2, r3, #25
    5d60:	bpl.n	5d0c <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    5d62:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    5d66:	ldrb	r7, [r0, #13]
    5d68:	b.n	5d0c <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    5d6a:	movs	r0, #0
    5d6c:	b.n	5d7e <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    5d6e:	str	r4, [sp, #0]
    5d70:	mov	r3, r9
    5d72:	ubfx	r2, r8, #5, #16
    5d76:	mov	r1, r5
    5d78:	mov	r0, r6
    5d7a:	bl	5c2a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    5d7e:	add	sp, #12
    5d80:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00005d84 <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    5d84:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    5d86:	ldrb	r3, [r0, #0]
    5d88:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    5d8a:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    5d8c:	bpl.n	5dce <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    5d8e:	movs	r1, #0
    5d90:	bl	5b7e <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    5d94:	movs	r1, #1
    5d96:	mov	r0, r4
    5d98:	bl	5b44 <FatFile::readDirCache(bool)>
    if (!dir) {
    5d9c:	cbnz	r0, 5da4 <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    5d9e:	ldrb	r3, [r4, #1]
    5da0:	cbz	r3, 5db8 <FatFile::rmdir()+0x34>
    5da2:	b.n	5dce <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    5da4:	ldrb	r3, [r0, #0]
    5da6:	cbz	r3, 5db8 <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    5da8:	cmp	r3, #229	; 0xe5
    5daa:	beq.n	5d94 <FatFile::rmdir()+0x10>
    5dac:	cmp	r3, #46	; 0x2e
    5dae:	beq.n	5d94 <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    5db0:	ldrb	r3, [r0, #11]
    5db2:	lsls	r3, r3, #28
    5db4:	bmi.n	5d94 <FatFile::rmdir()+0x10>
    5db6:	b.n	5dce <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    5db8:	movs	r3, #8
    5dba:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    5dbc:	ldrb	r3, [r4, #2]
    5dbe:	orr.w	r3, r3, #2
    5dc2:	strb	r3, [r4, #2]
  return remove();
    5dc4:	mov	r0, r4

 fail:
  return false;
}
    5dc6:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    5dca:	b.w	700c <FatFile::remove()>

 fail:
  return false;
}
    5dce:	movs	r0, #0
    5dd0:	pop	{r4, pc}
    5dd2:	Address 0x00005dd2 is out of bounds.


00005dd4 <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5dd4:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5dd6:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5dd8:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5dda:	cmp	r3, #0
    5ddc:	beq.n	5e48 <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    5dde:	ldrsb.w	r3, [r0, #2]
    5de2:	cmp	r3, #0
    5de4:	bge.n	5e3c <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5de6:	movs	r1, #1
    5de8:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5dec:	mov	r5, r0
    5dee:	cbnz	r0, 5dfc <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    5df0:	ldrb	r3, [r4, #1]
    5df2:	orr.w	r3, r3, #1
    5df6:	strb	r3, [r4, #1]
  return false;
    5df8:	movs	r0, #0
    5dfa:	b.n	5e4a <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5dfc:	ldrb	r3, [r0, #0]
    5dfe:	cmp	r3, #229	; 0xe5
    5e00:	beq.n	5df0 <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    5e02:	ldrb	r3, [r4, #0]
    5e04:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    5e06:	itt	mi
    5e08:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5e0a:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    5e0c:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5e0e:	strh	r3, [r0, #26]
    5e10:	lsrs	r3, r3, #16
    5e12:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    5e14:	ldr	r3, [pc, #56]	; (5e50 <FatFile::sync()+0x7c>)
    5e16:	ldr	r3, [r3, #0]
    5e18:	cbz	r3, 5e34 <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    5e1a:	add.w	r2, sp, #3
    5e1e:	add.w	r1, sp, #6
    5e22:	add	r0, sp, #4
    5e24:	blx	r3
      setLe16(dir->modifyDate, date);
    5e26:	ldrh.w	r3, [sp, #4]
    5e2a:	strh	r3, [r5, #24]
    5e2c:	strh	r3, [r5, #18]
    5e2e:	ldrh.w	r3, [sp, #6]
    5e32:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    5e34:	ldrb	r3, [r4, #2]
    5e36:	and.w	r3, r3, #127	; 0x7f
    5e3a:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    5e3c:	ldr	r0, [r4, #8]
    5e3e:	bl	5840 <FatPartition::cacheSync()>
    5e42:	cmp	r0, #0
    5e44:	beq.n	5df0 <FatFile::sync()+0x1c>
    5e46:	b.n	5e4a <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    5e48:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    5e4a:	add	sp, #12
    5e4c:	pop	{r4, r5, pc}
    5e4e:	nop
    5e50:	.word	0x20019e98

00005e54 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    5e54:	push	{r4, lr}
    5e56:	mov	r4, r0
  bool rtn = sync();
    5e58:	bl	5dd4 <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    5e5c:	movs	r3, #0
    5e5e:	strb	r3, [r4, #0]
  m_flags = 0;
    5e60:	strb	r3, [r4, #2]
  return rtn;
}
    5e62:	pop	{r4, pc}

00005e64 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5e64:	push	{r4, r5, r6, r7, lr}
    5e66:	sub	sp, #84	; 0x54
    5e68:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5e6a:	movs	r3, #0
    5e6c:	strb.w	r3, [sp, #8]
    5e70:	strb.w	r3, [sp, #9]
    5e74:	strb.w	r3, [sp, #10]
    5e78:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5e7c:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5e7e:	str	r2, [sp, #4]
    5e80:	mov	r6, r0
    5e82:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5e84:	cbz	r3, 5e8a <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    5e86:	movs	r0, #0
    5e88:	b.n	5f08 <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5e8a:	ldrb	r3, [r1, #0]
    5e8c:	tst.w	r3, #112	; 0x70
    5e90:	beq.n	5e86 <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5e92:	ldrb	r3, [r2, #0]
    5e94:	cmp	r3, #47	; 0x2f
    5e96:	bne.n	5ebe <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    5e98:	ldr	r3, [sp, #4]
    5e9a:	ldrb	r2, [r3, #0]
    5e9c:	cmp	r2, #47	; 0x2f
    5e9e:	bne.n	5ea6 <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    5ea0:	adds	r3, #1
    5ea2:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5ea4:	b.n	5e98 <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    5ea6:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    5ea8:	cbnz	r2, 5eb2 <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    5eaa:	mov	r0, r6
    5eac:	bl	5946 <FatFile::openRoot(FatVolume*)>
    5eb0:	b.n	5f08 <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    5eb2:	add	r0, sp, #8
    5eb4:	bl	5946 <FatFile::openRoot(FatVolume*)>
    5eb8:	cmp	r0, #0
    5eba:	beq.n	5e86 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    5ebc:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5ebe:	add	r3, sp, #4
    5ec0:	add	r2, sp, #44	; 0x2c
    5ec2:	ldr	r1, [sp, #4]
    5ec4:	mov	r0, r6
    5ec6:	bl	6f74 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    5eca:	cmp	r0, #0
    5ecc:	beq.n	5e86 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    5ece:	ldr	r3, [sp, #4]
    5ed0:	ldrb	r3, [r3, #0]
    5ed2:	cbz	r3, 5efc <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5ed4:	movs	r3, #0
    5ed6:	add	r2, sp, #44	; 0x2c
    5ed8:	mov	r1, r4
    5eda:	mov	r0, r6
    5edc:	bl	6d24 <FatFile::open(FatFile*, FatName_t*, int)>
    5ee0:	cmp	r0, #0
    5ee2:	beq.n	5e86 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    5ee4:	mov	r5, r6
    5ee6:	ldmia	r5!, {r0, r1, r2, r3}
    5ee8:	add	r4, sp, #8
    5eea:	stmia	r4!, {r0, r1, r2, r3}
    5eec:	ldmia	r5!, {r0, r1, r2, r3}
    5eee:	stmia	r4!, {r0, r1, r2, r3}
    5ef0:	ldr	r3, [r5, #0]
    5ef2:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    5ef4:	mov	r0, r6
    5ef6:	bl	5e54 <FatFile::close()>
    5efa:	b.n	5ebc <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    5efc:	mov	r3, r7
    5efe:	add	r2, sp, #44	; 0x2c
    5f00:	mov	r1, r4
    5f02:	mov	r0, r6
    5f04:	bl	6d24 <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    5f08:	add	sp, #84	; 0x54
    5f0a:	pop	{r4, r5, r6, r7, pc}

00005f0c <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    5f0c:	cbz	r1, 5f16 <FatFile::open(FatVolume*, char const*, int)+0xa>
    5f0e:	add.w	r1, r1, #1096	; 0x448
    5f12:	b.w	5e64 <FatFile::open(FatFile*, char const*, int)>
}
    5f16:	mov	r0, r1
    5f18:	bx	lr

00005f1a <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    5f1a:	push	{r4, r5, r6, lr}
    5f1c:	mov	r6, r0
    5f1e:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    5f20:	bl	5dd4 <FatFile::sync()>
    5f24:	mov	r5, r0
    5f26:	cbnz	r0, 5f2c <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    5f28:	movs	r5, #0
    5f2a:	b.n	5f4a <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5f2c:	movs	r1, #0
    5f2e:	mov	r0, r6
    5f30:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5f34:	cmp	r0, #0
    5f36:	beq.n	5f28 <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    5f38:	mov	r1, r4
    5f3a:	add.w	r3, r0, #32
    5f3e:	ldr.w	r2, [r0], #4
    5f42:	str.w	r2, [r1], #4
    5f46:	cmp	r0, r3
    5f48:	bne.n	5f3e <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    5f4a:	mov	r0, r5
    5f4c:	pop	{r4, r5, r6, pc}

00005f4e <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    5f4e:	push	{r4, r5, lr}
    5f50:	sub	sp, #36	; 0x24
    5f52:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5f54:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    5f56:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5f58:	bl	5f1a <FatFile::dirEntry(DirFat_t*)>
    5f5c:	cbz	r0, 5f6a <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    5f5e:	ldrh.w	r3, [sp, #16]
    5f62:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    5f64:	ldrh.w	r3, [sp, #14]
    5f68:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    5f6a:	add	sp, #36	; 0x24
    5f6c:	pop	{r4, r5, pc}

00005f6e <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    5f6e:	push	{r4, r5, lr}
    5f70:	sub	sp, #36	; 0x24
    5f72:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5f74:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    5f76:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5f78:	bl	5f1a <FatFile::dirEntry(DirFat_t*)>
    5f7c:	cbz	r0, 5f8a <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    5f7e:	ldrh.w	r3, [sp, #24]
    5f82:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    5f84:	ldrh.w	r3, [sp, #22]
    5f88:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    5f8a:	add	sp, #36	; 0x24
    5f8c:	pop	{r4, r5, pc}

00005f8e <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    5f8e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5f92:	ldrb	r3, [r1, #0]
    5f94:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    5f98:	sub	sp, #32
    5f9a:	mov	r4, r0
    5f9c:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5f9e:	beq.n	5fda <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    5fa0:	movw	r3, #2562	; 0xa02
    5fa4:	bl	6d24 <FatFile::open(FatFile*, FatName_t*, int)>
    5fa8:	cbz	r0, 5fda <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5faa:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    5fac:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5fae:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    5fb0:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    5fb2:	mov	r0, r4
    5fb4:	bl	589c <FatFile::addDirCluster()>
    5fb8:	cbz	r0, 5fda <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    5fba:	ldr	r3, [r4, #16]
    5fbc:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    5fbe:	movs	r1, #0
    5fc0:	mov	r0, r4
    5fc2:	bl	5b7e <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    5fc6:	mov	r0, r4
    5fc8:	bl	5dd4 <FatFile::sync()>
    5fcc:	cbz	r0, 5fda <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5fce:	mov	r1, r7
    5fd0:	mov	r0, r4
    5fd2:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5fd6:	mov	r3, r0
    5fd8:	cbnz	r0, 5fde <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    5fda:	movs	r0, #0
    5fdc:	b.n	6082 <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    5fde:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    5fe0:	mov	r2, r0
    5fe2:	mov	r7, sp
    5fe4:	add.w	ip, r0, #32
    5fe8:	mov	r5, sp
    5fea:	ldr	r0, [r2, #0]
    5fec:	ldr	r1, [r2, #4]
    5fee:	mov	lr, r7
    5ff0:	stmia.w	lr!, {r0, r1}
    5ff4:	adds	r2, #8
    5ff6:	cmp	r2, ip
    5ff8:	mov	r7, lr
    5ffa:	bne.n	5fea <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    5ffc:	ldrh	r7, [r3, #20]
    5ffe:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    6002:	movs	r3, #46	; 0x2e
    6004:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6008:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    600a:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    600c:	adds	r2, r5, r3
    600e:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6010:	cmp	r3, #10
    dot.name[i] = ' ';
    6012:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6014:	bne.n	600c <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    6016:	ldr	r0, [r4, #8]
    6018:	ldr	r1, [r4, #32]
    601a:	ldrb	r3, [r0, #6]
    601c:	subs	r1, #2
    601e:	lsls	r1, r3
    6020:	ldr	r3, [r0, #20]
    6022:	movs	r2, #1
    6024:	add	r1, r3
    6026:	adds	r0, #40	; 0x28
    6028:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    602c:	mov	r3, r0
    602e:	cmp	r0, #0
    6030:	beq.n	5fda <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    6032:	strh.w	r7, [sp, #20]
    6036:	strh.w	r8, [sp, #26]
    603a:	mov	lr, r5
    603c:	mov	r7, r0
    603e:	add.w	ip, sp, #32
    6042:	mov	r2, lr
    6044:	ldmia	r2!, {r0, r1}
    6046:	cmp	r2, ip
    6048:	str	r0, [r7, #0]
    604a:	str	r1, [r7, #4]
    604c:	mov	lr, r2
    604e:	add.w	r7, r7, #8
    6052:	bne.n	6042 <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    6054:	movs	r2, #46	; 0x2e
    6056:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    605a:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    605c:	strh.w	r2, [sp, #26]
    6060:	lsrs	r1, r2, #16
    6062:	strh.w	r1, [sp, #20]
    6066:	adds	r3, #32
    6068:	add	r6, sp, #32
    606a:	mov	r2, r5
    606c:	ldmia	r2!, {r0, r1}
    606e:	cmp	r2, r6
    6070:	str	r0, [r3, #0]
    6072:	str	r1, [r3, #4]
    6074:	mov	r5, r2
    6076:	add.w	r3, r3, #8
    607a:	bne.n	606a <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    607c:	ldr	r0, [r4, #8]
    607e:	bl	5840 <FatPartition::cacheSync()>

 fail:
  return false;
}
    6082:	add	sp, #32
    6084:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006088 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    6088:	push	{r4, r5, r6, r7, lr}
    608a:	sub	sp, #84	; 0x54
    608c:	mov	r7, r3
    608e:	movs	r3, #0
    6090:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    6094:	strb.w	r3, [sp, #44]	; 0x2c
    6098:	strb.w	r3, [sp, #45]	; 0x2d
    609c:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    60a0:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    60a2:	str	r2, [sp, #4]
    60a4:	mov	r6, r0
    60a6:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    60a8:	cmp	r3, #0
    60aa:	bne.n	612c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    60ac:	ldrb	r3, [r1, #0]
    60ae:	tst.w	r3, #112	; 0x70
    60b2:	beq.n	612c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    60b4:	ldrb	r3, [r2, #0]
    60b6:	cmp	r3, #47	; 0x2f
    60b8:	bne.n	60d4 <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    60ba:	ldr	r3, [sp, #4]
    60bc:	ldrb	r2, [r3, #0]
    60be:	cmp	r2, #47	; 0x2f
    60c0:	bne.n	60c8 <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    60c2:	adds	r3, #1
    60c4:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    60c6:	b.n	60ba <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    60c8:	ldr	r1, [r4, #8]
    60ca:	add	r0, sp, #44	; 0x2c
    60cc:	bl	5946 <FatFile::openRoot(FatVolume*)>
    60d0:	cbz	r0, 612c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    60d2:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    60d4:	add	r3, sp, #4
    60d6:	add	r2, sp, #8
    60d8:	ldr	r1, [sp, #4]
    60da:	mov	r0, r6
    60dc:	bl	6f74 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    60e0:	cbz	r0, 612c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    60e2:	ldr	r3, [sp, #4]
    60e4:	ldrb	r3, [r3, #0]
    60e6:	cbz	r3, 6120 <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    60e8:	movs	r3, #0
    60ea:	add	r2, sp, #8
    60ec:	mov	r1, r4
    60ee:	mov	r0, r6
    60f0:	bl	6d24 <FatFile::open(FatFile*, FatName_t*, int)>
    60f4:	cbz	r0, 610e <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    60f6:	mov	r5, r6
    60f8:	ldmia	r5!, {r0, r1, r2, r3}
    60fa:	add	r4, sp, #44	; 0x2c
    60fc:	stmia	r4!, {r0, r1, r2, r3}
    60fe:	ldmia	r5!, {r0, r1, r2, r3}
    6100:	stmia	r4!, {r0, r1, r2, r3}
    6102:	ldr	r3, [r5, #0]
    6104:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    6106:	mov	r0, r6
    6108:	bl	5e54 <FatFile::close()>
    610c:	b.n	60d2 <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    610e:	cbz	r7, 612c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    6110:	add	r2, sp, #8
    6112:	mov	r1, r4
    6114:	mov	r0, r6
    6116:	bl	5f8e <FatFile::mkdir(FatFile*, FatName_t*)>
    611a:	cmp	r0, #0
    611c:	bne.n	60f6 <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    611e:	b.n	612c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    6120:	add	r2, sp, #8
    6122:	mov	r1, r4
    6124:	mov	r0, r6
    6126:	bl	5f8e <FatFile::mkdir(FatFile*, FatName_t*)>
    612a:	b.n	612e <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    612c:	movs	r0, #0
}
    612e:	add	sp, #84	; 0x54
    6130:	pop	{r4, r5, r6, r7, pc}

00006132 <FatFile::preAllocate(unsigned long)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
bool FatFile::preAllocate(uint32_t length) {
    6132:	push	{r3, r4, r5, lr}
    6134:	mov	r4, r0
  uint32_t need;
  if (!length || !isWritable() || m_firstCluster) {
    6136:	mov	r5, r1
    6138:	cbz	r1, 6170 <FatFile::preAllocate(unsigned long)+0x3e>
    613a:	ldrb	r3, [r0, #2]
    613c:	lsls	r3, r3, #30
    613e:	bpl.n	6170 <FatFile::preAllocate(unsigned long)+0x3e>
    6140:	ldr	r3, [r0, #32]
    6142:	cbnz	r3, 6170 <FatFile::preAllocate(unsigned long)+0x3e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  need = 1 + ((length - 1) >> m_vol->bytesPerClusterShift());
    6144:	ldr	r0, [r0, #8]
  // allocate clusters
  if (!m_vol->allocContiguous(need, &m_firstCluster)) {
    6146:	ldrb	r3, [r0, #6]
    6148:	adds	r3, #9
    614a:	subs	r1, #1
    614c:	uxtb	r3, r3
    614e:	lsrs	r1, r3
    6150:	add.w	r2, r4, #32
    6154:	adds	r1, #1
    6156:	bl	671e <FatPartition::allocContiguous(unsigned long, unsigned long*)>
    615a:	cbz	r0, 6170 <FatFile::preAllocate(unsigned long)+0x3e>
  }
  m_fileSize = length;

#if USE_FAT_FILE_FLAG_CONTIGUOUS
  // Mark contiguous and insure sync() will update dir entry
  m_flags |= FILE_FLAG_PREALLOCATE | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    615c:	ldrb	r3, [r4, #2]
  // allocate clusters
  if (!m_vol->allocContiguous(need, &m_firstCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fileSize = length;
    615e:	str	r5, [r4, #28]

#if USE_FAT_FILE_FLAG_CONTIGUOUS
  // Mark contiguous and insure sync() will update dir entry
  m_flags |= FILE_FLAG_PREALLOCATE | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    6160:	orn	r3, r3, #31
    6164:	strb	r3, [r4, #2]
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // insure sync() will update dir entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  return sync();
    6166:	mov	r0, r4

 fail:
  return false;
}
    6168:	ldmia.w	sp!, {r3, r4, r5, lr}
  m_flags |= FILE_FLAG_PREALLOCATE | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // insure sync() will update dir entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  return sync();
    616c:	b.w	5dd4 <FatFile::sync()>

 fail:
  return false;
}
    6170:	movs	r0, #0
    6172:	pop	{r3, r4, r5, pc}

00006174 <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6174:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    6178:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    617a:	sub	sp, #108	; 0x6c
    617c:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    617e:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6182:	mov	r4, r0
    6184:	mov	r8, r1
    6186:	mov	r9, r2
    6188:	strb.w	r7, [sp, #32]
    618c:	strb.w	r7, [sp, #33]	; 0x21
    6190:	strb.w	r7, [sp, #34]	; 0x22
    6194:	strb.w	r7, [sp, #68]	; 0x44
    6198:	strb.w	r7, [sp, #69]	; 0x45
    619c:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    61a0:	bne.n	61a6 <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    61a2:	movs	r0, #0
    61a4:	b.n	6304 <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    61a6:	ldr	r2, [r0, #8]
    61a8:	ldr	r3, [r1, #8]
    61aa:	cmp	r2, r3
    61ac:	bne.n	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    61ae:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    61b0:	bl	5dd4 <FatFile::sync()>
  oldFile = *this;
    61b4:	ldmia	r6!, {r0, r1, r2, r3}
    61b6:	add	r5, sp, #68	; 0x44
    61b8:	stmia	r5!, {r0, r1, r2, r3}
    61ba:	ldmia	r6!, {r0, r1, r2, r3}
    61bc:	stmia	r5!, {r0, r1, r2, r3}
    61be:	ldr	r3, [r6, #0]
    61c0:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    61c2:	mov	r1, r7
    61c4:	mov	r0, r4
    61c6:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    61ca:	cmp	r0, #0
    61cc:	beq.n	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    61ce:	mov	r3, r0
    61d0:	mov	r2, sp
    61d2:	add.w	r7, r0, #32
    61d6:	mov	r5, sp
    61d8:	ldr	r0, [r3, #0]
    61da:	ldr	r1, [r3, #4]
    61dc:	mov	r6, r2
    61de:	stmia	r6!, {r0, r1}
    61e0:	adds	r3, #8
    61e2:	cmp	r3, r7
    61e4:	mov	r2, r6
    61e6:	bne.n	61d8 <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    61e8:	ldrb	r2, [r4, #0]
    61ea:	and.w	r2, r2, #8
    61ee:	and.w	r3, r2, #255	; 0xff
    61f2:	add	r6, sp, #32
    61f4:	cbz	r2, 620c <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    61f6:	movw	r3, #2561	; 0xa01
    61fa:	mov	r2, r9
    61fc:	mov	r1, r8
    61fe:	mov	r0, r6
    6200:	bl	5e64 <FatFile::open(FatFile*, char const*, int)>
    6204:	cmp	r0, #0
    6206:	beq.n	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    6208:	movs	r7, #0
    620a:	b.n	621c <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    620c:	mov	r2, r9
    620e:	mov	r1, r8
    6210:	mov	r0, r6
    6212:	bl	6088 <FatFile::mkdir(FatFile*, char const*, bool)>
    6216:	cmp	r0, #0
    6218:	beq.n	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    621a:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    621c:	ldr	r3, [sp, #56]	; 0x38
    621e:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    6220:	ldrh.w	r3, [sp, #36]	; 0x24
    6224:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    6226:	ldrb.w	r3, [sp, #35]	; 0x23
    622a:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    622c:	ldr	r3, [sp, #44]	; 0x2c
    622e:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6230:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6232:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6234:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6236:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    623a:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    623e:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6242:	cmp	r0, #0
    6244:	beq.n	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    6246:	add.w	r3, sp, #13
    624a:	add.w	r2, r0, #13
    624e:	add.w	r1, sp, #29
    6252:	ldr.w	lr, [r3], #4
    6256:	str.w	lr, [r2], #4
    625a:	cmp	r3, r1
    625c:	bne.n	6252 <FatFile::rename(FatFile*, char const*)+0xde>
    625e:	ldrh	r1, [r3, #0]
    6260:	strh	r1, [r2, #0]
    6262:	ldrb	r3, [r3, #2]
    6264:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    6266:	ldrb.w	r3, [sp, #11]
    626a:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    626c:	cmp	r7, #0
    626e:	beq.n	62e2 <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    6270:	ldr	r0, [r4, #8]
    6272:	ldrb	r1, [r0, #6]
    6274:	subs	r3, r7, #2
    6276:	lsls	r3, r1
    6278:	ldr	r1, [r0, #20]
    627a:	movs	r2, #0
    627c:	add	r1, r3
    627e:	adds	r0, #40	; 0x28
    6280:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6284:	cmp	r0, #0
    6286:	beq.n	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    6288:	add.w	r3, r0, #32
    628c:	mov	lr, r5
    628e:	add.w	ip, r0, #64	; 0x40
    6292:	ldr	r0, [r3, #0]
    6294:	ldr	r1, [r3, #4]
    6296:	mov	r2, lr
    6298:	stmia	r2!, {r0, r1}
    629a:	adds	r3, #8
    629c:	cmp	r3, ip
    629e:	mov	lr, r2
    62a0:	bne.n	6292 <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    62a2:	mov	r1, r7
    62a4:	ldr	r0, [r4, #8]
    62a6:	bl	6830 <FatPartition::freeChain(unsigned long)>
    62aa:	cmp	r0, #0
    62ac:	beq.w	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    62b0:	ldr	r0, [r4, #8]
    62b2:	ldr	r1, [r4, #32]
    62b4:	ldrb	r3, [r0, #6]
    62b6:	subs	r1, #2
    62b8:	lsls	r1, r3
    62ba:	ldr	r3, [r0, #20]
    62bc:	movs	r2, #1
    62be:	add	r1, r3
    62c0:	adds	r0, #40	; 0x28
    62c2:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    62c6:	cmp	r0, #0
    62c8:	beq.w	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    62cc:	add.w	r3, r0, #32
    62d0:	mov	r2, r5
    62d2:	ldmia	r2!, {r0, r1}
    62d4:	cmp	r2, r6
    62d6:	str	r0, [r3, #0]
    62d8:	str	r1, [r3, #4]
    62da:	mov	r5, r2
    62dc:	add.w	r3, r3, #8
    62e0:	bne.n	62d0 <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    62e2:	movs	r3, #0
    62e4:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    62e6:	movs	r3, #2
    62e8:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    62ec:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    62ee:	movs	r3, #8
    62f0:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    62f4:	bl	700c <FatFile::remove()>
    62f8:	cmp	r0, #0
    62fa:	beq.w	61a2 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    62fe:	ldr	r0, [r4, #8]
    6300:	bl	5840 <FatPartition::cacheSync()>

 fail:
  return false;
}
    6304:	add	sp, #108	; 0x6c
    6306:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000630a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    630a:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    630e:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6310:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6312:	ldrb.w	fp, [sp, #40]	; 0x28
    6316:	ldrb.w	r9, [sp, #44]	; 0x2c
    631a:	ldrb.w	sl, [sp, #48]	; 0x30
    631e:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6322:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6324:	mov	r6, r0
    6326:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6328:	bmi.n	6330 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    632a:	movs	r0, #0
    632c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    6330:	subw	r2, r2, #1980	; 0x7bc
    6334:	uxth.w	r8, r2
    6338:	cmp.w	r8, #127	; 0x7f
    633c:	bhi.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    633e:	subs	r3, r4, #1
    6340:	cmp	r3, #11
    6342:	bhi.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    6344:	add.w	r3, fp, #4294967295
    6348:	cmp	r3, #30
    634a:	bhi.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    634c:	cmp.w	r9, #23
    6350:	bhi.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    6352:	cmp.w	sl, #59	; 0x3b
    6356:	bhi.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    6358:	cmp	r5, #59	; 0x3b
    635a:	bhi.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    635c:	bl	5dd4 <FatFile::sync()>
    6360:	cmp	r0, #0
    6362:	beq.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6364:	movs	r1, #1
    6366:	mov	r0, r6
    6368:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    636c:	cmp	r0, #0
    636e:	beq.n	632a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    6370:	orr.w	r4, fp, r4, lsl #5
    6374:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    6378:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    637a:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    637c:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    6380:	orr.w	r3, r3, sl, lsl #5
    6384:	orr.w	r3, r3, r9, lsl #11
    6388:	it	mi
    638a:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    638e:	lsls	r1, r7, #30
    6390:	uxth	r3, r3
    6392:	bpl.n	63a4 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    6394:	ands.w	r5, r5, #1
    6398:	it	ne
    639a:	movne	r5, #100	; 0x64
    639c:	strh.w	r8, [r0, #16]
    63a0:	strh	r3, [r0, #14]
    63a2:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    63a4:	lsls	r2, r7, #29
    63a6:	itt	mi
    63a8:	strhmi.w	r8, [r0, #24]
    63ac:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    63ae:	ldr	r0, [r6, #8]
    63b0:	bl	5840 <FatPartition::cacheSync()>
    63b4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000063b8 <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    63b8:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    63ba:	ldrb	r3, [r0, #2]
    63bc:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    63be:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    63c0:	bmi.n	63c6 <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    63c2:	movs	r0, #0
    63c4:	b.n	641c <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    63c6:	ldr	r3, [r0, #32]
    63c8:	cbz	r3, 641a <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    63ca:	ldr	r1, [r0, #16]
    63cc:	cbz	r1, 63f2 <FatFile::truncate()+0x3a>
    toFree = 0;
    63ce:	add	r2, sp, #8
    63d0:	movs	r3, #0
    63d2:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    63d6:	ldr	r0, [r0, #8]
    63d8:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    63dc:	cmp	r0, #0
    63de:	blt.n	63c2 <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    63e0:	beq.n	63f6 <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    63e2:	mvn.w	r2, #4026531840	; 0xf0000000
    63e6:	ldr	r1, [r4, #16]
    63e8:	ldr	r0, [r4, #8]
    63ea:	bl	66c2 <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    63ee:	cbnz	r0, 63f6 <FatFile::truncate()+0x3e>
    63f0:	b.n	63c2 <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    63f2:	str	r3, [sp, #4]
    m_firstCluster = 0;
    63f4:	str	r1, [r0, #32]
  }
  if (toFree) {
    63f6:	ldr	r1, [sp, #4]
    63f8:	cbnz	r1, 640e <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    63fa:	ldr	r3, [r4, #20]
    63fc:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    63fe:	ldrb	r3, [r4, #2]
    6400:	orn	r3, r3, #127	; 0x7f
    6404:	strb	r3, [r4, #2]
  return sync();
    6406:	mov	r0, r4
    6408:	bl	5dd4 <FatFile::sync()>
    640c:	b.n	641c <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    640e:	ldr	r0, [r4, #8]
    6410:	bl	6830 <FatPartition::freeChain(unsigned long)>
    6414:	cmp	r0, #0
    6416:	bne.n	63fa <FatFile::truncate()+0x42>
    6418:	b.n	63c2 <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    641a:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    641c:	add	sp, #8
    641e:	pop	{r4, pc}

00006420 <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6420:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6424:	ldrb	r3, [r0, #2]
    6426:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6428:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    642a:	mov	r4, r0
    642c:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    642e:	bpl.w	654e <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    6432:	lsls	r2, r3, #28
    6434:	bmi.n	644c <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    6436:	ldr	r3, [r4, #20]
    6438:	mvns	r3, r3
    643a:	cmp	r5, r3
    643c:	bhi.w	654e <FatFile::write(void const*, unsigned int)+0x12e>
    6440:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6442:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    6446:	mov.w	fp, #4294967295
    644a:	b.n	64da <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    644c:	ldr	r1, [r0, #28]
    644e:	bl	5b7e <FatFile::seekSet(unsigned long)>
    6452:	cmp	r0, #0
    6454:	bne.n	6436 <FatFile::write(void const*, unsigned int)+0x16>
    6456:	b.n	654e <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    6458:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    645a:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    645c:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    6460:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6464:	beq.n	64e2 <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    6466:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    646a:	ldr	r1, [r4, #16]
    646c:	ldrb.w	r3, [lr, #6]
    6470:	subs	r1, #2
    6472:	lsls	r1, r3
    6474:	ldr.w	r3, [lr, #20]
    6478:	add	r1, r3
    647a:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    647c:	cmp.w	r8, #0
    6480:	bne.n	6514 <FatFile::write(void const*, unsigned int)+0xf4>
    6482:	cmp.w	r7, #512	; 0x200
    6486:	bcs.n	6562 <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    6488:	ldr	r2, [r4, #20]
    648a:	ldr	r3, [r4, #28]
    648c:	cmp	r2, r3
    648e:	bcs.n	6518 <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    6490:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6492:	tst.w	r3, #32
    6496:	ite	eq
    6498:	moveq	r2, #1
    649a:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    649c:	add.w	r0, lr, #40	; 0x28
    64a0:	bl	33da <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    64a4:	cmp	r0, #0
    64a6:	beq.n	654e <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    64a8:	rsb	r6, r8, #512	; 0x200
    64ac:	cmp	r6, r7
    64ae:	it	cs
    64b0:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    64b2:	add	r0, r8
    64b4:	mov	r2, r6
    64b6:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    64b8:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    64ba:	bl	8b4c <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    64be:	cmp.w	r8, #512	; 0x200
    64c2:	bne.n	64d0 <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    64c4:	ldr	r0, [r4, #8]
    64c6:	adds	r0, #40	; 0x28
    64c8:	bl	338e <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    64cc:	cmp	r0, #0
    64ce:	beq.n	654e <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    64d0:	ldr	r3, [r4, #20]
    64d2:	add	r3, r6
    64d4:	str	r3, [r4, #20]
    src += n;
    64d6:	add	r9, r6
    nToWrite -= n;
    64d8:	subs	r7, r7, r6
    64da:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    64dc:	cmp	r7, #0
    64de:	bne.n	6458 <FatFile::write(void const*, unsigned int)+0x38>
    64e0:	b.n	651c <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    64e2:	cmp.w	r8, #0
    64e6:	bne.n	6466 <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    64e8:	ldr	r1, [r4, #16]
    64ea:	cbz	r1, 64fe <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    64ec:	ldrb	r3, [r4, #2]
    64ee:	lsls	r3, r3, #25
    64f0:	bpl.n	6536 <FatFile::write(void const*, unsigned int)+0x116>
    64f2:	ldr	r3, [r4, #28]
    64f4:	cmp	r2, r3
    64f6:	bcs.n	6536 <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    64f8:	adds	r1, #1
    64fa:	str	r1, [r4, #16]
    64fc:	b.n	6466 <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    64fe:	ldr	r3, [r4, #32]
    6500:	cbnz	r3, 6510 <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    6502:	mov	r0, r4
    6504:	bl	5866 <FatFile::addCluster()>
    6508:	cbz	r0, 654e <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    650a:	ldr	r3, [r4, #16]
    650c:	str	r3, [r4, #32]
    650e:	b.n	6466 <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    6510:	str	r3, [r4, #16]
    6512:	b.n	6466 <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    6514:	movs	r2, #1
    6516:	b.n	649c <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6518:	movs	r2, #5
    651a:	b.n	649c <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    651c:	ldr	r3, [r4, #28]
    651e:	cmp	r2, r3
    6520:	bls.n	6526 <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    6522:	str	r2, [r4, #28]
    6524:	b.n	652c <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    6526:	ldr	r3, [pc, #180]	; (65dc <FatFile::write(void const*, unsigned int)+0x1bc>)
    6528:	ldr	r3, [r3, #0]
    652a:	cbz	r3, 655c <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    652c:	ldrb	r3, [r4, #2]
    652e:	orn	r3, r3, #127	; 0x7f
    6532:	strb	r3, [r4, #2]
    6534:	b.n	655c <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    6536:	add.w	r2, r4, #16
    653a:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    653e:	cmp	r0, #0
    6540:	blt.n	654e <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    6542:	bne.n	65c4 <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    6544:	mov	r0, r4
    6546:	bl	5866 <FatFile::addCluster()>
    654a:	cmp	r0, #0
    654c:	bne.n	65c4 <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    654e:	ldrb	r3, [r4, #1]
    6550:	orr.w	r3, r3, #1
    6554:	strb	r3, [r4, #1]
  return 0;
    6556:	movs	r0, #0
    6558:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    655c:	mov	r0, r5
    655e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    6562:	cmp.w	r7, #1024	; 0x400
    6566:	ldr.w	r2, [lr, #52]	; 0x34
    656a:	ldr.w	r0, [lr, #44]	; 0x2c
    656e:	bcc.n	659a <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    6570:	ldrb.w	r3, [lr, #4]
    6574:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    6576:	lsrs	r3, r7, #9
    6578:	cmp	r3, r6
    657a:	it	cs
    657c:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    657e:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    6580:	mov.w	r6, r3, lsl #9
    6584:	bcc.n	658e <FatFile::write(void const*, unsigned int)+0x16e>
    6586:	add.w	ip, r3, r1
    658a:	cmp	r2, ip
    658c:	bcc.n	65ba <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    658e:	ldr	r2, [r0, #0]
    6590:	ldr.w	r8, [r2, #36]	; 0x24
    6594:	mov	r2, r9
    6596:	blx	r8
    6598:	b.n	64cc <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    659a:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    659c:	it	eq
    659e:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    65a2:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    65a4:	it	eq
    65a6:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    65aa:	ldr	r3, [r3, #32]
    65ac:	mov	r2, r9
    65ae:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    65b0:	cmp	r0, #0
    65b2:	beq.n	654e <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    65b4:	mov.w	r6, #512	; 0x200
    65b8:	b.n	64d0 <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    65ba:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    65be:	str.w	fp, [lr, #52]	; 0x34
    65c2:	b.n	658e <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    65c4:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    65c8:	ldr	r1, [r4, #16]
    65ca:	ldrb.w	r3, [lr, #6]
    65ce:	subs	r1, #2
    65d0:	lsls	r1, r3
    65d2:	ldr.w	r3, [lr, #20]
    65d6:	add	r1, r3
    65d8:	b.n	6482 <FatFile::write(void const*, unsigned int)+0x62>
    65da:	nop
    65dc:	.word	0x20019e98

000065e0 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    65e0:	ldr	r3, [r2, #0]
    65e2:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    65e6:	push	{r4, r5, lr}
    65e8:	mov	r4, r3
    65ea:	it	cs
    65ec:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    65f0:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    65f4:	cmp	r1, r5
    65f6:	bcs.n	6608 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    65f8:	ldrh.w	r0, [r1], #2
    65fc:	cmp	r0, #0
    65fe:	bne.n	65f4 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    6600:	ldr	r0, [r2, #4]
    6602:	adds	r0, #1
    6604:	str	r0, [r2, #4]
    6606:	b.n	65f4 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    6608:	subs	r3, r3, r4
    660a:	str	r3, [r2, #0]
    660c:	pop	{r4, r5, pc}

0000660e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    660e:	ldr	r3, [r2, #0]
    6610:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    6612:	push	{r4, r5, lr}
    6614:	mov	r4, r3
    6616:	it	cs
    6618:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    661a:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    661e:	cmp	r1, r5
    6620:	bcs.n	6632 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    6622:	ldr.w	r0, [r1], #4
    6626:	cmp	r0, #0
    6628:	bne.n	661e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    662a:	ldr	r0, [r2, #4]
    662c:	adds	r0, #1
    662e:	str	r0, [r2, #4]
    6630:	b.n	661e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    6632:	subs	r3, r3, r4
    6634:	str	r3, [r2, #0]
    6636:	pop	{r4, r5, pc}

00006638 <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6638:	push	{r4, lr}
    if (isDirty() && !sync()) {
    663a:	ldrb	r3, [r0, #0]
    663c:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    663e:	mov	r4, r0
    if (isDirty() && !sync()) {
    6640:	bpl.n	6648 <FsCache::clear()+0x10>
    6642:	bl	338e <FsCache::sync()>
    6646:	cbz	r0, 6656 <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6648:	movs	r3, #0
    664a:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    664c:	mov.w	r3, #4294967295
    6650:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    6652:	add.w	r0, r4, #16
  }
    6656:	pop	{r4, pc}

00006658 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6658:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    665a:	push	{r4, r5, r6, lr}
    665c:	mov	r5, r0
    665e:	mov	r4, r1
    6660:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6662:	bhi.n	666a <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6664:	mov.w	r0, #4294967295
    6668:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    666a:	ldr	r3, [r0, #28]
    666c:	cmp	r1, r3
    666e:	bhi.n	6664 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6670:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6672:	cmp	r3, #32
    6674:	bne.n	6694 <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    6676:	ldr	r1, [r0, #24]
    6678:	movs	r2, #2
    667a:	add.w	r1, r1, r4, lsr #7
    667e:	add.w	r0, r0, #568	; 0x238
    6682:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6686:	cmp	r0, #0
    6688:	beq.n	6664 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    668a:	and.w	r4, r4, #127	; 0x7f
    668e:	ldr.w	r3, [r0, r4, lsl #2]
    6692:	b.n	66b4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    6694:	cmp	r3, #16
    6696:	bne.n	6664 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6698:	ldr	r3, [r0, #24]
    669a:	ubfx	r1, r1, #8, #8
    669e:	movs	r2, #2
    66a0:	add	r1, r3
    66a2:	add.w	r0, r0, #568	; 0x238
    66a6:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    66aa:	cmp	r0, #0
    66ac:	beq.n	6664 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    66ae:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    66b0:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    66b4:	ldr	r2, [r5, #28]
    66b6:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    66b8:	itte	ls
    66ba:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    66bc:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    66be:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    66c0:	pop	{r4, r5, r6, pc}

000066c2 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    66c2:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    66c4:	push	{r3, r4, r5, lr}
    66c6:	mov	r4, r1
    66c8:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    66ca:	bhi.n	66d0 <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    66cc:	movs	r0, #0
    66ce:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    66d0:	ldr	r3, [r0, #28]
    66d2:	cmp	r1, r3
    66d4:	bhi.n	66cc <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    66d6:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    66d8:	cmp	r3, #32
    66da:	bne.n	66fa <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    66dc:	ldr	r1, [r0, #24]
    66de:	movs	r2, #3
    66e0:	add.w	r1, r1, r4, lsr #7
    66e4:	add.w	r0, r0, #568	; 0x238
    66e8:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    66ec:	cmp	r0, #0
    66ee:	beq.n	66cc <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    66f0:	and.w	r4, r4, #127	; 0x7f
    66f4:	str.w	r5, [r0, r4, lsl #2]
    66f8:	b.n	671a <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    66fa:	cmp	r3, #16
    66fc:	bne.n	66cc <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    66fe:	ldr	r3, [r0, #24]
    6700:	ubfx	r1, r1, #8, #8
    6704:	movs	r2, #3
    6706:	add	r1, r3
    6708:	add.w	r0, r0, #568	; 0x238
    670c:	bl	33da <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6710:	cmp	r0, #0
    6712:	beq.n	66cc <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6714:	uxtb	r4, r4
    6716:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    671a:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    671c:	pop	{r3, r4, r5, pc}

0000671e <FatPartition::allocContiguous(unsigned long, unsigned long*)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// find a contiguous group of clusters
bool FatPartition::allocContiguous(uint32_t count, uint32_t* firstCluster) {
    671e:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  // start of group
  uint32_t bgnCluster;
  // end of group
  uint32_t endCluster;
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;
    6722:	ldr	r6, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
// find a contiguous group of clusters
bool FatPartition::allocContiguous(uint32_t count, uint32_t* firstCluster) {
    6724:	mov	r5, r0
  // start of group
  uint32_t bgnCluster;
  // end of group
  uint32_t endCluster;
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;
    6726:	adds	r7, r6, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// find a contiguous group of clusters
bool FatPartition::allocContiguous(uint32_t count, uint32_t* firstCluster) {
    6728:	mov	r9, r1
    672a:	mov	r8, r2
    672c:	adds	r6, #2
  // flag to save place to start next search
  bool setStart = true;
    672e:	mov.w	sl, #1
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    if (endCluster > m_lastCluster) {
    6732:	ldr	r3, [r5, #28]
    6734:	subs	r4, r6, #1
    6736:	cmp	r4, r3
    6738:	bhi.n	677c <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
      // Can't find space.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(endCluster, &f);
    673a:	add	r2, sp, #4
    673c:	mov	r1, r4
    673e:	mov	r0, r5
    6740:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6744:	cmp	r0, #0
    6746:	blt.n	677c <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (f || fg == 0) {
    6748:	ldr	r3, [sp, #4]
    674a:	cbnz	r3, 674e <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x30>
    674c:	cbnz	r0, 675a <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x3c>
      // don't update search start if unallocated clusters before endCluster.
      if (bgnCluster != endCluster) {
        setStart = false;
    674e:	cmp	r7, r4
    6750:	it	ne
    6752:	movne.w	sl, #0
      }
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    6756:	mov	r7, r6
    6758:	b.n	6760 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x42>
    } else if ((endCluster - bgnCluster + 1) == count) {
    675a:	subs	r3, r6, r7
    675c:	cmp	r3, r9
    675e:	beq.n	6764 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x46>
    6760:	adds	r6, #1
  uint32_t endCluster;
  // Start at cluster after last allocated cluster.
  endCluster = bgnCluster = m_allocSearchStart + 1;

  // search the FAT for free clusters
  while (1) {
    6762:	b.n	6732 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x14>
      break;
    }
    endCluster++;
  }
  // Remember possible next free cluster.
  if (setStart) {
    6764:	cmp.w	sl, #0
    6768:	beq.n	676c <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x4e>
    m_allocSearchStart = endCluster;
    676a:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    676c:	mvn.w	r2, #4026531840	; 0xf0000000
    6770:	mov	r1, r4
    6772:	mov	r0, r5
    6774:	bl	66c2 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) {
    6778:	mov	r6, r0
    677a:	cbnz	r0, 6794 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x76>
  // return first cluster number to caller
  *firstCluster = bgnCluster;
  return true;

 fail:
  return false;
    677c:	movs	r6, #0
    677e:	b.n	67a8 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x8a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) {
    6780:	add.w	sl, r4, #4294967295
    6784:	mov	r2, r4
    6786:	mov	r1, sl
    6788:	mov	r0, r5
    678a:	bl	66c2 <FatPartition::fatPut(unsigned long, unsigned long)>
    678e:	cmp	r0, #0
    6790:	beq.n	677c <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x5e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    endCluster--;
    6792:	mov	r4, sl
  if (!fatPutEOC(endCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // link clusters
  while (endCluster > bgnCluster) {
    6794:	cmp	r7, r4
    6796:	bcc.n	6780 <FatPartition::allocContiguous(unsigned long, unsigned long*)+0x62>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6798:	ldr	r1, [r5, #36]	; 0x24
    679a:	cmp	r1, #0
      m_freeClusterCount += change;
    679c:	itt	ge
    679e:	rsbge	r1, r9, r1
    67a2:	strge	r1, [r5, #36]	; 0x24
  }
  // Maintain count of free clusters.
  updateFreeClusterCount(-count);

  // return first cluster number to caller
  *firstCluster = bgnCluster;
    67a4:	str.w	r7, [r8]
  return true;

 fail:
  return false;
}
    67a8:	mov	r0, r6
    67aa:	add	sp, #8
    67ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000067b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    67b0:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    67b4:	ldr	r4, [r0, #12]
    67b6:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    67b8:	mov	r5, r0
    67ba:	mov	r6, r1
    67bc:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    67be:	bcs.n	67d0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    67c0:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    67c2:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    67c4:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    67c6:	adds	r4, #1
    if (find > m_lastCluster) {
    67c8:	cmp	r4, r3
    67ca:	bls.n	67d4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    67cc:	cbnz	r7, 6802 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    67ce:	ldr	r4, [r5, #12]
      setStart = true;
    67d0:	movs	r7, #1
    67d2:	b.n	67c4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    67d4:	cmp	r6, r4
    67d6:	beq.n	6802 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    67d8:	add	r2, sp, #4
    67da:	mov	r1, r4
    67dc:	mov	r0, r5
    67de:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    67e2:	cmp	r0, #0
    67e4:	blt.n	6802 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    67e6:	beq.n	67c4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    67e8:	ldr	r3, [sp, #4]
    67ea:	cmp	r3, #0
    67ec:	bne.n	67c4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    67ee:	cbz	r7, 67f2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    67f0:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    67f2:	mvn.w	r2, #4026531840	; 0xf0000000
    67f6:	mov	r1, r4
    67f8:	mov	r0, r5
    67fa:	bl	66c2 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    67fe:	mov	r7, r0
    6800:	cbnz	r0, 6806 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    6802:	movs	r7, #0
    6804:	b.n	6828 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    6806:	cbnz	r6, 6814 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6808:	ldr	r3, [r5, #36]	; 0x24
    680a:	cmp	r3, #0
    680c:	blt.n	6824 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    680e:	subs	r3, #1
    6810:	str	r3, [r5, #36]	; 0x24
    6812:	b.n	6824 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    6814:	mov	r2, r4
    6816:	mov	r1, r6
    6818:	mov	r0, r5
    681a:	bl	66c2 <FatPartition::fatPut(unsigned long, unsigned long)>
    681e:	cmp	r0, #0
    6820:	bne.n	6808 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    6822:	b.n	6802 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    6824:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    6828:	mov	r0, r7
    682a:	add	sp, #8
    682c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006830 <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    6830:	push	{r0, r1, r4, r5, r6, lr}
    6832:	mov	r5, r0
    6834:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    6836:	add	r2, sp, #4
    6838:	mov	r1, r4
    683a:	mov	r0, r5
    683c:	bl	6658 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6840:	subs	r6, r0, #0
    6842:	bge.n	6848 <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    6844:	movs	r0, #0
    6846:	b.n	6872 <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6848:	movs	r2, #0
    684a:	mov	r1, r4
    684c:	mov	r0, r5
    684e:	bl	66c2 <FatPartition::fatPut(unsigned long, unsigned long)>
    6852:	cmp	r0, #0
    6854:	beq.n	6844 <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6856:	ldr	r3, [r5, #36]	; 0x24
    6858:	cmp	r3, #0
      m_freeClusterCount += change;
    685a:	itt	ge
    685c:	addge	r3, #1
    685e:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    6860:	ldr	r3, [r5, #12]
    6862:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6864:	itt	cc
    6866:	addcc.w	r4, r4, #4294967295
    686a:	strcc	r4, [r5, #12]
    }
    cluster = next;
    686c:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    686e:	cmp	r6, #0
    6870:	bne.n	6836 <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    6872:	add	sp, #8
    6874:	pop	{r4, r5, r6, pc}
    6876:	Address 0x00006876 is out of bounds.


00006878 <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6878:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    687a:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    687c:	ldr	r0, [r0, #36]	; 0x24
    687e:	cmp	r0, #0
    6880:	bge.n	68c6 <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    6882:	movs	r3, #0
    6884:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    6886:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6888:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    688a:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    688c:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6890:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6892:	bl	6638 <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    6896:	mov	r2, r0
    6898:	cbnz	r0, 68a0 <FatPartition::freeClusterCount()+0x28>
    689a:	mov.w	r0, #4294967295
    689e:	b.n	68c6 <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    68a0:	ldrb	r3, [r4, #7]
    68a2:	ldr	r0, [r4, #0]
    68a4:	cmp	r3, #32
    68a6:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    68a8:	ldr	r1, [r0, #0]
    68aa:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    68ac:	bne.n	68b2 <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    68ae:	ldr	r3, [pc, #28]	; (68cc <FatPartition::freeClusterCount()+0x54>)
    68b0:	b.n	68b4 <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    68b2:	ldr	r3, [pc, #28]	; (68d0 <FatPartition::freeClusterCount()+0x58>)
    68b4:	str	r3, [sp, #0]
    68b6:	ldr	r6, [r1, #20]
    68b8:	ldr	r1, [r4, #24]
    68ba:	mov	r3, r5
    68bc:	blx	r6
    68be:	cmp	r0, #0
    68c0:	beq.n	689a <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    68c2:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    68c4:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    68c6:	add	sp, #16
    68c8:	pop	{r4, r5, r6, pc}
    68ca:	nop
    68cc:	.word	0x0000660f
    68d0:	.word	0x000065e1

000068d4 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    68d4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    68d8:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    68da:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    68dc:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    68e0:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    68e2:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    68e6:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    68e8:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    68ea:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    68ec:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    68ee:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    68f0:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    68f2:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    68f6:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    68fa:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    68fe:	strb.w	r7, [r0, #568]	; 0x238
    6902:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6904:	mov	r5, r1
    6906:	mov	r9, r2
    6908:	bl	6638 <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    690c:	str	r7, [sp, #8]
    690e:	mov	r2, r0
    6910:	str	r7, [sp, #4]
    6912:	str	r7, [sp, #0]
    6914:	add	r3, sp, #20
    6916:	mov	r1, r9
    6918:	mov	r0, r5
    691a:	bl	3150 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    691e:	tst.w	r0, #251	; 0xfb
    6922:	beq.n	69a8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    6924:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6926:	mov	r2, r7
    6928:	mov	r1, r5
    692a:	mov	r0, r8
    692c:	bl	33da <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    6930:	cmp	r0, #0
    6932:	beq.n	69a8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6934:	ldrb	r3, [r0, #16]
    6936:	cmp	r3, #2
    6938:	bne.n	69a8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    693a:	ldrh.w	r3, [r0, #11]
    693e:	cmp.w	r3, #512	; 0x200
    6942:	bne.n	69a8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6944:	b.n	69ac <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    6946:	subs	r2, #1
    6948:	beq.n	69a8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    694a:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    694c:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    694e:	adds	r6, #1
    6950:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6952:	uxtb	r3, r3
    6954:	cmp	r3, r1
    6956:	bne.n	6946 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6958:	ldrh	r3, [r0, #22]
    695a:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    695c:	cbnz	r3, 6962 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    695e:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    6960:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6962:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6964:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6968:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    696a:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    696c:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    696e:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6972:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6974:	lsls	r1, r2, #5
    6976:	addw	r1, r1, #511	; 0x1ff
    697a:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    697e:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6980:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6984:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6986:	cbnz	r3, 698a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6988:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    698a:	subs	r1, r5, r1
    698c:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    698e:	ldrb	r3, [r4, #6]
    6990:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    6992:	adds	r3, r1, #1
    6994:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6996:	mov.w	r3, #4294967295
    699a:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    699c:	movw	r3, #4084	; 0xff4
    69a0:	cmp	r1, r3
    69a2:	bhi.n	69bc <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    69a4:	movs	r3, #12
    69a6:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    69a8:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    69aa:	b.n	69d6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    69ac:	ldrb	r1, [r0, #13]
    69ae:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    69b0:	subs	r3, r1, #1
    69b2:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    69b4:	strb	r7, [r4, #6]
    69b6:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    69b8:	mov	r3, r6
    69ba:	b.n	6954 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    69bc:	movw	r3, #65524	; 0xfff4
    69c0:	cmp	r1, r3
    69c2:	ittet	hi
    69c4:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    69c6:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    69c8:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    69ca:	movhi	r3, #32
    69cc:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    69ce:	str	r6, [r4, #48]	; 0x30
    69d0:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    69d4:	movs	r0, #1

 fail:
  return false;
}
    69d6:	add	sp, #28
    69d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000069dc <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    69dc:	subs	r1, r0, #1
    69de:	add.w	r2, r0, #10
    uint8_t sum = 0;
    69e2:	movs	r0, #0
    69e4:	lsls	r3, r0, #7
    69e6:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    69ea:	ldrb.w	r3, [r1, #1]!
    69ee:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    69f2:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    69f4:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    69f6:	bne.n	69e4 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    69f8:	bx	lr

000069fa <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    69fa:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    69fe:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6a00:	mov	r6, r2
    6a02:	mov	r7, r0
    6a04:	mov	r8, r1
    6a06:	mov	r9, r3
  FatFile dir = *this;
    6a08:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6a0a:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6a0c:	add	r4, sp, #12
    6a0e:	stmia	r4!, {r0, r1, r2, r3}
    6a10:	ldmia	r5!, {r0, r1, r2, r3}
    6a12:	stmia	r4!, {r0, r1, r2, r3}
    6a14:	ldr	r3, [r5, #0]
    6a16:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6a18:	ldr	r3, [r6, #0]
    6a1a:	str	r3, [r6, #4]
    ls = 0;
    6a1c:	movs	r3, #0
    6a1e:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6a20:	movs	r5, #1
    6a22:	cmp	r5, r9
    6a24:	bhi.n	6a60 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6a26:	rsb	r1, r5, r8
    6a2a:	uxth	r1, r1
    6a2c:	add	r0, sp, #12
    6a2e:	bl	5680 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6a32:	mov	fp, r0
    6a34:	cbnz	r0, 6a3a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6a36:	movs	r0, #0
    6a38:	b.n	6a90 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    6a3a:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    6a3e:	uxtb.w	r2, sl
    6a42:	mov	r1, fp
    6a44:	mov	r0, r7
    6a46:	bl	569a <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6a4a:	ldrh	r3, [r6, #12]
    6a4c:	mov	r4, r0
    6a4e:	cbnz	r3, 6a64 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    6a50:	ldr	r2, [r6, #4]
    6a52:	ldr	r3, [r6, #8]
    6a54:	cmp	r2, r3
    6a56:	bne.n	6a64 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    6a58:	clz	r0, r0
    6a5c:	lsrs	r0, r0, #5
    6a5e:	b.n	6a90 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    6a60:	movs	r0, #1
    6a62:	b.n	6a90 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6a64:	mov	r0, r6
    6a66:	bl	34cc <FsName::get16()>
    6a6a:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    6a6c:	mov	r0, r4
    6a6e:	bl	3428 <toUpcase(unsigned short)>
    6a72:	ldr	r3, [sp, #4]
    6a74:	mov	r4, r0
    6a76:	mov	r0, r3
    6a78:	bl	3428 <toUpcase(unsigned short)>
    6a7c:	cmp	r4, r0
    6a7e:	bne.n	6a36 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    6a80:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6a84:	cmp.w	sl, #13
    6a88:	bne.n	6a3e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6a8a:	adds	r5, #1
    6a8c:	uxtb	r5, r5
    6a8e:	b.n	6a22 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    6a90:	add	sp, #52	; 0x34
    6a92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006a96 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6a96:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6a9a:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6a9c:	mov	r6, r2
    6a9e:	mov	sl, r1
    6aa0:	mov	r7, r3
  FatFile dir = *this;
    6aa2:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6aa4:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6aa6:	add	r4, sp, #12
    6aa8:	stmia	r4!, {r0, r1, r2, r3}
    6aaa:	ldmia	r5!, {r0, r1, r2, r3}
    6aac:	stmia	r4!, {r0, r1, r2, r3}
    6aae:	ldr	r3, [r5, #0]
    6ab0:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    6ab2:	add.w	r0, r6, #22
    6ab6:	bl	69dc <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    6aba:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6abc:	ldr	r3, [r6, #0]
    6abe:	str	r3, [r6, #4]
    6ac0:	mov	r9, r0
    ls = 0;
    6ac2:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6ac4:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    6ac8:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6aca:	cmp	fp, r7
    6acc:	bhi.n	6b1c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6ace:	rsb	r1, fp, sl
    6ad2:	uxth	r1, r1
    6ad4:	add	r0, sp, #12
    6ad6:	bl	5680 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6ada:	cmp	r0, #0
    6adc:	beq.n	6b64 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    6ade:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    6ae0:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    6ae4:	cmp	fp, r7
    6ae6:	orr.w	r3, r3, #1
    6aea:	strb.w	r3, [r2, #40]	; 0x28
    6aee:	ite	eq
    6af0:	orreq.w	r3, fp, #64	; 0x40
    6af4:	movne	r3, fp
    6af6:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    6af8:	mov.w	r3, #15
    6afc:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    6afe:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    6b02:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6b06:	strh.w	r8, [r0, #26]
    6b0a:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6b0c:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6b0e:	ldrh	r3, [r6, #12]
    6b10:	cbnz	r3, 6b20 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6b12:	ldr	r2, [r6, #4]
    6b14:	ldr	r3, [r6, #8]
    6b16:	cmp	r2, r3
    6b18:	bne.n	6b20 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6b1a:	b.n	6b52 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    6b1c:	movs	r0, #1
    6b1e:	b.n	6b64 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    6b20:	mov	r0, r6
    6b22:	str	r1, [sp, #4]
    6b24:	bl	34cc <FsName::get16()>
    6b28:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    6b2a:	cmp	r1, #4
    6b2c:	bhi.n	6b34 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    6b2e:	strh.w	r0, [r4, #-3]
    6b32:	b.n	6b3c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6b34:	cmp	r1, #10
    6b36:	ite	ls
    6b38:	strhls	r0, [r4, #0]
    6b3a:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6b3c:	adds	r1, #1
    6b3e:	uxtb	r1, r1
    6b40:	cmp	r1, #13
    6b42:	add.w	r4, r4, #2
    6b46:	bne.n	6b0e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6b48:	add.w	fp, fp, #1
    6b4c:	uxtb.w	fp, fp
    6b50:	b.n	6aca <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6b52:	cbz	r5, 6b5e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6b54:	adds	r5, #1
    6b56:	uxtb	r5, r5
    6b58:	movw	r0, #65535	; 0xffff
    6b5c:	b.n	6b2a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    6b5e:	mov	r0, r5
    6b60:	movs	r5, #1
    6b62:	b.n	6b2a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6b64:	add	sp, #52	; 0x34
    6b66:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006b6a <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6b6a:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    6b6c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6b70:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6b74:	ldr	r7, [r0, #8]
    6b76:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6b7a:	movs	r4, #32
    6b7c:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6b80:	cmp	r1, r2
    6b82:	bne.n	6b7c <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6b84:	ldrb	r6, [r3, #0]
    6b86:	subs	r6, #46	; 0x2e
    6b88:	it	ne
    6b8a:	movne	r6, #1
    6b8c:	mov	r5, r3
    6b8e:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    6b90:	ldrb	r2, [r5, #0]
    6b92:	cmp	r2, #46	; 0x2e
    6b94:	beq.n	6b8c <FatFile::makeSFN(FatName_t*)+0x22>
    6b96:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    6b98:	cmp	r3, r5
    6b9a:	mov	lr, r3
    6b9c:	bhi.n	6bae <FatFile::makeSFN(FatName_t*)+0x44>
    6b9e:	movs	r2, #0
    6ba0:	mov.w	ip, #7
    6ba4:	mov	r1, r2
    6ba6:	mov	r8, r2
    6ba8:	mov.w	r9, #8
    6bac:	b.n	6bd2 <FatFile::makeSFN(FatName_t*)+0x68>
    6bae:	ldrb.w	r2, [lr]
    6bb2:	cmp	r2, #46	; 0x2e
    6bb4:	add.w	r3, r3, #4294967295
    6bb8:	bne.n	6b98 <FatFile::makeSFN(FatName_t*)+0x2e>
    6bba:	b.n	6b9e <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    6bbc:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    6bbe:	cmp	r3, #46	; 0x2e
    6bc0:	bne.n	6bd8 <FatFile::makeSFN(FatName_t*)+0x6e>
    6bc2:	cmp	lr, r5
    6bc4:	bne.n	6be0 <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    6bc6:	mov.w	ip, #10
      i = 8;    // Place for extension.
    6bca:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6bcc:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    6bd0:	adds	r5, #1
    6bd2:	cmp	r5, r7
    6bd4:	bcc.n	6bbc <FatFile::makeSFN(FatName_t*)+0x52>
    6bd6:	b.n	6c62 <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    6bd8:	cmp	r3, #34	; 0x22
    6bda:	beq.n	6c04 <FatFile::makeSFN(FatName_t*)+0x9a>
    6bdc:	cmp	r3, #124	; 0x7c
    6bde:	beq.n	6c04 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6be0:	sub.w	r4, r3, #42	; 0x2a
    6be4:	cmp	r4, #5
    6be6:	bhi.n	6bec <FatFile::makeSFN(FatName_t*)+0x82>
    6be8:	cmp	r3, #45	; 0x2d
    6bea:	bne.n	6c04 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    6bec:	sub.w	r4, r3, #58	; 0x3a
    6bf0:	cmp	r4, #5
    6bf2:	bls.n	6c04 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    6bf4:	sub.w	r4, r3, #91	; 0x5b
    6bf8:	cmp	r4, #2
    6bfa:	bls.n	6c04 <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    6bfc:	sub.w	r4, r3, #33	; 0x21
    6c00:	cmp	r4, #93	; 0x5d
    6c02:	bls.n	6c0e <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    6c04:	and.w	r3, r3, #192	; 0xc0
    6c08:	cmp	r3, #128	; 0x80
    6c0a:	bne.n	6c34 <FatFile::makeSFN(FatName_t*)+0xca>
    6c0c:	b.n	6c58 <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6c0e:	cmp	r1, ip
    6c10:	bls.n	6c22 <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    6c12:	cmp.w	ip, #10
    6c16:	beq.n	6c60 <FatFile::makeSFN(FatName_t*)+0xf6>
    6c18:	cmp	lr, r5
    6c1a:	bcc.n	6c60 <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    6c1c:	add.w	r5, lr, #4294967295
    6c20:	b.n	6c58 <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    6c22:	sub.w	r4, r3, #97	; 0x61
    6c26:	cmp	r4, #25
    6c28:	bhi.n	6c3c <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    6c2a:	subs	r3, #32
    6c2c:	uxtb	r3, r3
        lc |= bit;
    6c2e:	orr.w	r2, r9, r2
    6c32:	b.n	6c48 <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6c34:	cmp	r1, ip
    6c36:	bhi.n	6c12 <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    6c38:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6c3a:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    6c3c:	sub.w	r4, r3, #65	; 0x41
    6c40:	cmp	r4, #25
        uc |= bit;
    6c42:	it	ls
    6c44:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    6c48:	adds	r4, r1, #1
    6c4a:	uxtb	r4, r4
    6c4c:	add	r1, r0
      if (i < 7) {
    6c4e:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    6c50:	strb	r3, [r1, #22]
      if (i < 7) {
    6c52:	bhi.n	6c5c <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    6c54:	strb	r4, [r0, #20]
    6c56:	b.n	6c5c <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6c58:	movs	r6, #0
    6c5a:	b.n	6bd0 <FatFile::makeSFN(FatName_t*)+0x66>
    6c5c:	mov	r1, r4
    6c5e:	b.n	6bd0 <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    6c60:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6c62:	ldrb	r3, [r0, #22]
    6c64:	cmp	r3, #32
    6c66:	beq.n	6c8c <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    6c68:	cbz	r6, 6c7a <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    6c6a:	tst.w	r8, r2
    6c6e:	it	ne
    6c70:	movne	r2, #2
    6c72:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    6c74:	movs	r0, #1
    6c76:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    6c7a:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    6c7c:	movs	r3, #1
    6c7e:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    6c80:	add	r0, r2
    6c82:	movs	r2, #126	; 0x7e
    6c84:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    6c86:	movs	r2, #49	; 0x31
    6c88:	strb	r2, [r0, #23]
    6c8a:	b.n	6c74 <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    6c8c:	movs	r0, #0
    6c8e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006c92 <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6c92:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    6c96:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6c98:	mov	r7, r0
    6c9a:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    6c9c:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    6c9e:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    6ca2:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6ca6:	bl	9220 <micros>
    6caa:	cmp	r5, #3
    6cac:	it	cs
    6cae:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6cb0:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6cb2:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6cb4:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    6cb6:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6cba:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6cbc:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6cbe:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6cc0:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6cc2:	ite	ls
    6cc4:	addls	r2, #48	; 0x30
    6cc6:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6cc8:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6cca:	strb	r2, [r1, #22]
      hex >>= 4;
    6ccc:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6cd0:	bcc.n	6cb6 <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    6cd2:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    6cd4:	movs	r1, #0
    6cd6:	strb.w	r8, [r3, #22]
    6cda:	mov	r0, r7
    6cdc:	bl	5b7e <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    6ce0:	movs	r1, #1
    6ce2:	mov	r0, r7
    6ce4:	bl	5b44 <FatFile::readDirCache(bool)>
      if (!dir) {
    6ce8:	mov	r1, r0
    6cea:	cbnz	r0, 6cf8 <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    6cec:	ldrb	r0, [r7, #1]
    6cee:	clz	r0, r0
    6cf2:	lsrs	r0, r0, #5
    6cf4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    6cf8:	ldrb	r3, [r0, #0]
    6cfa:	cbz	r3, 6d10 <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    6cfc:	ldrb	r3, [r0, #11]
    6cfe:	lsls	r3, r3, #28
    6d00:	bmi.n	6ce0 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    6d02:	movs	r2, #11
    6d04:	mov	r0, r9
    6d06:	bl	bb00 <memcmp>
    6d0a:	cmp	r0, #0
    6d0c:	bne.n	6ce0 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    6d0e:	b.n	6d16 <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    6d10:	movs	r0, #1
    6d12:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6d16:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    6d18:	ands.w	r4, r0, #255	; 0xff
    6d1c:	bne.n	6ca6 <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    6d1e:	mov	r0, r4
    6d20:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00006d24 <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6d24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6d28:	sub	sp, #44	; 0x2c
    6d2a:	mov	r6, r1
    6d2c:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6d2e:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6d30:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6d32:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6d36:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6d38:	bne.n	6d3e <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    6d3a:	movs	r0, #0
    6d3c:	b.n	6f68 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6d3e:	ldr	r3, [sp, #24]
    6d40:	ldrb	r3, [r3, #0]
    6d42:	cmp	r3, #0
    6d44:	bne.n	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    6d46:	ldr	r3, [r2, #16]
    6d48:	movs	r2, #13
    6d4a:	adds	r3, #12
    6d4c:	udiv	r3, r3, r2
    6d50:	uxtb	r3, r3
    6d52:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    6d54:	ldrb.w	r3, [sl, #21]
    6d58:	lsls	r3, r3, #30
    6d5a:	beq.w	6f62 <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    6d5e:	ldr	r3, [sp, #8]
    6d60:	add.w	fp, r3, #1
    6d64:	uxtb.w	fp, fp
    6d68:	movs	r1, #0
    6d6a:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    6d6c:	mov.w	r9, #0
    6d70:	bl	5b7e <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6d74:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    6d78:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    6d7c:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    6d7e:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    6d80:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    6d82:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6d86:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    6d88:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    6d8a:	movs	r1, #0
    6d8c:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    6d8e:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    6d92:	bl	5b44 <FatFile::readDirCache(bool)>
    if (!dir) {
    6d96:	cbnz	r0, 6da0 <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    6d98:	ldrb	r3, [r6, #1]
    6d9a:	cmp	r3, #0
    6d9c:	beq.n	6e60 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    6d9e:	b.n	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    6da0:	ldrb	r3, [r0, #0]
    6da2:	cmp	r3, #229	; 0xe5
    6da4:	beq.n	6da8 <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    6da6:	cbnz	r3, 6dba <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    6da8:	cmp	r4, #0
    6daa:	it	eq
    6dac:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    6dae:	cmp	r4, fp
        freeFound++;
    6db0:	itt	cc
    6db2:	addcc	r4, #1
    6db4:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    6db6:	cbnz	r3, 6dc2 <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    6db8:	b.n	6e60 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    6dba:	cmp	r4, fp
    6dbc:	it	cc
    6dbe:	movcc	r4, #0
    6dc0:	b.n	6dca <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    6dc2:	cmp	r3, #229	; 0xe5
    6dc4:	bne.n	6dca <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    6dc6:	movs	r5, #0
    6dc8:	b.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    6dca:	cmp	r3, #46	; 0x2e
    6dcc:	beq.n	6dc6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    6dce:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    6dd0:	cmp	r2, #15
    6dd2:	bne.n	6e24 <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    6dd4:	cbnz	r5, 6df4 <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    6dd6:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    6dd8:	and.w	r8, r3, #31
        if (order != nameOrd ||
    6ddc:	cmp	r2, r8
    6dde:	bne.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    6de0:	lsls	r1, r3, #25
    6de2:	bmi.n	6dea <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    6de4:	ldr.w	r8, [sp, #8]
    6de8:	b.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    6dea:	ldrb	r3, [r0, #13]
    6dec:	str	r3, [sp, #16]
    6dee:	mov	r8, r2
    6df0:	mov	r5, r2
    6df2:	b.n	6e08 <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    6df4:	add.w	r8, r8, #4294967295
    6df8:	uxtb.w	r8, r8
    6dfc:	cmp	r3, r8
    6dfe:	bne.n	6dc6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    6e00:	ldrb	r3, [r0, #13]
    6e02:	ldr	r2, [sp, #16]
    6e04:	cmp	r2, r3
    6e06:	bne.n	6dc6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    6e08:	cmp.w	r8, #1
    6e0c:	bne.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    6e0e:	adds	r1, r7, #1
    6e10:	mov	r3, r5
    6e12:	mov	r2, sl
    6e14:	uxth	r1, r1
    6e16:	mov	r0, r6
    6e18:	bl	69fa <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    6e1c:	cmp	r0, #0
    6e1e:	it	eq
    6e20:	moveq	r5, #0
    6e22:	b.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    6e24:	lsls	r3, r2, #28
    6e26:	bmi.n	6dc6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    6e28:	cbz	r5, 6e3e <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    6e2a:	cmp.w	r8, #1
    6e2e:	bne.n	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6e30:	bl	69dc <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    6e34:	ldr	r3, [sp, #16]
    6e36:	cmp	r3, r0
    6e38:	bne.w	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6e3c:	b.n	6e58 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6e3e:	movs	r2, #11
    6e40:	ldr	r1, [sp, #28]
    6e42:	bl	bb00 <memcmp>
    6e46:	cmp	r0, #0
    6e48:	bne.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    6e4a:	ldrb.w	r3, [sl, #21]
    6e4e:	lsls	r0, r3, #31
    6e50:	bpl.n	6e58 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    6e52:	movs	r3, #1
    6e54:	str	r3, [sp, #20]
    6e56:	b.n	6d88 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    6e58:	ldr	r3, [sp, #12]
    6e5a:	lsls	r1, r3, #20
    6e5c:	bpl.n	6f52 <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    6e5e:	b.n	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    6e60:	ldr	r3, [sp, #12]
    6e62:	lsls	r2, r3, #22
    6e64:	bpl.w	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6e68:	and.w	r3, r3, #3
    6e6c:	subs	r3, #1
    6e6e:	cmp	r3, #1
    6e70:	bhi.w	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    6e74:	cmp	r4, #0
    6e76:	it	eq
    6e78:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    6e7a:	cmp	r4, fp
    6e7c:	bcc.n	6e84 <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    6e7e:	ldr	r3, [sp, #20]
    6e80:	cbnz	r3, 6eb2 <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    6e82:	b.n	6ec0 <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    6e84:	movs	r1, #0
    6e86:	mov	r0, r6
    6e88:	bl	5b44 <FatFile::readDirCache(bool)>
    if (!dir) {
    6e8c:	cbnz	r0, 6e94 <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    6e8e:	ldrb	r3, [r6, #1]
    6e90:	cbz	r3, 6ea6 <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    6e92:	b.n	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    6e94:	adds	r4, #1
    6e96:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    6e98:	b.n	6e7a <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    6e9a:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    6e9c:	ldrb	r3, [r3, #4]
    6e9e:	add	r4, r3
    6ea0:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    6ea2:	cmp	fp, r4
    6ea4:	bls.n	6e7e <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    6ea6:	mov	r0, r6
    6ea8:	bl	589c <FatFile::addDirCluster()>
    6eac:	cmp	r0, #0
    6eae:	bne.n	6e9a <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    6eb0:	b.n	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    6eb2:	mov	r1, sl
    6eb4:	mov	r0, r6
    6eb6:	bl	6c92 <FatFile::makeUniqueSfn(FatName_t*)>
    6eba:	cmp	r0, #0
    6ebc:	beq.w	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    6ec0:	add.w	r5, fp, #4294967295
    6ec4:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    6ec6:	add.w	r7, r9, r5
    6eca:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    6ecc:	mov	r3, r5
    6ece:	mov	r2, sl
    6ed0:	mov	r1, r7
    6ed2:	mov	r0, r6
    6ed4:	bl	6a96 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    6ed8:	cmp	r0, #0
    6eda:	beq.w	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    6ede:	mov	r1, r7
    6ee0:	mov	r0, r6
    6ee2:	bl	5680 <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    6ee6:	mov	r4, r0
    6ee8:	cmp	r0, #0
    6eea:	beq.w	6d3a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    6eee:	movs	r2, #32
    6ef0:	movs	r1, #0
    6ef2:	bl	8cf4 <memset>
  memcpy(dir->name, fname->sfn, 11);
    6ef6:	mov	r3, sl
    6ef8:	ldr.w	r2, [r3, #22]!
    6efc:	str	r2, [r4, #0]
    6efe:	ldr	r2, [r3, #4]
    6f00:	str	r2, [r4, #4]
    6f02:	ldrh	r2, [r3, #8]
    6f04:	strh	r2, [r4, #8]
    6f06:	ldrb	r3, [r3, #10]
    6f08:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    6f0a:	ldrb.w	r3, [sl, #21]
    6f0e:	and.w	r3, r3, #24
    6f12:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    6f14:	ldr	r3, [pc, #88]	; (6f70 <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    6f16:	ldr	r3, [r3, #0]
    6f18:	cbz	r3, 6f3a <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    6f1a:	add.w	r2, sp, #35	; 0x23
    6f1e:	add.w	r1, sp, #38	; 0x26
    6f22:	add	r0, sp, #36	; 0x24
    6f24:	blx	r3
    6f26:	ldrh.w	r3, [sp, #36]	; 0x24
    6f2a:	strh	r3, [r4, #16]
    6f2c:	ldrh.w	r3, [sp, #38]	; 0x26
    6f30:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    6f32:	ldrb.w	r3, [sp, #35]	; 0x23
    6f36:	strb	r3, [r4, #13]
    6f38:	b.n	6f44 <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    6f3a:	movw	r3, #21537	; 0x5421
    6f3e:	strh	r3, [r4, #16]
    6f40:	strh	r3, [r4, #24]
    6f42:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    6f44:	ldr	r2, [r6, #8]
    6f46:	ldrb.w	r3, [r2, #40]	; 0x28
    6f4a:	orr.w	r3, r3, #1
    6f4e:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    6f52:	str	r5, [sp, #0]
    6f54:	ldr	r3, [sp, #12]
    6f56:	ldr	r0, [sp, #24]
    6f58:	mov	r2, r7
    6f5a:	mov	r1, r6
    6f5c:	bl	5c2a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    6f60:	b.n	6f68 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    6f62:	mov.w	fp, #1
    6f66:	b.n	6d68 <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    6f68:	add	sp, #44	; 0x2c
    6f6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6f6e:	nop
    6f70:	.word	0x20019e98

00006f74 <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    6f74:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6f76:	mov	r4, r2
    6f78:	mov	r6, r3
    6f7a:	mov	r0, r1
    6f7c:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    6f7e:	ldrb	r3, [r0, #0]
    6f80:	cmp	r3, #32
    6f82:	beq.n	6f7a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    6f84:	ldr	r7, [pc, #128]	; (7008 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    6f86:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    6f88:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    6f8a:	ldrb	r3, [r0, #0]
    6f8c:	cbz	r3, 6fe0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    6f8e:	cmp	r3, #47	; 0x2f
    6f90:	beq.n	6fe0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    6f92:	add	r2, sp, #4
    6f94:	adds	r1, r0, #4
    6f96:	bl	30cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    6f9a:	cbz	r0, 7000 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    6f9c:	ldr	r2, [sp, #4]
    6f9e:	cmp.w	r2, #65536	; 0x10000
    6fa2:	ite	cs
    6fa4:	movcs	r3, #2
    6fa6:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    6fa8:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    6faa:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    6fac:	bhi.n	6fd6 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    6fae:	cmp	r2, #31
    6fb0:	bls.n	7000 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6fb2:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    6fb4:	sub.w	r1, r3, #34	; 0x22
    6fb8:	uxtb	r1, r1
    6fba:	cmp	r1, #29
    6fbc:	bhi.n	6fc6 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    6fbe:	lsr.w	r1, r7, r1
    6fc2:	lsls	r1, r1, #31
    6fc4:	bmi.n	7000 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    6fc6:	and.w	r3, r3, #191	; 0xbf
    6fca:	cmp	r3, #60	; 0x3c
    6fcc:	beq.n	7000 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6fce:	cmp	r2, #92	; 0x5c
    6fd0:	beq.n	7000 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    6fd2:	cmp	r2, #46	; 0x2e
    6fd4:	beq.n	6f8a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    6fd6:	cmp	r2, #32
    6fd8:	beq.n	6f8a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    6fda:	str	r5, [r4, #16]
      fname->end = path;
    6fdc:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    6fde:	b.n	6f8a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    6fe0:	ldr	r3, [r4, #16]
    6fe2:	subs	r3, #1
    6fe4:	cmp	r3, #254	; 0xfe
    6fe6:	bhi.n	7000 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6fe8:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    6fea:	ldrb.w	r3, [r0], #1
    6fee:	cmp	r3, #32
    6ff0:	beq.n	6fe8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    6ff2:	cmp	r3, #47	; 0x2f
    6ff4:	beq.n	6fe8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    6ff6:	str	r2, [r6, #0]
  return makeSFN(fname);
    6ff8:	mov	r0, r4
    6ffa:	bl	6b6a <FatFile::makeSFN(FatName_t*)>
    6ffe:	b.n	7002 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    7000:	movs	r0, #0
}
    7002:	add	sp, #12
    7004:	pop	{r4, r5, r6, r7, pc}
    7006:	nop
    7008:	.word	0x31002101

0000700c <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    700c:	push	{r4, r5, r6, r7, lr}
    700e:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    7010:	movs	r3, #0
    7012:	strb.w	r3, [sp, #4]
    7016:	strb.w	r3, [sp, #5]
    701a:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    701e:	ldrb	r3, [r0, #2]
    7020:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    7022:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    7024:	bpl.n	7056 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    7026:	ldr	r1, [r0, #32]
    7028:	cbz	r1, 7032 <FatFile::remove()+0x26>
    702a:	ldr	r0, [r0, #8]
    702c:	bl	6830 <FatPartition::freeChain(unsigned long)>
    7030:	cbz	r0, 7056 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    7032:	movs	r1, #1
    7034:	mov	r0, r4
    7036:	bl	5928 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    703a:	mov	r5, r0
    703c:	cbz	r0, 7056 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    703e:	bl	69dc <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    7042:	movs	r6, #229	; 0xe5
    7044:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    7046:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    7048:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    704a:	strb	r3, [r4, #0]
  m_flags = 0;
    704c:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    704e:	ldr	r0, [r4, #8]
    7050:	bl	5840 <FatPartition::cacheSync()>
    7054:	cbnz	r0, 705a <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    7056:	movs	r0, #0
    7058:	b.n	70ba <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    705a:	ldrb	r3, [r4, #3]
    705c:	cbz	r3, 70ba <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    705e:	mov	r1, r4
    7060:	add	r0, sp, #4
    7062:	bl	5976 <FatFile::openCluster(FatFile*)>
    7066:	cmp	r0, #0
    7068:	beq.n	7056 <FatFile::remove()+0x4a>
    706a:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    706c:	ldrb	r3, [r4, #3]
    706e:	cmp	r3, r5
    7070:	bcc.n	7056 <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    7072:	ldrh	r1, [r4, #4]
    7074:	subs	r1, r1, r5
    7076:	uxth	r1, r1
    7078:	add	r0, sp, #4
    707a:	bl	5680 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    707e:	cmp	r0, #0
    7080:	beq.n	7056 <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    7082:	ldrb	r3, [r0, #11]
    7084:	cmp	r3, #15
    7086:	bne.n	7056 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7088:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    708a:	and.w	r3, r2, #31
    708e:	cmp	r5, r3
    7090:	bne.n	7056 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7092:	ldrb	r3, [r0, #13]
    7094:	cmp	r3, r7
    7096:	bne.n	7056 <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    7098:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    709a:	ldr	r1, [r4, #8]
    709c:	ldrb.w	r3, [r1, #40]	; 0x28
    70a0:	orr.w	r3, r3, #1
    70a4:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    70a8:	lsls	r3, r2, #25
    70aa:	bpl.n	70b4 <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    70ac:	ldr	r0, [r4, #8]
    70ae:	bl	5840 <FatPartition::cacheSync()>
    70b2:	b.n	70ba <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    70b4:	adds	r5, #1
    70b6:	uxtb	r5, r5
    70b8:	b.n	706c <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    70ba:	add	sp, #44	; 0x2c
    70bc:	pop	{r4, r5, r6, r7, pc}

000070be <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    70be:	push	{r3, r4, r5, r6, r7, lr}
    70c0:	movs	r4, #0
    70c2:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    70c4:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    70c6:	str	r4, [r0, #60]	; 0x3c
    70c8:	mov	r6, r0
    70ca:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    70cc:	cbz	r7, 70f0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    70ce:	mov	r1, r0
    70d0:	movs	r0, #36	; 0x24
    70d2:	bl	7308 <operator new(unsigned int, unsigned long*)>
    70d6:	strb	r4, [r0, #0]
    70d8:	strb	r4, [r0, #1]
    70da:	strb	r4, [r0, #2]
    70dc:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    70de:	ldr	r5, [r5, #56]	; 0x38
    70e0:	mov	r4, r0
    70e2:	ldmia	r5!, {r0, r1, r2, r3}
    70e4:	stmia	r4!, {r0, r1, r2, r3}
    70e6:	ldmia	r5!, {r0, r1, r2, r3}
    70e8:	stmia	r4!, {r0, r1, r2, r3}
    70ea:	ldr	r3, [r5, #0]
    70ec:	str	r3, [r4, #0]
    70ee:	b.n	711c <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    70f0:	ldr	r3, [r1, #60]	; 0x3c
    70f2:	cbz	r3, 711c <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    70f4:	mov	r1, r0
    70f6:	movs	r0, #56	; 0x38
    70f8:	bl	7308 <operator new(unsigned int, unsigned long*)>
    70fc:	strb.w	r7, [r0, #49]	; 0x31
    7100:	strb.w	r7, [r0, #50]	; 0x32
    7104:	strb.w	r7, [r0, #51]	; 0x33
    7108:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    710a:	ldr	r3, [r5, #60]	; 0x3c
    710c:	add.w	r2, r3, #52	; 0x34
    7110:	ldr.w	r1, [r3], #4
    7114:	str.w	r1, [r0], #4
    7118:	cmp	r3, r2
    711a:	bne.n	7110 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    711c:	mov	r0, r6
    711e:	pop	{r3, r4, r5, r6, r7, pc}

00007120 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    7120:	push	{r4, lr}
    7122:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    7124:	ldr	r0, [r0, #56]	; 0x38
    7126:	cbz	r0, 712e <FsBaseFile::close()+0xe>
    7128:	bl	5e54 <FatFile::close()>
    712c:	cbnz	r0, 713e <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    712e:	ldr	r0, [r4, #60]	; 0x3c
    7130:	cbz	r0, 7144 <FsBaseFile::close()+0x24>
    7132:	bl	3c1a <ExFatFile::close()>
    7136:	cbz	r0, 7144 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    7138:	movs	r3, #0
    713a:	str	r3, [r4, #60]	; 0x3c
    713c:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    713e:	movs	r3, #0
    7140:	str	r3, [r4, #56]	; 0x38
    return true;
    7142:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    7144:	movs	r0, #0
}
    7146:	pop	{r4, pc}

00007148 <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    7148:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    714c:	mov	r4, r0
    714e:	mov	r7, r2
    7150:	mov	r8, r3
  if (!vol) {
    7152:	mov	r5, r1
    7154:	cbnz	r1, 715c <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    7156:	movs	r0, #0
    7158:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    715c:	bl	7120 <FsBaseFile::close()>
  if (vol->m_fVol) {
    7160:	ldr.w	r6, [r5, #1152]	; 0x480
    7164:	cbz	r6, 718c <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    7166:	mov	r1, r4
    7168:	movs	r0, #36	; 0x24
    716a:	bl	7308 <operator new(unsigned int, unsigned long*)>
    716e:	movs	r2, #0
    7170:	strb	r2, [r0, #0]
    7172:	strb	r2, [r0, #1]
    7174:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    7176:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    7178:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    717a:	mov	r2, r7
    717c:	ldr.w	r1, [r5, #1152]	; 0x480
    7180:	bl	5f0c <FatFile::open(FatVolume*, char const*, int)>
    7184:	cbz	r0, 71c0 <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    7186:	movs	r0, #1
    7188:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    718c:	ldr.w	r3, [r5, #1156]	; 0x484
    7190:	cmp	r3, #0
    7192:	beq.n	7156 <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    7194:	mov	r1, r4
    7196:	movs	r0, #56	; 0x38
    7198:	bl	7308 <operator new(unsigned int, unsigned long*)>
    719c:	strb.w	r6, [r0, #49]	; 0x31
    71a0:	strb.w	r6, [r0, #50]	; 0x32
    71a4:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    71a8:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    71aa:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    71ac:	mov	r2, r7
    71ae:	ldr.w	r1, [r5, #1156]	; 0x484
    71b2:	bl	439a <ExFatFile::open(ExFatVolume*, char const*, int)>
    71b6:	cmp	r0, #0
    71b8:	bne.n	7186 <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    71ba:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    71bc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    71c0:	str	r0, [r4, #56]	; 0x38
    71c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000071c6 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    71c6:	push	{r3, r4, r5, r6, r7, lr}
    71c8:	mov	r5, r1
    71ca:	mov	r4, r0
    71cc:	mov	r7, r2
  close();
    71ce:	bl	7120 <FsBaseFile::close()>
  if (dir->m_fFile) {
    71d2:	ldr	r6, [r5, #56]	; 0x38
    71d4:	cbz	r6, 71fa <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    71d6:	mov	r1, r4
    71d8:	movs	r0, #36	; 0x24
    71da:	bl	7308 <operator new(unsigned int, unsigned long*)>
    71de:	movs	r2, #0
    71e0:	strb	r2, [r0, #0]
    71e2:	strb	r2, [r0, #1]
    71e4:	strb	r2, [r0, #2]
    71e6:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    71e8:	mov	r2, r7
    71ea:	ldr	r1, [r5, #56]	; 0x38
    71ec:	bl	5cec <FatFile::openNext(FatFile*, int)>
    71f0:	cbz	r0, 71f6 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    71f2:	movs	r0, #1
    71f4:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    71f6:	str	r0, [r4, #56]	; 0x38
    71f8:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    71fa:	ldr	r0, [r5, #60]	; 0x3c
    71fc:	cbz	r0, 7222 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    71fe:	mov	r1, r4
    7200:	movs	r0, #56	; 0x38
    7202:	bl	7308 <operator new(unsigned int, unsigned long*)>
    7206:	strb.w	r6, [r0, #49]	; 0x31
    720a:	strb.w	r6, [r0, #50]	; 0x32
    720e:	strb.w	r6, [r0, #51]	; 0x33
    7212:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    7214:	mov	r2, r7
    7216:	ldr	r1, [r5, #60]	; 0x3c
    7218:	bl	43a8 <ExFatFile::openNext(ExFatFile*, int)>
    721c:	cmp	r0, #0
    721e:	bne.n	71f2 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    7220:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    7222:	pop	{r3, r4, r5, r6, r7, pc}

00007224 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    7224:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    7226:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    7228:	mov	r4, r0
  m_blockDev = blockDev;
    722a:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    722e:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    7232:	mov	r1, r0
    7234:	mov.w	r0, #1152	; 0x480
    7238:	bl	7308 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    723c:	strb.w	r6, [r0, #1092]	; 0x444
    7240:	strb.w	r6, [r0, #1145]	; 0x479
    7244:	strb.w	r6, [r0, #1146]	; 0x47a
    7248:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    724c:	movs	r2, #1
    724e:	str.w	r0, [r4, #1156]	; 0x484
    7252:	ldr.w	r1, [r4, #1160]	; 0x488
    7256:	ldr	r7, [pc, #124]	; (72d4 <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    7258:	mov	r5, r0
    725a:	bl	4700 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    725e:	cbz	r0, 7278 <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    7260:	add.w	r6, r5, #1096	; 0x448
    7264:	mov	r0, r6
    7266:	bl	3c1a <ExFatFile::close()>
    return m_vwd.openRoot(this);
    726a:	mov	r1, r5
    726c:	mov	r0, r6
    726e:	bl	3c6e <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    7272:	cbz	r0, 7278 <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    7274:	ldr	r3, [pc, #96]	; (72d8 <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    7276:	b.n	72be <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7278:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    727a:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    727c:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    7280:	movw	r0, #1132	; 0x46c
    7284:	bl	7308 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    7288:	strb	r6, [r0, #7]
    728a:	strb.w	r6, [r0, #1096]	; 0x448
    728e:	strb.w	r6, [r0, #1097]	; 0x449
    7292:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7296:	movs	r2, #1
    7298:	str.w	r0, [r4, #1152]	; 0x480
    729c:	ldr.w	r1, [r4, #1160]	; 0x488
    72a0:	mov	r5, r0
    72a2:	bl	68d4 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    72a6:	cbz	r0, 72ca <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    72a8:	add.w	r6, r5, #1096	; 0x448
    72ac:	mov	r0, r6
    72ae:	bl	5e54 <FatFile::close()>
    return m_vwd.openRoot(this);
    72b2:	mov	r1, r5
    72b4:	mov	r0, r6
    72b6:	bl	5946 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    72ba:	cbz	r0, 72ca <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    72bc:	ldr	r3, [pc, #28]	; (72dc <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    72be:	ldr	r2, [r3, #0]
    72c0:	cbnz	r2, 72c4 <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    72c2:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    72c4:	str	r4, [r7, #0]
  return true;
    72c6:	movs	r0, #1
    72c8:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    72ca:	movs	r0, #0
    72cc:	str	r0, [r7, #0]
  m_fVol = nullptr;
    72ce:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    72d2:	pop	{r3, r4, r5, r6, r7, pc}
    72d4:	.word	0x20019ea4
    72d8:	.word	0x20019e9c
    72dc:	.word	0x20019ea0

000072e0 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    72e0:	push	{r3, r4, r5, lr}
    72e2:	mov	r4, r0
    72e4:	movs	r0, #0
    72e6:	strb	r0, [r4, #4]
    72e8:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    72ea:	str	r0, [r4, #72]	; 0x48
    72ec:	str	r0, [r4, #76]	; 0x4c
    72ee:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    72f2:	mov	r0, r4
    72f4:	str	r5, [r4, #8]
    72f6:	ldr	r5, [pc, #12]	; (7304 <FsVolume::open(char const*, int)+0x24>)
    72f8:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    72fc:	bl	7148 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    7300:	mov	r0, r4
    7302:	pop	{r3, r4, r5, pc}
    7304:	.word	0x000127e8

00007308 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    7308:	mov	r0, r1
    730a:	bx	lr

0000730c <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    730c:	ldrb	r0, [r0, #15]
    730e:	bx	lr

00007310 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    7310:	ldrb	r0, [r0, #17]
    7312:	bx	lr

00007314 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7314:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    7316:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7318:	ldr	r4, [r3, #16]
    731a:	movs	r3, #1
    731c:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    731e:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7322:	bx	ip

00007324 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    7324:	ldrb	r0, [r0, #18]
    7326:	bx	lr

00007328 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    7328:	bx	lr

0000732a <SdSpiCard::~SdSpiCard()>:
    732a:	push	{r4, lr}
    732c:	movs	r1, #20
    732e:	mov	r4, r0
    7330:	bl	a362 <operator delete(void*, unsigned int)>
    7334:	mov	r0, r4
    7336:	pop	{r4, pc}

00007338 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    7338:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    733a:	ldr	r3, [r0, #0]
    733c:	mov	r1, sp
    733e:	ldr	r3, [r3, #60]	; 0x3c
    7340:	blx	r3
    7342:	cbz	r0, 73b2 <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7344:	ldrb.w	r3, [sp]
    7348:	ands.w	r3, r3, #192	; 0xc0
    734c:	bne.n	738e <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    734e:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7352:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    7356:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    735a:	and.w	r0, r0, #3
    735e:	lsls	r3, r3, #2
    7360:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7364:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7368:	orr.w	r0, r3, r0, lsr #6
    736c:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    736e:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7372:	and.w	r0, r0, #3
    7376:	lsls	r0, r0, #1
    7378:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    737c:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7380:	and.w	r2, r2, #15
    7384:	add	r0, r2
    7386:	subs	r0, #7
    7388:	lsl.w	r0, r3, r0
    738c:	b.n	73b2 <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    738e:	cmp	r3, #64	; 0x40
    7390:	bne.n	73b0 <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7392:	ldrb.w	r0, [sp, #9]
    7396:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7398:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    739c:	and.w	r0, r0, #63	; 0x3f
    73a0:	add.w	r0, r3, r0, lsl #16
    73a4:	ldrb.w	r3, [sp, #8]
    73a8:	add.w	r0, r0, r3, lsl #8
    73ac:	lsls	r0, r0, #10
    73ae:	b.n	73b2 <SdSpiCard::sectorCount()+0x7a>
    73b0:	movs	r0, #0
}
    73b2:	add	sp, #20
    73b4:	ldr.w	pc, [sp], #4

000073b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    73b8:	ldr	r3, [r0, #0]
    73ba:	ldr	r3, [r3, #20]
    73bc:	bx	r3

000073be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    73be:	ldr	r3, [r0, #0]
    73c0:	ldr	r3, [r3, #12]
    73c2:	bx	r3

000073c4 <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    73c4:	ldr	r3, [pc, #12]	; (73d4 <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    73c6:	sub	sp, #8
    73c8:	ldr	r3, [r3, #0]
    73ca:	str	r3, [sp, #4]
	return ret;
    73cc:	ldr	r0, [sp, #4]
  return millis();
}
    73ce:	uxth	r0, r0
    73d0:	add	sp, #8
    73d2:	bx	lr
    73d4:	.word	0x20019f04

000073d8 <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    73d8:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    73da:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    73dc:	mov	r4, r0
  if (!m_spiActive) {
    73de:	cbnz	r5, 73fc <SdSpiCard::spiStart()+0x24>
    73e0:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    73e2:	ldr	r3, [r0, #0]
    73e4:	ldr	r3, [r3, #0]
    73e6:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    73e8:	mov	r1, r5
    73ea:	ldrb	r0, [r4, #14]
    73ec:	bl	8b46 <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    73f0:	movs	r1, #255	; 0xff
    73f2:	ldr	r0, [r4, #4]
    73f4:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    73f8:	movs	r3, #1
    73fa:	strb	r3, [r4, #16]
    73fc:	pop	{r3, r4, r5, pc}

000073fe <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    73fe:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    7400:	push	{r4, lr}
    7402:	mov	r4, r0
  if (m_spiActive) {
    7404:	cbz	r3, 7422 <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7406:	movs	r1, #1
    7408:	ldrb	r0, [r0, #14]
    740a:	bl	8b46 <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    740e:	movs	r1, #255	; 0xff
    7410:	ldr	r0, [r4, #4]
    7412:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7416:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    7418:	ldr	r3, [r0, #0]
    741a:	ldr	r3, [r3, #8]
    741c:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    741e:	movs	r3, #0
    7420:	strb	r3, [r4, #16]
    7422:	pop	{r4, pc}

00007424 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7424:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7426:	ldrb	r3, [r0, #12]
    7428:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    742a:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    742c:	beq.n	744e <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    742e:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    7430:	cbnz	r6, 7436 <SdSpiCard::isBusy()+0x12>
    spiStart();
    7432:	bl	73d8 <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    7436:	ldr	r0, [r5, #4]
    7438:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    743c:	subs.w	r4, r0, #255	; 0xff
    7440:	it	ne
    7442:	movne	r4, #1
  if (!spiActive) {
    7444:	cbnz	r6, 7452 <SdSpiCard::isBusy()+0x2e>
    spiStop();
    7446:	mov	r0, r5
    7448:	bl	73fe <SdSpiCard::spiStop()>
    744c:	b.n	7452 <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    744e:	movs	r0, #0
    7450:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    7452:	mov	r0, r4
}
    7454:	pop	{r4, r5, r6, pc}

00007456 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    7456:	push	{r3, r4, r5, r6, r7, lr}
    7458:	mov	r4, r0
    745a:	mov	r5, r1
    745c:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    745e:	bl	73c4 <SysCall::curTimeMS()>
    7462:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    7464:	ldr	r0, [r4, #4]
    7466:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    746a:	cmp	r0, #255	; 0xff
    746c:	strb	r0, [r4, #17]
    746e:	bne.n	7480 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7470:	bl	73c4 <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    7474:	subs	r0, r0, r7
    7476:	cmp.w	r0, #300	; 0x12c
    747a:	ble.n	7464 <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    747c:	movs	r3, #29
    747e:	b.n	749a <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    7480:	cmp	r0, #254	; 0xfe
    7482:	beq.n	7488 <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    7484:	movs	r3, #24
    7486:	b.n	749a <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    7488:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    748a:	ldr	r3, [r0, #0]
    748c:	mov	r2, r6
    748e:	ldr	r3, [r3, #16]
    7490:	mov	r1, r5
    7492:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    7494:	strb	r0, [r4, #17]
    7496:	cbz	r0, 74a6 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7498:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    749a:	mov	r0, r4
    749c:	strb	r3, [r4, #15]
    749e:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    74a2:	movs	r0, #0
}
    74a4:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    74a6:	ldr	r0, [r4, #4]
    74a8:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    74ac:	ldr	r0, [r4, #4]
    74ae:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    74b2:	movs	r0, #1
    74b4:	pop	{r3, r4, r5, r6, r7, pc}

000074b6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    74b6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74ba:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    74bc:	ldrb	r3, [r0, #12]
    74be:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    74c0:	mov	r4, r0
    74c2:	mov	r5, r1
    74c4:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    74c6:	bne.n	74ce <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    74c8:	ldr	r3, [r0, #8]
    74ca:	cmp	r3, r1
    74cc:	beq.n	74e0 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    74ce:	ldr	r3, [r4, #0]
    74d0:	mov	r1, r5
    74d2:	ldr	r3, [r3, #80]	; 0x50
    74d4:	mov	r0, r4
    74d6:	blx	r3
    74d8:	cbz	r0, 750e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    74da:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    74dc:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    74de:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    74e0:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    74e2:	cmp	r5, r7
    74e4:	add.w	r1, r6, r5, lsl #9
    74e8:	beq.n	74f8 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    74ea:	ldr	r3, [r4, #0]
    74ec:	mov	r0, r4
    74ee:	ldr	r3, [r3, #76]	; 0x4c
    74f0:	blx	r3
    74f2:	cbz	r0, 750e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    74f4:	adds	r5, #1
    74f6:	b.n	74e2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    74f8:	ldr	r3, [r4, #8]
    74fa:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    74fc:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    74fe:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7500:	cbz	r3, 751a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    7502:	ldr	r3, [r4, #0]
    7504:	mov	r0, r4
    7506:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7508:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    750c:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    750e:	mov	r0, r4
    7510:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7514:	movs	r0, #0
    7516:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    751a:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    751c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007520 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7520:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7524:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7526:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7528:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    752c:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    752e:	mov	r4, r0
    7530:	mov	r5, r1
    7532:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7534:	bne.n	753c <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    7536:	ldr	r3, [r0, #8]
    7538:	cmp	r3, r1
    753a:	beq.n	754e <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    753c:	ldr	r3, [r4, #0]
    753e:	mov	r1, r5
    7540:	ldr	r3, [r3, #80]	; 0x50
    7542:	mov	r0, r4
    7544:	blx	r3
    7546:	cbz	r0, 7584 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    7548:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    754a:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    754c:	strb	r3, [r4, #12]
    754e:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7552:	cmp	r5, r9
    7554:	beq.n	756e <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    7556:	mov	r1, r8
    7558:	mov	r0, r5
    755a:	blx	r7
    if (!writeData(src)) {
    755c:	ldr	r3, [r4, #0]
    755e:	mov	r1, r0
    7560:	ldr	r3, [r3, #76]	; 0x4c
    7562:	mov	r0, r4
    7564:	blx	r3
    7566:	adds	r5, #1
    7568:	cmp	r0, #0
    756a:	bne.n	7552 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    756c:	b.n	7584 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    756e:	ldr	r3, [r4, #8]
    7570:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7572:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7574:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7576:	cbz	r3, 7590 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    7578:	ldr	r3, [r4, #0]
    757a:	mov	r0, r4
    757c:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    757e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7582:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7584:	mov	r0, r4
    7586:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    758a:	movs	r0, #0
    758c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7590:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7592:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007596 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    7596:	push	{r4, r5, r6, lr}
    7598:	mov	r6, r0
    759a:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    759c:	bl	73c4 <SysCall::curTimeMS()>
    75a0:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    75a2:	ldr	r0, [r6, #4]
    75a4:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    75a8:	cmp	r0, #255	; 0xff
    75aa:	beq.n	75ba <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    75ac:	bl	73c4 <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    75b0:	subs	r0, r0, r5
    75b2:	cmp	r0, r4
    75b4:	ble.n	75a2 <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    75b6:	movs	r0, #0
    75b8:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    75ba:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    75bc:	pop	{r4, r5, r6, pc}

000075be <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    75be:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    75c0:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    75c2:	str	r2, [sp, #4]
    75c4:	mov	r4, r0
    75c6:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    75c8:	cbz	r3, 75d6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    75ca:	ldr	r3, [r0, #0]
    75cc:	ldr	r3, [r3, #28]
    75ce:	blx	r3
    75d0:	cbnz	r0, 75d6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    75d2:	movs	r0, #255	; 0xff
    75d4:	b.n	7636 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    75d6:	ldrb	r3, [r4, #16]
    75d8:	cbnz	r3, 75e0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    75da:	mov	r0, r4
    75dc:	bl	73d8 <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    75e0:	cbz	r5, 75ec <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    75e2:	mov.w	r1, #300	; 0x12c
    75e6:	mov	r0, r4
    75e8:	bl	7596 <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    75ec:	orr.w	r1, r5, #64	; 0x40
    75f0:	ldr	r0, [r4, #4]
    75f2:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    75f6:	add.w	r6, sp, #7
    75fa:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    75fe:	ldrb.w	r1, [r6], #-1
    7602:	ldr	r0, [r4, #4]
    7604:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    7608:	cmp	r7, r6
    760a:	bne.n	75fe <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    760c:	cmp	r5, #0
    760e:	ite	eq
    7610:	moveq	r1, #149	; 0x95
    7612:	movne	r1, #135	; 0x87
    7614:	ldr	r0, [r4, #4]
    7616:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    761a:	ldr	r0, [r4, #4]
    761c:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7620:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    7622:	ldr	r0, [r4, #4]
    7624:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7628:	lsls	r3, r0, #24
    762a:	strb	r0, [r4, #17]
    762c:	bpl.n	7636 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    762e:	subs	r5, #1
    7630:	ands.w	r5, r5, #255	; 0xff
    7634:	bne.n	7622 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    7636:	add	sp, #12
    7638:	pop	{r4, r5, r6, r7, pc}

0000763a <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    763a:	push	{r4, r5, r6, lr}
    763c:	mov	r4, r0
    763e:	mov	r5, r1
    7640:	mov	r6, r2
    cardCommand(CMD55, 0);
    7642:	movs	r1, #55	; 0x37
    7644:	movs	r2, #0
    7646:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    764a:	mov	r2, r6
    764c:	mov	r1, r5
    764e:	mov	r0, r4
  }
    7650:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    7654:	b.w	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>

00007658 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    7658:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    765c:	sub	sp, #36	; 0x24
    765e:	add	r5, sp, #4
    7660:	stmia.w	r5, {r1, r2, r3}
    7664:	mov	r4, r0
    7666:	ldrb.w	sl, [sp, #4]
    766a:	ldr.w	fp, [sp, #12]
    766e:	ldrb.w	r8, [sp, #5]
    7672:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    7674:	bl	73c4 <SysCall::curTimeMS()>
  m_spiActive = false;
    7678:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    767c:	mov	r7, r0
  m_spiActive = false;
    767e:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    7682:	strb.w	r9, [r4, #15]
  m_type = 0;
    7686:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    768a:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    768e:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    7692:	cmp.w	fp, #0
    7696:	bne.n	769c <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7698:	movs	r3, #42	; 0x2a
    769a:	b.n	77d0 <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    769c:	mov	r0, sl
    769e:	bl	8b40 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    76a2:	movs	r1, #1
    76a4:	ldrb	r0, [r4, #14]
    76a6:	bl	8b46 <sdCsWrite(unsigned char, bool)>
    76aa:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    76ac:	ldr	r1, [pc, #344]	; (7808 <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    76ae:	ldr	r3, [r0, #0]
    76b0:	ldr	r3, [r3, #28]
    76b2:	blx	r3
    76b4:	ldmia.w	r5, {r0, r1, r2}
    76b8:	add	r3, sp, #20
    76ba:	ldr.w	lr, [r4, #4]
    76be:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    76c2:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    76c6:	and.w	r8, r8, #1
    76ca:	mov	r0, lr
    76cc:	ldr	r5, [r2, #4]
    76ce:	eor.w	r8, r8, #1
    76d2:	ldmia	r3, {r1, r2, r3}
    76d4:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    76d6:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    76d8:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    76dc:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    76e0:	bl	73d8 <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    76e4:	movs	r1, #1
    76e6:	ldrb	r0, [r4, #14]
    76e8:	bl	8b46 <sdCsWrite(unsigned char, bool)>
    76ec:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    76ee:	movs	r1, #255	; 0xff
    76f0:	ldr	r0, [r4, #4]
    76f2:	subs	r5, #1
    76f4:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    76f8:	ands.w	r5, r5, #255	; 0xff
    76fc:	bne.n	76ee <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    76fe:	mov	r1, r5
    7700:	ldrb	r0, [r4, #14]
    7702:	bl	8b46 <sdCsWrite(unsigned char, bool)>
    7706:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    7708:	movs	r2, #0
    770a:	mov	r1, r2
    770c:	mov	r0, r4
    770e:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7712:	cmp	r0, #1
    7714:	mov	r8, r0
    7716:	beq.n	773e <SdSpiCard::begin(SdSpiConfig)+0xe6>
    7718:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    771a:	ands.w	r5, r5, #255	; 0xff
    771e:	bne.n	7724 <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7720:	movs	r3, #1
    7722:	b.n	77d0 <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    7724:	movs	r1, #253	; 0xfd
    7726:	ldr	r0, [r4, #4]
    7728:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    772c:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7730:	ldr	r0, [r4, #4]
    7732:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    7736:	subs.w	r8, r8, #1
    773a:	bne.n	7730 <SdSpiCard::begin(SdSpiConfig)+0xd8>
    773c:	b.n	7708 <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    773e:	mov.w	r2, #426	; 0x1aa
    7742:	movs	r1, #8
    7744:	mov	r0, r4
    7746:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    774a:	lsls	r3, r0, #29
    774c:	bmi.n	776c <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    774e:	movs	r3, #2
    7750:	strb	r3, [r4, #18]
    7752:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7754:	ldr	r0, [r4, #4]
    7756:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    775a:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    775c:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7760:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7762:	bne.n	7754 <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7764:	cmp	r0, #170	; 0xaa
    7766:	beq.n	7770 <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7768:	movs	r3, #6
    776a:	b.n	77d0 <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    776c:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7770:	ldr	r3, [r4, #0]
    7772:	mov	r0, r4
    7774:	ldr	r3, [r3, #72]	; 0x48
    7776:	blx	r3
    7778:	cmp	r0, #2
    777a:	ite	eq
    777c:	moveq.w	r8, #1073741824	; 0x40000000
    7780:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7784:	mov	r2, r8
    7786:	movs	r1, #41	; 0x29
    7788:	mov	r0, r4
    778a:	bl	763a <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    778e:	mov	r5, r0
    7790:	cbz	r0, 77a2 <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7792:	bl	73c4 <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    7796:	subs	r0, r0, r7
    7798:	cmp.w	r0, #2000	; 0x7d0
    779c:	ble.n	7784 <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    779e:	movs	r3, #23
    77a0:	b.n	77d0 <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    77a2:	ldr	r3, [r4, #0]
    77a4:	mov	r0, r4
    77a6:	ldr	r3, [r3, #72]	; 0x48
    77a8:	blx	r3
    77aa:	cmp	r0, #2
    77ac:	beq.n	77c2 <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    77ae:	mov	r0, r4
    77b0:	bl	73fe <SdSpiCard::spiStop()>
    77b4:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    77b6:	ldr	r3, [r0, #0]
    77b8:	mov	r1, r6
    77ba:	ldr	r3, [r3, #28]
    77bc:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    77be:	movs	r0, #1
    77c0:	b.n	7802 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    77c2:	mov	r2, r5
    77c4:	movs	r1, #58	; 0x3a
    77c6:	mov	r0, r4
    77c8:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    77cc:	cbz	r0, 77dc <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    77ce:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    77d0:	mov	r0, r4
    77d2:	strb	r3, [r4, #15]
    77d4:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    77d8:	movs	r0, #0
    77da:	b.n	7802 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    77dc:	ldr	r0, [r4, #4]
    77de:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    77e2:	and.w	r0, r0, #192	; 0xc0
    77e6:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    77e8:	itt	eq
    77ea:	moveq	r3, #3
    77ec:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    77ee:	ldr	r0, [r4, #4]
    77f0:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    77f4:	ldr	r0, [r4, #4]
    77f6:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    77fa:	ldr	r0, [r4, #4]
    77fc:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7800:	b.n	77ae <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    7802:	add	sp, #36	; 0x24
    7804:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7808:	.word	0x00061a80

0000780c <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    780c:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    780e:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7810:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7812:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7814:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7816:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    781a:	cbz	r0, 782a <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    781c:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    781e:	mov	r0, r4
    7820:	strb	r3, [r4, #15]
    7822:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7826:	movs	r0, #0
    7828:	pop	{r4, r5, r6, pc}
    782a:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    782c:	ldr	r0, [r4, #4]
    782e:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7832:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7836:	cmp	r5, r6
    7838:	bne.n	782c <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    783a:	mov	r0, r4
    783c:	bl	73fe <SdSpiCard::spiStop()>
  return true;
    7840:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7842:	pop	{r4, r5, r6, pc}

00007844 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7844:	push	{r3, r4, r5, lr}
    7846:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7848:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    784a:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    784c:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7850:	cbz	r0, 7858 <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7852:	movs	r3, #27
    7854:	strb	r3, [r4, #15]
    7856:	b.n	786e <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7858:	mov	r1, r5
    785a:	movs	r2, #16
    785c:	mov	r0, r4
    785e:	bl	7456 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7862:	mov	r5, r0
    7864:	cbz	r0, 786e <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    7866:	mov	r0, r4
    7868:	bl	73fe <SdSpiCard::spiStop()>
  return true;
    786c:	b.n	7876 <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    786e:	mov	r0, r4
    7870:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7874:	movs	r5, #0
}
    7876:	mov	r0, r5
    7878:	pop	{r3, r4, r5, pc}

0000787a <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    787a:	mov	r2, r1
    787c:	movs	r1, #9
    787e:	b.w	7844 <SdSpiCard::readRegister(unsigned char, void*)>

00007882 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7882:	mov	r2, r1
    7884:	movs	r1, #10
    7886:	b.w	7844 <SdSpiCard::readRegister(unsigned char, void*)>

0000788a <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    788a:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    788c:	ldr	r3, [r0, #0]
    788e:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7890:	mov	r5, r1
    7892:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7894:	blx	r3
    7896:	cmp	r0, #3
    sector <<= 9;
    7898:	it	ne
    789a:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    789c:	mov	r2, r5
    789e:	movs	r1, #18
    78a0:	mov	r0, r4
    78a2:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    78a6:	cbz	r0, 78b6 <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    78a8:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    78aa:	mov	r0, r4
    78ac:	strb	r3, [r4, #15]
    78ae:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    78b2:	movs	r0, #0
    78b4:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    78b6:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    78b8:	pop	{r3, r4, r5, pc}

000078ba <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    78ba:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    78be:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    78c0:	ldrb	r3, [r0, #12]
    78c2:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    78c4:	mov	r4, r0
    78c6:	mov	r5, r1
    78c8:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    78ca:	bne.n	78d2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    78cc:	ldr	r3, [r0, #8]
    78ce:	cmp	r3, r1
    78d0:	beq.n	78e8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    78d2:	mov	r1, r5
    78d4:	mov	r0, r4
    78d6:	bl	788a <SdSpiCard::readStart(unsigned long)>
    78da:	cbnz	r0, 78e2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    78dc:	movs	r0, #0
    78de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    78e2:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    78e4:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    78e6:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    78e8:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    78ea:	cmp	r5, r7
    78ec:	add.w	r1, r6, r5, lsl #9
    78f0:	beq.n	7904 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    78f2:	mov.w	r2, #512	; 0x200
    78f6:	mov	r0, r4
    78f8:	bl	7456 <SdSpiCard::readData(unsigned char*, unsigned int)>
    78fc:	cmp	r0, #0
    78fe:	beq.n	78dc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7900:	adds	r5, #1
    7902:	b.n	78ea <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7904:	ldr	r3, [r4, #8]
    7906:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    7908:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    790a:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    790c:	cbz	r3, 791a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    790e:	ldr	r3, [r4, #0]
    7910:	mov	r0, r4
    7912:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7914:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7918:	bx	r3
    791a:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    791c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007920 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7920:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7924:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7926:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7928:	ldr.w	r8, [sp, #32]
    792c:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7930:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7932:	mov	r4, r0
    7934:	mov	r5, r1
    7936:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7938:	bne.n	7940 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    793a:	ldr	r3, [r0, #8]
    793c:	cmp	r3, r1
    793e:	beq.n	7956 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7940:	mov	r1, r5
    7942:	mov	r0, r4
    7944:	bl	788a <SdSpiCard::readStart(unsigned long)>
    7948:	cbnz	r0, 7950 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    794a:	movs	r0, #0
    794c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7950:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7952:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7954:	strb	r3, [r4, #12]
    7956:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    795a:	cmp	r5, sl
    795c:	beq.n	797a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    795e:	mov.w	r2, #512	; 0x200
    7962:	mov	r1, r7
    7964:	mov	r0, r4
    7966:	bl	7456 <SdSpiCard::readData(unsigned char*, unsigned int)>
    796a:	cmp	r0, #0
    796c:	beq.n	794a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    796e:	mov	r0, r5
    7970:	mov	r2, r9
    7972:	mov	r1, r7
    7974:	blx	r8
    7976:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    7978:	b.n	795a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    797a:	ldr	r3, [r4, #8]
    797c:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    797e:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7980:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7982:	cbz	r3, 7990 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7984:	ldr	r3, [r4, #0]
    7986:	mov	r0, r4
    7988:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    798a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    798e:	bx	r3
    7990:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7992:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007996 <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7996:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    7998:	movs	r2, #0
    799a:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    799c:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    799e:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    79a2:	cbz	r0, 79b2 <SdSpiCard::readStop()+0x1c>
    79a4:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    79a6:	mov	r0, r4
    79a8:	strb	r3, [r4, #15]
    79aa:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    79ae:	movs	r0, #0
    79b0:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    79b2:	mov	r0, r4
    79b4:	bl	73fe <SdSpiCard::spiStop()>
  return true;
    79b8:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    79ba:	pop	{r4, pc}

000079bc <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    79bc:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    79be:	movs	r1, #0
  if (state == WRITE_STATE) {
    79c0:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    79c2:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    79c4:	bne.n	79cc <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    79c6:	ldr	r3, [r0, #0]
    79c8:	ldr	r3, [r3, #84]	; 0x54
    79ca:	bx	r3
  }
  if (state == READ_STATE) {
    79cc:	cmp	r2, #1
    79ce:	bne.n	79d4 <SdSpiCard::syncDevice()+0x18>
    return readStop();
    79d0:	b.w	7996 <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    79d4:	movs	r0, #1
    79d6:	bx	lr

000079d8 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    79d8:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    79da:	ldr	r3, [r0, #0]
    79dc:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    79de:	mov	r5, r1
    79e0:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    79e2:	blx	r3
    79e4:	cmp	r0, #3
    sector <<= 9;
    79e6:	it	ne
    79e8:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    79ea:	mov	r2, r5
    79ec:	movs	r1, #25
    79ee:	mov	r0, r4
    79f0:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    79f4:	cbz	r0, 7a04 <SdSpiCard::writeStart(unsigned long)+0x2c>
    79f6:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    79f8:	mov	r0, r4
    79fa:	strb	r3, [r4, #15]
    79fc:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7a00:	movs	r0, #0
    7a02:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    7a04:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7a06:	pop	{r3, r4, r5, pc}

00007a08 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7a08:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    7a0a:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7a0c:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    7a0e:	ldr	r3, [r3, #60]	; 0x3c
    7a10:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7a12:	mov	r4, r0
    7a14:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    7a16:	blx	r3
    7a18:	cbz	r0, 7a80 <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    7a1a:	ldrb.w	r3, [sp, #10]
    7a1e:	lsls	r2, r3, #25
    7a20:	bmi.n	7a3c <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7a22:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7a26:	and.w	r3, r3, #63	; 0x3f
    7a2a:	lsls	r3, r3, #1
    7a2c:	orr.w	r3, r3, r2, lsr #7
    7a30:	adds	r2, r5, #1
    7a32:	orrs	r2, r6
    7a34:	tst	r3, r2
    7a36:	beq.n	7a3c <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    7a38:	movs	r3, #39	; 0x27
    7a3a:	b.n	7a7e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7a3c:	ldrb	r3, [r4, #18]
    7a3e:	cmp	r3, #3
    firstSector <<= 9;
    7a40:	it	ne
    7a42:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7a44:	mov	r2, r6
    7a46:	mov.w	r1, #32
    7a4a:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7a4c:	it	ne
    7a4e:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7a50:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7a54:	cbnz	r0, 7a8a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7a56:	mov	r2, r5
    7a58:	movs	r1, #33	; 0x21
    7a5a:	mov	r0, r4
    7a5c:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7a60:	mov	r2, r0
    7a62:	cbnz	r0, 7a8a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7a64:	movs	r1, #38	; 0x26
    7a66:	mov	r0, r4
    7a68:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7a6c:	cbnz	r0, 7a8a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7a6e:	movw	r1, #10000	; 0x2710
    7a72:	mov	r0, r4
    7a74:	bl	7596 <SdSpiCard::waitNotBusy(unsigned short)>
    7a78:	mov	r5, r0
    7a7a:	cbnz	r0, 7a8e <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    7a7c:	movs	r3, #40	; 0x28
    7a7e:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7a80:	mov	r0, r4
    7a82:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7a86:	movs	r5, #0
    7a88:	b.n	7a94 <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    7a8a:	movs	r3, #38	; 0x26
    7a8c:	b.n	7a7e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    7a8e:	mov	r0, r4
    7a90:	bl	73fe <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7a94:	mov	r0, r5
    7a96:	add	sp, #16
    7a98:	pop	{r4, r5, r6, pc}

00007a9a <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7a9a:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7a9c:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7aa0:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7aa2:	bl	7596 <SdSpiCard::waitNotBusy(unsigned short)>
    7aa6:	mov	r5, r0
    7aa8:	cbz	r0, 7ab4 <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    7aaa:	movs	r1, #253	; 0xfd
    7aac:	ldr	r0, [r4, #4]
    7aae:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7ab2:	b.n	7ab8 <SdSpiCard::writeStop()+0x1e>
    7ab4:	movs	r3, #30
    7ab6:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    7ab8:	mov	r0, r4
    7aba:	bl	73fe <SdSpiCard::spiStop()>
  return false;
}
    7abe:	mov	r0, r5
    7ac0:	pop	{r3, r4, r5, pc}

00007ac2 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7ac2:	push	{r3, r4, r5, lr}
    7ac4:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7ac6:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7ac8:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7aca:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7ace:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    7ad0:	ldr	r3, [r0, #0]
    7ad2:	mov.w	r2, #512	; 0x200
    7ad6:	ldr	r3, [r3, #24]
    7ad8:	mov	r1, r5
    7ada:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    7adc:	movs	r1, #255	; 0xff
    7ade:	ldr	r0, [r4, #4]
    7ae0:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    7ae4:	movs	r1, #255	; 0xff
    7ae6:	ldr	r0, [r4, #4]
    7ae8:	bl	73b8 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    7aec:	ldr	r0, [r4, #4]
    7aee:	bl	73be <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7af2:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7af4:	and.w	r0, r0, #31
    7af8:	cmp	r0, #5
    7afa:	beq.n	7b0a <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7afc:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7afe:	mov	r0, r4
    7b00:	strb	r3, [r4, #15]
    7b02:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7b06:	movs	r0, #0
    7b08:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    7b0a:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7b0c:	pop	{r3, r4, r5, pc}

00007b0e <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7b0e:	push	{r3, r4, r5, lr}
    7b10:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7b12:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7b16:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7b18:	bl	7596 <SdSpiCard::waitNotBusy(unsigned short)>
    7b1c:	cbnz	r0, 7b24 <SdSpiCard::writeData(unsigned char const*)+0x16>
    7b1e:	movs	r3, #36	; 0x24
    7b20:	strb	r3, [r4, #15]
    7b22:	b.n	7b30 <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7b24:	mov	r2, r5
    7b26:	movs	r1, #252	; 0xfc
    7b28:	mov	r0, r4
    7b2a:	bl	7ac2 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7b2e:	cbnz	r0, 7b38 <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7b30:	mov	r0, r4
    7b32:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7b36:	movs	r0, #0
}
    7b38:	pop	{r3, r4, r5, pc}

00007b3a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7b3a:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7b3c:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7b3e:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7b40:	mov	r5, r1
    7b42:	mov	r4, r0
    7b44:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7b46:	blx	r3
    7b48:	cmp	r0, #3
    sector <<= 9;
    7b4a:	it	ne
    7b4c:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    7b4e:	mov	r2, r5
    7b50:	movs	r1, #24
    7b52:	mov	r0, r4
    7b54:	bl	75be <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b58:	cbz	r0, 7b60 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    7b5a:	movs	r3, #13
    7b5c:	strb	r3, [r4, #15]
    7b5e:	b.n	7b76 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7b60:	mov	r2, r6
    7b62:	movs	r1, #254	; 0xfe
    7b64:	mov	r0, r4
    7b66:	bl	7ac2 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7b6a:	mov	r5, r0
    7b6c:	cbz	r0, 7b76 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    7b6e:	mov	r0, r4
    7b70:	bl	73fe <SdSpiCard::spiStop()>
  return true;
    7b74:	b.n	7b7e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    7b76:	mov	r0, r4
    7b78:	bl	73fe <SdSpiCard::spiStop()>
  return false;
    7b7c:	movs	r5, #0
}
    7b7e:	mov	r0, r5
    7b80:	pop	{r4, r5, r6, pc}

00007b82 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7b82:	push	{r4}
    if (m_sharedSpi) {
    7b84:	ldrb	r4, [r0, #13]
    7b86:	cbz	r4, 7b90 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    7b88:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7b8c:	b.w	7b3a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7b90:	ldr	r3, [r0, #0]
    7b92:	ldr	r4, [r3, #36]	; 0x24
    7b94:	movs	r3, #1
    7b96:	mov	ip, r4
    }
  }
    7b98:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7b9c:	bx	ip
    7b9e:	Address 0x00007b9e is out of bounds.


00007ba0 <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7ba0:	ldr	r2, [pc, #24]	; (7bbc <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7ba2:	ldr	r1, [pc, #28]	; (7bc0 <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7ba4:	movs	r3, #0
    7ba6:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    7ba8:	ldr.w	r0, [r2, #-8]
    7bac:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    7bae:	ldr	r1, [r1, #0]
    7bb0:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7bb4:	ldr	r2, [pc, #12]	; (7bc4 <sdIrs()+0x24>)
    7bb6:	strb	r3, [r2, #0]
    7bb8:	bx	lr
    7bba:	nop
    7bbc:	.word	0x400b1038
    7bc0:	.word	0x20019ed0
    7bc4:	.word	0x20019ee5

00007bc8 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    7bc8:	ldr	r3, [pc, #12]	; (7bd8 <isBusyCommandComplete()+0x10>)
    7bca:	ldr	r0, [pc, #16]	; (7bdc <isBusyCommandComplete()+0x14>)
    7bcc:	ldr	r3, [r3, #0]
    7bce:	ands	r0, r3
}
    7bd0:	clz	r0, r0
    7bd4:	lsrs	r0, r0, #5
    7bd6:	bx	lr
    7bd8:	.word	0x400b1030
    7bdc:	.word	0x000f0001

00007be0 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    7be0:	ldr	r3, [pc, #8]	; (7bec <isBusyCommandInhibit()+0xc>)
    7be2:	ldr	r0, [r3, #0]
}
    7be4:	and.w	r0, r0, #1
    7be8:	bx	lr
    7bea:	nop
    7bec:	.word	0x400b1024

00007bf0 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    7bf0:	ldr	r3, [pc, #12]	; (7c00 <isBusyDat()+0x10>)
    7bf2:	ldr	r0, [r3, #0]
    7bf4:	eor.w	r0, r0, #16777216	; 0x1000000
}
    7bf8:	ubfx	r0, r0, #24, #1
    7bfc:	bx	lr
    7bfe:	nop
    7c00:	.word	0x400b1024

00007c04 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    7c04:	ldr	r3, [pc, #4]	; (7c0c <isBusyDMA()+0x8>)
    7c06:	ldrb	r0, [r3, #0]
}
    7c08:	bx	lr
    7c0a:	nop
    7c0c:	.word	0x20019ee5

00007c10 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    7c10:	ldr	r3, [pc, #12]	; (7c20 <isBusyFifoRead()+0x10>)
    7c12:	ldr	r0, [r3, #0]
    7c14:	eor.w	r0, r0, #2048	; 0x800
}
    7c18:	ubfx	r0, r0, #11, #1
    7c1c:	bx	lr
    7c1e:	nop
    7c20:	.word	0x400b1024

00007c24 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    7c24:	ldr	r3, [pc, #12]	; (7c34 <isBusyFifoWrite()+0x10>)
    7c26:	ldr	r0, [r3, #0]
    7c28:	eor.w	r0, r0, #1024	; 0x400
}
    7c2c:	ubfx	r0, r0, #10, #1
    7c30:	bx	lr
    7c32:	nop
    7c34:	.word	0x400b1024

00007c38 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    7c38:	ldr	r3, [pc, #12]	; (7c48 <isBusyTransferComplete()+0x10>)
    7c3a:	ldr	r0, [pc, #16]	; (7c4c <isBusyTransferComplete()+0x14>)
    7c3c:	ldr	r3, [r3, #0]
    7c3e:	ands	r0, r3
}
    7c40:	clz	r0, r0
    7c44:	lsrs	r0, r0, #5
    7c46:	bx	lr
    7c48:	.word	0x400b1030
    7c4c:	.word	0x117f0002

00007c50 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7c50:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    7c54:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7c56:	ldr	r4, [pc, #128]	; (7cd8 <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7c58:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    7c5a:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    7c5c:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7c5e:	lsls	r1, r2, #4
    7c60:	udiv	r1, r4, r1
    7c64:	cmp	r0, r1
    7c66:	bcc.n	7c70 <setSdclk(unsigned long)+0x20>
    7c68:	movs	r4, #1
    7c6a:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7c6c:	ldr	r5, [pc, #104]	; (7cd8 <setSdclk(unsigned long)+0x88>)
    7c6e:	b.n	7c84 <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7c70:	subs	r3, #1
    7c72:	beq.n	7c68 <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    7c74:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7c76:	b.n	7c5e <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7c78:	cmp	r4, #16
    7c7a:	add.w	r1, r3, r2
    7c7e:	beq.n	7c8c <setSdclk(unsigned long)+0x3c>
    dvs++;
    7c80:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7c82:	mov	r3, r1
    7c84:	udiv	r1, r5, r3
    7c88:	cmp	r0, r1
    7c8a:	bcc.n	7c78 <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    7c8c:	mov.w	r1, #1000	; 0x3e8
    7c90:	muls	r3, r1
    7c92:	ldr	r1, [pc, #68]	; (7cd8 <setSdclk(unsigned long)+0x88>)
    7c94:	udiv	r3, r1, r3
    7c98:	ldr	r1, [pc, #64]	; (7cdc <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    7c9a:	ldr	r0, [pc, #68]	; (7ce0 <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    7c9c:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    7c9e:	ldr	r3, [r0, #0]
    7ca0:	bic.w	r3, r3, #8
    7ca4:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    7ca6:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    7ca8:	bic.w	r3, r1, #1044480	; 0xff000
    7cac:	lsls	r2, r2, #7
    7cae:	bic.w	r3, r3, #4080	; 0xff0
    7cb2:	orr.w	r3, r3, #917504	; 0xe0000
    7cb6:	and.w	r2, r2, #65280	; 0xff00
    7cba:	orrs	r2, r3
    7cbc:	subs	r3, r4, #1
    7cbe:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    7cc2:	ldr	r2, [pc, #32]	; (7ce4 <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    7cc4:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    7cc6:	ldr	r3, [r2, #0]
    7cc8:	lsls	r3, r3, #28
    7cca:	bpl.n	7cc6 <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    7ccc:	ldr	r3, [r0, #0]
    7cce:	orr.w	r3, r3, #8
    7cd2:	str	r3, [r0, #0]
    7cd4:	pop	{r4, r5, pc}
    7cd6:	nop
    7cd8:	.word	0x05b8d800
    7cdc:	.word	0x20019ee8
    7ce0:	.word	0x400b102c
    7ce4:	.word	0x400b1024

00007ce8 <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    7ce8:	ldr	r3, [pc, #4]	; (7cf0 <SdioCard::errorCode() const+0x8>)
    7cea:	ldrb	r0, [r3, #0]
    7cec:	bx	lr
    7cee:	nop
    7cf0:	.word	0x20013d44

00007cf4 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    7cf4:	ldr	r3, [pc, #4]	; (7cfc <SdioCard::errorData() const+0x8>)
    7cf6:	ldr	r0, [r3, #0]
}
    7cf8:	bx	lr
    7cfa:	nop
    7cfc:	.word	0x20019ed0

00007d00 <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    7d00:	ldr	r3, [pc, #20]	; (7d18 <SdioCard::readCID(CID*)+0x18>)
    7d02:	add.w	r2, r3, #16
    7d06:	ldr.w	r0, [r3], #4
    7d0a:	str.w	r0, [r1], #4
    7d0e:	cmp	r3, r2
    7d10:	bne.n	7d06 <SdioCard::readCID(CID*)+0x6>
  return true;
}
    7d12:	movs	r0, #1
    7d14:	bx	lr
    7d16:	nop
    7d18:	.word	0x20019ea9

00007d1c <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    7d1c:	ldr	r3, [pc, #20]	; (7d34 <SdioCard::readCSD(csd_t*)+0x18>)
    7d1e:	add.w	r2, r3, #16
    7d22:	ldr.w	r0, [r3], #4
    7d26:	str.w	r0, [r1], #4
    7d2a:	cmp	r3, r2
    7d2c:	bne.n	7d22 <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    7d2e:	movs	r0, #1
    7d30:	bx	lr
    7d32:	nop
    7d34:	.word	0x20019ed5

00007d38 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    7d38:	ldr	r3, [pc, #8]	; (7d44 <SdioCard::readOCR(unsigned long*)+0xc>)
    7d3a:	ldr	r3, [r3, #0]
    7d3c:	str	r3, [r1, #0]
  return true;
}
    7d3e:	movs	r0, #1
    7d40:	bx	lr
    7d42:	nop
    7d44:	.word	0x20019ec4

00007d48 <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    7d48:	bx	lr
    7d4a:	Address 0x00007d4a is out of bounds.


00007d4c <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    7d4c:	push	{r3, r4, r5, r6, r7, lr}
    7d4e:	mov	r7, r0
  uint32_t m = micros();
    7d50:	bl	9220 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7d54:	ldr	r5, [pc, #20]	; (7d6c <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    7d56:	mov	r6, r0
  while (fcn()) {
    7d58:	blx	r7
    7d5a:	mov	r4, r0
    7d5c:	cbz	r0, 7d68 <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7d5e:	bl	9220 <micros>
    7d62:	subs	r0, r0, r6
    7d64:	cmp	r0, r5
    7d66:	bls.n	7d58 <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    7d68:	mov	r0, r4
    7d6a:	pop	{r3, r4, r5, r6, r7, pc}
    7d6c:	.word	0x000f4240

00007d70 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    7d70:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    7d74:	ldr	r4, [pc, #48]	; (7da8 <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7d76:	ldr.w	r8, [pc, #52]	; 7dac <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    7d7a:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    7d7c:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    7d7e:	bl	9220 <micros>
    7d82:	mov	r7, r0
  while (fcn()) {
    7d84:	blx	r6
    7d86:	mov	r5, r0
    7d88:	cbz	r0, 7da0 <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7d8a:	bl	9220 <micros>
    7d8e:	subs	r0, r0, r7
    7d90:	cmp	r0, r8
    7d92:	bls.n	7d9a <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    7d94:	movs	r3, #0
    7d96:	str	r3, [r4, #0]
      return true;
    7d98:	b.n	7da2 <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    7d9a:	bl	9c60 <yield>
    7d9e:	b.n	7d84 <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    7da0:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    7da2:	mov	r0, r5
    7da4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7da8:	.word	0x20019ebc
    7dac:	.word	0x000f4240

00007db0 <SdioCard::~SdioCard()>:
    7db0:	push	{r4, lr}
    7db2:	movs	r1, #12
    7db4:	mov	r4, r0
    7db6:	bl	a362 <operator delete(void*, unsigned int)>
    7dba:	mov	r0, r4
    7dbc:	pop	{r4, pc}
    7dbe:	Address 0x00007dbe is out of bounds.


00007dc0 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    7dc0:	ldr	r3, [pc, #20]	; (7dd8 <SdioCard::type() const+0x18>)
    7dc2:	ldrb	r3, [r3, #0]
    7dc4:	cbz	r3, 7dd4 <SdioCard::type() const+0x14>
    7dc6:	ldr	r3, [pc, #20]	; (7ddc <SdioCard::type() const+0x1c>)
    7dc8:	ldrb	r3, [r3, #0]
    7dca:	cmp	r3, #0
    7dcc:	ite	ne
    7dce:	movne	r0, #3
    7dd0:	moveq	r0, #2
    7dd2:	bx	lr
    7dd4:	movs	r0, #1
}
    7dd6:	bx	lr
    7dd8:	.word	0x20019ea8
    7ddc:	.word	0x20019ec0

00007de0 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    7de0:	push	{r3, r4, r5, lr}
    7de2:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    7de4:	ldr	r0, [pc, #56]	; (7e20 <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    7de6:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    7de8:	bl	7d4c <waitTimeout(bool (*)())>
    7dec:	cbnz	r0, 7e16 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    7dee:	ldr	r3, [pc, #52]	; (7e24 <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    7df0:	ldr	r0, [pc, #52]	; (7e28 <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    7df2:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    7df4:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    7df6:	bl	7d4c <waitTimeout(bool (*)())>
    7dfa:	cbnz	r0, 7e16 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    7dfc:	ldr	r2, [pc, #44]	; (7e2c <cardCommand(unsigned long, unsigned long)+0x4c>)
    7dfe:	ldr	r3, [pc, #48]	; (7e30 <cardCommand(unsigned long, unsigned long)+0x50>)
    7e00:	ldr	r1, [r2, #0]
    7e02:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    7e04:	ldr	r1, [r3, #0]
    7e06:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    7e08:	ldr	r2, [r3, #0]
    7e0a:	lsls	r2, r2, #31
    7e0c:	bpl.n	7e16 <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    7e0e:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    7e10:	tst.w	r3, #983040	; 0xf0000
    7e14:	beq.n	7e1a <cardCommand(unsigned long, unsigned long)+0x3a>
    7e16:	movs	r0, #0
    7e18:	pop	{r3, r4, r5, pc}
    7e1a:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    7e1c:	pop	{r3, r4, r5, pc}
    7e1e:	nop
    7e20:	.word	0x00007be1
    7e24:	.word	0x400b1008
    7e28:	.word	0x00007bc9
    7e2c:	.word	0x400b1030
    7e30:	.word	0x20019ed0

00007e34 <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    7e34:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    7e36:	ldr	r3, [pc, #16]	; (7e48 <statusCMD13()+0x14>)
    7e38:	ldr	r0, [pc, #16]	; (7e4c <statusCMD13()+0x18>)
    7e3a:	ldr	r1, [r3, #0]
    7e3c:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    7e40:	cbz	r0, 7e46 <statusCMD13()+0x12>
    7e42:	ldr	r3, [pc, #12]	; (7e50 <statusCMD13()+0x1c>)
    7e44:	ldr	r0, [r3, #0]
}
    7e46:	pop	{r3, pc}
    7e48:	.word	0x20019ec8
    7e4c:	.word	0x0d1a0000
    7e50:	.word	0x400b1010

00007e54 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    7e54:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    7e56:	bl	7e34 <statusCMD13()>
    7e5a:	eor.w	r0, r0, #256	; 0x100
}
    7e5e:	ubfx	r0, r0, #8, #1
    7e62:	pop	{r3, pc}

00007e64 <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    7e64:	b.w	7e34 <statusCMD13()>

00007e68 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    7e68:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    7e6a:	ldr	r3, [pc, #80]	; (7ebc <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    7e6c:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    7e6e:	ldr	r1, [r3, #0]
    7e70:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    7e74:	cbz	r0, 7eb6 <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    7e76:	ldr	r3, [pc, #72]	; (7ec0 <readReg16(unsigned long, void*)+0x58>)
    7e78:	ldr	r3, [r3, #0]
    7e7a:	str	r3, [sp, #0]
    7e7c:	ldr	r3, [pc, #68]	; (7ec4 <readReg16(unsigned long, void*)+0x5c>)
    7e7e:	ldr	r3, [r3, #0]
    7e80:	str	r3, [sp, #4]
    7e82:	ldr	r3, [pc, #68]	; (7ec8 <readReg16(unsigned long, void*)+0x60>)
    7e84:	ldr	r3, [r3, #0]
    7e86:	str	r3, [sp, #8]
    7e88:	ldr	r3, [pc, #64]	; (7ecc <readReg16(unsigned long, void*)+0x64>)
    7e8a:	ldr	r3, [r3, #0]
    7e8c:	str	r3, [sp, #12]
    7e8e:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    7e92:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7e94:	bic.w	r4, r3, #3
    7e98:	add	r2, sp, #16
    7e9a:	add	r4, r2
    7e9c:	and.w	r2, r3, #3
    7ea0:	lsls	r1, r2, #3
    7ea2:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7ea6:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7ea8:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7eaa:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7eac:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7eb0:	bne.n	7e94 <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    7eb2:	movs	r3, #0
    7eb4:	strb	r3, [r5, #15]
  return true;
}
    7eb6:	add	sp, #16
    7eb8:	pop	{r4, r5, r6, pc}
    7eba:	nop
    7ebc:	.word	0x20019ec8
    7ec0:	.word	0x400b1010
    7ec4:	.word	0x400b1014
    7ec8:	.word	0x400b1018
    7ecc:	.word	0x400b101c

00007ed0 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    7ed0:	ldr	r3, [pc, #20]	; (7ee8 <waitDmaStatus() [clone .part.4]+0x18>)
    7ed2:	ldr	r0, [r3, #0]
    7ed4:	ands.w	r0, r0, #2
    7ed8:	beq.n	7ee6 <waitDmaStatus() [clone .part.4]+0x16>
    7eda:	ldr	r3, [r3, #0]
    7edc:	ldr	r0, [pc, #12]	; (7eec <waitDmaStatus() [clone .part.4]+0x1c>)
    7ede:	ands	r0, r3
    7ee0:	clz	r0, r0
    7ee4:	lsrs	r0, r0, #5
}
    7ee6:	bx	lr
    7ee8:	.word	0x20019ed0
    7eec:	.word	0x117f0000

00007ef0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    7ef0:	push	{r3, r4, r5, r6, r7, lr}
    7ef2:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    7ef4:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    7ef6:	mov	r7, r0
    7ef8:	mov	r5, r1
    7efa:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    7efc:	bne.n	7f00 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    7efe:	cbnz	r4, 7f0c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7f00:	ldr	r3, [pc, #100]	; (7f68 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    7f02:	movs	r2, #37	; 0x25
    7f04:	strb	r2, [r3, #0]
  m_errorLine = line;
    7f06:	mov.w	r2, #506	; 0x1fa
    7f0a:	b.n	7f1e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    7f0c:	ldr	r0, [pc, #92]	; (7f6c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    7f0e:	bl	7d70 <yieldTimeout(bool (*)())>
    7f12:	cbz	r0, 7f24 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7f14:	ldr	r3, [pc, #80]	; (7f68 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    7f16:	movs	r2, #10
    7f18:	strb	r2, [r3, #0]
  m_errorLine = line;
    7f1a:	movw	r2, #509	; 0x1fd
    7f1e:	ldr	r3, [pc, #80]	; (7f70 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    7f20:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7f22:	b.n	7f62 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    7f24:	ldr	r3, [pc, #76]	; (7f74 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    7f26:	movs	r2, #1
    7f28:	strb	r2, [r3, #0]
  m_irqstat = 0;
    7f2a:	ldr	r3, [pc, #76]	; (7f78 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    7f2c:	ldr	r2, [pc, #76]	; (7f7c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    7f2e:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7f30:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    7f32:	ldr	r3, [pc, #76]	; (7f80 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7f34:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    7f38:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7f3a:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    7f3c:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    7f3e:	ldr	r3, [pc, #68]	; (7f84 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    7f40:	ldrb	r3, [r3, #0]
    7f42:	cbnz	r3, 7f48 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    7f44:	lsls	r1, r5, #9
    7f46:	b.n	7f4a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    7f48:	mov	r1, r5
    7f4a:	mov	r0, r7
    7f4c:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    7f50:	cbz	r0, 7f62 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    7f52:	ldr	r0, [pc, #52]	; (7f88 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    7f54:	bl	7d70 <yieldTimeout(bool (*)())>
    7f58:	cbnz	r0, 7f62 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    7f5a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    7f5e:	b.w	7ed0 <waitDmaStatus() [clone .part.4]>
    7f62:	movs	r0, #0
    7f64:	pop	{r3, r4, r5, r6, r7, pc}
    7f66:	nop
    7f68:	.word	0x20013d44
    7f6c:	.word	0x00007e55
    7f70:	.word	0x20019eec
    7f74:	.word	0x20019ee5
    7f78:	.word	0x20019ed0
    7f7c:	.word	0x117f0002
    7f80:	.word	0x400b1000
    7f84:	.word	0x20019ec0
    7f88:	.word	0x00007c05

00007f8c <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7f8c:	ldr	r2, [pc, #92]	; (7fec <SdioCard::sectorCount()+0x60>)
    7f8e:	ldrb	r3, [r2, #0]
    7f90:	ands.w	r3, r3, #192	; 0xc0
    7f94:	bne.n	7fca <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    7f96:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7f98:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    7f9a:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7f9c:	and.w	r0, r0, #3
    7fa0:	lsls	r3, r3, #2
    7fa2:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7fa6:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7fa8:	orr.w	r0, r3, r0, lsr #6
    7fac:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    7fae:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7fb0:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7fb2:	and.w	r0, r0, #3
    7fb6:	lsls	r0, r0, #1
    7fb8:	orr.w	r0, r0, r1, lsr #7
    7fbc:	and.w	r2, r2, #15
    7fc0:	add	r0, r2
    7fc2:	subs	r0, #7
    7fc4:	lsl.w	r0, r3, r0
    7fc8:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    7fca:	cmp	r3, #64	; 0x40
    7fcc:	bne.n	7fe6 <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7fce:	ldrb	r0, [r2, #9]
    7fd0:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7fd2:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7fd4:	and.w	r0, r0, #63	; 0x3f
    7fd8:	add.w	r0, r3, r0, lsl #16
    7fdc:	ldrb	r3, [r2, #8]
    7fde:	add.w	r0, r0, r3, lsl #8
    7fe2:	lsls	r0, r0, #10
    7fe4:	bx	lr
  } else {
    return 0;
    7fe6:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    7fe8:	bx	lr
    7fea:	nop
    7fec:	.word	0x20019ed5

00007ff0 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7ff0:	push	{r4, r5, r6, lr}
    7ff2:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7ff4:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7ff6:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7ff8:	cbz	r2, 8006 <SdioCard::erase(unsigned long, unsigned long)+0x16>
    7ffa:	ldr	r3, [r0, #0]
    7ffc:	ldr	r3, [r3, #28]
    7ffe:	blx	r3
    8000:	mov	r4, r0
    8002:	cmp	r0, #0
    8004:	beq.n	80a2 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    8006:	ldr	r1, [pc, #160]	; (80a8 <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    8008:	ldrb	r3, [r1, #10]
    800a:	and.w	r2, r3, #64	; 0x40
    800e:	and.w	r4, r2, #255	; 0xff
    8012:	cbnz	r2, 8034 <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    8014:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    8016:	and.w	r3, r3, #63	; 0x3f
    801a:	lsls	r3, r3, #1
    801c:	orr.w	r3, r3, r2, lsr #7
    8020:	adds	r2, r6, #1
    8022:	orrs	r2, r5
    8024:	tst	r3, r2
    8026:	beq.n	8034 <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8028:	ldr	r3, [pc, #128]	; (80ac <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    802a:	movs	r2, #39	; 0x27
    802c:	strb	r2, [r3, #0]
  m_errorLine = line;
    802e:	movw	r2, #747	; 0x2eb
    8032:	b.n	8084 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    8034:	ldr	r3, [pc, #120]	; (80b0 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    8036:	ldrb	r3, [r3, #0]
    8038:	cbnz	r3, 803e <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    803a:	lsls	r5, r5, #9
    lastSector <<= 9;
    803c:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    803e:	mov	r1, r5
    8040:	ldr	r0, [pc, #112]	; (80b4 <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    8042:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    8046:	mov	r4, r0
    8048:	cbnz	r0, 8056 <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    804a:	ldr	r3, [pc, #96]	; (80ac <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    804c:	movs	r2, #15
    804e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8050:	movw	r2, #755	; 0x2f3
    8054:	b.n	8084 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    8056:	mov	r1, r6
    8058:	ldr	r0, [pc, #92]	; (80b8 <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    805a:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    805e:	mov	r4, r0
    8060:	cbnz	r0, 806e <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8062:	ldr	r3, [pc, #72]	; (80ac <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8064:	movs	r2, #16
    8066:	strb	r2, [r3, #0]
  m_errorLine = line;
    8068:	movw	r2, #758	; 0x2f6
    806c:	b.n	8084 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    806e:	movs	r1, #0
    8070:	ldr	r0, [pc, #72]	; (80bc <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    8072:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    8076:	mov	r4, r0
    8078:	cbnz	r0, 808a <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    807a:	ldr	r3, [pc, #48]	; (80ac <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    807c:	movs	r2, #17
    807e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8080:	movw	r2, #761	; 0x2f9
    8084:	ldr	r3, [pc, #56]	; (80c0 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    8086:	str	r2, [r3, #0]
    8088:	b.n	80a2 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    808a:	ldr	r0, [pc, #56]	; (80c4 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    808c:	bl	7d4c <waitTimeout(bool (*)())>
    8090:	cbz	r0, 80a2 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8092:	ldr	r3, [pc, #24]	; (80ac <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8094:	movs	r2, #40	; 0x28
    8096:	strb	r2, [r3, #0]
  m_errorLine = line;
    8098:	ldr	r3, [pc, #36]	; (80c0 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    809a:	mov.w	r2, #764	; 0x2fc
    809e:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    80a0:	movs	r4, #0
  }
  return true;
}
    80a2:	mov	r0, r4
    80a4:	pop	{r4, r5, r6, pc}
    80a6:	nop
    80a8:	.word	0x20019ed5
    80ac:	.word	0x20013d44
    80b0:	.word	0x20019ec0
    80b4:	.word	0x201a0000
    80b8:	.word	0x211a0000
    80bc:	.word	0x261b0000
    80c0:	.word	0x20019eec
    80c4:	.word	0x00007e55

000080c8 <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    80c8:	push	{r4, lr}
  if (!m_transferActive) {
    80ca:	ldr	r4, [pc, #60]	; (8108 <waitTransferComplete()+0x40>)
    80cc:	ldrb	r3, [r4, #0]
    80ce:	cbnz	r3, 80d4 <waitTransferComplete()+0xc>
    return true;
    80d0:	movs	r0, #1
    80d2:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    80d4:	ldr	r0, [pc, #52]	; (810c <waitTransferComplete()+0x44>)
    80d6:	bl	7d4c <waitTimeout(bool (*)())>
  m_transferActive = false;
    80da:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    80dc:	ldr	r2, [pc, #48]	; (8110 <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    80de:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    80e0:	ldr	r3, [pc, #48]	; (8114 <waitTransferComplete()+0x4c>)
    80e2:	ldr	r1, [r2, #0]
    80e4:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    80e6:	ldr	r1, [r3, #0]
    80e8:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    80ea:	cbnz	r0, 80f6 <waitTransferComplete()+0x2e>
    80ec:	ldr	r2, [r3, #0]
    80ee:	ldr	r3, [pc, #40]	; (8118 <waitTransferComplete()+0x50>)
    80f0:	ands	r3, r2
    80f2:	cmp	r3, #0
    80f4:	beq.n	80d0 <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    80f6:	ldr	r3, [pc, #36]	; (811c <waitTransferComplete()+0x54>)
    80f8:	movs	r2, #31
    80fa:	strb	r2, [r3, #0]
  m_errorLine = line;
    80fc:	ldr	r3, [pc, #32]	; (8120 <waitTransferComplete()+0x58>)
    80fe:	movw	r2, #641	; 0x281
    8102:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    8104:	movs	r0, #0
  }
  return true;
}
    8106:	pop	{r4, pc}
    8108:	.word	0x20019ecc
    810c:	.word	0x00007c39
    8110:	.word	0x400b1030
    8114:	.word	0x20019ed0
    8118:	.word	0x117f0000
    811c:	.word	0x20013d44
    8120:	.word	0x20019eec

00008124 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    8124:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8126:	ldr	r4, [pc, #100]	; (818c <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8128:	ldr	r0, [pc, #100]	; (8190 <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    812a:	ldr	r3, [r4, #0]
    812c:	bic.w	r3, r3, #65536	; 0x10000
    8130:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8132:	movs	r1, #0
    8134:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    8138:	mov	r5, r0
    813a:	cbnz	r0, 814c <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    813c:	ldr	r3, [pc, #84]	; (8194 <SdioCard::readStop()+0x70>)
    813e:	movs	r2, #9
    8140:	strb	r2, [r3, #0]
  m_errorLine = line;
    8142:	ldr	r3, [pc, #84]	; (8198 <SdioCard::readStop()+0x74>)
    8144:	movw	r2, #578	; 0x242
    8148:	str	r2, [r3, #0]
    814a:	b.n	8186 <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    814c:	ldr	r0, [pc, #76]	; (819c <SdioCard::readStop()+0x78>)
    814e:	bl	7d70 <yieldTimeout(bool (*)())>
    8152:	cbz	r0, 8166 <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8154:	ldr	r3, [pc, #60]	; (8194 <SdioCard::readStop()+0x70>)
    8156:	movs	r2, #10
    8158:	strb	r2, [r3, #0]
  m_errorLine = line;
    815a:	ldr	r3, [pc, #60]	; (8198 <SdioCard::readStop()+0x74>)
    815c:	movw	r2, #582	; 0x246
    8160:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8162:	movs	r5, #0
    8164:	b.n	8186 <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    8166:	ldr	r3, [pc, #56]	; (81a0 <SdioCard::readStop()+0x7c>)
    8168:	ldr	r3, [r3, #0]
    816a:	lsls	r3, r3, #30
    816c:	bpl.n	8186 <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    816e:	ldr	r1, [pc, #52]	; (81a4 <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8170:	ldr	r0, [pc, #52]	; (81a8 <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    8172:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8174:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8176:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8178:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    817c:	orr.w	r2, r2, #67108864	; 0x4000000
    8180:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    8182:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    8184:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    8186:	mov	r0, r5
    8188:	pop	{r4, r5, r6, pc}
    818a:	nop
    818c:	.word	0x400b1028
    8190:	.word	0x0cdb0000
    8194:	.word	0x20013d44
    8198:	.word	0x20019eec
    819c:	.word	0x00007bf1
    81a0:	.word	0x400b1024
    81a4:	.word	0x400b1034
    81a8:	.word	0x400b102c

000081ac <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    81ac:	push	{r4, r5, r6, lr}
    81ae:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    81b0:	bl	80c8 <waitTransferComplete()>
    81b4:	mov	r6, r0
    81b6:	cmp	r0, #0
    81b8:	beq.n	8220 <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    81ba:	ldr	r5, [pc, #104]	; (8224 <SdioCard::writeData(unsigned char const*)+0x78>)
    81bc:	ldr	r3, [r5, #0]
    81be:	tst.w	r3, #256	; 0x100
    81c2:	ldr	r3, [pc, #100]	; (8228 <SdioCard::writeData(unsigned char const*)+0x7c>)
    81c4:	bne.n	81d6 <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    81c6:	ldr	r2, [r3, #0]
    81c8:	bic.w	r2, r2, #65536	; 0x10000
    81cc:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    81ce:	ldr	r2, [r3, #0]
    81d0:	orr.w	r2, r2, #131072	; 0x20000
    81d4:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    81d6:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    81d8:	ldr	r0, [pc, #80]	; (822c <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    81da:	orr.w	r2, r2, #65536	; 0x10000
    81de:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    81e0:	bl	7d4c <waitTimeout(bool (*)())>
    81e4:	cbnz	r0, 8210 <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    81e6:	ldr	r1, [pc, #72]	; (8230 <SdioCard::writeData(unsigned char const*)+0x84>)
    81e8:	subs	r3, r4, #4
    81ea:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    81ee:	ldr	r2, [r5, #0]
    81f0:	lsls	r2, r2, #21
    81f2:	bpl.n	81ee <SdioCard::writeData(unsigned char const*)+0x42>
    81f4:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    81f8:	ldr.w	r0, [r3, #4]!
    81fc:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    81fe:	cmp	r2, r3
    8200:	bne.n	81f8 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8202:	cmp	r4, r2
    8204:	mov	r3, r2
    8206:	bne.n	81ee <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    8208:	ldr	r3, [pc, #40]	; (8234 <SdioCard::writeData(unsigned char const*)+0x88>)
    820a:	movs	r2, #1
    820c:	strb	r2, [r3, #0]
    820e:	b.n	8220 <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8210:	ldr	r3, [pc, #36]	; (8238 <SdioCard::writeData(unsigned char const*)+0x8c>)
    8212:	movs	r2, #33	; 0x21
    8214:	strb	r2, [r3, #0]
  m_errorLine = line;
    8216:	ldr	r3, [pc, #36]	; (823c <SdioCard::writeData(unsigned char const*)+0x90>)
    8218:	movw	r2, #1015	; 0x3f7
    821c:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    821e:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8220:	mov	r0, r6
    8222:	pop	{r4, r5, r6, pc}
    8224:	.word	0x400b1024
    8228:	.word	0x400b1028
    822c:	.word	0x00007c25
    8230:	.word	0x400b1020
    8234:	.word	0x20019ecc
    8238:	.word	0x20013d44
    823c:	.word	0x20019eec

00008240 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    8240:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    8242:	ldr	r0, [pc, #80]	; (8294 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    8244:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    8246:	bl	7d70 <yieldTimeout(bool (*)())>
    824a:	cbz	r0, 825e <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    824c:	ldr	r3, [pc, #72]	; (8298 <SdioCard::writeStart(unsigned long)+0x58>)
    824e:	movs	r2, #10
    8250:	strb	r2, [r3, #0]
  m_errorLine = line;
    8252:	ldr	r3, [pc, #72]	; (829c <SdioCard::writeStart(unsigned long)+0x5c>)
    8254:	movw	r2, #1119	; 0x45f
    8258:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    825a:	movs	r0, #0
    825c:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    825e:	ldr	r2, [pc, #64]	; (82a0 <SdioCard::writeStart(unsigned long)+0x60>)
    8260:	ldr	r3, [r2, #0]
    8262:	bic.w	r3, r3, #65536	; 0x10000
    8266:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8268:	ldr	r3, [pc, #56]	; (82a4 <SdioCard::writeStart(unsigned long)+0x64>)
    826a:	ldr	r2, [pc, #60]	; (82a8 <SdioCard::writeStart(unsigned long)+0x68>)
    826c:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    826e:	ldr	r3, [pc, #60]	; (82ac <SdioCard::writeStart(unsigned long)+0x6c>)
    8270:	ldrb	r3, [r3, #0]
    8272:	cbnz	r3, 8278 <SdioCard::writeStart(unsigned long)+0x38>
    8274:	lsls	r1, r4, #9
    8276:	b.n	827a <SdioCard::writeStart(unsigned long)+0x3a>
    8278:	mov	r1, r4
    827a:	ldr	r0, [pc, #52]	; (82b0 <SdioCard::writeStart(unsigned long)+0x70>)
    827c:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    8280:	cbnz	r0, 8290 <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8282:	ldr	r3, [pc, #20]	; (8298 <SdioCard::writeStart(unsigned long)+0x58>)
    8284:	movs	r2, #14
    8286:	strb	r2, [r3, #0]
  m_errorLine = line;
    8288:	ldr	r3, [pc, #16]	; (829c <SdioCard::writeStart(unsigned long)+0x5c>)
    828a:	movw	r2, #1131	; 0x46b
    828e:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    8290:	pop	{r4, pc}
    8292:	nop
    8294:	.word	0x00007e55
    8298:	.word	0x20013d44
    829c:	.word	0x20019eec
    82a0:	.word	0x400b1028
    82a4:	.word	0x400b1004
    82a8:	.word	0xffff0200
    82ac:	.word	0x20019ec0
    82b0:	.word	0x193a0022

000082b4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    82b4:	push	{r3, r4, r5, r6, r7, lr}
    82b6:	mov	r7, r0
    82b8:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    82ba:	ldrb	r6, [r7, #8]
    82bc:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    82be:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    82c0:	bpl.n	82fe <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    82c2:	lsls	r6, r2, #30
    82c4:	beq.n	82e6 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    82c6:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    82c8:	cmp	r4, r6
    82ca:	beq.n	831c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    82cc:	ldr	r3, [r7, #0]
    82ce:	mov	r2, r5
    82d0:	ldr	r3, [r3, #32]
    82d2:	mov	r1, r4
    82d4:	mov	r0, r7
    82d6:	blx	r3
    82d8:	cbnz	r0, 82de <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    82da:	movs	r0, #0
    82dc:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    82de:	adds	r4, #1
    82e0:	add.w	r5, r5, #512	; 0x200
    82e4:	b.n	82c8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    82e6:	ldr	r0, [pc, #56]	; (8320 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    82e8:	bl	7ef0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    82ec:	cbnz	r0, 831c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82ee:	ldr	r3, [pc, #52]	; (8324 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    82f0:	movs	r2, #14
    82f2:	strb	r2, [r3, #0]
  m_errorLine = line;
    82f4:	ldr	r3, [pc, #48]	; (8328 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    82f6:	movw	r2, #1105	; 0x451
    82fa:	str	r2, [r3, #0]
    82fc:	pop	{r3, r4, r5, r6, r7, pc}
    82fe:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8300:	cmp	r4, r6
    8302:	beq.n	831c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    8304:	ldr	r3, [r7, #0]
    8306:	mov	r2, r5
    8308:	mov	r1, r4
    830a:	ldr	r3, [r3, #32]
    830c:	mov	r0, r7
    830e:	blx	r3
    8310:	adds	r4, #1
    8312:	add.w	r5, r5, #512	; 0x200
    8316:	cmp	r0, #0
    8318:	bne.n	8300 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    831a:	b.n	82da <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    831c:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    831e:	pop	{r3, r4, r5, r6, r7, pc}
    8320:	.word	0x193a0027
    8324:	.word	0x20013d44
    8328:	.word	0x20019eec

0000832c <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    832c:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    832e:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8330:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8332:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8334:	sub.w	sp, sp, #512	; 0x200
    8338:	mov	r4, r0
    833a:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    833c:	bpl.n	8370 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    833e:	lsls	r3, r5, #30
    8340:	beq.n	8350 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    8342:	mov	r1, r5
    8344:	mov.w	r2, #512	; 0x200
    8348:	mov	r0, sp
    834a:	bl	8b4c <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    834e:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    8350:	movs	r3, #1
    8352:	mov	r2, r5
    8354:	mov	r1, r6
    8356:	ldr	r0, [pc, #132]	; (83dc <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    8358:	bl	7ef0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    835c:	cmp	r0, #0
    835e:	bne.n	83d4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8360:	ldr	r3, [pc, #124]	; (83e0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    8362:	movs	r2, #13
    8364:	strb	r2, [r3, #0]
  m_errorLine = line;
    8366:	ldr	r3, [pc, #124]	; (83e4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    8368:	movw	r2, #1049	; 0x419
    836c:	str	r2, [r3, #0]
    836e:	b.n	83d4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8370:	bl	80c8 <waitTransferComplete()>
    8374:	cbnz	r0, 837a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    8376:	movs	r0, #0
    8378:	b.n	83d4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    837a:	ldr	r3, [pc, #108]	; (83e8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    837c:	ldr	r3, [r3, #0]
    837e:	lsrs	r3, r3, #16
    8380:	lsls	r3, r3, #16
    8382:	cbz	r3, 838c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8384:	ldrb	r3, [r4, #9]
    8386:	cmp	r3, #2
    8388:	bne.n	83a0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    838a:	b.n	839a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    838c:	ldr	r3, [r4, #0]
    838e:	mov	r0, r4
    8390:	ldr	r3, [r3, #28]
    8392:	blx	r3
    8394:	cmp	r0, #0
    8396:	bne.n	8384 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    8398:	b.n	8376 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    839a:	ldr	r3, [r4, #4]
    839c:	cmp	r6, r3
    839e:	beq.n	83c0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    83a0:	ldr	r3, [r4, #0]
    83a2:	mov	r0, r4
    83a4:	ldr	r3, [r3, #28]
    83a6:	blx	r3
    83a8:	cmp	r0, #0
    83aa:	beq.n	8376 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    83ac:	ldr	r3, [r4, #0]
    83ae:	mov	r1, r6
    83b0:	ldr	r3, [r3, #80]	; 0x50
    83b2:	mov	r0, r4
    83b4:	blx	r3
    83b6:	cmp	r0, #0
    83b8:	beq.n	8376 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    83ba:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    83bc:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    83be:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    83c0:	ldr	r3, [r4, #0]
    83c2:	mov	r1, r5
    83c4:	ldr	r3, [r3, #76]	; 0x4c
    83c6:	mov	r0, r4
    83c8:	blx	r3
    83ca:	cmp	r0, #0
    83cc:	beq.n	8376 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    83ce:	ldr	r3, [r4, #4]
    83d0:	adds	r3, #1
    83d2:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    83d4:	add.w	sp, sp, #512	; 0x200
    83d8:	pop	{r4, r5, r6, pc}
    83da:	nop
    83dc:	.word	0x183a0001
    83e0:	.word	0x20013d44
    83e4:	.word	0x20019eec
    83e8:	.word	0x400b1004

000083ec <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    83ec:	push	{r3, r4, r5, r6, r7, lr}
    83ee:	mov	r7, r0
    83f0:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    83f2:	ldrb	r6, [r7, #8]
    83f4:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    83f6:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    83f8:	bpl.n	8436 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    83fa:	lsls	r6, r2, #30
    83fc:	beq.n	841e <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    83fe:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    8400:	cmp	r4, r6
    8402:	beq.n	8454 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    8404:	ldr	r3, [r7, #0]
    8406:	mov	r2, r5
    8408:	ldr	r3, [r3, #12]
    840a:	mov	r1, r4
    840c:	mov	r0, r7
    840e:	blx	r3
    8410:	cbnz	r0, 8416 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    8412:	movs	r0, #0
    8414:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    8416:	adds	r4, #1
    8418:	add.w	r5, r5, #512	; 0x200
    841c:	b.n	8400 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    841e:	ldr	r0, [pc, #56]	; (8458 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    8420:	bl	7ef0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8424:	cbnz	r0, 8454 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8426:	ldr	r3, [pc, #52]	; (845c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    8428:	movs	r2, #12
    842a:	strb	r2, [r3, #0]
  m_errorLine = line;
    842c:	ldr	r3, [pc, #48]	; (8460 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    842e:	mov.w	r2, #912	; 0x390
    8432:	str	r2, [r3, #0]
    8434:	pop	{r3, r4, r5, r6, r7, pc}
    8436:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8438:	cmp	r4, r6
    843a:	beq.n	8454 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    843c:	ldr	r3, [r7, #0]
    843e:	mov	r2, r5
    8440:	mov	r1, r4
    8442:	ldr	r3, [r3, #12]
    8444:	mov	r0, r7
    8446:	blx	r3
    8448:	adds	r4, #1
    844a:	add.w	r5, r5, #512	; 0x200
    844e:	cmp	r0, #0
    8450:	bne.n	8438 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    8452:	b.n	8412 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    8454:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    8456:	pop	{r3, r4, r5, r6, r7, pc}
    8458:	.word	0x123a0037
    845c:	.word	0x20013d44
    8460:	.word	0x20019eec

00008464 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8464:	push	{r3, r4, r5, lr}
    8466:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8468:	ldr	r0, [pc, #104]	; (84d4 <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    846a:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    846c:	bl	7d4c <waitTimeout(bool (*)())>
    8470:	cbz	r0, 847e <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8472:	ldr	r3, [pc, #100]	; (84d8 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8474:	movs	r2, #10
    8476:	strb	r2, [r3, #0]
  m_errorLine = line;
    8478:	movw	r2, #413	; 0x19d
    847c:	b.n	84c0 <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    847e:	ldr	r3, [pc, #92]	; (84dc <cardCMD6(unsigned long, unsigned char*)+0x78>)
    8480:	movs	r2, #1
    8482:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8484:	ldr	r3, [pc, #88]	; (84e0 <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8486:	ldr	r2, [pc, #92]	; (84e4 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8488:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    848a:	ldr	r3, [pc, #92]	; (84e8 <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    848c:	ldr	r0, [pc, #92]	; (84ec <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    848e:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8490:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8492:	ldr	r2, [pc, #92]	; (84f0 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    8494:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8496:	mov	r1, r4
    8498:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    849c:	cbnz	r0, 84ae <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    849e:	ldr	r3, [pc, #56]	; (84d8 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    84a0:	movs	r2, #4
    84a2:	strb	r2, [r3, #0]
  m_errorLine = line;
    84a4:	ldr	r3, [pc, #76]	; (84f4 <cardCMD6(unsigned long, unsigned char*)+0x90>)
    84a6:	mov.w	r2, #420	; 0x1a4
    84aa:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    84ac:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    84ae:	ldr	r0, [pc, #72]	; (84f8 <cardCMD6(unsigned long, unsigned char*)+0x94>)
    84b0:	bl	7d70 <yieldTimeout(bool (*)())>
    84b4:	cbz	r0, 84c8 <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84b6:	ldr	r3, [pc, #32]	; (84d8 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    84b8:	movs	r2, #37	; 0x25
    84ba:	strb	r2, [r3, #0]
  m_errorLine = line;
    84bc:	movw	r2, #423	; 0x1a7
    84c0:	ldr	r3, [pc, #48]	; (84f4 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    84c2:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    84c4:	str	r2, [r3, #0]
    84c6:	pop	{r3, r4, r5, pc}
    84c8:	bl	7ed0 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    84cc:	cmp	r0, #0
    84ce:	beq.n	84b6 <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    84d0:	pop	{r3, r4, r5, pc}
    84d2:	nop
    84d4:	.word	0x00007e55
    84d8:	.word	0x20013d44
    84dc:	.word	0x20019ee5
    84e0:	.word	0x20019ed0
    84e4:	.word	0x00010040
    84e8:	.word	0x400b1000
    84ec:	.word	0x063a0011
    84f0:	.word	0x117f0002
    84f4:	.word	0x20019eec
    84f8:	.word	0x00007c05

000084fc <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    84fc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    8500:	ldr	r4, [pc, #712]	; (87cc <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8502:	ldr	r2, [pc, #716]	; (87d0 <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    8504:	ldr.w	ip, [pc, #828]	; 8844 <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    8508:	ldr.w	lr, [pc, #828]	; 8848 <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    850c:	ldr.w	sl, [pc, #828]	; 884c <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    8510:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    8512:	movs	r3, #0
    8514:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    8516:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    8518:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    851c:	strb.w	r3, [lr]
  m_version2 = false;
    8520:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8524:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8526:	ldr	r0, [pc, #684]	; (87d4 <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8528:	ldr	r5, [pc, #684]	; (87d8 <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    852a:	ldr	r6, [pc, #688]	; (87dc <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    852c:	ldr	r7, [pc, #688]	; (87e0 <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    852e:	ldr.w	r8, [pc, #800]	; 8850 <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8532:	ldr	r1, [pc, #688]	; (87e4 <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8534:	orr.w	r3, r3, #201326592	; 0xc000000
    8538:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    853a:	add.w	r2, r2, #239616	; 0x3a800
    853e:	adds	r2, #48	; 0x30
    8540:	ldr	r3, [r2, #0]
    8542:	orr.w	r3, r3, #131072	; 0x20000
    8546:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8548:	ldr	r2, [pc, #668]	; (87e8 <SdioCard::begin(SdioConfig)+0x2ec>)
    854a:	movw	r3, #259	; 0x103
    854e:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8550:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8552:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8554:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8556:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    855a:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    855c:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    855e:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8560:	orr.w	r3, r3, #16777216	; 0x1000000
    8564:	orr.w	r3, r3, #32768	; 0x8000
    8568:	str	r3, [r1, #0]
    856a:	mov	r9, r0
    856c:	str.w	ip, [sp, #4]
    8570:	str.w	lr, [sp, #8]
    8574:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    8576:	ldr.w	r1, [fp]
    857a:	ldr	r3, [pc, #616]	; (87e4 <SdioCard::begin(SdioConfig)+0x2e8>)
    857c:	lsls	r1, r1, #7
    857e:	bmi.n	8576 <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8580:	mov.w	r0, #400	; 0x190
    8584:	str	r3, [sp, #0]
    8586:	str	r2, [sp, #12]
    8588:	bl	7c50 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    858c:	ldr	r2, [sp, #12]
    858e:	movw	r1, #1091	; 0x443
    8592:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8594:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8598:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    859a:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    859c:	ldr	r2, [pc, #588]	; (87ec <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    859e:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    85a0:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    85a4:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    85a8:	ldr	r1, [pc, #580]	; (87f0 <SdioCard::begin(SdioConfig)+0x2f4>)
    85aa:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    85ac:	movs	r0, #81	; 0x51
    85ae:	ldr	r1, [pc, #580]	; (87f4 <SdioCard::begin(SdioConfig)+0x2f8>)
    85b0:	bl	9120 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    85b4:	ldr	r2, [pc, #576]	; (87f8 <SdioCard::begin(SdioConfig)+0x2fc>)
    85b6:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    85b8:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    85bc:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    85be:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    85c0:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    85c2:	mov.w	r1, #131072	; 0x20000
    85c6:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    85c8:	ldr	r2, [r3, #0]
    85ca:	orr.w	r2, r2, #134217728	; 0x8000000
    85ce:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    85d0:	ldr.w	r1, [fp]
    85d4:	ands.w	r1, r1, #134217728	; 0x8000000
    85d8:	bne.n	85d0 <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    85da:	mov	r0, r1
    85dc:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    85e0:	mov	fp, r0
    85e2:	cbnz	r0, 85ee <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85e4:	movs	r3, #1
    85e6:	strb	r3, [r4, #0]
  m_errorLine = line;
    85e8:	movw	r2, #662	; 0x296
    85ec:	b.n	8696 <SdioCard::begin(SdioConfig)+0x19a>
    85ee:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    85f2:	mov.w	r1, #426	; 0x1aa
    85f6:	ldr	r0, [pc, #516]	; (87fc <SdioCard::begin(SdioConfig)+0x300>)
    85f8:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    85fc:	cbz	r0, 861a <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    85fe:	ldr	r3, [pc, #512]	; (8800 <SdioCard::begin(SdioConfig)+0x304>)
    8600:	ldr	r3, [r3, #0]
    8602:	cmp.w	r3, #426	; 0x1aa
    8606:	beq.n	8612 <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8608:	movs	r3, #6
    860a:	strb	r3, [r4, #0]
  m_errorLine = line;
    860c:	mov.w	r2, #668	; 0x29c
    8610:	b.n	8732 <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    8612:	movs	r3, #1
    8614:	strb.w	r3, [sl]
      break;
    8618:	b.n	8620 <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    861a:	subs.w	fp, fp, #1
    861e:	bne.n	85f2 <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    8620:	ldrb.w	r3, [sl]
    8624:	cmp	r3, #0
    8626:	ldr	r3, [pc, #476]	; (8804 <SdioCard::begin(SdioConfig)+0x308>)
    8628:	ite	eq
    862a:	moveq.w	fp, #3145728	; 0x300000
    862e:	movne	fp, r3
  int m = micros();
    8630:	bl	9220 <micros>
    8634:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8636:	movs	r1, #0
    8638:	ldr	r0, [pc, #460]	; (8808 <SdioCard::begin(SdioConfig)+0x30c>)
    863a:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    863e:	cmp	r0, #0
    8640:	beq.n	8720 <SdioCard::begin(SdioConfig)+0x224>
    8642:	mov	r1, fp
    8644:	ldr	r0, [pc, #452]	; (880c <SdioCard::begin(SdioConfig)+0x310>)
    8646:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    864a:	cmp	r0, #0
    864c:	beq.n	8720 <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    864e:	bl	9220 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8652:	ldr	r3, [sp, #0]
    8654:	subs	r0, r0, r3
    8656:	ldr	r3, [pc, #440]	; (8810 <SdioCard::begin(SdioConfig)+0x314>)
    8658:	cmp	r0, r3
    865a:	bhi.n	8720 <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    865c:	ldr	r3, [pc, #416]	; (8800 <SdioCard::begin(SdioConfig)+0x304>)
    865e:	ldr.w	sl, [pc, #416]	; 8800 <SdioCard::begin(SdioConfig)+0x304>
    8662:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    8664:	cmp	r3, #0
    8666:	bge.n	8636 <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    8668:	ldr	r2, [pc, #424]	; (8814 <SdioCard::begin(SdioConfig)+0x318>)
    866a:	ldr.w	r1, [sl]
    866e:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8670:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8674:	ldr	r0, [pc, #416]	; (8818 <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    8676:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    8678:	itt	mi
    867a:	ldrmi	r3, [sp, #8]
    867c:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    867e:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8682:	it	mi
    8684:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8686:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    868a:	mov	fp, r0
    868c:	cbnz	r0, 869c <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    868e:	movs	r3, #2
    8690:	strb	r3, [r4, #0]
  m_errorLine = line;
    8692:	mov.w	r2, #688	; 0x2b0
    8696:	ldr	r3, [pc, #388]	; (881c <SdioCard::begin(SdioConfig)+0x320>)
    8698:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    869a:	b.n	87c2 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    869c:	movs	r1, #0
    869e:	ldr	r0, [pc, #384]	; (8820 <SdioCard::begin(SdioConfig)+0x324>)
    86a0:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    86a4:	mov	fp, r0
    86a6:	cbnz	r0, 86b2 <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86a8:	movs	r3, #3
    86aa:	strb	r3, [r4, #0]
  m_errorLine = line;
    86ac:	movw	r2, #691	; 0x2b3
    86b0:	b.n	8696 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    86b2:	ldr.w	r3, [sl]
    86b6:	ldr.w	sl, [pc, #412]	; 8854 <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    86ba:	ldr	r1, [pc, #360]	; (8824 <SdioCard::begin(SdioConfig)+0x328>)
    86bc:	ldr	r0, [pc, #360]	; (8828 <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    86be:	lsrs	r3, r3, #16
    86c0:	lsls	r3, r3, #16
    86c2:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    86c6:	bl	7e68 <readReg16(unsigned long, void*)>
    86ca:	mov	fp, r0
    86cc:	cbnz	r0, 86d8 <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86ce:	movs	r3, #7
    86d0:	strb	r3, [r4, #0]
  m_errorLine = line;
    86d2:	mov.w	r2, #696	; 0x2b8
    86d6:	b.n	8696 <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    86d8:	ldr	r1, [pc, #336]	; (882c <SdioCard::begin(SdioConfig)+0x330>)
    86da:	ldr	r0, [pc, #340]	; (8830 <SdioCard::begin(SdioConfig)+0x334>)
    86dc:	bl	7e68 <readReg16(unsigned long, void*)>
    86e0:	mov	fp, r0
    86e2:	cbnz	r0, 86ee <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86e4:	movs	r3, #8
    86e6:	strb	r3, [r4, #0]
  m_errorLine = line;
    86e8:	movw	r2, #699	; 0x2bb
    86ec:	b.n	8696 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    86ee:	ldr.w	r1, [sl]
    86f2:	ldr	r0, [pc, #320]	; (8834 <SdioCard::begin(SdioConfig)+0x338>)
    86f4:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    86f8:	mov	fp, r0
    86fa:	cbnz	r0, 8706 <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86fc:	movs	r3, #5
    86fe:	strb	r3, [r4, #0]
  m_errorLine = line;
    8700:	movw	r2, #702	; 0x2be
    8704:	b.n	8696 <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8706:	ldr.w	r1, [sl]
    870a:	ldr	r0, [pc, #252]	; (8808 <SdioCard::begin(SdioConfig)+0x30c>)
    870c:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    8710:	cbz	r0, 872a <SdioCard::begin(SdioConfig)+0x22e>
    8712:	movs	r1, #2
    8714:	ldr	r0, [pc, #288]	; (8838 <SdioCard::begin(SdioConfig)+0x33c>)
    8716:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    871a:	mov	fp, r0
    871c:	cbz	r0, 872a <SdioCard::begin(SdioConfig)+0x22e>
    871e:	b.n	873c <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8720:	movs	r3, #23
    8722:	strb	r3, [r4, #0]
  m_errorLine = line;
    8724:	movw	r2, #679	; 0x2a7
    8728:	b.n	8732 <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    872a:	movs	r3, #20
    872c:	strb	r3, [r4, #0]
  m_errorLine = line;
    872e:	movw	r2, #706	; 0x2c2
    8732:	ldr	r3, [pc, #232]	; (881c <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8734:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8738:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    873a:	b.n	87c2 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    873c:	ldr	r3, [pc, #252]	; (883c <SdioCard::begin(SdioConfig)+0x340>)
    873e:	ldr	r2, [r3, #0]
    8740:	bic.w	r2, r2, #6
    8744:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8746:	ldr	r2, [r3, #0]
    8748:	orr.w	r2, r2, #2
    874c:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    874e:	mov.w	r2, #1048592	; 0x100010
    8752:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8754:	add	r1, sp, #16
    8756:	mvn.w	r0, #4278190080	; 0xff000000
    875a:	bl	8464 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    875e:	cbz	r0, 8768 <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8760:	ldrb.w	r3, [sp, #29]
    8764:	lsls	r3, r3, #30
    8766:	bmi.n	876e <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8768:	movw	r0, #25000	; 0x61a8
    876c:	b.n	878a <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    876e:	add	r1, sp, #16
    8770:	ldr	r0, [pc, #204]	; (8840 <SdioCard::begin(SdioConfig)+0x344>)
    8772:	bl	8464 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8776:	cmp	r0, #0
    8778:	beq.n	8768 <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    877a:	ldrb.w	r3, [sp, #32]
    877e:	and.w	r3, r3, #15
    8782:	cmp	r3, #1
    8784:	bne.n	8768 <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    8786:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    878a:	ldr	r4, [pc, #92]	; (87e8 <SdioCard::begin(SdioConfig)+0x2ec>)
    878c:	movw	r3, #259	; 0x103
    8790:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8792:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8794:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8796:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8798:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    879c:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    87a0:	bl	7c50 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    87a4:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    87a8:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    87ac:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    87ae:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    87b0:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    87b2:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    87b4:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    87b6:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    87ba:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    87be:	movs	r3, #1
    87c0:	strb	r3, [r2, #0]
  return true;
}
    87c2:	mov	r0, fp
    87c4:	add	sp, #84	; 0x54
    87c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    87ca:	nop
    87cc:	.word	0x20013d44
    87d0:	.word	0x4000d800
    87d4:	.word	0x4004d014
    87d8:	.word	0x4004d004
    87dc:	.word	0x4004d008
    87e0:	.word	0x4004d00c
    87e4:	.word	0x400b102c
    87e8:	.word	0x4004d000
    87ec:	.word	0x400b1034
    87f0:	.word	0x117f000b
    87f4:	.word	0x00007ba1
    87f8:	.word	0xe000e451
    87fc:	.word	0x081a0000
    8800:	.word	0x400b1010
    8804:	.word	0x40300000
    8808:	.word	0x371a0000
    880c:	.word	0x29020000
    8810:	.word	0x000f4240
    8814:	.word	0x20019ec4
    8818:	.word	0x02090000
    881c:	.word	0x20019eec
    8820:	.word	0x031a0000
    8824:	.word	0x20019ed5
    8828:	.word	0x09090000
    882c:	.word	0x20019ea9
    8830:	.word	0x0a090000
    8834:	.word	0x071b0000
    8838:	.word	0x061a0000
    883c:	.word	0x400b1028
    8840:	.word	0x80fffff1
    8844:	.word	0x20019ed4
    8848:	.word	0x20019ec0
    884c:	.word	0x20019ea8
    8850:	.word	0x4004d010
    8854:	.word	0x20019ec8

00008858 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8858:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    885a:	ldr	r5, [pc, #152]	; (88f4 <SdioCard::readData(unsigned char*)+0x9c>)
    885c:	ldr	r3, [r5, #0]
    885e:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8860:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8862:	bmi.n	8882 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8864:	ldr	r3, [pc, #144]	; (88f8 <SdioCard::readData(unsigned char*)+0xa0>)
    8866:	ldr	r2, [r3, #0]
    8868:	bic.w	r2, r2, #65536	; 0x10000
    886c:	str	r2, [r3, #0]
    noInterrupts();
    886e:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8870:	ldr	r2, [r3, #0]
    8872:	orr.w	r2, r2, #131072	; 0x20000
    8876:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8878:	ldr	r2, [r3, #0]
    887a:	orr.w	r2, r2, #65536	; 0x10000
    887e:	str	r2, [r3, #0]
    interrupts();
    8880:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8882:	ldr	r0, [pc, #120]	; (88fc <SdioCard::readData(unsigned char*)+0xa4>)
    8884:	bl	7d4c <waitTimeout(bool (*)())>
    8888:	cbnz	r0, 88e0 <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    888a:	ldr	r1, [pc, #116]	; (8900 <SdioCard::readData(unsigned char*)+0xa8>)
    888c:	subs	r3, r4, #4
    888e:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8892:	ldr	r2, [r5, #0]
    8894:	lsls	r0, r2, #20
    8896:	bpl.n	8892 <SdioCard::readData(unsigned char*)+0x3a>
    8898:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    889c:	ldr	r0, [r1, #0]
    889e:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    88a2:	cmp	r2, r3
    88a4:	bne.n	889c <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    88a6:	cmp	r4, r2
    88a8:	mov	r3, r2
    88aa:	bne.n	8892 <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    88ac:	ldr	r0, [pc, #84]	; (8904 <SdioCard::readData(unsigned char*)+0xac>)
    88ae:	bl	7d4c <waitTimeout(bool (*)())>
    88b2:	cbz	r0, 88c0 <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    88b4:	ldr	r3, [pc, #80]	; (8908 <SdioCard::readData(unsigned char*)+0xb0>)
    88b6:	movs	r2, #29
    88b8:	strb	r2, [r3, #0]
  m_errorLine = line;
    88ba:	movw	r2, #846	; 0x34e
    88be:	b.n	88ea <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    88c0:	ldr	r2, [pc, #72]	; (890c <SdioCard::readData(unsigned char*)+0xb4>)
    88c2:	ldr	r3, [pc, #76]	; (8910 <SdioCard::readData(unsigned char*)+0xb8>)
    88c4:	ldr	r1, [r2, #0]
    88c6:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    88c8:	ldr	r1, [r3, #0]
    88ca:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    88cc:	ldr	r2, [r3, #0]
    88ce:	lsls	r2, r2, #30
    88d0:	bpl.n	88f0 <SdioCard::readData(unsigned char*)+0x98>
    88d2:	ldr	r3, [r3, #0]
    88d4:	ldr	r0, [pc, #60]	; (8914 <SdioCard::readData(unsigned char*)+0xbc>)
    88d6:	ands	r0, r3
    88d8:	clz	r0, r0
    88dc:	lsrs	r0, r0, #5
    88de:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    88e0:	ldr	r3, [pc, #36]	; (8908 <SdioCard::readData(unsigned char*)+0xb0>)
    88e2:	movs	r2, #26
    88e4:	strb	r2, [r3, #0]
  m_errorLine = line;
    88e6:	movw	r2, #835	; 0x343
    88ea:	ldr	r3, [pc, #44]	; (8918 <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    88ec:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    88ee:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    88f0:	pop	{r3, r4, r5, pc}
    88f2:	nop
    88f4:	.word	0x400b1024
    88f8:	.word	0x400b1028
    88fc:	.word	0x00007c11
    8900:	.word	0x400b1020
    8904:	.word	0x00007c39
    8908:	.word	0x20013d44
    890c:	.word	0x400b1030
    8910:	.word	0x20019ed0
    8914:	.word	0x117f0000
    8918:	.word	0x20019eec

0000891c <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    891c:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    891e:	ldr	r0, [pc, #80]	; (8970 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8920:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8922:	bl	7d70 <yieldTimeout(bool (*)())>
    8926:	cbz	r0, 893a <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8928:	ldr	r3, [pc, #72]	; (8974 <SdioCard::readStart(unsigned long)+0x58>)
    892a:	movs	r2, #10
    892c:	strb	r2, [r3, #0]
  m_errorLine = line;
    892e:	ldr	r3, [pc, #72]	; (8978 <SdioCard::readStart(unsigned long)+0x5c>)
    8930:	mov.w	r2, #928	; 0x3a0
    8934:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8936:	movs	r0, #0
    8938:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    893a:	ldr	r2, [pc, #64]	; (897c <SdioCard::readStart(unsigned long)+0x60>)
    893c:	ldr	r3, [r2, #0]
    893e:	orr.w	r3, r3, #65536	; 0x10000
    8942:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8944:	ldr	r3, [pc, #56]	; (8980 <SdioCard::readStart(unsigned long)+0x64>)
    8946:	ldr	r2, [pc, #60]	; (8984 <SdioCard::readStart(unsigned long)+0x68>)
    8948:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    894a:	ldr	r3, [pc, #60]	; (8988 <SdioCard::readStart(unsigned long)+0x6c>)
    894c:	ldrb	r3, [r3, #0]
    894e:	cbnz	r3, 8954 <SdioCard::readStart(unsigned long)+0x38>
    8950:	lsls	r1, r4, #9
    8952:	b.n	8956 <SdioCard::readStart(unsigned long)+0x3a>
    8954:	mov	r1, r4
    8956:	ldr	r0, [pc, #52]	; (898c <SdioCard::readStart(unsigned long)+0x70>)
    8958:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    895c:	cbnz	r0, 896c <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    895e:	ldr	r3, [pc, #20]	; (8974 <SdioCard::readStart(unsigned long)+0x58>)
    8960:	movs	r2, #12
    8962:	strb	r2, [r3, #0]
  m_errorLine = line;
    8964:	ldr	r3, [pc, #16]	; (8978 <SdioCard::readStart(unsigned long)+0x5c>)
    8966:	mov.w	r2, #940	; 0x3ac
    896a:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    896c:	pop	{r4, pc}
    896e:	nop
    8970:	.word	0x00007e55
    8974:	.word	0x20013d44
    8978:	.word	0x20019eec
    897c:	.word	0x400b1028
    8980:	.word	0x400b1004
    8984:	.word	0xffff0200
    8988:	.word	0x20019ec0
    898c:	.word	0x123a0032

00008990 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8990:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8992:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8994:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    8996:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8998:	sub.w	sp, sp, #512	; 0x200
    899c:	mov	r4, r0
    899e:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    89a0:	bpl.n	89da <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    89a2:	lsls	r3, r6, #30
    89a4:	ite	eq
    89a6:	moveq	r4, r6
    89a8:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    89aa:	movs	r3, #1
    89ac:	mov	r2, r4
    89ae:	ldr	r0, [pc, #148]	; (8a44 <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    89b0:	bl	7ef0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    89b4:	mov	r5, r0
    89b6:	cbnz	r0, 89c8 <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89b8:	ldr	r3, [pc, #140]	; (8a48 <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    89ba:	movs	r2, #11
    89bc:	strb	r2, [r3, #0]
  m_errorLine = line;
    89be:	ldr	r3, [pc, #140]	; (8a4c <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    89c0:	movw	r2, #865	; 0x361
    89c4:	str	r2, [r3, #0]
    89c6:	b.n	8a3c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    89c8:	cmp	r4, r6
    89ca:	beq.n	8a3c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    89cc:	mov.w	r2, #512	; 0x200
    89d0:	mov	r1, sp
    89d2:	mov	r0, r6
    89d4:	bl	8b4c <memcpy>
    89d8:	b.n	8a3c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    89da:	bl	80c8 <waitTransferComplete()>
    89de:	cbnz	r0, 89e4 <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    89e0:	movs	r5, #0
    89e2:	b.n	8a3c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    89e4:	ldrb	r3, [r4, #9]
    89e6:	cmp	r3, #1
    89e8:	bne.n	89f0 <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    89ea:	ldr	r3, [r4, #4]
    89ec:	cmp	r5, r3
    89ee:	beq.n	8a0e <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    89f0:	ldr	r3, [r4, #0]
    89f2:	mov	r0, r4
    89f4:	ldr	r3, [r3, #28]
    89f6:	blx	r3
    89f8:	cmp	r0, #0
    89fa:	beq.n	89e0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    89fc:	mov	r1, r5
    89fe:	mov	r0, r4
    8a00:	bl	891c <SdioCard::readStart(unsigned long)>
    8a04:	cmp	r0, #0
    8a06:	beq.n	89e0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    8a08:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    8a0a:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    8a0c:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8a0e:	mov	r1, r6
    8a10:	mov	r0, r4
    8a12:	bl	8858 <SdioCard::readData(unsigned char*)>
    8a16:	mov	r5, r0
    8a18:	cmp	r0, #0
    8a1a:	beq.n	89e0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8a1c:	ldr	r3, [pc, #48]	; (8a50 <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    8a1e:	ldr	r3, [r3, #0]
    8a20:	lsrs	r3, r3, #16
    8a22:	lsls	r3, r3, #16
    8a24:	cbz	r3, 8a2e <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8a26:	ldr	r3, [r4, #4]
    8a28:	adds	r3, #1
    8a2a:	str	r3, [r4, #4]
    8a2c:	b.n	8a3c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8a2e:	ldr	r3, [r4, #0]
    8a30:	mov	r0, r4
    8a32:	ldr	r3, [r3, #28]
    8a34:	blx	r3
    8a36:	cmp	r0, #0
    8a38:	bne.n	8a26 <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    8a3a:	b.n	89e0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8a3c:	mov	r0, r5
    8a3e:	add.w	sp, sp, #512	; 0x200
    8a42:	pop	{r4, r5, r6, pc}
    8a44:	.word	0x113a0011
    8a48:	.word	0x20013d44
    8a4c:	.word	0x20019eec
    8a50:	.word	0x400b1004

00008a54 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8a54:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8a56:	ldr	r2, [pc, #72]	; (8aa0 <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8a58:	movs	r5, #0
    8a5a:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8a5c:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8a5e:	ldr	r0, [pc, #68]	; (8aa4 <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8a60:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8a64:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8a66:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8a68:	mov	r1, r5
    8a6a:	bl	7de0 <cardCommand(unsigned long, unsigned long)>
    8a6e:	mov	r4, r0
    8a70:	cbnz	r0, 8a82 <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a72:	ldr	r3, [pc, #52]	; (8aa8 <SdioCard::stopTransmission(bool)+0x54>)
    8a74:	movs	r2, #9
    8a76:	strb	r2, [r3, #0]
  m_errorLine = line;
    8a78:	ldr	r3, [pc, #48]	; (8aac <SdioCard::stopTransmission(bool)+0x58>)
    8a7a:	movw	r2, #962	; 0x3c2
    8a7e:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8a80:	b.n	8a9c <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8a82:	cbz	r6, 8a9c <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8a84:	ldr	r0, [pc, #40]	; (8ab0 <SdioCard::stopTransmission(bool)+0x5c>)
    8a86:	bl	7d70 <yieldTimeout(bool (*)())>
    8a8a:	cbz	r0, 8a9c <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a8c:	ldr	r3, [pc, #24]	; (8aa8 <SdioCard::stopTransmission(bool)+0x54>)
    8a8e:	movs	r2, #10
    8a90:	strb	r2, [r3, #0]
  m_errorLine = line;
    8a92:	ldr	r3, [pc, #24]	; (8aac <SdioCard::stopTransmission(bool)+0x58>)
    8a94:	movw	r2, #966	; 0x3c6
    8a98:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    8a9a:	mov	r4, r5
    }
  }
  return true;
}
    8a9c:	mov	r0, r4
    8a9e:	pop	{r4, r5, r6, pc}
    8aa0:	.word	0x400b1028
    8aa4:	.word	0x0cdb0000
    8aa8:	.word	0x20013d44
    8aac:	.word	0x20019eec
    8ab0:	.word	0x00007bf1

00008ab4 <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    8ab4:	push	{r4, lr}
    8ab6:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8ab8:	bl	80c8 <waitTransferComplete()>
    8abc:	cbz	r0, 8ace <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    8abe:	ldrb	r3, [r4, #9]
    8ac0:	cbz	r3, 8ace <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    8ac2:	mov	r0, r4
    8ac4:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8ac6:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    8aca:	b.w	8a54 <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8ace:	pop	{r4, pc}

00008ad0 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8ad0:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8ad2:	ldrb	r3, [r0, #8]
    8ad4:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8ad6:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8ad8:	bpl.n	8af8 <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ada:	ldr	r3, [pc, #80]	; (8b2c <SdioCard::isBusy()+0x5c>)
    8adc:	ldr	r3, [r3, #0]
    8ade:	cbz	r3, 8ae6 <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8ae0:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ae4:	bx	r3
    8ae6:	ldr	r3, [pc, #72]	; (8b30 <SdioCard::isBusy()+0x60>)
    8ae8:	ldrb	r3, [r3, #0]
    8aea:	cbnz	r3, 8af0 <SdioCard::isBusy()+0x20>
    8aec:	movs	r0, #0
    8aee:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8af0:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8af4:	b.w	7e54 <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    8af8:	ldr	r1, [pc, #56]	; (8b34 <SdioCard::isBusy()+0x64>)
    8afa:	ldrb	r4, [r1, #0]
    8afc:	cbz	r4, 8b1e <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    8afe:	bl	7c38 <isBusyTransferComplete()>
    8b02:	cbnz	r0, 8b2a <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    8b04:	ldr	r3, [pc, #48]	; (8b38 <SdioCard::isBusy()+0x68>)
    8b06:	ldr	r3, [r3, #0]
    8b08:	lsrs	r3, r3, #16
    8b0a:	lsls	r3, r3, #16
    8b0c:	cmp	r3, #0
    8b0e:	bne.n	8aec <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    8b10:	strb	r0, [r1, #0]
      stopTransmission(false);
    8b12:	mov	r1, r0
    8b14:	mov	r0, r2
    8b16:	bl	8a54 <SdioCard::stopTransmission(bool)>
    8b1a:	mov	r0, r4
    8b1c:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    8b1e:	ldr	r3, [pc, #28]	; (8b3c <SdioCard::isBusy()+0x6c>)
    8b20:	ldr	r0, [r3, #0]
    8b22:	eor.w	r0, r0, #16777216	; 0x1000000
    8b26:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8b2a:	pop	{r4, pc}
    8b2c:	.word	0x20019ebc
    8b30:	.word	0x20019ed4
    8b34:	.word	0x20019ecc
    8b38:	.word	0x400b1004
    8b3c:	.word	0x400b1024

00008b40 <sdCsInit(unsigned char)>:
}
#elif SD_CHIP_SELECT_MODE == 1
//------------------------------------------------------------------------------
__attribute__((weak))
void sdCsInit(SdCsPin_t pin) {
  pinMode(pin, OUTPUT);
    8b40:	movs	r1, #1
    8b42:	b.w	91bc <pinMode>

00008b46 <sdCsWrite(unsigned char, bool)>:
}
//------------------------------------------------------------------------------
__attribute__((weak))
void sdCsWrite(SdCsPin_t pin, bool level) {
  digitalWrite(pin, level);
    8b46:	b.w	9160 <digitalWrite>
    8b4a:	Address 0x00008b4a is out of bounds.


00008b4c <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8b4c:	push	{r0}
#endif
	orr	r3, r1, r0
    8b4e:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8b52:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    8b56:	bne.n	8c38 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8b58:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8b5a:	bcc.n	8be0 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8b5c:	ldr.w	r3, [r1], #4
    8b60:	str.w	r3, [r0], #4
    8b64:	ldr.w	r3, [r1], #4
    8b68:	str.w	r3, [r0], #4
    8b6c:	ldr.w	r3, [r1], #4
    8b70:	str.w	r3, [r0], #4
    8b74:	ldr.w	r3, [r1], #4
    8b78:	str.w	r3, [r0], #4
    8b7c:	ldr.w	r3, [r1], #4
    8b80:	str.w	r3, [r0], #4
    8b84:	ldr.w	r3, [r1], #4
    8b88:	str.w	r3, [r0], #4
    8b8c:	ldr.w	r3, [r1], #4
    8b90:	str.w	r3, [r0], #4
    8b94:	ldr.w	r3, [r1], #4
    8b98:	str.w	r3, [r0], #4
    8b9c:	ldr.w	r3, [r1], #4
    8ba0:	str.w	r3, [r0], #4
    8ba4:	ldr.w	r3, [r1], #4
    8ba8:	str.w	r3, [r0], #4
    8bac:	ldr.w	r3, [r1], #4
    8bb0:	str.w	r3, [r0], #4
    8bb4:	ldr.w	r3, [r1], #4
    8bb8:	str.w	r3, [r0], #4
    8bbc:	ldr.w	r3, [r1], #4
    8bc0:	str.w	r3, [r0], #4
    8bc4:	ldr.w	r3, [r1], #4
    8bc8:	str.w	r3, [r0], #4
    8bcc:	ldr.w	r3, [r1], #4
    8bd0:	str.w	r3, [r0], #4
    8bd4:	ldr.w	r3, [r1], #4
    8bd8:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8bdc:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    8bde:	bcs.n	8b5c <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    8be0:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    8be2:	bcc.n	8c08 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8be4:	ldr.w	r3, [r1], #4
    8be8:	str.w	r3, [r0], #4
    8bec:	ldr.w	r3, [r1], #4
    8bf0:	str.w	r3, [r0], #4
    8bf4:	ldr.w	r3, [r1], #4
    8bf8:	str.w	r3, [r0], #4
    8bfc:	ldr.w	r3, [r1], #4
    8c00:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8c04:	subs	r2, #16
	bhs	.Lmid_block_loop
    8c06:	bcs.n	8be4 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8c08:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8c0a:	bcc.n	8c18 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8c0c:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    8c10:	str.w	r3, [r0], #4
	subs	r2, #4
    8c14:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    8c16:	bcs.n	8c0c <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8c18:	adds	r2, #4
	beq	.Ldone
    8c1a:	beq.n	8c32 <memcpy+0xe6>

	lsls	r2, r2, #31
    8c1c:	lsls	r2, r2, #31
	itt ne
    8c1e:	itt	ne
	ldrbne  r3, [r1], #1
    8c20:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8c24:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8c28:	bcc.n	8c32 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    8c2a:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8c2c:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8c2e:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8c30:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8c32:	pop	{r0}
#endif
	bx	lr
    8c34:	bx	lr
    8c36:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    8c38:	cmp	r2, #12
	blo	.Lbyte_copy
    8c3a:	bcc.n	8cd2 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8c3c:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    8c40:	beq.n	8c66 <memcpy+0x11a>

	rsb	r3, #4
    8c42:	rsb	r3, r3, #4
	subs	r2, r3
    8c46:	subs	r2, r2, r3

	lsls    r3, r3, #31
    8c48:	lsls	r3, r3, #31
	itt ne
    8c4a:	itt	ne
	ldrbne  r3, [r1], #1
    8c4c:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8c50:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    8c54:	bcc.n	8c66 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    8c56:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8c5a:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    8c5e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8c62:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    8c66:	ands.w	r3, r1, #3
	beq	.Lbig_block
    8c6a:	beq.w	8b58 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    8c6e:	push	{r4, r5}
	subs	r2, #4
    8c70:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    8c72:	subs	r1, r1, r3
	rsb	ip, r3, #4
    8c74:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    8c78:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    8c7c:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    8c7e:	beq.n	8cb4 <memcpy+0x168>
	cmp	r3, #3
    8c80:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    8c82:	beq.n	8c9c <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    8c84:	lsrs	r4, r4, #8
    8c86:	ldr.w	r3, [r1], #4
    8c8a:	lsls	r5, r3, #24
    8c8c:	orr.w	r4, r4, r5
    8c90:	str.w	r4, [r0], #4
    8c94:	mov	r4, r3
    8c96:	subs	r2, #4
    8c98:	bcs.n	8c84 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    8c9a:	b.n	8cca <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    8c9c:	lsrs	r4, r4, #24
    8c9e:	ldr.w	r3, [r1], #4
    8ca2:	lsls	r5, r3, #8
    8ca4:	orr.w	r4, r4, r5
    8ca8:	str.w	r4, [r0], #4
    8cac:	mov	r4, r3
    8cae:	subs	r2, #4
    8cb0:	bcs.n	8c9c <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    8cb2:	b.n	8cca <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    8cb4:	lsrs	r4, r4, #16
    8cb6:	ldr.w	r3, [r1], #4
    8cba:	lsls	r5, r3, #16
    8cbc:	orr.w	r4, r4, r5
    8cc0:	str.w	r4, [r0], #4
    8cc4:	mov	r4, r3
    8cc6:	subs	r2, #4
    8cc8:	bcs.n	8cb4 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    8cca:	adds	r2, #4
	subs	r1, ip
    8ccc:	subs.w	r1, r1, ip
	pop	{r4, r5}
    8cd0:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    8cd2:	subs	r2, #4
	blo	.Lcopy_less_than_4
    8cd4:	bcc.n	8c18 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    8cd6:	subs	r2, #1
	ldrb    r3, [r1], #1
    8cd8:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8cdc:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    8ce0:	bcs.n	8cd6 <memcpy+0x18a>

	ldrb	r3, [r1]
    8ce2:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8ce4:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8ce6:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8ce8:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    8cea:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    8cec:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8cee:	pop	{r0}
#endif
	bx	lr
    8cf0:	bx	lr
    8cf2:	nop

00008cf4 <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    8cf4:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    8cf6:	cbz	r2, 8d34 <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    8cf8:	cmp	r2, #16
    blt     .L_bytewise
    8cfa:	blt.n	8d2c <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    8cfc:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    8d00:	cbz	r3, 8d10 <memset+0x1c>
    rsb     r3, #8
    8d02:	rsb	r3, r3, #8
    subs    r2, r3
    8d06:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    8d08:	subs	r3, #1
    strb    r1, [r0], #1
    8d0a:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    8d0e:	bgt.n	8d08 <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    8d10:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    8d12:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    8d16:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    8d1a:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    8d1c:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    8d1e:	subs	r3, #1
    strd    r1, r12, [r0], #8
    8d20:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    8d24:	bgt.n	8d1e <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    8d26:	ands.w	r2, r2, #7
    beq     .L_done
    8d2a:	beq.n	8d34 <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    8d2c:	subs	r2, #1
    strb    r1, [r0], #1
    8d2e:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    8d32:	bgt.n	8d2c <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    8d34:	pop	{r0, pc}
    8d36:	nop

00008d38 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    8d38:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    8d3a:	ldr	r4, [pc, #64]	; (8d7c <usb_serial_getchar+0x44>)
    8d3c:	ldr	r3, [r4, #0]
    8d3e:	cbz	r3, 8d5c <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    8d40:	ldr	r0, [r4, #0]
    8d42:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    8d44:	adds	r2, r3, #1
    8d46:	add	r3, r0
    8d48:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    8d4a:	ldrh	r3, [r0, #0]
    8d4c:	cmp	r2, r3
    8d4e:	bcc.n	8d76 <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    8d50:	bl	93d0 <usb_free>
		rx_packet = NULL;
    8d54:	ldr	r3, [pc, #36]	; (8d7c <usb_serial_getchar+0x44>)
    8d56:	movs	r2, #0
    8d58:	str	r2, [r3, #0]
    8d5a:	b.n	8d78 <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8d5c:	ldr	r3, [pc, #32]	; (8d80 <usb_serial_getchar+0x48>)
    8d5e:	ldrb	r3, [r3, #0]
    8d60:	cbnz	r3, 8d68 <usb_serial_getchar+0x30>
    8d62:	mov.w	r0, #4294967295
    8d66:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8d68:	movs	r0, #3
    8d6a:	bl	9454 <usb_rx>
    8d6e:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    8d70:	cmp	r0, #0
    8d72:	bne.n	8d40 <usb_serial_getchar+0x8>
    8d74:	b.n	8d62 <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    8d76:	strh	r2, [r0, #2]
	}
	return c;
    8d78:	mov	r0, r4
}
    8d7a:	pop	{r4, pc}
    8d7c:	.word	0x20019efc
    8d80:	.word	0x20019fe7

00008d84 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    8d84:	push	{r4, lr}
	if (!rx_packet) {
    8d86:	ldr	r4, [pc, #44]	; (8db4 <usb_serial_peekchar+0x30>)
    8d88:	ldr	r3, [r4, #0]
    8d8a:	cbz	r3, 8d92 <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    8d8c:	ldr	r2, [r4, #0]
    8d8e:	cbnz	r2, 8dac <usb_serial_peekchar+0x28>
    8d90:	b.n	8d98 <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8d92:	ldr	r3, [pc, #36]	; (8db8 <usb_serial_peekchar+0x34>)
    8d94:	ldrb	r3, [r3, #0]
    8d96:	cbnz	r3, 8d9e <usb_serial_peekchar+0x1a>
    8d98:	mov.w	r0, #4294967295
    8d9c:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8d9e:	movs	r0, #3
    8da0:	bl	9454 <usb_rx>
    8da4:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    8da6:	cmp	r0, #0
    8da8:	bne.n	8d8c <usb_serial_peekchar+0x8>
    8daa:	b.n	8d98 <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    8dac:	ldrh	r3, [r2, #2]
    8dae:	add	r3, r2
    8db0:	ldrb	r0, [r3, #8]
}
    8db2:	pop	{r4, pc}
    8db4:	.word	0x20019efc
    8db8:	.word	0x20019fe7

00008dbc <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    8dbc:	ldr	r3, [pc, #16]	; (8dd0 <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    8dbe:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    8dc0:	ldr	r3, [pc, #16]	; (8dd4 <usb_serial_available+0x18>)
    8dc2:	ldr	r2, [r3, #0]
    8dc4:	cbz	r2, 8dce <usb_serial_available+0x12>
    8dc6:	ldrh	r3, [r2, #0]
    8dc8:	ldrh	r2, [r2, #2]
    8dca:	subs	r3, r3, r2
    8dcc:	add	r0, r3
	return count;
}
    8dce:	bx	lr
    8dd0:	.word	0x2001a0e4
    8dd4:	.word	0x20019efc

00008dd8 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    8dd8:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    8dda:	ldr	r3, [pc, #36]	; (8e00 <usb_serial_flush_input+0x28>)
    8ddc:	ldrb	r3, [r3, #0]
    8dde:	cbz	r3, 8dfc <usb_serial_flush_input+0x24>
	if (rx_packet) {
    8de0:	ldr	r4, [pc, #32]	; (8e04 <usb_serial_flush_input+0x2c>)
    8de2:	ldr	r0, [r4, #0]
    8de4:	cbz	r0, 8dee <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    8de6:	bl	93d0 <usb_free>
		rx_packet = NULL;
    8dea:	movs	r3, #0
    8dec:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    8dee:	movs	r0, #3
    8df0:	bl	9454 <usb_rx>
		if (!rx) break;
    8df4:	cbz	r0, 8dfc <usb_serial_flush_input+0x24>
		usb_free(rx);
    8df6:	bl	93d0 <usb_free>
	}
    8dfa:	b.n	8dee <usb_serial_flush_input+0x16>
    8dfc:	pop	{r4, pc}
    8dfe:	nop
    8e00:	.word	0x20019fe7
    8e04:	.word	0x20019efc

00008e08 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    8e08:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    8e0c:	ldr	r5, [pc, #196]	; (8ed4 <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    8e0e:	ldr.w	r9, [pc, #212]	; 8ee4 <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    8e12:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    8e14:	mov	sl, r0
    8e16:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    8e18:	strb	r3, [r5, #0]
	while (size > 0) {
    8e1a:	mov	r6, r1
    8e1c:	mov	r7, r9
    8e1e:	cmp	r6, #0
    8e20:	beq.n	8eca <usb_serial_write+0xc2>
		if (!tx_packet) {
    8e22:	ldr.w	r3, [r9]
    8e26:	cbnz	r3, 8e78 <usb_serial_write+0x70>
    8e28:	ldr.w	fp, [pc, #176]	; 8edc <usb_serial_write+0xd4>
    8e2c:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    8e30:	ldr	r3, [pc, #164]	; (8ed8 <usb_serial_write+0xd0>)
    8e32:	ldrb	r3, [r3, #0]
    8e34:	and.w	r1, r3, #255	; 0xff
    8e38:	cbnz	r3, 8e3e <usb_serial_write+0x36>
					tx_noautoflush = 0;
    8e3a:	strb	r1, [r5, #0]
    8e3c:	b.n	8e6a <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    8e3e:	movs	r0, #4
    8e40:	bl	948c <usb_tx_packet_count>
    8e44:	cmp	r0, #7
    8e46:	bhi.n	8e58 <usb_serial_write+0x50>
					tx_noautoflush = 1;
    8e48:	movs	r3, #1
    8e4a:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    8e4c:	bl	9394 <usb_malloc>
    8e50:	str	r0, [r7, #0]
					if (tx_packet) break;
    8e52:	cbnz	r0, 8e78 <usb_serial_write+0x70>
					tx_noautoflush = 0;
    8e54:	ldr	r3, [pc, #124]	; (8ed4 <usb_serial_write+0xcc>)
    8e56:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    8e58:	subs.w	r8, r8, #1
    8e5c:	beq.n	8e64 <usb_serial_write+0x5c>
    8e5e:	ldrb.w	r3, [fp]
    8e62:	cbz	r3, 8e72 <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    8e64:	ldr	r3, [pc, #116]	; (8edc <usb_serial_write+0xd4>)
    8e66:	movs	r2, #1
    8e68:	strb	r2, [r3, #0]
					return -1;
    8e6a:	mov.w	r0, #4294967295
    8e6e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    8e72:	bl	9c60 <yield>
			}
    8e76:	b.n	8e30 <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    8e78:	ldr	r3, [pc, #96]	; (8edc <usb_serial_write+0xd4>)
    8e7a:	movs	r1, #0
    8e7c:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    8e7e:	ldr	r1, [r7, #0]
    8e80:	ldrh	r3, [r1, #2]
    8e82:	rsb	r0, r3, #64	; 0x40
    8e86:	cmp	r0, r6
    8e88:	it	cs
    8e8a:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    8e8c:	add.w	lr, r3, r0
    8e90:	add	r3, r1
    8e92:	strh.w	lr, [r1, #2]
		size -= len;
    8e96:	subs	r6, r6, r0
    8e98:	adds	r3, #7
    8e9a:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    8e9e:	cmp	sl, r8
    8ea0:	beq.n	8eac <usb_serial_write+0xa4>
    8ea2:	ldrb.w	r0, [sl], #1
    8ea6:	strb.w	r0, [r3, #1]!
    8eaa:	b.n	8e9e <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    8eac:	ldrh	r3, [r1, #2]
    8eae:	cmp	r3, #63	; 0x3f
    8eb0:	bls.n	8ec0 <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    8eb2:	movs	r3, #64	; 0x40
    8eb4:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8eb6:	movs	r0, #4
    8eb8:	bl	9528 <usb_tx>
			tx_packet = NULL;
    8ebc:	movs	r3, #0
    8ebe:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    8ec0:	ldr	r3, [pc, #28]	; (8ee0 <usb_serial_write+0xd8>)
    8ec2:	movs	r2, #5
    8ec4:	strb	r2, [r3, #0]
    8ec6:	mov	sl, r8
    8ec8:	b.n	8e1e <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    8eca:	strb	r6, [r5, #0]
	return ret;
    8ecc:	mov	r0, r4
}
    8ece:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8ed2:	nop
    8ed4:	.word	0x20019ef1
    8ed8:	.word	0x20019fe7
    8edc:	.word	0x20019ef8
    8ee0:	.word	0x20019ef0
    8ee4:	.word	0x20019ef4

00008ee8 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8ee8:	push	{r0, r1, r2, lr}
    8eea:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    8eec:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8eee:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    8ef2:	mov	r0, r3
    8ef4:	bl	8e08 <usb_serial_write>
}
    8ef8:	add	sp, #12
    8efa:	ldr.w	pc, [sp], #4
    8efe:	Address 0x00008efe is out of bounds.


00008f00 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    8f00:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    8f02:	ldr	r4, [pc, #56]	; (8f3c <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    8f04:	ldr	r5, [pc, #56]	; (8f40 <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    8f06:	movs	r3, #1
    8f08:	strb	r3, [r4, #0]
	if (!tx_packet) {
    8f0a:	ldr	r3, [r5, #0]
    8f0c:	cbnz	r3, 8f2e <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    8f0e:	ldr	r3, [pc, #52]	; (8f44 <usb_serial_write_buffer_free+0x44>)
    8f10:	ldrb	r3, [r3, #0]
    8f12:	cbnz	r3, 8f1a <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    8f14:	movs	r0, #0
    8f16:	strb	r0, [r4, #0]
			return 0;
    8f18:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8f1a:	movs	r0, #4
    8f1c:	bl	948c <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    8f20:	cmp	r0, #7
    8f22:	bhi.n	8f14 <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    8f24:	bl	9394 <usb_malloc>
    8f28:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8f2a:	cmp	r0, #0
    8f2c:	beq.n	8f14 <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8f2e:	ldr	r3, [r5, #0]
    8f30:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    8f32:	movs	r3, #0
    8f34:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8f36:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    8f3a:	pop	{r3, r4, r5, pc}
    8f3c:	.word	0x20019ef1
    8f40:	.word	0x20019ef4
    8f44:	.word	0x20019fe7

00008f48 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    8f48:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    8f4c:	ldr	r3, [pc, #68]	; (8f94 <usb_serial_flush_output+0x4c>)
    8f4e:	ldrb	r3, [r3, #0]
    8f50:	cbz	r3, 8f90 <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    8f52:	ldr	r7, [pc, #68]	; (8f98 <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8f54:	ldr	r3, [pc, #68]	; (8f9c <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    8f56:	ldr	r4, [r7, #0]
    8f58:	ldr	r5, [pc, #68]	; (8fa0 <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8f5a:	movs	r6, #1
    8f5c:	strb	r6, [r3, #0]
    8f5e:	mov	r8, r3
	if (tx_packet) {
    8f60:	cbz	r4, 8f76 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    8f62:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    8f64:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    8f66:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8f68:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    8f6a:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8f6c:	movs	r0, #4
    8f6e:	bl	9528 <usb_tx>
		tx_packet = NULL;
    8f72:	str	r6, [r7, #0]
    8f74:	b.n	8f8a <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    8f76:	bl	9394 <usb_malloc>
		if (tx) {
    8f7a:	mov	r1, r0
    8f7c:	cbz	r0, 8f88 <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    8f7e:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    8f80:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    8f82:	bl	9528 <usb_tx>
    8f86:	b.n	8f8a <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8f88:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    8f8a:	movs	r3, #0
    8f8c:	strb.w	r3, [r8]
    8f90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8f94:	.word	0x20019fe7
    8f98:	.word	0x20019ef4
    8f9c:	.word	0x20019ef1
    8fa0:	.word	0x20019ef0

00008fa4 <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    8fa4:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    8fa6:	ldr	r3, [pc, #56]	; (8fe0 <usb_serial_flush_callback+0x3c>)
    8fa8:	ldrb	r3, [r3, #0]
    8faa:	and.w	r5, r3, #255	; 0xff
    8fae:	cbnz	r3, 8fdc <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    8fb0:	ldr	r4, [pc, #48]	; (8fe4 <usb_serial_flush_callback+0x40>)
    8fb2:	ldr	r1, [r4, #0]
    8fb4:	cbz	r1, 8fc4 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    8fb6:	ldrh	r3, [r1, #2]
    8fb8:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8fba:	movs	r0, #4
    8fbc:	bl	9528 <usb_tx>
		tx_packet = NULL;
    8fc0:	str	r5, [r4, #0]
    8fc2:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    8fc4:	bl	9394 <usb_malloc>
		if (tx) {
    8fc8:	mov	r1, r0
    8fca:	cbz	r0, 8fd6 <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    8fcc:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    8fce:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    8fd2:	b.w	9528 <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8fd6:	ldr	r3, [pc, #16]	; (8fe8 <usb_serial_flush_callback+0x44>)
    8fd8:	movs	r2, #1
    8fda:	strb	r2, [r3, #0]
    8fdc:	pop	{r3, r4, r5, pc}
    8fde:	nop
    8fe0:	.word	0x20019ef1
    8fe4:	.word	0x20019ef4
    8fe8:	.word	0x20019ef0

00008fec <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    8fec:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    8fee:	ldr	r3, [pc, #128]	; (9070 <analog_init+0x84>)
    8ff0:	ldr	r0, [pc, #128]	; (9074 <analog_init+0x88>)
    8ff2:	ldr	r1, [pc, #132]	; (9078 <analog_init+0x8c>)
    8ff4:	movs	r2, #96	; 0x60
    8ff6:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    8ff8:	movs	r2, #225	; 0xe1
    8ffa:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    8ffc:	ldr	r3, [pc, #124]	; (907c <analog_init+0x90>)
    8ffe:	ldr	r2, [pc, #128]	; (9080 <analog_init+0x94>)
    9000:	ldrb	r4, [r3, #0]
    9002:	ldr	r3, [pc, #128]	; (9084 <analog_init+0x98>)
    9004:	cmp	r4, #8
    9006:	bne.n	900c <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    9008:	movs	r4, #1
    900a:	b.n	9012 <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    900c:	cmp	r4, #10
    900e:	bne.n	9018 <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    9010:	movs	r4, #57	; 0x39
    9012:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    9014:	movs	r0, #19
    9016:	b.n	9024 <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    9018:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    901a:	ite	eq
    901c:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    901e:	movne	r4, #61	; 0x3d
    9020:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    9022:	movs	r0, #18
    9024:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    9026:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    9028:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    902a:	ldr	r3, [pc, #92]	; (9088 <analog_init+0x9c>)
    902c:	ldr	r1, [pc, #92]	; (908c <analog_init+0xa0>)
    902e:	ldrb	r3, [r3, #0]
    9030:	ldr	r2, [pc, #92]	; (9090 <analog_init+0xa4>)
    9032:	cbz	r3, 9036 <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    9034:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    9036:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    9038:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    903a:	ldr	r3, [pc, #88]	; (9094 <analog_init+0xa8>)
    903c:	ldr	r2, [pc, #88]	; (9098 <analog_init+0xac>)
    903e:	ldrb	r1, [r3, #0]
    9040:	ldr	r3, [pc, #88]	; (909c <analog_init+0xb0>)
	if (num <= 1) {
    9042:	cmp	r1, #1
    9044:	bhi.n	904a <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    9046:	movs	r1, #128	; 0x80
    9048:	b.n	9062 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    904a:	cmp	r1, #4
    904c:	bhi.n	9052 <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    904e:	movs	r1, #132	; 0x84
    9050:	b.n	9062 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    9052:	cmp	r1, #8
    9054:	bhi.n	905a <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    9056:	movs	r1, #133	; 0x85
    9058:	b.n	9062 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    905a:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    905c:	ite	ls
    905e:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    9060:	movhi	r1, #135	; 0x87
    9062:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    9064:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    9066:	ldr	r3, [pc, #56]	; (90a0 <analog_init+0xb4>)
    9068:	movs	r2, #1
    906a:	strb	r2, [r3, #0]
    906c:	pop	{r4, pc}
    906e:	nop
    9070:	.word	0x40074000
    9074:	.word	0x4003b008
    9078:	.word	0x4003b00c
    907c:	.word	0x20013d45
    9080:	.word	0x400bb008
    9084:	.word	0x400bb00c
    9088:	.word	0x20019f02
    908c:	.word	0x4003b020
    9090:	.word	0x400bb020
    9094:	.word	0x20013d46
    9098:	.word	0x4003b024
    909c:	.word	0x400bb024
    90a0:	.word	0x20019f01

000090a4 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    90a4:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    90a6:	ldr	r5, [pc, #44]	; (90d4 <fault_isr+0x30>)
    90a8:	mov	r4, r5
    90aa:	ldr	r3, [r5, #0]
    90ac:	lsls	r0, r3, #13
    90ae:	bpl.n	90b4 <fault_isr+0x10>
    90b0:	bl	95a8 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    90b4:	ldr	r3, [r4, #0]
    90b6:	lsls	r1, r3, #21
    90b8:	bpl.n	90be <fault_isr+0x1a>
    90ba:	bl	90d8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    90be:	ldr	r3, [r4, #0]
    90c0:	lsls	r2, r3, #20
    90c2:	bpl.n	90c8 <fault_isr+0x24>
    90c4:	bl	90d8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    90c8:	ldr	r3, [r4, #0]
    90ca:	lsls	r3, r3, #19
    90cc:	bpl.n	90aa <fault_isr+0x6>
    90ce:	bl	90d8 <unused_isr>
    90d2:	b.n	90aa <fault_isr+0x6>
    90d4:	.word	0x40048034

000090d8 <unused_isr>:
	}
}

void unused_isr(void)
{
    90d8:	push	{r3, lr}
	fault_isr();
    90da:	bl	90a4 <fault_isr>
    90de:	Address 0x000090de is out of bounds.


000090e0 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    90e0:	ldr	r3, [pc, #4]	; (90e8 <startup_early_hook+0x8>)
    90e2:	movs	r2, #16
    90e4:	strh	r2, [r3, #0]
    90e6:	bx	lr
    90e8:	.word	0x40052000

000090ec <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    90ec:	bx	lr
    90ee:	Address 0x000090ee is out of bounds.


000090f0 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    90f0:	ldr	r1, [pc, #36]	; (9118 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    90f2:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    90f4:	ldr	r3, [r1, #0]
	if (incr != 0) {
    90f6:	cbz	r0, 9114 <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    90f8:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    90fa:	add	r0, r3
    90fc:	sub.w	r2, r2, #8192	; 0x2000
    9100:	cmp	r0, r2
    9102:	bcc.n	9112 <_sbrk+0x22>
			errno = ENOMEM;
    9104:	bl	b3f8 <__errno>
    9108:	movs	r3, #12
    910a:	str	r3, [r0, #0]
			return (void *)-1;
    910c:	mov.w	r0, #4294967295
    9110:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    9112:	str	r0, [r1, #0]
	}
	return prev;
    9114:	mov	r0, r3
}
    9116:	pop	{r3, pc}
    9118:	.word	0x20013d48

0000911c <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    911c:	b.n	911c <__cxa_pure_virtual>
    911e:	Address 0x0000911e is out of bounds.


00009120 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9120:	adds	r0, #16
    9122:	ldr	r3, [pc, #8]	; (912c <attachInterruptVector+0xc>)
    9124:	str.w	r1, [r3, r0, lsl #2]
    9128:	bx	lr
    912a:	nop
    912c:	.word	0x20013400

00009130 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    9130:	ldr	r3, [pc, #4]	; (9138 <rtc_get+0x8>)
    9132:	ldr	r0, [r3, #0]
}
    9134:	bx	lr
    9136:	nop
    9138:	.word	0x4003d000

0000913c <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    913c:	ldr	r3, [pc, #16]	; (9150 <rtc_set+0x14>)
	RTC_TPR = 0;
    913e:	ldr	r1, [pc, #20]	; (9154 <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9140:	movs	r2, #0
    9142:	str	r2, [r3, #0]
	RTC_TPR = 0;
    9144:	str	r2, [r1, #0]
	RTC_TSR = t;
    9146:	ldr	r2, [pc, #16]	; (9158 <rtc_set+0x1c>)
    9148:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    914a:	movs	r2, #16
    914c:	str	r2, [r3, #0]
    914e:	bx	lr
    9150:	.word	0x4003d014
    9154:	.word	0x4003d004
    9158:	.word	0x4003d000

0000915c <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    915c:	bx	lr
    915e:	Address 0x0000915e is out of bounds.


00009160 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    9160:	cmp	r0, #63	; 0x3f


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
    9162:	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
    9164:	bhi.n	9198 <digitalWrite+0x38>
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    9166:	ldr	r3, [pc, #52]	; (919c <digitalWrite+0x3c>)
    9168:	ldr.w	r2, [r3, r0, lsl #3]
    916c:	ldrb.w	r4, [r2, #640]	; 0x280
    9170:	cbz	r4, 9182 <digitalWrite+0x22>
    9172:	movs	r3, #1
		if (val) {
    9174:	cbz	r1, 917c <digitalWrite+0x1c>
			*portSetRegister(pin) = 1;
    9176:	strb.w	r3, [r2, #128]	; 0x80
    917a:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = 1;
    917c:	strb.w	r3, [r2, #256]	; 0x100
    9180:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    9182:	add.w	r3, r3, r0, lsl #3
    9186:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9188:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    918a:	cbz	r1, 9192 <digitalWrite+0x32>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    918c:	orr.w	r2, r2, #3
    9190:	b.n	9196 <digitalWrite+0x36>
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    9192:	bic.w	r2, r2, #2
    9196:	str	r2, [r3, #0]
    9198:	pop	{r4, pc}
    919a:	nop
    919c:	.word	0x00013164

000091a0 <digitalRead>:
#endif
}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    91a0:	cmp	r0, #63	; 0x3f
#ifdef KINETISK
	return *portInputRegister(pin);
    91a2:	itttt	ls
    91a4:	ldrls	r3, [pc, #16]	; (91b8 <digitalRead+0x18>)
    91a6:	ldrls.w	r3, [r3, r0, lsl #3]
    91aa:	ldrbls.w	r0, [r3, #512]	; 0x200
    91ae:	uxtbls	r0, r0
#endif
}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    91b0:	it	hi
    91b2:	movhi	r0, #0
#ifdef KINETISK
	return *portInputRegister(pin);
#else
	return (*portInputRegister(pin) & digitalPinToBitMask(pin)) ? 1 : 0;
#endif
}
    91b4:	bx	lr
    91b6:	nop
    91b8:	.word	0x00013164

000091bc <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    91bc:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    91be:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    91c0:	bhi.n	921a <pinMode+0x5e>
	config = portConfigRegister(pin);
    91c2:	ldr	r2, [pc, #88]	; (921c <pinMode+0x60>)
    91c4:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    91c8:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    91ca:	ldr	r3, [r3, #4]
    91cc:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    91ce:	beq.n	91d4 <pinMode+0x18>
    91d0:	cmp	r1, #4
    91d2:	bne.n	91f4 <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    91d4:	ldr.w	r2, [r4, r0, lsl #3]
    91d8:	movs	r0, #1
    91da:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    91de:	mov.w	r2, #324	; 0x144
    91e2:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    91e4:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    91e6:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    91e8:	ite	eq
    91ea:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    91ee:	bicne.w	r2, r2, #32
    91f2:	b.n	9218 <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    91f4:	ldr.w	r0, [r2, r0, lsl #3]
    91f8:	movs	r2, #0
    91fa:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    91fe:	cbnz	r1, 9206 <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    9200:	mov.w	r2, #256	; 0x100
    9204:	b.n	9218 <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    9206:	cmp	r1, #2
    9208:	bne.n	9210 <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    920a:	movw	r2, #259	; 0x103
    920e:	b.n	9218 <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    9210:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    9212:	it	eq
    9214:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    9218:	str	r2, [r3, #0]
    921a:	pop	{r4, pc}
    921c:	.word	0x00013164

00009220 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9220:	cpsid	i
	current = SYST_CVR;
    9222:	ldr	r3, [pc, #44]	; (9250 <micros+0x30>)
	count = systick_millis_count;
    9224:	ldr	r2, [pc, #44]	; (9254 <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9226:	ldr	r1, [pc, #48]	; (9258 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9228:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    922a:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    922c:	ldr	r1, [r1, #0]
	__enable_irq();
    922e:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9230:	lsls	r1, r1, #5
    9232:	bpl.n	923a <micros+0x1a>
    9234:	cmp	r3, #50	; 0x32
    9236:	it	hi
    9238:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    923a:	rsb	r3, r3, #95744	; 0x17600
    923e:	movs	r0, #96	; 0x60
    9240:	adds	r3, #255	; 0xff
    9242:	udiv	r3, r3, r0
}
    9246:	mov.w	r0, #1000	; 0x3e8
    924a:	mla	r0, r0, r2, r3
    924e:	bx	lr
    9250:	.word	0xe000e018
    9254:	.word	0x20019f04
    9258:	.word	0xe000ed04

0000925c <delay>:

void delay(uint32_t ms)
{
    925c:	push	{r3, r4, r5, lr}
    925e:	mov	r4, r0
	uint32_t start = micros();
    9260:	bl	9220 <micros>
    9264:	mov	r5, r0

	if (ms > 0) {
    9266:	cbnz	r4, 9272 <delay+0x16>
    9268:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    926a:	subs	r4, #1
    926c:	beq.n	9284 <delay+0x28>
				start += 1000;
    926e:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    9272:	bl	9220 <micros>
    9276:	subs	r0, r0, r5
    9278:	cmp.w	r0, #1000	; 0x3e8
    927c:	bcs.n	926a <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    927e:	bl	9c60 <yield>
		}
    9282:	b.n	9272 <delay+0x16>
    9284:	pop	{r3, r4, r5, pc}
    9286:	Address 0x00009286 is out of bounds.


00009288 <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9288:	ldr	r3, [pc, #224]	; (936c <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    928a:	ldr	r1, [pc, #228]	; (9370 <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    928c:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    9290:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9292:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    9294:	mov.w	r2, #268435456	; 0x10000000
    9298:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    929a:	mov.w	r2, #536870912	; 0x20000000
    929e:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    92a0:	mov.w	r2, #1073741824	; 0x40000000
    92a4:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    92a6:	mov.w	r2, #2147483648	; 0x80000000
    92aa:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    92ac:	ldr	r3, [pc, #196]	; (9374 <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    92ae:	ldr	r5, [pc, #200]	; (9378 <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    92b0:	ldr	r4, [pc, #200]	; (937c <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    92b2:	ldr	r6, [pc, #204]	; (9380 <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    92b4:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    92b6:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    92ba:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    92bc:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    92be:	movs	r3, #40	; 0x28
    92c0:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    92c2:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    92c4:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    92c6:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    92c8:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    92ca:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    92cc:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    92ce:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    92d0:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    92d2:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    92d6:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    92d8:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    92da:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    92dc:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    92de:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    92e0:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    92e2:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    92e4:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    92e6:	movs	r1, #9
    92e8:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    92ea:	add.w	r6, r6, #4096	; 0x1000
    92ee:	adds	r6, #4
    92f0:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    92f2:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    92f4:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    92f6:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    92f8:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    92fc:	add.w	r6, r6, #520192	; 0x7f000
    9300:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    9302:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    9304:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    9306:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9308:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    930c:	add.w	r6, r6, #4096	; 0x1000
    9310:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    9312:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9314:	ldr	r0, [pc, #108]	; (9384 <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    9316:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    9318:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    931a:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    931c:	sub.w	r0, r0, #460800	; 0x70800
    9320:	subw	r0, r0, #2004	; 0x7d4
    9324:	ldr	r1, [r0, #0]
    9326:	orr.w	r1, r1, #512	; 0x200
    932a:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    932c:	ldr.w	r1, [r0, #-40]
    9330:	orr.w	r1, r1, #33554432	; 0x2000000
    9334:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    9338:	ldr	r1, [pc, #76]	; (9388 <_init_Teensyduino_internal_+0x100>)
    933a:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    933c:	ldr	r2, [pc, #76]	; (938c <_init_Teensyduino_internal_+0x104>)
    933e:	movw	r1, #32767	; 0x7fff
    9342:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    9344:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    9346:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9348:	ldr	r3, [pc, #68]	; (9390 <_init_Teensyduino_internal_+0x108>)
    934a:	movs	r2, #8
    934c:	str	r2, [r3, #0]
#endif
	analog_init();
    934e:	bl	8fec <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    9352:	bl	915c <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    9356:	movs	r0, #20
    9358:	bl	925c <delay>
	usb_init();
    935c:	bl	9bcc <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9360:	mov.w	r0, #280	; 0x118
}
    9364:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9368:	b.w	925c <delay>
    936c:	.word	0xe000e104
    9370:	.word	0x4003800c
    9374:	.word	0x40038004
    9378:	.word	0x400b900c
    937c:	.word	0x400b9014
    9380:	.word	0x40038000
    9384:	.word	0x400b9000
    9388:	.word	0x400c9004
    938c:	.word	0x400c9008
    9390:	.word	0x400c9000

00009394 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    9394:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    9396:	cpsid	i
	avail = usb_buffer_available;
    9398:	ldr	r0, [pc, #44]	; (93c8 <usb_malloc+0x34>)
    939a:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    939c:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    93a0:	cmp	r1, #11
    93a2:	ble.n	93aa <usb_malloc+0x16>
		__enable_irq();
    93a4:	cpsie	i
		return NULL;
    93a6:	movs	r0, #0
    93a8:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    93aa:	mov.w	r3, #2147483648	; 0x80000000
    93ae:	lsrs	r3, r1
    93b0:	bic.w	r2, r2, r3
    93b4:	str	r2, [r0, #0]
	__enable_irq();
    93b6:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    93b8:	ldr	r4, [pc, #16]	; (93cc <usb_malloc+0x38>)
    93ba:	movs	r3, #72	; 0x48
    93bc:	muls	r3, r1
    93be:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    93c0:	movs	r2, #0
    93c2:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    93c4:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    93c6:	pop	{r4, pc}
    93c8:	.word	0x20013d4c
    93cc:	.word	0x200135d0

000093d0 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    93d0:	ldr	r3, [pc, #48]	; (9404 <usb_free+0x34>)
    93d2:	movs	r2, #72	; 0x48
    93d4:	subs	r3, r0, r3
    93d6:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    93da:	cmp	r3, #11
    93dc:	bhi.n	9402 <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    93de:	ldr	r2, [pc, #40]	; (9408 <usb_free+0x38>)
    93e0:	ldrb	r2, [r2, #0]
    93e2:	cbz	r2, 93ee <usb_free+0x1e>
    93e4:	ldr	r2, [pc, #36]	; (940c <usb_free+0x3c>)
    93e6:	ldrb	r2, [r2, #0]
    93e8:	cbz	r2, 93ee <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    93ea:	b.w	94b0 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    93ee:	cpsid	i
	usb_buffer_available |= mask;
    93f0:	ldr	r1, [pc, #28]	; (9410 <usb_free+0x40>)
    93f2:	mov.w	r2, #2147483648	; 0x80000000
    93f6:	lsr.w	r3, r2, r3
    93fa:	ldr	r2, [r1, #0]
    93fc:	orrs	r2, r3
    93fe:	str	r2, [r1, #0]
	__enable_irq();
    9400:	cpsie	i
    9402:	bx	lr
    9404:	.word	0x200135d0
    9408:	.word	0x20019fde
    940c:	.word	0x20019fe7
    9410:	.word	0x20013d4c

00009414 <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    9414:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9416:	ldr	r4, [pc, #48]	; (9448 <endpoint0_transmit+0x34>)
    9418:	ldr	r6, [pc, #48]	; (944c <endpoint0_transmit+0x38>)
    941a:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    941c:	ldr	r5, [pc, #48]	; (9450 <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    941e:	orr.w	r7, r3, #2
    9422:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9426:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    942a:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    942c:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    942e:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9430:	cmp	r2, #0
    9432:	ite	ne
    9434:	movne	r0, #200	; 0xc8
    9436:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    9438:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    943c:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    9440:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9442:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9446:	pop	{r4, r5, r6, r7, pc}
    9448:	.word	0x20019f70
    944c:	.word	0x1fff0000
    9450:	.word	0x20019fe8

00009454 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    9454:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9456:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    9458:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    945a:	bhi.n	947e <usb_rx+0x2a>
	__disable_irq();
    945c:	cpsid	i
	ret = rx_first[endpoint];
    945e:	ldr	r2, [pc, #36]	; (9484 <usb_rx+0x30>)
    9460:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    9464:	cbz	r0, 947a <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    9466:	ldr	r1, [r0, #4]
    9468:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    946c:	ldr	r1, [pc, #24]	; (9488 <usb_rx+0x34>)
    946e:	ldrh	r4, [r0, #0]
    9470:	ldrh.w	r2, [r1, r3, lsl #1]
    9474:	subs	r2, r2, r4
    9476:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    947a:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    947c:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    947e:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9480:	pop	{r4, pc}
    9482:	nop
    9484:	.word	0x20019f60
    9488:	.word	0x2001a0e4

0000948c <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    948c:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    948e:	cmp	r0, #3
    9490:	bhi.n	94a8 <usb_tx_packet_count+0x1c>
	__disable_irq();
    9492:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9494:	ldr	r3, [pc, #20]	; (94ac <usb_tx_packet_count+0x20>)
    9496:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    949a:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    949c:	cbz	r3, 94a4 <usb_tx_packet_count+0x18>
    949e:	adds	r0, #1
    94a0:	ldr	r3, [r3, #4]
    94a2:	b.n	949c <usb_tx_packet_count+0x10>
	__enable_irq();
    94a4:	cpsie	i
	return count;
    94a6:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    94a8:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    94aa:	bx	lr
    94ac:	.word	0x20019fb4

000094b0 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    94b0:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    94b2:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    94b4:	ldr	r5, [pc, #92]	; (9514 <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    94b6:	ldr	r4, [pc, #96]	; (9518 <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    94b8:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    94ba:	adds	r2, r3, r5
    94bc:	ldrb.w	r2, [r2, #-1]
    94c0:	lsls	r2, r2, #28
    94c2:	bpl.n	9500 <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    94c4:	lsls	r2, r3, #2
    94c6:	ldr	r1, [pc, #80]	; (9518 <usb_rx_memory+0x68>)
    94c8:	ldr.w	r6, [r4, r2, lsl #3]
    94cc:	cbnz	r6, 94da <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    94ce:	add.w	r3, r1, r3, lsl #5
    94d2:	adds	r0, #8
    94d4:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    94d6:	ldr	r3, [pc, #68]	; (951c <usb_rx_memory+0x6c>)
    94d8:	b.n	94ee <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    94da:	orr.w	r2, r2, #1
    94de:	ldr.w	r6, [r4, r2, lsl #3]
    94e2:	cbnz	r6, 9500 <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    94e4:	add.w	r3, r1, r2, lsl #3
    94e8:	adds	r0, #8
    94ea:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    94ec:	ldr	r3, [pc, #48]	; (9520 <usb_rx_memory+0x70>)
    94ee:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    94f2:	ldr	r2, [pc, #48]	; (9524 <usb_rx_memory+0x74>)
    94f4:	ldrb	r3, [r2, #0]
    94f6:	subs	r3, #1
    94f8:	strb	r3, [r2, #0]
				__enable_irq();
    94fa:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    94fc:	pop	{r4, r5, r6}
    94fe:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9500:	adds	r3, #1
    9502:	cmp	r3, #5
    9504:	bne.n	94ba <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    9506:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9508:	ldr	r3, [pc, #24]	; (9524 <usb_rx_memory+0x74>)
    950a:	movs	r2, #0
    950c:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    950e:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    9510:	b.w	93d0 <usb_free>
    9514:	.word	0x0001338e
    9518:	.word	0x1fff0000
    951c:	.word	0x00400088
    9520:	.word	0x004000c8
    9524:	.word	0x20019fde

00009528 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    9528:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    952a:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    952c:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    952e:	bhi.n	9596 <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9530:	ldr	r2, [pc, #100]	; (9598 <usb_tx+0x70>)
    9532:	lsls	r0, r0, #5
    9534:	orr.w	r0, r0, #16
    9538:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    953a:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    953c:	ldr	r2, [pc, #92]	; (959c <usb_tx+0x74>)
    953e:	ldrb	r4, [r2, r3]
    9540:	cmp	r4, #3
    9542:	bhi.n	955c <usb_tx+0x34>
    9544:	tbb	[pc, r4]
    9548:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    954c:	movs	r4, #5
    954e:	b.n	957a <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    9550:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    9552:	movs	r4, #2
		break;
    9554:	b.n	957a <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    9556:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9558:	movs	r4, #4
		break;
    955a:	b.n	957a <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    955c:	ldr	r0, [pc, #64]	; (95a0 <usb_tx+0x78>)
    955e:	ldr	r2, [pc, #68]	; (95a4 <usb_tx+0x7c>)
    9560:	ldr.w	r4, [r0, r3, lsl #2]
    9564:	cbnz	r4, 956c <usb_tx+0x44>
			tx_first[endpoint] = packet;
    9566:	str.w	r1, [r0, r3, lsl #2]
    956a:	b.n	9572 <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    956c:	ldr.w	r0, [r2, r3, lsl #2]
    9570:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    9572:	str.w	r1, [r2, r3, lsl #2]
    9576:	b.n	9594 <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9578:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    957a:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    957c:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9580:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9584:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9586:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9588:	ite	ne
    958a:	movne	r3, #200	; 0xc8
    958c:	moveq	r3, #136	; 0x88
    958e:	orr.w	r3, r3, r2, lsl #16
    9592:	str	r3, [r0, #0]
	__enable_irq();
    9594:	cpsie	i
    9596:	pop	{r4, pc}
    9598:	.word	0x1fff0000
    959c:	.word	0x20019f1c
    95a0:	.word	0x20019fb4
    95a4:	.word	0x20019fc4

000095a8 <usb_isr>:
}



void usb_isr(void)
{
    95a8:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    95ac:	ldr.w	r8, [pc, #680]	; 9858 <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    95b0:	ldr	r3, [pc, #676]	; (9858 <usb_isr+0x2b0>)
    95b2:	ldrb	r4, [r3, #0]
    95b4:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    95b6:	tst.w	r4, #4
    95ba:	mov	r5, r3
    95bc:	beq.n	95f4 <usb_isr+0x4c>
		if (usb_configuration) {
    95be:	ldr	r3, [pc, #668]	; (985c <usb_isr+0x2b4>)
    95c0:	ldrb	r3, [r3, #0]
    95c2:	cbz	r3, 95ee <usb_isr+0x46>
			t = usb_reboot_timer;
    95c4:	ldr	r2, [pc, #664]	; (9860 <usb_isr+0x2b8>)
    95c6:	ldrb	r1, [r2, #0]
			if (t) {
    95c8:	and.w	r3, r1, #255	; 0xff
    95cc:	cbz	r1, 95d8 <usb_isr+0x30>
				usb_reboot_timer = --t;
    95ce:	subs	r3, #1
    95d0:	uxtb	r3, r3
    95d2:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    95d4:	cbnz	r3, 95d8 <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    95d6:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    95d8:	ldr	r2, [pc, #648]	; (9864 <usb_isr+0x2bc>)
    95da:	ldrb	r1, [r2, #0]
			if (t) {
    95dc:	and.w	r3, r1, #255	; 0xff
    95e0:	cbz	r1, 95ee <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    95e2:	subs	r3, #1
    95e4:	uxtb	r3, r3
    95e6:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    95e8:	cbnz	r3, 95ee <usb_isr+0x46>
    95ea:	bl	8fa4 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    95ee:	movs	r3, #4
    95f0:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    95f4:	and.w	r3, r4, #8
    95f8:	and.w	r2, r3, #255	; 0xff
    95fc:	cmp	r3, #0
    95fe:	beq.w	9ae8 <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    9602:	ldr	r3, [pc, #612]	; (9868 <usb_isr+0x2c0>)
    9604:	ldr	r4, [pc, #612]	; (986c <usb_isr+0x2c4>)
    9606:	ldrb	r3, [r3, #0]
    9608:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    960a:	lsrs	r7, r3, #4
    960c:	mov.w	r6, r3, lsr #2
    9610:	bne.w	99f0 <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    9614:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9618:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    961c:	ubfx	r3, r3, #2, #4
    9620:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    9622:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9624:	cmp	r3, #12
    9626:	bhi.w	99e8 <usb_isr+0x440>
    962a:	tbh	[pc, r3, lsl #1]
    962e:	.short	0x019e
    9630:	.word	0x01dd019e
    9634:	.word	0x01dd01dd
    9638:	.word	0x01dd01dd
    963c:	.word	0x01bb01dd
    9640:	.word	0x01dd01dd
    9644:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9648:	ldr	r5, [pc, #548]	; (9870 <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    964a:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    964c:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    964e:	ldr	r0, [pc, #548]	; (9874 <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    9650:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9652:	ldr	r3, [pc, #548]	; (9878 <usb_isr+0x2d0>)
    9654:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9658:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    965a:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    965c:	ldr.w	sl, [pc, #584]	; 98a8 <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9660:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9662:	uxth	r1, r1
    9664:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9668:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    966a:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    966c:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    966e:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    9672:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9674:	bhi.n	96a6 <usb_isr+0xfe>
    9676:	cmp.w	r1, #1664	; 0x680
    967a:	bcs.w	98ce <usb_isr+0x326>
    967e:	cmp.w	r1, #258	; 0x102
    9682:	beq.w	9838 <usb_isr+0x290>
    9686:	bhi.n	9696 <usb_isr+0xee>
    9688:	cmp	r1, #128	; 0x80
    968a:	beq.w	9812 <usb_isr+0x26a>
    968e:	cmp	r1, #130	; 0x82
    9690:	beq.w	981a <usb_isr+0x272>
    9694:	b.n	9908 <usb_isr+0x360>
    9696:	movw	r3, #770	; 0x302
    969a:	cmp	r1, r3
    969c:	beq.w	98b0 <usb_isr+0x308>
    96a0:	cmp.w	r1, #1280	; 0x500
    96a4:	b.n	96de <usb_isr+0x136>
    96a6:	movw	r0, #8225	; 0x2021
    96aa:	cmp	r1, r0
    96ac:	beq.w	9964 <usb_isr+0x3bc>
    96b0:	bhi.n	96ce <usb_isr+0x126>
    96b2:	cmp.w	r1, #2176	; 0x880
    96b6:	beq.w	9808 <usb_isr+0x260>
    96ba:	cmp.w	r1, #2304	; 0x900
    96be:	bne.w	9908 <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    96c2:	ldr	r3, [pc, #408]	; (985c <usb_isr+0x2b4>)
    96c4:	ldrb	r2, [r5, #2]
    96c6:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    96c8:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    96ca:	ldr	r7, [pc, #416]	; (986c <usb_isr+0x2c4>)
    96cc:	b.n	96e4 <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    96ce:	movw	r3, #8737	; 0x2221
    96d2:	cmp	r1, r3
    96d4:	beq.w	98f4 <usb_isr+0x34c>
    96d8:	movw	r3, #8993	; 0x2321
    96dc:	cmp	r1, r3
    96de:	beq.w	9910 <usb_isr+0x368>
    96e2:	b.n	9908 <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    96e4:	ldr.w	r3, [r4, r6, lsl #3]
    96e8:	lsls	r3, r3, #24
    96ea:	bpl.n	96f8 <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    96ec:	add.w	r3, r7, r6, lsl #3
    96f0:	ldr	r0, [r3, #4]
    96f2:	subs	r0, #8
    96f4:	bl	93d0 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    96f8:	adds	r6, #1
    96fa:	cmp	r6, #20
    96fc:	bne.n	96e4 <usb_isr+0x13c>
    96fe:	ldr	r7, [pc, #380]	; (987c <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    9700:	ldr.w	fp, [pc, #380]	; 9880 <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9704:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    9706:	ldr.w	r0, [fp, r6, lsl #2]
    970a:	mov.w	r9, r6, lsl #2
			while (p) {
    970e:	cbz	r0, 971e <usb_isr+0x176>
				n = p->next;
    9710:	ldr	r2, [r0, #4]
    9712:	str	r2, [sp, #0]
				usb_free(p);
    9714:	bl	93d0 <usb_free>
				p = n;
    9718:	ldr	r2, [sp, #0]
    971a:	mov	r0, r2
    971c:	b.n	970e <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    971e:	ldr	r3, [pc, #352]	; (9880 <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    9720:	ldr	r2, [pc, #352]	; (9884 <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    9722:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    9726:	ldr	r3, [pc, #352]	; (9888 <usb_isr+0x2e0>)
    9728:	str.w	r0, [r9, r3]
			p = tx_first[i];
    972c:	ldr.w	r0, [r9, r2]
			while (p) {
    9730:	cbz	r0, 9744 <usb_isr+0x19c>
				n = p->next;
    9732:	ldr	r1, [r0, #4]
    9734:	str	r2, [sp, #4]
    9736:	str	r1, [sp, #0]
				usb_free(p);
    9738:	bl	93d0 <usb_free>
				p = n;
    973c:	ldr	r1, [sp, #0]
    973e:	ldr	r2, [sp, #4]
    9740:	mov	r0, r1
    9742:	b.n	9730 <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    9744:	ldr	r3, [pc, #324]	; (988c <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    9746:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    974a:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    974e:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9750:	ldr	r2, [pc, #316]	; (9890 <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9752:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9754:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9758:	cmp	r3, #3
    975a:	bhi.n	976c <usb_isr+0x1c4>
    975c:	tbb	[pc, r3]
    9760:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9764:	movs	r3, #0
    9766:	b.n	976a <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9768:	movs	r3, #1
    976a:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    976c:	adds	r6, #1
    976e:	cmp	r6, #4
    9770:	add.w	r7, r7, #1
    9774:	bne.n	9706 <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9776:	ldr	r1, [pc, #284]	; (9894 <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    9778:	ldr.w	r9, [pc, #304]	; 98ac <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    977c:	movs	r3, #0
    977e:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9780:	mov.w	fp, #1
    9784:	mov	r7, r1
    9786:	ldr	r3, [pc, #272]	; (9898 <usb_isr+0x2f0>)
			epconf = *cfg++;
    9788:	add.w	r0, fp, r9
    978c:	add	r3, fp
    978e:	ldrb.w	r0, [r0, #-1]
    9792:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9794:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9798:	strb	r0, [r3, #0]
    979a:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    979e:	beq.n	97e8 <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    97a0:	bl	9394 <usb_malloc>
				if (p) {
    97a4:	cbz	r0, 97b8 <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    97a6:	add.w	lr, r4, fp, lsl #5
    97aa:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    97ac:	ldr	r3, [pc, #236]	; (989c <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    97ae:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    97b2:	str.w	r3, [r4, r6, lsl #3]
    97b6:	b.n	97c2 <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    97b8:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    97bc:	ldrb	r0, [r7, #0]
    97be:	adds	r0, #1
    97c0:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    97c2:	bl	9394 <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    97c6:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    97ca:	cbz	r0, 97de <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    97cc:	add.w	ip, r4, lr, lsl #3
    97d0:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    97d2:	ldr	r3, [pc, #164]	; (9878 <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    97d4:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    97d8:	str.w	r3, [r4, lr, lsl #3]
    97dc:	b.n	97e8 <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    97de:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    97e2:	ldrb	r0, [r7, #0]
    97e4:	adds	r0, #1
    97e6:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    97e8:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    97ec:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    97f0:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    97f4:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    97f6:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    97fa:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    97fe:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9802:	bne.n	9786 <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9804:	mov	r3, r0
    9806:	b.n	991a <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9808:	ldr	r2, [pc, #80]	; (985c <usb_isr+0x2b4>)
    980a:	ldr	r6, [pc, #148]	; (98a0 <usb_isr+0x2f8>)
    980c:	ldrb	r2, [r2, #0]
    980e:	strb	r2, [r6, #0]
    9810:	b.n	991c <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    9812:	ldr	r6, [pc, #140]	; (98a0 <usb_isr+0x2f8>)
    9814:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9816:	strb	r2, [r6, #1]
    9818:	b.n	9914 <usb_isr+0x36c>
    981a:	ldrh	r1, [r5, #4]
    981c:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9820:	cmp	r1, #4
    9822:	bhi.n	9908 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9824:	ldr	r6, [pc, #120]	; (98a0 <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9826:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9828:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    982a:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    982c:	ldr	r2, [pc, #116]	; (98a4 <usb_isr+0x2fc>)
    982e:	ldrb	r2, [r2, r1]
    9830:	lsls	r4, r2, #30
    9832:	bpl.n	9914 <usb_isr+0x36c>
    9834:	strb	r3, [r6, #0]
    9836:	b.n	9914 <usb_isr+0x36c>
    9838:	ldrh	r2, [r5, #4]
    983a:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    983e:	cmp	r2, #4
    9840:	bhi.n	9908 <usb_isr+0x360>
    9842:	ldrh	r3, [r5, #2]
    9844:	cmp	r3, #0
    9846:	bne.n	9908 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    9848:	ldr	r1, [pc, #88]	; (98a4 <usb_isr+0x2fc>)
    984a:	lsls	r2, r2, #2
    984c:	add	r1, r2
    984e:	ldrb	r2, [r1, #0]
    9850:	bic.w	r2, r2, #2
    9854:	b.n	98ca <usb_isr+0x322>
    9856:	nop
    9858:	.word	0x40072080
    985c:	.word	0x20019fe7
    9860:	.word	0x20019f71
    9864:	.word	0x20019ef0
    9868:	.word	0x40072090
    986c:	.word	0x1fff0000
    9870:	.word	0x20019fd4
    9874:	.word	0x20019fe8
    9878:	.word	0x004000c8
    987c:	.word	0x20019f1c
    9880:	.word	0x20019f60
    9884:	.word	0x20019fb4
    9888:	.word	0x20019f0c
    988c:	.word	0x2001a0e4
    9890:	.word	0x20019fc4
    9894:	.word	0x20019fde
    9898:	.word	0x1001c830
    989c:	.word	0x00400088
    98a0:	.word	0x20019fdf
    98a4:	.word	0x400720c0
    98a8:	.word	0x20019f08
    98ac:	.word	0x0001338e
    98b0:	ldrh	r2, [r5, #4]
    98b2:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    98b6:	cmp	r2, #4
    98b8:	bhi.n	9908 <usb_isr+0x360>
    98ba:	ldrh	r3, [r5, #2]
    98bc:	cbnz	r3, 9908 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    98be:	ldr	r1, [pc, #620]	; (9b2c <usb_isr+0x584>)
    98c0:	lsls	r2, r2, #2
    98c2:	add	r1, r2
    98c4:	ldrb	r2, [r1, #0]
    98c6:	orr.w	r2, r2, #2
    98ca:	strb	r2, [r1, #0]
    98cc:	b.n	991a <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    98ce:	ldrh	r2, [r5, #2]
    98d0:	ldrh	r1, [r5, #4]
    98d2:	ldr	r3, [pc, #604]	; (9b30 <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    98d4:	ldr	r6, [r3, #4]
    98d6:	cbz	r6, 9908 <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    98d8:	ldrh	r0, [r3, #0]
    98da:	cmp	r0, r2
    98dc:	bne.n	98f0 <usb_isr+0x348>
    98de:	ldrh	r0, [r3, #2]
    98e0:	cmp	r0, r1
    98e2:	bne.n	98f0 <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    98e4:	lsrs	r2, r2, #8
    98e6:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    98e8:	ite	eq
    98ea:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    98ec:	ldrhne	r3, [r3, #8]
    98ee:	b.n	991c <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    98f0:	adds	r3, #12
    98f2:	b.n	98d4 <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    98f4:	ldrh	r3, [r5, #4]
    98f6:	cbnz	r3, 9918 <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    98f8:	ldr	r2, [pc, #568]	; (9b34 <usb_isr+0x58c>)
    98fa:	ldr	r1, [r2, #0]
    98fc:	ldr	r2, [pc, #568]	; (9b38 <usb_isr+0x590>)
    98fe:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    9900:	ldr	r2, [pc, #568]	; (9b3c <usb_isr+0x594>)
    9902:	ldrb	r1, [r5, #2]
    9904:	strb	r1, [r2, #0]
    9906:	b.n	991a <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9908:	ldr	r3, [pc, #544]	; (9b2c <usb_isr+0x584>)
    990a:	movs	r2, #15
    990c:	strb	r2, [r3, #0]
    990e:	b.n	9964 <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9910:	movs	r3, #0
    9912:	b.n	991a <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    9914:	movs	r3, #2
    9916:	b.n	991c <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9918:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    991a:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    991c:	ldrh	r4, [r5, #6]
    991e:	cmp	r4, r3
    9920:	it	cs
    9922:	movcs	r4, r3
    9924:	cmp	r4, #64	; 0x40
    9926:	mov	r5, r4
    9928:	it	cs
    992a:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    992c:	mov	r0, r6
    992e:	mov	r1, r5
    9930:	bl	9414 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9934:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9936:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9938:	bne.n	9942 <usb_isr+0x39a>
    993a:	cmp	r5, #64	; 0x40
    993c:	bne.n	9964 <usb_isr+0x3bc>
    993e:	mov	r5, r4
    9940:	b.n	994a <usb_isr+0x3a2>
    9942:	cmp	r4, #64	; 0x40
    9944:	mov	r5, r4
    9946:	it	cs
    9948:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    994a:	mov	r0, r6
    994c:	mov	r1, r5
    994e:	bl	9414 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9952:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9954:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9956:	bne.n	995c <usb_isr+0x3b4>
    9958:	cmp	r5, #64	; 0x40
    995a:	bne.n	9964 <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    995c:	ldr	r3, [pc, #480]	; (9b40 <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    995e:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    9962:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9964:	movs	r2, #1
    9966:	ldr	r3, [pc, #476]	; (9b44 <usb_isr+0x59c>)
    9968:	b.n	99e6 <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    996a:	ldr	r3, [pc, #476]	; (9b48 <usb_isr+0x5a0>)
    996c:	ldrh	r0, [r3, #0]
    996e:	movw	r1, #8225	; 0x2021
    9972:	cmp	r0, r1
    9974:	bne.n	999c <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    9976:	ldrh	r3, [r3, #4]
    9978:	cbnz	r3, 9994 <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    997a:	ldr	r1, [pc, #464]	; (9b4c <usb_isr+0x5a4>)
    997c:	ldrb	r0, [r2, r3]
    997e:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    9980:	adds	r3, #1
    9982:	cmp	r3, #7
    9984:	bne.n	997c <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    9986:	ldr	r3, [pc, #452]	; (9b4c <usb_isr+0x5a4>)
    9988:	ldr	r3, [r3, #0]
    998a:	cmp	r3, #134	; 0x86
    998c:	ittt	eq
    998e:	ldreq	r3, [pc, #448]	; (9b50 <usb_isr+0x5a8>)
    9990:	moveq	r2, #15
    9992:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    9994:	movs	r1, #0
    9996:	mov	r0, r1
    9998:	bl	9414 <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    999c:	ldr	r3, [pc, #436]	; (9b54 <usb_isr+0x5ac>)
    999e:	str.w	r3, [r4, r6, lsl #3]
    99a2:	b.n	99e8 <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    99a4:	ldr	r7, [pc, #432]	; (9b58 <usb_isr+0x5b0>)
    99a6:	ldr	r6, [r7, #0]
		if (data) {
    99a8:	cbz	r6, 99d4 <usb_isr+0x42c>
			size = ep0_tx_len;
    99aa:	ldr.w	sl, [pc, #404]	; 9b40 <usb_isr+0x598>
    99ae:	ldrh.w	r4, [sl]
    99b2:	cmp	r4, #64	; 0x40
    99b4:	mov	r5, r4
    99b6:	it	cs
    99b8:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    99ba:	mov	r0, r6
    99bc:	mov	r1, r5
    99be:	bl	9414 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    99c2:	subs	r0, r4, r5
    99c4:	uxth	r0, r0
    99c6:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    99ca:	cbnz	r0, 99d0 <usb_isr+0x428>
    99cc:	cmp	r5, #64	; 0x40
    99ce:	bne.n	99d2 <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    99d0:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    99d2:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    99d4:	ldr	r3, [pc, #368]	; (9b48 <usb_isr+0x5a0>)
    99d6:	ldrh	r2, [r3, #0]
    99d8:	cmp.w	r2, #1280	; 0x500
    99dc:	bne.n	99e8 <usb_isr+0x440>
			setup.bRequest = 0;
    99de:	movs	r2, #0
    99e0:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    99e2:	ldrb	r2, [r3, #2]
    99e4:	ldr	r3, [pc, #372]	; (9b5c <usb_isr+0x5b4>)
    99e6:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    99e8:	ldr	r3, [pc, #344]	; (9b44 <usb_isr+0x59c>)
    99ea:	movs	r2, #1
    99ec:	strb	r2, [r3, #0]
    99ee:	b.n	9ae0 <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    99f0:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    99f4:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    99f6:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    99f8:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    99fc:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9a00:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9a02:	and.w	lr, r3, #255	; 0xff
    9a06:	cmp	r3, #0
    9a08:	beq.n	9a78 <usb_isr+0x4d0>
				usb_free(packet);
    9a0a:	bl	93d0 <usb_free>
				packet = tx_first[endpoint];
    9a0e:	ldr	r0, [pc, #336]	; (9b60 <usb_isr+0x5b8>)
    9a10:	ldr	r3, [pc, #336]	; (9b64 <usb_isr+0x5bc>)
    9a12:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    9a16:	cbz	r1, 9a54 <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9a18:	ldr	r2, [r1, #4]
    9a1a:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    9a1e:	add.w	r2, r1, #8
    9a22:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    9a24:	ldrb	r2, [r3, r7]
    9a26:	cmp	r2, #3
    9a28:	bhi.n	9a42 <usb_isr+0x49a>
    9a2a:	tbb	[pc, r2]
    9a2e:	.short	0x0402
    9a30:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    9a32:	movs	r2, #3
    9a34:	b.n	9a40 <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    9a36:	movs	r2, #2
    9a38:	b.n	9a40 <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    9a3a:	movs	r2, #5
    9a3c:	b.n	9a40 <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9a3e:	movs	r2, #4
    9a40:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    9a42:	tst.w	r5, #8
    9a46:	ldrh	r2, [r1, #0]
    9a48:	ite	ne
    9a4a:	movne	r3, #200	; 0xc8
    9a4c:	moveq	r3, #136	; 0x88
    9a4e:	orr.w	r3, r3, r2, lsl #16
    9a52:	b.n	9adc <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    9a54:	ldrb	r2, [r3, r7]
    9a56:	cmp	r2, #3
    9a58:	bhi.n	9a6a <usb_isr+0x4c2>
    9a5a:	tbb	[pc, r2]
    9a5e:	.short	0x4141
    9a60:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9a62:	movs	r2, #0
    9a64:	b.n	9a74 <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9a66:	movs	r2, #1
    9a68:	b.n	9a74 <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    9a6a:	tst.w	r5, #8
    9a6e:	ite	ne
    9a70:	movne	r2, #3
    9a72:	moveq	r2, #2
    9a74:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    9a76:	b.n	9ae0 <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9a78:	ldr.w	r3, [r4, r6, lsl #3]
    9a7c:	lsrs	r3, r3, #16
    9a7e:	uxth	r1, r3
    9a80:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9a84:	cbz	r3, 9ad0 <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9a86:	ldr	r3, [pc, #224]	; (9b68 <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9a88:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9a8c:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9a90:	ldr.w	r2, [r3, r7, lsl #2]
    9a94:	ldr.w	lr, [pc, #252]	; 9b94 <usb_isr+0x5ec>
    9a98:	cbnz	r2, 9aa0 <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9a9a:	str.w	r0, [r3, r7, lsl #2]
    9a9e:	b.n	9aa6 <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9aa0:	ldr.w	r3, [lr, r7, lsl #2]
    9aa4:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9aa6:	ldr	r2, [pc, #196]	; (9b6c <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9aa8:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9aac:	ldrh.w	r3, [r2, r7, lsl #1]
    9ab0:	add	r3, r1
    9ab2:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9ab6:	bl	9394 <usb_malloc>
					if (packet) {
    9aba:	cbz	r0, 9ac2 <usb_isr+0x51a>
						b->addr = packet->buf;
    9abc:	adds	r0, #8
    9abe:	str	r0, [r5, #4]
    9ac0:	b.n	9ad0 <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    9ac2:	ldr	r2, [pc, #172]	; (9b70 <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    9ac4:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9ac8:	ldrb	r3, [r2, #0]
    9aca:	adds	r3, #1
    9acc:	strb	r3, [r2, #0]
    9ace:	b.n	9ae0 <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9ad0:	ldr	r2, [pc, #160]	; (9b74 <usb_isr+0x5cc>)
    9ad2:	ldr	r3, [pc, #128]	; (9b54 <usb_isr+0x5ac>)
    9ad4:	tst.w	r5, #8
    9ad8:	it	eq
    9ada:	moveq	r3, r2
    9adc:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9ae0:	movs	r3, #8
    9ae2:	strb.w	r3, [r8]
		goto restart;
    9ae6:	b.n	95b0 <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9ae8:	lsls	r0, r4, #31
    9aea:	bpl.n	9b98 <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9aec:	ldr	r1, [pc, #84]	; (9b44 <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9aee:	ldr	r0, [pc, #132]	; (9b74 <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9af0:	ldr	r4, [pc, #132]	; (9b78 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9af2:	movs	r3, #2
    9af4:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9af6:	ldr	r3, [pc, #132]	; (9b7c <usb_isr+0x5d4>)
    9af8:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9afa:	ldr	r3, [pc, #132]	; (9b80 <usb_isr+0x5d8>)
    9afc:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9afe:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    9b00:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    9b02:	ldr	r0, [pc, #128]	; (9b84 <usb_isr+0x5dc>)
    9b04:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    9b06:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9b08:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9b0a:	ldr	r3, [pc, #32]	; (9b2c <usb_isr+0x584>)
    9b0c:	movs	r0, #13
    9b0e:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    9b10:	ldr	r0, [pc, #116]	; (9b88 <usb_isr+0x5e0>)
    9b12:	movs	r3, #255	; 0xff
    9b14:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    9b16:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    9b18:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    9b1a:	ldr	r2, [pc, #112]	; (9b8c <usb_isr+0x5e4>)
    9b1c:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9b1e:	ldr	r3, [pc, #112]	; (9b90 <usb_isr+0x5e8>)
    9b20:	movs	r2, #159	; 0x9f
    9b22:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    9b24:	movs	r3, #1
    9b26:	strb	r3, [r1, #0]
		return;
    9b28:	b.n	9bbe <usb_isr+0x616>
    9b2a:	nop
    9b2c:	.word	0x400720c0
    9b30:	.word	0x00013394
    9b34:	.word	0x20019f04
    9b38:	.word	0x2001a0e0
    9b3c:	.word	0x20019f00
    9b40:	.word	0x20019fdc
    9b44:	.word	0x40072094
    9b48:	.word	0x20019fd4
    9b4c:	.word	0x2001a0d8
    9b50:	.word	0x20019f71
    9b54:	.word	0x004000c8
    9b58:	.word	0x20019f08
    9b5c:	.word	0x40072098
    9b60:	.word	0x20019fb4
    9b64:	.word	0x20019f1c
    9b68:	.word	0x20019f60
    9b6c:	.word	0x2001a0e4
    9b70:	.word	0x20019fde
    9b74:	.word	0x00400088
    9b78:	.word	0x20019f20
    9b7c:	.word	0x20019f70
    9b80:	.word	0x1fff0000
    9b84:	.word	0x20019f74
    9b88:	.word	0x40072088
    9b8c:	.word	0x4007208c
    9b90:	.word	0x40072084
    9b94:	.word	0x20019f0c
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9b98:	lsls	r1, r4, #24
    9b9a:	bpl.n	9ba6 <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9b9c:	ldr	r3, [pc, #36]	; (9bc4 <usb_isr+0x61c>)
    9b9e:	movs	r2, #13
    9ba0:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    9ba2:	movs	r3, #128	; 0x80
    9ba4:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    9ba6:	lsls	r2, r4, #30
    9ba8:	bpl.n	9bb6 <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9baa:	ldr	r2, [pc, #28]	; (9bc8 <usb_isr+0x620>)
    9bac:	ldrb	r3, [r2, #0]
    9bae:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9bb0:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    9bb2:	movs	r3, #2
    9bb4:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    9bb6:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9bb8:	itt	mi
    9bba:	movmi	r3, #16
    9bbc:	strbmi	r3, [r5, #0]
	}

}
    9bbe:	add	sp, #12
    9bc0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9bc4:	.word	0x400720c0
    9bc8:	.word	0x40072088

00009bcc <usb_init>:



void usb_init(void)
{
    9bcc:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    9bce:	bl	a368 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9bd2:	movs	r3, #0
		table[i].desc = 0;
    9bd4:	ldr	r0, [pc, #108]	; (9c44 <usb_init+0x78>)
    9bd6:	mov	r1, r3
    9bd8:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9bdc:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9be0:	adds	r3, #1
    9be2:	cmp	r3, #20
		table[i].desc = 0;
    9be4:	ldr	r2, [pc, #92]	; (9c44 <usb_init+0x78>)
		table[i].addr = 0;
    9be6:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9be8:	bne.n	9bd8 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9bea:	ldr	r1, [pc, #92]	; (9c48 <usb_init+0x7c>)
    9bec:	ldr	r3, [r1, #0]
    9bee:	orr.w	r3, r3, #262144	; 0x40000
    9bf2:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    9bf4:	ldr	r1, [pc, #84]	; (9c4c <usb_init+0x80>)
    9bf6:	ldr	r3, [r1, #0]
    9bf8:	orr.w	r3, r3, #50331648	; 0x3000000
    9bfc:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9bfe:	ldr	r3, [pc, #80]	; (9c50 <usb_init+0x84>)
    9c00:	ubfx	r1, r2, #8, #8
    9c04:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9c06:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9c0a:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9c0c:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9c0e:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    9c10:	ldr	r2, [pc, #64]	; (9c54 <usb_init+0x88>)
    9c12:	movs	r3, #255	; 0xff
    9c14:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    9c16:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    9c18:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    9c1a:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    9c1e:	movs	r3, #1
    9c20:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    9c22:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    9c26:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9c28:	ldr	r3, [pc, #44]	; (9c58 <usb_init+0x8c>)
    9c2a:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9c2c:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9c30:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9c32:	add	r3, r1
    9c34:	mov.w	r2, #2097152	; 0x200000
    9c38:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    9c3a:	ldr	r3, [pc, #32]	; (9c5c <usb_init+0x90>)
    9c3c:	movs	r2, #16
    9c3e:	strb	r2, [r3, #0]
    9c40:	pop	{r4, pc}
    9c42:	nop
    9c44:	.word	0x1fff0000
    9c48:	.word	0x40048034
    9c4c:	.word	0x4000d800
    9c50:	.word	0x4007209c
    9c54:	.word	0x40072080
    9c58:	.word	0xe000e435
    9c5c:	.word	0x40072108

00009c60 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    9c60:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    9c64:	ldr	r4, [pc, #176]	; (9d18 <yield+0xb8>)
    9c66:	ldrb	r3, [r4, #0]
    9c68:	cmp	r3, #0
    9c6a:	beq.n	9d12 <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    9c6c:	ldr	r5, [pc, #172]	; (9d1c <yield+0xbc>)
    9c6e:	ldrb	r2, [r5, #0]
    9c70:	cmp	r2, #0
    9c72:	bne.n	9d12 <yield+0xb2>
	running = 1;
    9c74:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9c76:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    9c78:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9c7a:	bpl.n	9c94 <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9c7c:	bl	8dbc <usb_serial_available>
		if (Serial.available()) serialEvent();
    9c80:	cbz	r0, 9c86 <yield+0x26>
    9c82:	bl	a35c <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    9c86:	ldr	r3, [pc, #152]	; (9d20 <yield+0xc0>)
    9c88:	ldrb	r3, [r3, #0]
    9c8a:	cbz	r3, 9c94 <yield+0x34>
    9c8c:	ldrb	r3, [r4, #0]
    9c8e:	bic.w	r3, r3, #1
    9c92:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    9c94:	ldrb	r3, [r4, #0]
    9c96:	lsls	r2, r3, #30
    9c98:	bpl.n	9cc4 <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9c9a:	ldr.w	r8, [pc, #148]	; 9d30 <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    9c9e:	ldr.w	r9, [pc, #148]	; 9d34 <yield+0xd4>
    9ca2:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9ca4:	ldrb.w	r2, [r8]
    9ca8:	uxtb	r3, r6
    9caa:	cmp	r2, r3
    9cac:	bls.n	9cc4 <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    9cae:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    9cb2:	ldr	r3, [r7, #0]
    9cb4:	mov	r0, r7
    9cb6:	ldr	r3, [r3, #16]
    9cb8:	blx	r3
    9cba:	cbz	r0, 9cc0 <yield+0x60>
    9cbc:	ldr	r3, [r7, #16]
    9cbe:	blx	r3
    9cc0:	adds	r6, #1
    9cc2:	b.n	9ca4 <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    9cc4:	movs	r3, #0
    9cc6:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9cc8:	ldrb	r3, [r4, #0]
    9cca:	lsls	r3, r3, #29
    9ccc:	bpl.n	9d12 <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    9cce:	ldr	r1, [pc, #84]	; (9d24 <yield+0xc4>)
    9cd0:	ldr	r3, [r1, #0]
    9cd2:	cbz	r3, 9d12 <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9cd4:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9cd8:	cbnz	r3, 9d12 <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9cda:	mrs	r2, PRIMASK
		__disable_irq();
    9cde:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9ce0:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    9ce2:	cbz	r0, 9cea <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    9ce4:	ldr	r4, [pc, #64]	; (9d28 <yield+0xc8>)
    9ce6:	ldrb	r5, [r4, #0]
    9ce8:	cbz	r5, 9cf2 <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9cea:	cbnz	r2, 9d12 <yield+0xb2>
    9cec:	cpsie	i
    9cee:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    9cf2:	movs	r3, #1
    9cf4:	strb	r3, [r4, #0]
		firstYield = first->_next;
    9cf6:	ldr	r3, [r0, #20]
    9cf8:	str	r3, [r1, #0]
		if (firstYield) {
    9cfa:	cbz	r3, 9d00 <yield+0xa0>
			firstYield->_prev = nullptr;
    9cfc:	str	r5, [r3, #24]
    9cfe:	b.n	9d04 <yield+0xa4>
		} else {
			lastYield = nullptr;
    9d00:	ldr	r1, [pc, #40]	; (9d2c <yield+0xcc>)
    9d02:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9d04:	cbnz	r2, 9d08 <yield+0xa8>
    9d06:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9d08:	movs	r5, #0
    9d0a:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    9d0c:	ldr	r3, [r0, #8]
    9d0e:	blx	r3
		runningFromYield = false;
    9d10:	strb	r5, [r4, #0]
    9d12:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9d16:	nop
    9d18:	.word	0x20013d50
    9d1c:	.word	0x20019fe9
    9d20:	.word	0x20013d64
    9d24:	.word	0x20019ff8
    9d28:	.word	0x20019ffc
    9d2c:	.word	0x20019ff4
    9d30:	.word	0x2001a0a0
    9d34:	.word	0x2001a088

00009d38 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    9d38:	push	{r4, r5, lr}
	uint32_t ch = 0;

	__disable_irq();
    9d3a:	cpsid	i
    9d3c:	ldr	r4, [pc, #148]	; (9dd4 <DMAChannel::begin(bool)+0x9c>)
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    9d3e:	cbnz	r1, 9d64 <DMAChannel::begin(bool)+0x2c>
    9d40:	ldr	r1, [r0, #0]
    9d42:	cbz	r1, 9d64 <DMAChannel::begin(bool)+0x2c>
    9d44:	ldrb	r3, [r0, #4]
    9d46:	cmp	r3, #15
    9d48:	bhi.n	9d64 <DMAChannel::begin(bool)+0x2c>
	  && (dma_channel_allocated_mask & (1 << channel))
    9d4a:	ldrh	r2, [r4, #0]
    9d4c:	asrs	r2, r3
    9d4e:	lsls	r2, r2, #31
    9d50:	bpl.n	9d64 <DMAChannel::begin(bool)+0x2c>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    9d52:	add.w	r3, r3, #33554432	; 0x2000000
    9d56:	add.w	r3, r3, #1152	; 0x480
    9d5a:	cmp.w	r1, r3, lsl #5
    9d5e:	bne.n	9d64 <DMAChannel::begin(bool)+0x2c>
		// DMA channel already allocated
		__enable_irq();
    9d60:	cpsie	i
		return;
    9d62:	pop	{r4, r5, pc}
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    9d64:	ldrh	r1, [r4, #0]
    9d66:	movs	r3, #0
    9d68:	asr.w	r2, r1, r3
    9d6c:	ands.w	r2, r2, #1
    9d70:	bne.n	9dc4 <DMAChannel::begin(bool)+0x8c>
			dma_channel_allocated_mask |= (1 << ch);
    9d72:	movs	r5, #1
    9d74:	lsls	r5, r3
    9d76:	orrs	r1, r5
    9d78:	strh	r1, [r4, #0]
			__enable_irq();
    9d7a:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    9d7c:	ldr	r5, [pc, #88]	; (9dd8 <DMAChannel::begin(bool)+0xa0>)
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    9d7e:	uxtb	r1, r3
    9d80:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    9d82:	ldr	r4, [r5, #0]
    9d84:	orr.w	r4, r4, #2
    9d88:	str	r4, [r5, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    9d8a:	ldr.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9d8e:	add.w	r3, r3, #33554432	; 0x2000000
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    9d92:	orr.w	r4, r4, #2
    9d96:	str.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9d9a:	add.w	r3, r3, #1152	; 0x480
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    9d9e:	ldr	r4, [pc, #60]	; (9ddc <DMAChannel::begin(bool)+0xa4>)
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9da0:	lsls	r3, r3, #5
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    9da2:	movw	r5, #1154	; 0x482
    9da6:	str	r5, [r4, #0]
#endif
	DMA_CERQ = ch;
    9da8:	strb	r1, [r4, #26]
	DMA_CERR = ch;
    9daa:	strb	r1, [r4, #30]
	DMA_CEEI = ch;
    9dac:	strb	r1, [r4, #24]
	DMA_CINT = ch;
    9dae:	strb	r1, [r4, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9db0:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    9db2:	str	r2, [r3, #0]
	*p++ = 0;
    9db4:	str	r2, [r3, #4]
	*p++ = 0;
    9db6:	str	r2, [r3, #8]
	*p++ = 0;
    9db8:	str	r2, [r3, #12]
	*p++ = 0;
    9dba:	str	r2, [r3, #16]
	*p++ = 0;
    9dbc:	str	r2, [r3, #20]
	*p++ = 0;
    9dbe:	str	r2, [r3, #24]
	*p++ = 0;
    9dc0:	str	r2, [r3, #28]
    9dc2:	pop	{r4, r5, pc}
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    9dc4:	adds	r3, #1
    9dc6:	cmp	r3, #16
    9dc8:	bne.n	9d68 <DMAChannel::begin(bool)+0x30>
			__enable_irq();
    9dca:	cpsie	i
			TCD = (TCD_t *)0;
    9dcc:	movs	r2, #0
    9dce:	str	r2, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    9dd0:	strb	r3, [r0, #4]
    9dd2:	pop	{r4, r5, pc}
    9dd4:	.word	0x20019fea
    9dd8:	.word	0x40048040
    9ddc:	.word	0x40008000

00009de0 <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    9de0:	ldrb	r3, [r0, #4]
    9de2:	cmp	r3, #15
    9de4:	bhi.n	9e08 <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    9de6:	ldr	r2, [pc, #36]	; (9e0c <DMAChannel::release()+0x2c>)
    9de8:	strb	r3, [r2, #0]
	__disable_irq();
    9dea:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    9dec:	ldr	r1, [pc, #32]	; (9e10 <DMAChannel::release()+0x30>)
    9dee:	ldrb	r2, [r0, #4]
    9df0:	movs	r3, #1
    9df2:	lsl.w	r2, r3, r2
    9df6:	ldrh	r3, [r1, #0]
    9df8:	bic.w	r3, r3, r2
    9dfc:	strh	r3, [r1, #0]
	__enable_irq();
    9dfe:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    9e00:	movs	r3, #16
    9e02:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    9e04:	movs	r3, #0
    9e06:	str	r3, [r0, #0]
    9e08:	bx	lr
    9e0a:	nop
    9e0c:	.word	0x4000801a
    9e10:	.word	0x20019fea

00009e14 <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9e14:	mrs	r0, PRIMASK
		__disable_irq();
    9e18:	cpsid	i
		return (primask == 0) ? true : false;
	}
    9e1a:	clz	r0, r0
    9e1e:	lsrs	r0, r0, #5
    9e20:	bx	lr

00009e22 <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    9e22:	cbz	r0, 9e26 <MillisTimer::enableTimerInterrupt(bool)+0x4>
    9e24:	cpsie	i
    9e26:	bx	lr

00009e28 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    9e28:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    9e2a:	ldr	r6, [pc, #48]	; (9e5c <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    9e2c:	ldr	r7, [pc, #48]	; (9e60 <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    9e2e:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    9e30:	bl	9e14 <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    9e34:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    9e36:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    9e38:	cbz	r4, 9e56 <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    9e3a:	ldr	r3, [r4, #20]
    9e3c:	str	r3, [r6, #0]
			if (firstInterrupt) {
    9e3e:	cbz	r3, 9e44 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    9e40:	str	r5, [r3, #24]
    9e42:	b.n	9e46 <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    9e44:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    9e46:	mov	r0, r2
    9e48:	bl	9e22 <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    9e4c:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    9e4e:	ldr	r3, [r4, #8]
    9e50:	mov	r0, r4
    9e52:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    9e54:	b.n	9e30 <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    9e56:	bl	9e22 <MillisTimer::enableTimerInterrupt(bool)>
    9e5a:	pop	{r3, r4, r5, r6, r7, pc}
    9e5c:	.word	0x20019fec
    9e60:	.word	0x20019ff0

00009e64 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    9e64:	b.w	9e28 <EventResponder::runFromInterrupt()>

00009e68 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    9e68:	ldr	r2, [pc, #8]	; (9e74 <systick_isr+0xc>)
    9e6a:	ldr	r3, [r2, #0]
    9e6c:	adds	r3, #1
    9e6e:	str	r3, [r2, #0]
    9e70:	bx	lr
    9e72:	nop
    9e74:	.word	0x20019f04

00009e78 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    9e78:	b.w	8dd8 <usb_serial_flush_input>

00009e7c <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    9e7c:	b.w	8d84 <usb_serial_peekchar>

00009e80 <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    9e80:	b.w	8d38 <usb_serial_getchar>

00009e84 <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9e84:	b.w	8dbc <usb_serial_available>

00009e88 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    9e88:	b.w	8f48 <usb_serial_flush_output>

00009e8c <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    9e8c:	b.w	8f00 <usb_serial_write_buffer_free>

00009e90 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    9e90:	mov	r0, r1
    9e92:	mov	r1, r2
    9e94:	b.w	8e08 <usb_serial_write>

00009e98 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    9e98:	mov	r0, r1
    9e9a:	b.w	8ee8 <usb_serial_putchar>

00009e9e <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    9e9e:	push	{r3, r4, r5, r6, r7, lr}
    9ea0:	mov	r7, r0
	if (buffer == nullptr) return 0;
    9ea2:	mov	r5, r1
    9ea4:	cbz	r1, 9ebe <Print::write(unsigned char const*, unsigned int)+0x20>
    9ea6:	adds	r6, r1, r2
    9ea8:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    9eaa:	cmp	r5, r6
    9eac:	beq.n	9ec2 <Print::write(unsigned char const*, unsigned int)+0x24>
    9eae:	ldr	r3, [r7, #0]
    9eb0:	ldrb.w	r1, [r5], #1
    9eb4:	ldr	r3, [r3, #0]
    9eb6:	mov	r0, r7
    9eb8:	blx	r3
    9eba:	add	r4, r0
    9ebc:	b.n	9eaa <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    9ebe:	mov	r0, r1
    9ec0:	pop	{r3, r4, r5, r6, r7, pc}
    9ec2:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    9ec4:	pop	{r3, r4, r5, r6, r7, pc}
    9ec6:	Address 0x00009ec6 is out of bounds.


00009ec8 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    9ec8:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    9eca:	ldr	r3, [pc, #24]	; (9ee4 <Print::println()+0x1c>)
    9ecc:	ldrh	r3, [r3, #0]
    9ece:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    9ed2:	ldr	r3, [r0, #0]
    9ed4:	movs	r2, #2
    9ed6:	ldr	r3, [r3, #4]
    9ed8:	add	r1, sp, #4
    9eda:	blx	r3
}
    9edc:	add	sp, #12
    9ede:	ldr.w	pc, [sp], #4
    9ee2:	nop
    9ee4:	.word	0x0001338c

00009ee8 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    9ee8:	push	{r4, lr}
	((class Print *)file)->write((uint8_t *)ptr, len);
    9eea:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    9eec:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    9eee:	ldr	r3, [r3, #4]
    9ef0:	blx	r3
	return len;
}
    9ef2:	mov	r0, r4
    9ef4:	pop	{r4, pc}

00009ef6 <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    9ef6:	push	{r1, r2, r3}
    9ef8:	push	{r0, r1, lr}
    9efa:	add	r2, sp, #12
    9efc:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    9f00:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    9f02:	bl	fa48 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    9f06:	add	sp, #8
    9f08:	ldr.w	lr, [sp], #4
    9f0c:	add	sp, #12
    9f0e:	bx	lr

00009f10 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    9f10:	push	{r4, r5, r6, lr}
    9f12:	mov	r5, r0
    9f14:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    9f16:	cbnz	r2, 9f22 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    9f18:	ldr	r3, [r0, #0]
    9f1a:	uxtb	r1, r1
    9f1c:	ldr	r3, [r3, #0]
    9f1e:	blx	r3
    9f20:	b.n	9f82 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    9f22:	cmp	r2, #1
    9f24:	it	eq
    9f26:	moveq	r2, #10
	}


	if (n == 0) {
    9f28:	cbz	r1, 9f2e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    9f2a:	movs	r0, #33	; 0x21
    9f2c:	b.n	9f38 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    9f2e:	movs	r2, #48	; 0x30
    9f30:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    9f34:	movs	r0, #33	; 0x21
    9f36:	b.n	9f62 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9f38:	udiv	r6, r1, r2
    9f3c:	mls	r1, r2, r6, r1
    9f40:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9f42:	cmp	r1, #9
    9f44:	ite	ls
    9f46:	addls.w	r1, r4, #48	; 0x30
    9f4a:	addhi.w	r1, r4, #55	; 0x37
    9f4e:	add	r4, sp, #40	; 0x28
    9f50:	add	r4, r0
    9f52:	uxtb	r1, r1
    9f54:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    9f58:	mov	r1, r6
    9f5a:	cbz	r6, 9f62 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    9f5c:	subs	r0, #1
    9f5e:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    9f60:	b.n	9f38 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    9f62:	cbz	r3, 9f72 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    9f64:	subs	r0, #1
    9f66:	uxtb	r0, r0
		buf[i] = '-';
    9f68:	add	r3, sp, #40	; 0x28
    9f6a:	add	r3, r0
    9f6c:	movs	r2, #45	; 0x2d
    9f6e:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    9f72:	ldr	r3, [r5, #0]
    9f74:	add	r1, sp, #4
    9f76:	rsb	r2, r0, #34	; 0x22
    9f7a:	add	r1, r0
    9f7c:	ldr	r3, [r3, #4]
    9f7e:	mov	r0, r5
    9f80:	blx	r3
}
    9f82:	add	sp, #40	; 0x28
    9f84:	pop	{r4, r5, r6, pc}

00009f86 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    9f86:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    9f88:	bl	17f0 <setup>
	while (1) {
		loop();
    9f8c:	bl	1b0c <loop>
		yield();
    9f90:	bl	9c60 <yield>
    9f94:	b.n	9f8c <main+0x6>
    9f96:	Address 0x00009f96 is out of bounds.


00009f98 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>:


// Set up the pool of audio data blocks
// placing them all onto the free list
void AudioStream::initialize_memory(audio_block_t *data, unsigned int num)
{
    9f98:	cmp.w	r1, #896	; 0x380
    9f9c:	push	{r4, r5, r6, r7, lr}
    9f9e:	it	cs
    9fa0:	movcs.w	r1, #896	; 0x380
	unsigned int maxnum = MAX_AUDIO_MEMORY / AUDIO_BLOCK_SAMPLES / 2;

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
    9fa4:	cpsid	i
	memory_pool = data;
    9fa6:	ldr	r3, [pc, #84]	; (9ffc <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x64>)
	memory_pool_first_mask = 0;
    9fa8:	ldr	r2, [pc, #84]	; (a000 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x68>)

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
    9faa:	str	r0, [r3, #0]
	memory_pool_first_mask = 0;
    9fac:	movs	r3, #0
    9fae:	strh	r3, [r2, #0]
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
    9fb0:	ldr	r2, [pc, #80]	; (a004 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x6c>)
    9fb2:	mov	r4, r3
    9fb4:	str.w	r4, [r2, r3, lsl #2]
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
    9fb8:	adds	r3, #1
    9fba:	cmp	r3, #28
    9fbc:	ldr	r5, [pc, #68]	; (a004 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x6c>)
    9fbe:	bne.n	9fb4 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x1c>
    9fc0:	movs	r3, #0
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    9fc2:	movs	r7, #1
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    9fc4:	cmp	r3, r1
    9fc6:	bne.n	9fd0 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x38>
    9fc8:	movs	r3, #0
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
		data[i].memory_pool_index = i;
    9fca:	mov.w	r4, #260	; 0x104
    9fce:	b.n	9fe8 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x50>
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    9fd0:	lsrs	r6, r3, #5
    9fd2:	and.w	r2, r3, #31
    9fd6:	lsl.w	r4, r7, r2
    9fda:	ldr.w	r2, [r5, r6, lsl #2]
    9fde:	orrs	r2, r4
    9fe0:	str.w	r2, [r5, r6, lsl #2]
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    9fe4:	adds	r3, #1
    9fe6:	b.n	9fc4 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x2c>
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
    9fe8:	cmp	r3, r1
    9fea:	beq.n	9ff6 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x5e>
		data[i].memory_pool_index = i;
    9fec:	mla	r2, r4, r3, r0
    9ff0:	strh	r3, [r2, #2]
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
    9ff2:	adds	r3, #1
    9ff4:	b.n	9fe8 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x50>
		data[i].memory_pool_index = i;
	}
	__enable_irq();
    9ff6:	cpsie	i
    9ff8:	pop	{r4, r5, r6, r7, pc}
    9ffa:	nop
    9ffc:	.word	0x2001a008
    a000:	.word	0x2001a082
    a004:	.word	0x2001a010

0000a008 <AudioStream::allocate()>:
}

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_t * AudioStream::allocate(void)
{
    a008:	push	{r4, r5, r6, lr}
	audio_block_t *block;
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
    a00a:	cpsid	i
	index = memory_pool_first_mask;
    a00c:	ldr	r1, [pc, #112]	; (a080 <AudioStream::allocate()+0x78>)
    a00e:	ldr	r0, [pc, #116]	; (a084 <AudioStream::allocate()+0x7c>)
    a010:	ldrh	r2, [r1, #0]
    a012:	mov	r4, r1
    a014:	add.w	r3, r0, r2, lsl #2
	p += index;
	while (1) {
		if (p >= end) {
    a018:	add.w	r6, r0, #112	; 0x70
    a01c:	cmp	r3, r6
    a01e:	bcc.n	a026 <AudioStream::allocate()+0x1e>
			__enable_irq();
    a020:	cpsie	i
			//Serial.println("alloc:null");
			return NULL;
    a022:	movs	r0, #0
    a024:	pop	{r4, r5, r6, pc}
		}
		avail = *p;
    a026:	mov	r5, r3
    a028:	ldr.w	r1, [r5], #4
		if (avail) break;
    a02c:	cbnz	r1, a034 <AudioStream::allocate()+0x2c>
		index++;
    a02e:	adds	r2, #1
	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
    a030:	mov	r3, r5
    a032:	b.n	a01c <AudioStream::allocate()+0x14>
		avail = *p;
		if (avail) break;
		index++;
		p++;
	}
	n = __builtin_clz(avail);
    a034:	clz	r6, r1
	avail &= ~(0x80000000 >> n);
    a038:	mov.w	r5, #2147483648	; 0x80000000
    a03c:	lsrs	r5, r6
    a03e:	bic.w	r1, r1, r5
	*p = avail;
    a042:	str	r1, [r3, #0]
	if (!avail) index++;
    a044:	cbnz	r1, a048 <AudioStream::allocate()+0x40>
    a046:	adds	r2, #1
	memory_pool_first_mask = index;
    a048:	strh	r2, [r4, #0]
	used = memory_used + 1;
    a04a:	ldr	r2, [pc, #60]	; (a088 <AudioStream::allocate()+0x80>)
    a04c:	ldrh	r1, [r2, #0]
    a04e:	adds	r1, #1
	memory_used = used;
    a050:	uxth	r4, r1
    a052:	strh	r4, [r2, #0]
	__enable_irq();
    a054:	cpsie	i
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    a056:	subs	r3, r3, r0
    a058:	asrs	r3, r3, #2
    a05a:	rsb	r3, r6, r3, lsl #5
    a05e:	mov.w	r2, #260	; 0x104
    a062:	muls	r3, r2
    a064:	ldr	r2, [pc, #36]	; (a08c <AudioStream::allocate()+0x84>)
    a066:	add.w	r3, r3, #8032	; 0x1f60
    a06a:	ldr	r2, [r2, #0]
    a06c:	adds	r3, #28
	block->ref_count = 1;
    a06e:	movs	r5, #1
    a070:	strb	r5, [r2, r3]
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    a072:	adds	r0, r2, r3
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
    a074:	ldr	r3, [pc, #24]	; (a090 <AudioStream::allocate()+0x88>)
    a076:	ldrh	r2, [r3, #0]
    a078:	cmp	r1, r2
    a07a:	it	hi
    a07c:	strhhi	r4, [r3, #0]
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    a07e:	pop	{r4, r5, r6, pc}
    a080:	.word	0x2001a082
    a084:	.word	0x2001a010
    a088:	.word	0x2001a084
    a08c:	.word	0x2001a008
    a090:	.word	0x2001a004

0000a094 <AudioStream::release(audio_block_struct*)>:
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
    a094:	ldrh	r3, [r0, #2]
	uint32_t index = block->memory_pool_index >> 5;

	__disable_irq();
    a096:	cpsid	i
	if (block->ref_count > 1) {
    a098:	ldrb	r2, [r0, #0]
    a09a:	cmp	r2, #1
    a09c:	bls.n	a0a4 <AudioStream::release(audio_block_struct*)+0x10>
		block->ref_count--;
    a09e:	subs	r2, #1
    a0a0:	strb	r2, [r0, #0]
    a0a2:	b.n	a0d2 <AudioStream::release(audio_block_struct*)+0x3e>
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
	uint32_t index = block->memory_pool_index >> 5;
    a0a4:	asrs	r2, r3, #5
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    a0a6:	ldr	r0, [pc, #48]	; (a0d8 <AudioStream::release(audio_block_struct*)+0x44>)
    a0a8:	mvns	r3, r3
    a0aa:	mov.w	r1, #2147483648	; 0x80000000
    a0ae:	and.w	r3, r3, #31
    a0b2:	lsr.w	r3, r1, r3
    a0b6:	ldr.w	r1, [r0, r2, lsl #2]
    a0ba:	orrs	r1, r3
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    a0bc:	ldr	r3, [pc, #28]	; (a0dc <AudioStream::release(audio_block_struct*)+0x48>)
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    a0be:	str.w	r1, [r0, r2, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    a0c2:	ldrh	r1, [r3, #0]
    a0c4:	cmp	r2, r1
    a0c6:	it	cc
    a0c8:	strhcc	r2, [r3, #0]
		memory_used--;
    a0ca:	ldr	r2, [pc, #20]	; (a0e0 <AudioStream::release(audio_block_struct*)+0x4c>)
    a0cc:	ldrh	r3, [r2, #0]
    a0ce:	subs	r3, #1
    a0d0:	strh	r3, [r2, #0]
	}
	__enable_irq();
    a0d2:	cpsie	i
    a0d4:	bx	lr
    a0d6:	nop
    a0d8:	.word	0x2001a010
    a0dc:	.word	0x2001a082
    a0e0:	.word	0x2001a084

0000a0e4 <AudioStream::transmit(audio_block_struct*, unsigned char)>:
// owned by this object.  Normally, a block must be released
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
    a0e4:	push	{r4, r5, lr}
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    a0e6:	ldr	r3, [r0, #12]
    a0e8:	cbz	r3, a10a <AudioStream::transmit(audio_block_struct*, unsigned char)+0x26>
		if (c->src_index == index) {
    a0ea:	ldrb	r0, [r3, #8]
    a0ec:	cmp	r0, r2
    a0ee:	bne.n	a106 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x22>
			if (c->dst.inputQueue[c->dest_index] == NULL) {
    a0f0:	ldr	r0, [r3, #4]
    a0f2:	ldrb	r4, [r3, #9]
    a0f4:	ldr	r0, [r0, #16]
    a0f6:	ldr.w	r5, [r0, r4, lsl #2]
    a0fa:	cbnz	r5, a106 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x22>
				c->dst.inputQueue[c->dest_index] = block;
    a0fc:	str.w	r1, [r0, r4, lsl #2]
				block->ref_count++;
    a100:	ldrb	r0, [r1, #0]
    a102:	adds	r0, #1
    a104:	strb	r0, [r1, #0]
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    a106:	ldr	r3, [r3, #12]
    a108:	b.n	a0e8 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x4>
    a10a:	pop	{r4, r5, pc}

0000a10c <AudioStream::receiveReadOnly(unsigned int)>:
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
    a10c:	ldrb	r3, [r0, #9]
    a10e:	cmp	r3, r1
	in = inputQueue[index];
    a110:	it	hi
    a112:	ldrhi	r2, [r0, #16]
    a114:	mov.w	r3, #0
    a118:	itte	hi
    a11a:	ldrhi.w	r0, [r2, r1, lsl #2]
	inputQueue[index] = NULL;
    a11e:	strhi.w	r3, [r2, r1, lsl #2]
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
    a122:	movls	r0, r3
	in = inputQueue[index];
	inputQueue[index] = NULL;
	return in;
}
    a124:	bx	lr

0000a126 <AudioConnection::connect()>:

void AudioConnection::connect(void)
{
	AudioConnection *p;

	if (isConnected) return;
    a126:	ldrb	r3, [r0, #16]
	return in;
}


void AudioConnection::connect(void)
{
    a128:	push	{r4, r5, lr}
	AudioConnection *p;

	if (isConnected) return;
    a12a:	cmp	r3, #0
    a12c:	bne.n	a188 <AudioConnection::connect()+0x62>
	if (dest_index > dst.num_inputs) return;
    a12e:	ldr	r3, [r0, #4]
    a130:	ldrb	r2, [r0, #9]
    a132:	ldrb	r3, [r3, #9]
    a134:	cmp	r2, r3
    a136:	bhi.n	a188 <AudioConnection::connect()+0x62>
	__disable_irq();
    a138:	cpsid	i
	p = src.destination_list;
    a13a:	ldr	r2, [r0, #0]
    a13c:	ldr	r3, [r2, #12]
	if (p == NULL) {
    a13e:	cbnz	r3, a14c <AudioConnection::connect()+0x26>
		src.destination_list = this;
    a140:	str	r0, [r2, #12]
    a142:	b.n	a168 <AudioConnection::connect()+0x42>
	} else {
		while (p->next_dest) {
			if (&p->src == &this->src && &p->dst == &this->dst
    a144:	ldr	r4, [r3, #0]
    a146:	cmp	r2, r4
    a148:	beq.n	a154 <AudioConnection::connect()+0x2e>
	return in;
}


void AudioConnection::connect(void)
{
    a14a:	mov	r3, r1
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
    a14c:	ldr	r1, [r3, #12]
    a14e:	cmp	r1, #0
    a150:	bne.n	a144 <AudioConnection::connect()+0x1e>
    a152:	b.n	a166 <AudioConnection::connect()+0x40>
			if (&p->src == &this->src && &p->dst == &this->dst
    a154:	ldr	r5, [r3, #4]
    a156:	ldr	r4, [r0, #4]
    a158:	cmp	r5, r4
    a15a:	bne.n	a14a <AudioConnection::connect()+0x24>
				&& p->src_index == this->src_index && p->dest_index == this->dest_index) {
    a15c:	ldrh	r4, [r3, #8]
    a15e:	ldrh	r3, [r0, #8]
    a160:	cmp	r4, r3
    a162:	bne.n	a14a <AudioConnection::connect()+0x24>
    a164:	b.n	a186 <AudioConnection::connect()+0x60>
				__enable_irq();
				return;
			}
			p = p->next_dest;
		}
		p->next_dest = this;
    a166:	str	r0, [r3, #12]
	}
	this->next_dest = NULL;
    a168:	movs	r3, #0
    a16a:	str	r3, [r0, #12]
	src.numConnections++;
    a16c:	ldrb	r3, [r2, #10]
    a16e:	adds	r3, #1
    a170:	strb	r3, [r2, #10]
	src.active = true;
    a172:	ldr	r2, [r0, #0]

	dst.numConnections++;
    a174:	ldr	r1, [r0, #4]
		}
		p->next_dest = this;
	}
	this->next_dest = NULL;
	src.numConnections++;
	src.active = true;
    a176:	movs	r3, #1
    a178:	strb	r3, [r2, #8]

	dst.numConnections++;
    a17a:	ldrb	r2, [r1, #10]
    a17c:	add	r2, r3
    a17e:	strb	r2, [r1, #10]
	dst.active = true;
    a180:	ldr	r2, [r0, #4]
    a182:	strb	r3, [r2, #8]

	isConnected = true;
    a184:	strb	r3, [r0, #16]

	__enable_irq();
    a186:	cpsie	i
    a188:	pop	{r4, r5, pc}

0000a18a <AudioConnection::disconnect()>:

void AudioConnection::disconnect(void)
{
	AudioConnection *p;

	if (!isConnected) return;
    a18a:	ldrb	r3, [r0, #16]

	__enable_irq();
}

void AudioConnection::disconnect(void)
{
    a18c:	push	{r4, lr}
    a18e:	mov	r4, r0
	AudioConnection *p;

	if (!isConnected) return;
    a190:	cmp	r3, #0
    a192:	beq.n	a1fe <AudioConnection::disconnect()+0x74>
	if (dest_index > dst.num_inputs) return;
    a194:	ldr	r3, [r0, #4]
    a196:	ldrb	r2, [r0, #9]
    a198:	ldrb	r3, [r3, #9]
    a19a:	cmp	r2, r3
    a19c:	bhi.n	a1fe <AudioConnection::disconnect()+0x74>
	__disable_irq();
    a19e:	cpsid	i
	// Remove destination from source list
	p = src.destination_list;
    a1a0:	ldr	r2, [r0, #0]
    a1a2:	ldr	r3, [r2, #12]
	if (p == NULL) {
    a1a4:	cbz	r3, a1fc <AudioConnection::disconnect()+0x72>
//>>> PAH re-enable the IRQ
		__enable_irq();
		return;
	} else if (p == this) {
    a1a6:	cmp	r0, r3
    a1a8:	bne.n	a1b4 <AudioConnection::disconnect()+0x2a>
		if (p->next_dest) {
    a1aa:	ldr	r3, [r0, #12]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
    a1ac:	str	r3, [r2, #12]
    a1ae:	b.n	a1ba <AudioConnection::disconnect()+0x30>
		}
	} else {
		while (p) {
			if (p == this) {
    a1b0:	cmp	r4, r3
    a1b2:	beq.n	a1ba <AudioConnection::disconnect()+0x30>
				} else {
					p = NULL;
					break;
				}
			}
			p = p->next_dest;
    a1b4:	ldr	r3, [r3, #12]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
		}
	} else {
		while (p) {
    a1b6:	cmp	r3, #0
    a1b8:	bne.n	a1b0 <AudioConnection::disconnect()+0x26>
			p = p->next_dest;
		}
	}
//>>> PAH release the audio buffer properly
	//Remove possible pending src block from destination
	if(dst.inputQueue[dest_index] != NULL) {
    a1ba:	ldr	r3, [r4, #4]
    a1bc:	ldrb	r2, [r4, #9]
    a1be:	ldr	r3, [r3, #16]
    a1c0:	ldr.w	r0, [r3, r2, lsl #2]
    a1c4:	cbz	r0, a1d8 <AudioConnection::disconnect()+0x4e>
		AudioStream::release(dst.inputQueue[dest_index]);
    a1c6:	bl	a094 <AudioStream::release(audio_block_struct*)>
		// release() re-enables the IRQ. Need it to be disabled a little longer
		__disable_irq();
    a1ca:	cpsid	i
		dst.inputQueue[dest_index] = NULL;
    a1cc:	ldr	r3, [r4, #4]
    a1ce:	ldrb	r2, [r4, #9]
    a1d0:	ldr	r3, [r3, #16]
    a1d2:	movs	r1, #0
    a1d4:	str.w	r1, [r3, r2, lsl #2]
	}

	//Check if the disconnected AudioStream objects should still be active
	src.numConnections--;
    a1d8:	ldr	r2, [r4, #0]
    a1da:	ldrb	r3, [r2, #10]
    a1dc:	subs	r3, #1
    a1de:	strb	r3, [r2, #10]
	if (src.numConnections == 0) {
    a1e0:	ldr	r3, [r4, #0]
    a1e2:	ldrb	r2, [r3, #10]
    a1e4:	cbnz	r2, a1e8 <AudioConnection::disconnect()+0x5e>
		src.active = false;
    a1e6:	strb	r2, [r3, #8]
	}

	dst.numConnections--;
    a1e8:	ldr	r2, [r4, #4]
    a1ea:	ldrb	r3, [r2, #10]
    a1ec:	subs	r3, #1
    a1ee:	strb	r3, [r2, #10]
	if (dst.numConnections == 0) {
    a1f0:	ldr	r3, [r4, #4]
    a1f2:	ldrb	r2, [r3, #10]
    a1f4:	cbnz	r2, a1f8 <AudioConnection::disconnect()+0x6e>
		dst.active = false;
    a1f6:	strb	r2, [r3, #8]
	}

	isConnected = false;
    a1f8:	movs	r3, #0
    a1fa:	strb	r3, [r4, #16]

	__enable_irq();
    a1fc:	cpsie	i
    a1fe:	pop	{r4, pc}

0000a200 <AudioStream::update_setup()>:
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    a200:	ldr	r3, [pc, #24]	; (a21c <AudioStream::update_setup()+0x1c>)
    a202:	ldrb	r2, [r3, #0]
    a204:	cbnz	r2, a218 <AudioStream::update_setup()+0x18>
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
    a206:	ldr	r2, [pc, #24]	; (a220 <AudioStream::update_setup()+0x20>)
    a208:	movs	r1, #208	; 0xd0
    a20a:	strb	r1, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    a20c:	sub.w	r2, r2, #824	; 0x338
    a210:	movs	r0, #1
    a212:	str	r0, [r2, #0]
	update_scheduled = true;
    a214:	strb	r0, [r3, #0]
	return true;
    a216:	bx	lr
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    a218:	movs	r0, #0
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
	update_scheduled = true;
	return true;
}
    a21a:	bx	lr
    a21c:	.word	0x2001a00c
    a220:	.word	0xe000e440

0000a224 <software_isr>:
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    a224:	ldr	r2, [pc, #88]	; (a280 <software_isr+0x5c>)
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    a226:	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    a228:	ldr	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    a22a:	ldr	r5, [pc, #88]	; (a284 <software_isr+0x60>)
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    a22c:	orr.w	r3, r3, #16777216	; 0x1000000
    a230:	str	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    a232:	ldr	r2, [pc, #84]	; (a288 <software_isr+0x64>)
    a234:	ldr	r3, [r2, #0]
    a236:	orr.w	r3, r3, #1
    a23a:	str	r3, [r2, #0]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    a23c:	ldr	r3, [pc, #76]	; (a28c <software_isr+0x68>)
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    a23e:	ldr	r6, [r5, #0]
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    a240:	ldr	r4, [r3, #0]
    a242:	cbz	r4, a268 <software_isr+0x44>
		if (p->active) {
    a244:	ldrb	r3, [r4, #8]
    a246:	cbz	r3, a264 <software_isr+0x40>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
    a248:	ldr	r3, [r4, #0]
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
    a24a:	ldr	r7, [r5, #0]
			p->update();
    a24c:	ldr	r3, [r3, #0]
    a24e:	mov	r0, r4
    a250:	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    a252:	ldr	r2, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    a254:	ldrh	r3, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    a256:	subs	r2, r2, r7
    a258:	lsrs	r2, r2, #4
			p->cpu_cycles = cycles;
    a25a:	uxth	r1, r2
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    a25c:	cmp	r2, r3
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
			p->cpu_cycles = cycles;
    a25e:	strh	r1, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    a260:	it	hi
    a262:	strhhi	r1, [r4, #6]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    a264:	ldr	r4, [r4, #20]
    a266:	b.n	a242 <software_isr+0x1e>
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    a268:	ldr	r3, [r5, #0]
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    a26a:	ldr	r2, [pc, #36]	; (a290 <software_isr+0x6c>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    a26c:	subs	r3, r3, r6
    a26e:	lsrs	r3, r3, #4
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    a270:	uxth	r1, r3
    a272:	strh	r1, [r2, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    a274:	ldr	r2, [pc, #28]	; (a294 <software_isr+0x70>)
    a276:	ldrh	r0, [r2, #0]
    a278:	cmp	r3, r0
		AudioStream::cpu_cycles_total_max = totalcycles;
    a27a:	it	hi
    a27c:	strhhi	r1, [r2, #0]
    a27e:	pop	{r3, r4, r5, r6, r7, pc}
    a280:	.word	0xe000edfc
    a284:	.word	0xe0001004
    a288:	.word	0xe0001000
    a28c:	.word	0x2001a000
    a290:	.word	0x2001a086
    a294:	.word	0x2001a080

0000a298 <Stream::timedPeek()>:
  return -1;     // -1 indicates timeout
}

// private method to peek stream with timeout
int Stream::timedPeek()
{
    a298:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a29a:	ldr	r3, [pc, #48]	; (a2cc <Stream::timedPeek()+0x34>)
    a29c:	ldr	r2, [r3, #0]
    a29e:	str	r2, [sp, #0]
	return ret;
    a2a0:	ldr	r6, [sp, #0]
    a2a2:	mov	r4, r0
    a2a4:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = peek();
    a2a6:	ldr	r3, [r4, #0]
    a2a8:	mov	r0, r4
    a2aa:	ldr	r3, [r3, #24]
    a2ac:	blx	r3
    if (c >= 0) return c;
    a2ae:	cmp	r0, #0
    a2b0:	bge.n	a2c8 <Stream::timedPeek()+0x30>
    yield();
    a2b2:	bl	9c60 <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a2b6:	ldr	r3, [r5, #0]
    a2b8:	str	r3, [sp, #4]
	return ret;
    a2ba:	ldr	r3, [sp, #4]
// private method to peek stream with timeout
int Stream::timedPeek()
{
  int c;
  unsigned long startMillis = millis();
  do {
    a2bc:	ldr	r2, [r4, #8]
    a2be:	subs	r3, r3, r6
    a2c0:	cmp	r3, r2
    a2c2:	bcc.n	a2a6 <Stream::timedPeek()+0xe>
    c = peek();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    a2c4:	mov.w	r0, #4294967295
}
    a2c8:	add	sp, #8
    a2ca:	pop	{r4, r5, r6, pc}
    a2cc:	.word	0x20019f04

0000a2d0 <Stream::peekNextDigit()>:

// returns peek of the next digit in the stream or -1 if timeout
// discards non-numeric characters
int Stream::peekNextDigit()
{
    a2d0:	push	{r4, lr}
    a2d2:	mov	r4, r0
  int c;
  while (1) {
    c = timedPeek();
    a2d4:	mov	r0, r4
    a2d6:	bl	a298 <Stream::timedPeek()>
    if (c < 0) return c;  // timeout
    a2da:	cmp	r0, #0
    a2dc:	blt.n	a2f4 <Stream::peekNextDigit()+0x24>
    if (c == '-') return c;
    a2de:	cmp	r0, #45	; 0x2d
    a2e0:	beq.n	a2f4 <Stream::peekNextDigit()+0x24>
    if (c >= '0' && c <= '9') return c;
    a2e2:	sub.w	r3, r0, #48	; 0x30
    a2e6:	cmp	r3, #9
    a2e8:	bls.n	a2f4 <Stream::peekNextDigit()+0x24>
    read();  // discard non-numeric
    a2ea:	ldr	r3, [r4, #0]
    a2ec:	mov	r0, r4
    a2ee:	ldr	r3, [r3, #20]
    a2f0:	blx	r3
// returns peek of the next digit in the stream or -1 if timeout
// discards non-numeric characters
int Stream::peekNextDigit()
{
  int c;
  while (1) {
    a2f2:	b.n	a2d4 <Stream::peekNextDigit()+0x4>
    if (c < 0) return c;  // timeout
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    read();  // discard non-numeric
  }
}
    a2f4:	pop	{r4, pc}

0000a2f6 <Stream::parseInt(char)>:
}

// as above but a given skipChar is ignored
// this allows format characters (typically commas) in values to be ignored
long Stream::parseInt(char skipChar)
{
    a2f6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a2fa:	mov	r5, r0
    a2fc:	mov	r7, r1
  boolean isNegative = false;
  long value = 0;
  int c;

  c = peekNextDigit();
    a2fe:	bl	a2d0 <Stream::peekNextDigit()>
  // ignore non numeric leading characters
  if(c < 0)
    a302:	cmp	r0, #0
    a304:	blt.n	a34a <Stream::parseInt(char)+0x54>
    a306:	movs	r4, #0
    a308:	mov	r6, r4
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
      value = value * 10 + c - '0';
    a30a:	mov.w	r8, #10
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout

  do{
    if(c == skipChar)
    a30e:	cmp	r0, r7
    a310:	beq.n	a328 <Stream::parseInt(char)+0x32>
      ; // ignore this charactor
    else if(c == '-')
    a312:	cmp	r0, #45	; 0x2d
    a314:	beq.n	a326 <Stream::parseInt(char)+0x30>
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    a316:	sub.w	r3, r0, #48	; 0x30
    a31a:	cmp	r3, #9
    a31c:	bhi.n	a328 <Stream::parseInt(char)+0x32>
      value = value * 10 + c - '0';
    a31e:	mla	r4, r8, r4, r0
    a322:	subs	r4, #48	; 0x30
    a324:	b.n	a328 <Stream::parseInt(char)+0x32>

  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    a326:	movs	r6, #1
    else if(c >= '0' && c <= '9')        // is c a digit?
      value = value * 10 + c - '0';
    read();  // consume the character we got with peek
    a328:	ldr	r3, [r5, #0]
    a32a:	mov	r0, r5
    a32c:	ldr	r3, [r3, #20]
    a32e:	blx	r3
    c = timedPeek();
    a330:	mov	r0, r5
    a332:	bl	a298 <Stream::timedPeek()>
  }
  while( (c >= '0' && c <= '9') || c == skipChar );
    a336:	sub.w	r3, r0, #48	; 0x30
    a33a:	cmp	r3, #9
    a33c:	bls.n	a30e <Stream::parseInt(char)+0x18>
    a33e:	cmp	r7, r0
    a340:	beq.n	a30e <Stream::parseInt(char)+0x18>

  if(isNegative)
    a342:	cbz	r6, a350 <Stream::parseInt(char)+0x5a>
    value = -value;
    a344:	negs	r0, r4
    a346:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  int c;

  c = peekNextDigit();
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout
    a34a:	movs	r0, #0
    a34c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a350:	mov	r0, r4
  while( (c >= '0' && c <= '9') || c == skipChar );

  if(isNegative)
    value = -value;
  return value;
}
    a352:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000a356 <Stream::parseInt()>:
// returns the first valid (long) integer value from the current position.
// initial characters that are not digits (or the minus sign) are skipped
// function is terminated by the first character that is not a digit.
long Stream::parseInt()
{
  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
    a356:	movs	r1, #1
    a358:	b.w	a2f6 <Stream::parseInt(char)>

0000a35c <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    a35c:	bx	lr

0000a35e <operator new(unsigned int)>:
    a35e:	b.w	b4a4 <malloc>

0000a362 <operator delete(void*, unsigned int)>:
    a362:	b.w	b4b4 <free>
    a366:	Address 0x0000a366 is out of bounds.


0000a368 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    a368:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    a36a:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a36c:	ldr	r3, [pc, #76]	; (a3bc <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a36e:	ldr	r1, [pc, #80]	; (a3c0 <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a370:	movs	r2, #112	; 0x70
    a372:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a374:	ldr	r2, [pc, #76]	; (a3c4 <usb_init_serialnumber+0x5c>)
    a376:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    a378:	movs	r2, #128	; 0x80
    a37a:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    a37c:	ldrb	r2, [r3, #0]
    a37e:	lsls	r2, r2, #24
    a380:	bpl.n	a37c <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    a382:	ldr	r3, [pc, #68]	; (a3c8 <usb_init_serialnumber+0x60>)
    a384:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    a386:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a388:	ldr	r3, [pc, #64]	; (a3cc <usb_init_serialnumber+0x64>)
    a38a:	cmp	r0, r3
    a38c:	it	ls
    a38e:	movls	r3, #10
	ultoa(num, buf, 10);
    a390:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a392:	it	ls
    a394:	mulls	r0, r3
	ultoa(num, buf, 10);
    a396:	movs	r2, #10
    a398:	mov	r1, r4
    a39a:	bl	a3d8 <ultoa>
    a39e:	ldr	r2, [pc, #48]	; (a3d0 <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    a3a0:	movs	r3, #0
		char c = buf[i];
    a3a2:	ldrb	r1, [r4, r3]
		if (!c) break;
    a3a4:	cbz	r1, a3b0 <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a3a6:	adds	r3, #1
    a3a8:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    a3aa:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a3ae:	bne.n	a3a2 <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    a3b0:	ldr	r2, [pc, #32]	; (a3d4 <usb_init_serialnumber+0x6c>)
    a3b2:	adds	r3, #1
    a3b4:	lsls	r3, r3, #1
    a3b6:	strb	r3, [r2, #0]
}
    a3b8:	add	sp, #16
    a3ba:	pop	{r4, pc}
    a3bc:	.word	0x40020000
    a3c0:	.word	0x41070000
    a3c4:	.word	0x40020004
    a3c8:	.word	0x4002000c
    a3cc:	.word	0x0098967f
    a3d0:	.word	0x20013df0
    a3d4:	.word	0x20013dee

0000a3d8 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    a3d8:	push	{r4, r5, lr}
    a3da:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    a3dc:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    a3de:	udiv	r4, r3, r2
    a3e2:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a3e6:	cmp	r3, #9
    a3e8:	ite	ls
    a3ea:	addls	r3, #48	; 0x30
    a3ec:	addhi	r3, #55	; 0x37
    a3ee:	uxtb	r3, r3
    a3f0:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    a3f2:	mov	r3, r4
    a3f4:	cbz	r4, a3fa <ultoa+0x22>
		i++;
    a3f6:	adds	r0, #1
	}
    a3f8:	b.n	a3de <ultoa+0x6>
	buf[i + 1] = 0;
    a3fa:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    a3fc:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    a3fe:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    a400:	subs	r4, r0, r3
    a402:	cmp	r3, r4
    a404:	bge.n	a414 <ultoa+0x3c>
		t = buf[j];
    a406:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    a408:	ldrb	r5, [r2, #0]
    a40a:	strb	r5, [r1, r3]
		buf[i] = t;
    a40c:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    a410:	adds	r3, #1
    a412:	b.n	a400 <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    a414:	mov	r0, r1
    a416:	pop	{r4, r5, pc}

0000a418 <nanf>:
    a418:	vldr	s0, [pc, #4]	; a420 <nanf+0x8>
    a41c:	bx	lr
    a41e:	nop
    a420:	.word	0x7fc00000

0000a424 <__aeabi_atexit>:
    a424:	mov	r3, r1
    a426:	mov	r1, r0
    a428:	mov	r0, r3
    a42a:	b.w	b3ec <__cxa_atexit>
    a42e:	nop

0000a430 <__aeabi_llsr>:
    a430:	lsrs	r0, r2
    a432:	adds	r3, r1, #0
    a434:	lsrs	r1, r2
    a436:	mov	ip, r3
    a438:	subs	r2, #32
    a43a:	lsrs	r3, r2
    a43c:	orrs	r0, r3
    a43e:	negs	r2, r2
    a440:	mov	r3, ip
    a442:	lsls	r3, r2
    a444:	orrs	r0, r3
    a446:	bx	lr

0000a448 <__aeabi_drsub>:
    a448:	eor.w	r1, r1, #2147483648	; 0x80000000
    a44c:	b.n	a454 <__adddf3>
    a44e:	nop

0000a450 <__aeabi_dsub>:
    a450:	eor.w	r3, r3, #2147483648	; 0x80000000

0000a454 <__adddf3>:
    a454:	push	{r4, r5, lr}
    a456:	mov.w	r4, r1, lsl #1
    a45a:	mov.w	r5, r3, lsl #1
    a45e:	teq	r4, r5
    a462:	it	eq
    a464:	teqeq	r0, r2
    a468:	itttt	ne
    a46a:	orrsne.w	ip, r4, r0
    a46e:	orrsne.w	ip, r5, r2
    a472:	mvnsne.w	ip, r4, asr #21
    a476:	mvnsne.w	ip, r5, asr #21
    a47a:	beq.w	a642 <__adddf3+0x1ee>
    a47e:	mov.w	r4, r4, lsr #21
    a482:	rsbs	r5, r4, r5, lsr #21
    a486:	it	lt
    a488:	neglt	r5, r5
    a48a:	ble.n	a4a6 <__adddf3+0x52>
    a48c:	add	r4, r5
    a48e:	eor.w	r2, r0, r2
    a492:	eor.w	r3, r1, r3
    a496:	eor.w	r0, r2, r0
    a49a:	eor.w	r1, r3, r1
    a49e:	eor.w	r2, r0, r2
    a4a2:	eor.w	r3, r1, r3
    a4a6:	cmp	r5, #54	; 0x36
    a4a8:	it	hi
    a4aa:	pophi	{r4, r5, pc}
    a4ac:	tst.w	r1, #2147483648	; 0x80000000
    a4b0:	mov.w	r1, r1, lsl #12
    a4b4:	mov.w	ip, #1048576	; 0x100000
    a4b8:	orr.w	r1, ip, r1, lsr #12
    a4bc:	beq.n	a4c4 <__adddf3+0x70>
    a4be:	negs	r0, r0
    a4c0:	sbc.w	r1, r1, r1, lsl #1
    a4c4:	tst.w	r3, #2147483648	; 0x80000000
    a4c8:	mov.w	r3, r3, lsl #12
    a4cc:	orr.w	r3, ip, r3, lsr #12
    a4d0:	beq.n	a4d8 <__adddf3+0x84>
    a4d2:	negs	r2, r2
    a4d4:	sbc.w	r3, r3, r3, lsl #1
    a4d8:	teq	r4, r5
    a4dc:	beq.w	a62e <__adddf3+0x1da>
    a4e0:	sub.w	r4, r4, #1
    a4e4:	rsbs	lr, r5, #32
    a4e8:	blt.n	a506 <__adddf3+0xb2>
    a4ea:	lsl.w	ip, r2, lr
    a4ee:	lsr.w	r2, r2, r5
    a4f2:	adds	r0, r0, r2
    a4f4:	adc.w	r1, r1, #0
    a4f8:	lsl.w	r2, r3, lr
    a4fc:	adds	r0, r0, r2
    a4fe:	asr.w	r3, r3, r5
    a502:	adcs	r1, r3
    a504:	b.n	a524 <__adddf3+0xd0>
    a506:	sub.w	r5, r5, #32
    a50a:	add.w	lr, lr, #32
    a50e:	cmp	r2, #1
    a510:	lsl.w	ip, r3, lr
    a514:	it	cs
    a516:	orrcs.w	ip, ip, #2
    a51a:	asr.w	r3, r3, r5
    a51e:	adds	r0, r0, r3
    a520:	adcs.w	r1, r1, r3, asr #31
    a524:	and.w	r5, r1, #2147483648	; 0x80000000
    a528:	bpl.n	a53a <__adddf3+0xe6>
    a52a:	mov.w	lr, #0
    a52e:	rsbs	ip, ip, #0
    a532:	sbcs.w	r0, lr, r0
    a536:	sbc.w	r1, lr, r1
    a53a:	cmp.w	r1, #1048576	; 0x100000
    a53e:	bcc.n	a578 <__adddf3+0x124>
    a540:	cmp.w	r1, #2097152	; 0x200000
    a544:	bcc.n	a560 <__adddf3+0x10c>
    a546:	lsrs	r1, r1, #1
    a548:	movs.w	r0, r0, rrx
    a54c:	mov.w	ip, ip, rrx
    a550:	add.w	r4, r4, #1
    a554:	mov.w	r2, r4, lsl #21
    a558:	cmn.w	r2, #4194304	; 0x400000
    a55c:	bcs.w	a694 <__adddf3+0x240>
    a560:	cmp.w	ip, #2147483648	; 0x80000000
    a564:	it	eq
    a566:	movseq.w	ip, r0, lsr #1
    a56a:	adcs.w	r0, r0, #0
    a56e:	adc.w	r1, r1, r4, lsl #20
    a572:	orr.w	r1, r1, r5
    a576:	pop	{r4, r5, pc}
    a578:	movs.w	ip, ip, lsl #1
    a57c:	adcs	r0, r0
    a57e:	adc.w	r1, r1, r1
    a582:	tst.w	r1, #1048576	; 0x100000
    a586:	sub.w	r4, r4, #1
    a58a:	bne.n	a560 <__adddf3+0x10c>
    a58c:	teq	r1, #0
    a590:	itt	eq
    a592:	moveq	r1, r0
    a594:	moveq	r0, #0
    a596:	clz	r3, r1
    a59a:	it	eq
    a59c:	addeq	r3, #32
    a59e:	sub.w	r3, r3, #11
    a5a2:	subs.w	r2, r3, #32
    a5a6:	bge.n	a5c2 <__adddf3+0x16e>
    a5a8:	adds	r2, #12
    a5aa:	ble.n	a5be <__adddf3+0x16a>
    a5ac:	add.w	ip, r2, #20
    a5b0:	rsb	r2, r2, #12
    a5b4:	lsl.w	r0, r1, ip
    a5b8:	lsr.w	r1, r1, r2
    a5bc:	b.n	a5d8 <__adddf3+0x184>
    a5be:	add.w	r2, r2, #20
    a5c2:	it	le
    a5c4:	rsble	ip, r2, #32
    a5c8:	lsl.w	r1, r1, r2
    a5cc:	lsr.w	ip, r0, ip
    a5d0:	itt	le
    a5d2:	orrle.w	r1, r1, ip
    a5d6:	lslle	r0, r2
    a5d8:	subs	r4, r4, r3
    a5da:	ittt	ge
    a5dc:	addge.w	r1, r1, r4, lsl #20
    a5e0:	orrge	r1, r5
    a5e2:	popge	{r4, r5, pc}
    a5e4:	mvn.w	r4, r4
    a5e8:	subs	r4, #31
    a5ea:	bge.n	a626 <__adddf3+0x1d2>
    a5ec:	adds	r4, #12
    a5ee:	bgt.n	a60e <__adddf3+0x1ba>
    a5f0:	add.w	r4, r4, #20
    a5f4:	rsb	r2, r4, #32
    a5f8:	lsr.w	r0, r0, r4
    a5fc:	lsl.w	r3, r1, r2
    a600:	orr.w	r0, r0, r3
    a604:	lsr.w	r3, r1, r4
    a608:	orr.w	r1, r5, r3
    a60c:	pop	{r4, r5, pc}
    a60e:	rsb	r4, r4, #12
    a612:	rsb	r2, r4, #32
    a616:	lsr.w	r0, r0, r2
    a61a:	lsl.w	r3, r1, r4
    a61e:	orr.w	r0, r0, r3
    a622:	mov	r1, r5
    a624:	pop	{r4, r5, pc}
    a626:	lsr.w	r0, r1, r4
    a62a:	mov	r1, r5
    a62c:	pop	{r4, r5, pc}
    a62e:	teq	r4, #0
    a632:	eor.w	r3, r3, #1048576	; 0x100000
    a636:	itte	eq
    a638:	eoreq.w	r1, r1, #1048576	; 0x100000
    a63c:	addeq	r4, #1
    a63e:	subne	r5, #1
    a640:	b.n	a4e0 <__adddf3+0x8c>
    a642:	mvns.w	ip, r4, asr #21
    a646:	it	ne
    a648:	mvnsne.w	ip, r5, asr #21
    a64c:	beq.n	a6a2 <__adddf3+0x24e>
    a64e:	teq	r4, r5
    a652:	it	eq
    a654:	teqeq	r0, r2
    a658:	beq.n	a666 <__adddf3+0x212>
    a65a:	orrs.w	ip, r4, r0
    a65e:	itt	eq
    a660:	moveq	r1, r3
    a662:	moveq	r0, r2
    a664:	pop	{r4, r5, pc}
    a666:	teq	r1, r3
    a66a:	ittt	ne
    a66c:	movne	r1, #0
    a66e:	movne	r0, #0
    a670:	popne	{r4, r5, pc}
    a672:	movs.w	ip, r4, lsr #21
    a676:	bne.n	a684 <__adddf3+0x230>
    a678:	lsls	r0, r0, #1
    a67a:	adcs	r1, r1
    a67c:	it	cs
    a67e:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    a682:	pop	{r4, r5, pc}
    a684:	adds.w	r4, r4, #4194304	; 0x400000
    a688:	itt	cc
    a68a:	addcc.w	r1, r1, #1048576	; 0x100000
    a68e:	popcc	{r4, r5, pc}
    a690:	and.w	r5, r1, #2147483648	; 0x80000000
    a694:	orr.w	r1, r5, #2130706432	; 0x7f000000
    a698:	orr.w	r1, r1, #15728640	; 0xf00000
    a69c:	mov.w	r0, #0
    a6a0:	pop	{r4, r5, pc}
    a6a2:	mvns.w	ip, r4, asr #21
    a6a6:	itte	ne
    a6a8:	movne	r1, r3
    a6aa:	movne	r0, r2
    a6ac:	mvnseq.w	ip, r5, asr #21
    a6b0:	itt	ne
    a6b2:	movne	r3, r1
    a6b4:	movne	r2, r0
    a6b6:	orrs.w	r4, r0, r1, lsl #12
    a6ba:	itte	eq
    a6bc:	orrseq.w	r5, r2, r3, lsl #12
    a6c0:	teqeq	r1, r3
    a6c4:	orrne.w	r1, r1, #524288	; 0x80000
    a6c8:	pop	{r4, r5, pc}
    a6ca:	nop

0000a6cc <__aeabi_ui2d>:
    a6cc:	teq	r0, #0
    a6d0:	itt	eq
    a6d2:	moveq	r1, #0
    a6d4:	bxeq	lr
    a6d6:	push	{r4, r5, lr}
    a6d8:	mov.w	r4, #1024	; 0x400
    a6dc:	add.w	r4, r4, #50	; 0x32
    a6e0:	mov.w	r5, #0
    a6e4:	mov.w	r1, #0
    a6e8:	b.n	a58c <__adddf3+0x138>
    a6ea:	nop

0000a6ec <__aeabi_i2d>:
    a6ec:	teq	r0, #0
    a6f0:	itt	eq
    a6f2:	moveq	r1, #0
    a6f4:	bxeq	lr
    a6f6:	push	{r4, r5, lr}
    a6f8:	mov.w	r4, #1024	; 0x400
    a6fc:	add.w	r4, r4, #50	; 0x32
    a700:	ands.w	r5, r0, #2147483648	; 0x80000000
    a704:	it	mi
    a706:	negmi	r0, r0
    a708:	mov.w	r1, #0
    a70c:	b.n	a58c <__adddf3+0x138>
    a70e:	nop

0000a710 <__aeabi_f2d>:
    a710:	lsls	r2, r0, #1
    a712:	mov.w	r1, r2, asr #3
    a716:	mov.w	r1, r1, rrx
    a71a:	mov.w	r0, r2, lsl #28
    a71e:	itttt	ne
    a720:	andsne.w	r3, r2, #4278190080	; 0xff000000
    a724:	teqne	r3, #4278190080	; 0xff000000
    a728:	eorne.w	r1, r1, #939524096	; 0x38000000
    a72c:	bxne	lr
    a72e:	teq	r2, #0
    a732:	ite	ne
    a734:	teqne	r3, #4278190080	; 0xff000000
    a738:	bxeq	lr
    a73a:	push	{r4, r5, lr}
    a73c:	mov.w	r4, #896	; 0x380
    a740:	and.w	r5, r1, #2147483648	; 0x80000000
    a744:	bic.w	r1, r1, #2147483648	; 0x80000000
    a748:	b.n	a58c <__adddf3+0x138>
    a74a:	nop

0000a74c <__aeabi_ul2d>:
    a74c:	orrs.w	r2, r0, r1
    a750:	it	eq
    a752:	bxeq	lr
    a754:	push	{r4, r5, lr}
    a756:	mov.w	r5, #0
    a75a:	b.n	a772 <__aeabi_l2d+0x16>

0000a75c <__aeabi_l2d>:
    a75c:	orrs.w	r2, r0, r1
    a760:	it	eq
    a762:	bxeq	lr
    a764:	push	{r4, r5, lr}
    a766:	ands.w	r5, r1, #2147483648	; 0x80000000
    a76a:	bpl.n	a772 <__aeabi_l2d+0x16>
    a76c:	negs	r0, r0
    a76e:	sbc.w	r1, r1, r1, lsl #1
    a772:	mov.w	r4, #1024	; 0x400
    a776:	add.w	r4, r4, #50	; 0x32
    a77a:	movs.w	ip, r1, lsr #22
    a77e:	beq.w	a53a <__adddf3+0xe6>
    a782:	mov.w	r2, #3
    a786:	movs.w	ip, ip, lsr #3
    a78a:	it	ne
    a78c:	addne	r2, #3
    a78e:	movs.w	ip, ip, lsr #3
    a792:	it	ne
    a794:	addne	r2, #3
    a796:	add.w	r2, r2, ip, lsr #3
    a79a:	rsb	r3, r2, #32
    a79e:	lsl.w	ip, r0, r3
    a7a2:	lsr.w	r0, r0, r2
    a7a6:	lsl.w	lr, r1, r3
    a7aa:	orr.w	r0, r0, lr
    a7ae:	lsr.w	r1, r1, r2
    a7b2:	add	r4, r2
    a7b4:	b.n	a53a <__adddf3+0xe6>
    a7b6:	nop

0000a7b8 <__aeabi_dmul>:
    a7b8:	push	{r4, r5, r6, lr}
    a7ba:	mov.w	ip, #255	; 0xff
    a7be:	orr.w	ip, ip, #1792	; 0x700
    a7c2:	ands.w	r4, ip, r1, lsr #20
    a7c6:	ittte	ne
    a7c8:	andsne.w	r5, ip, r3, lsr #20
    a7cc:	teqne	r4, ip
    a7d0:	teqne	r5, ip
    a7d4:	bleq	a994 <__aeabi_dmul+0x1dc>
    a7d8:	add	r4, r5
    a7da:	eor.w	r6, r1, r3
    a7de:	bic.w	r1, r1, ip, lsl #21
    a7e2:	bic.w	r3, r3, ip, lsl #21
    a7e6:	orrs.w	r5, r0, r1, lsl #12
    a7ea:	it	ne
    a7ec:	orrsne.w	r5, r2, r3, lsl #12
    a7f0:	orr.w	r1, r1, #1048576	; 0x100000
    a7f4:	orr.w	r3, r3, #1048576	; 0x100000
    a7f8:	beq.n	a86c <__aeabi_dmul+0xb4>
    a7fa:	umull	ip, lr, r0, r2
    a7fe:	mov.w	r5, #0
    a802:	umlal	lr, r5, r1, r2
    a806:	and.w	r2, r6, #2147483648	; 0x80000000
    a80a:	umlal	lr, r5, r0, r3
    a80e:	mov.w	r6, #0
    a812:	umlal	r5, r6, r1, r3
    a816:	teq	ip, #0
    a81a:	it	ne
    a81c:	orrne.w	lr, lr, #1
    a820:	sub.w	r4, r4, #255	; 0xff
    a824:	cmp.w	r6, #512	; 0x200
    a828:	sbc.w	r4, r4, #768	; 0x300
    a82c:	bcs.n	a838 <__aeabi_dmul+0x80>
    a82e:	movs.w	lr, lr, lsl #1
    a832:	adcs	r5, r5
    a834:	adc.w	r6, r6, r6
    a838:	orr.w	r1, r2, r6, lsl #11
    a83c:	orr.w	r1, r1, r5, lsr #21
    a840:	mov.w	r0, r5, lsl #11
    a844:	orr.w	r0, r0, lr, lsr #21
    a848:	mov.w	lr, lr, lsl #11
    a84c:	subs.w	ip, r4, #253	; 0xfd
    a850:	it	hi
    a852:	cmphi.w	ip, #1792	; 0x700
    a856:	bhi.n	a896 <__aeabi_dmul+0xde>
    a858:	cmp.w	lr, #2147483648	; 0x80000000
    a85c:	it	eq
    a85e:	movseq.w	lr, r0, lsr #1
    a862:	adcs.w	r0, r0, #0
    a866:	adc.w	r1, r1, r4, lsl #20
    a86a:	pop	{r4, r5, r6, pc}
    a86c:	and.w	r6, r6, #2147483648	; 0x80000000
    a870:	orr.w	r1, r6, r1
    a874:	orr.w	r0, r0, r2
    a878:	eor.w	r1, r1, r3
    a87c:	subs.w	r4, r4, ip, lsr #1
    a880:	ittt	gt
    a882:	rsbsgt	r5, r4, ip
    a886:	orrgt.w	r1, r1, r4, lsl #20
    a88a:	popgt	{r4, r5, r6, pc}
    a88c:	orr.w	r1, r1, #1048576	; 0x100000
    a890:	mov.w	lr, #0
    a894:	subs	r4, #1
    a896:	bgt.w	a9f0 <__aeabi_dmul+0x238>
    a89a:	cmn.w	r4, #54	; 0x36
    a89e:	ittt	le
    a8a0:	movle	r0, #0
    a8a2:	andle.w	r1, r1, #2147483648	; 0x80000000
    a8a6:	pople	{r4, r5, r6, pc}
    a8a8:	rsb	r4, r4, #0
    a8ac:	subs	r4, #32
    a8ae:	bge.n	a91c <__aeabi_dmul+0x164>
    a8b0:	adds	r4, #12
    a8b2:	bgt.n	a8ec <__aeabi_dmul+0x134>
    a8b4:	add.w	r4, r4, #20
    a8b8:	rsb	r5, r4, #32
    a8bc:	lsl.w	r3, r0, r5
    a8c0:	lsr.w	r0, r0, r4
    a8c4:	lsl.w	r2, r1, r5
    a8c8:	orr.w	r0, r0, r2
    a8cc:	and.w	r2, r1, #2147483648	; 0x80000000
    a8d0:	bic.w	r1, r1, #2147483648	; 0x80000000
    a8d4:	adds.w	r0, r0, r3, lsr #31
    a8d8:	lsr.w	r6, r1, r4
    a8dc:	adc.w	r1, r2, r6
    a8e0:	orrs.w	lr, lr, r3, lsl #1
    a8e4:	it	eq
    a8e6:	biceq.w	r0, r0, r3, lsr #31
    a8ea:	pop	{r4, r5, r6, pc}
    a8ec:	rsb	r4, r4, #12
    a8f0:	rsb	r5, r4, #32
    a8f4:	lsl.w	r3, r0, r4
    a8f8:	lsr.w	r0, r0, r5
    a8fc:	lsl.w	r2, r1, r4
    a900:	orr.w	r0, r0, r2
    a904:	and.w	r1, r1, #2147483648	; 0x80000000
    a908:	adds.w	r0, r0, r3, lsr #31
    a90c:	adc.w	r1, r1, #0
    a910:	orrs.w	lr, lr, r3, lsl #1
    a914:	it	eq
    a916:	biceq.w	r0, r0, r3, lsr #31
    a91a:	pop	{r4, r5, r6, pc}
    a91c:	rsb	r5, r4, #32
    a920:	lsl.w	r2, r0, r5
    a924:	orr.w	lr, lr, r2
    a928:	lsr.w	r3, r0, r4
    a92c:	lsl.w	r2, r1, r5
    a930:	orr.w	r3, r3, r2
    a934:	lsr.w	r0, r1, r4
    a938:	and.w	r1, r1, #2147483648	; 0x80000000
    a93c:	lsr.w	r2, r1, r4
    a940:	bic.w	r0, r0, r2
    a944:	add.w	r0, r0, r3, lsr #31
    a948:	orrs.w	lr, lr, r3, lsl #1
    a94c:	it	eq
    a94e:	biceq.w	r0, r0, r3, lsr #31
    a952:	pop	{r4, r5, r6, pc}
    a954:	teq	r4, #0
    a958:	bne.n	a97a <__aeabi_dmul+0x1c2>
    a95a:	and.w	r6, r1, #2147483648	; 0x80000000
    a95e:	lsls	r0, r0, #1
    a960:	adc.w	r1, r1, r1
    a964:	tst.w	r1, #1048576	; 0x100000
    a968:	it	eq
    a96a:	subeq	r4, #1
    a96c:	beq.n	a95e <__aeabi_dmul+0x1a6>
    a96e:	orr.w	r1, r1, r6
    a972:	teq	r5, #0
    a976:	it	ne
    a978:	bxne	lr
    a97a:	and.w	r6, r3, #2147483648	; 0x80000000
    a97e:	lsls	r2, r2, #1
    a980:	adc.w	r3, r3, r3
    a984:	tst.w	r3, #1048576	; 0x100000
    a988:	it	eq
    a98a:	subeq	r5, #1
    a98c:	beq.n	a97e <__aeabi_dmul+0x1c6>
    a98e:	orr.w	r3, r3, r6
    a992:	bx	lr
    a994:	teq	r4, ip
    a998:	and.w	r5, ip, r3, lsr #20
    a99c:	it	ne
    a99e:	teqne	r5, ip
    a9a2:	beq.n	a9be <__aeabi_dmul+0x206>
    a9a4:	orrs.w	r6, r0, r1, lsl #1
    a9a8:	it	ne
    a9aa:	orrsne.w	r6, r2, r3, lsl #1
    a9ae:	bne.n	a954 <__aeabi_dmul+0x19c>
    a9b0:	eor.w	r1, r1, r3
    a9b4:	and.w	r1, r1, #2147483648	; 0x80000000
    a9b8:	mov.w	r0, #0
    a9bc:	pop	{r4, r5, r6, pc}
    a9be:	orrs.w	r6, r0, r1, lsl #1
    a9c2:	itte	eq
    a9c4:	moveq	r0, r2
    a9c6:	moveq	r1, r3
    a9c8:	orrsne.w	r6, r2, r3, lsl #1
    a9cc:	beq.n	aa02 <__aeabi_dmul+0x24a>
    a9ce:	teq	r4, ip
    a9d2:	bne.n	a9da <__aeabi_dmul+0x222>
    a9d4:	orrs.w	r6, r0, r1, lsl #12
    a9d8:	bne.n	aa02 <__aeabi_dmul+0x24a>
    a9da:	teq	r5, ip
    a9de:	bne.n	a9ec <__aeabi_dmul+0x234>
    a9e0:	orrs.w	r6, r2, r3, lsl #12
    a9e4:	itt	ne
    a9e6:	movne	r0, r2
    a9e8:	movne	r1, r3
    a9ea:	bne.n	aa02 <__aeabi_dmul+0x24a>
    a9ec:	eor.w	r1, r1, r3
    a9f0:	and.w	r1, r1, #2147483648	; 0x80000000
    a9f4:	orr.w	r1, r1, #2130706432	; 0x7f000000
    a9f8:	orr.w	r1, r1, #15728640	; 0xf00000
    a9fc:	mov.w	r0, #0
    aa00:	pop	{r4, r5, r6, pc}
    aa02:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aa06:	orr.w	r1, r1, #16252928	; 0xf80000
    aa0a:	pop	{r4, r5, r6, pc}

0000aa0c <__aeabi_ddiv>:
    aa0c:	push	{r4, r5, r6, lr}
    aa0e:	mov.w	ip, #255	; 0xff
    aa12:	orr.w	ip, ip, #1792	; 0x700
    aa16:	ands.w	r4, ip, r1, lsr #20
    aa1a:	ittte	ne
    aa1c:	andsne.w	r5, ip, r3, lsr #20
    aa20:	teqne	r4, ip
    aa24:	teqne	r5, ip
    aa28:	bleq	ab7a <__aeabi_ddiv+0x16e>
    aa2c:	sub.w	r4, r4, r5
    aa30:	eor.w	lr, r1, r3
    aa34:	orrs.w	r5, r2, r3, lsl #12
    aa38:	mov.w	r1, r1, lsl #12
    aa3c:	beq.w	ab50 <__aeabi_ddiv+0x144>
    aa40:	mov.w	r3, r3, lsl #12
    aa44:	mov.w	r5, #268435456	; 0x10000000
    aa48:	orr.w	r3, r5, r3, lsr #4
    aa4c:	orr.w	r3, r3, r2, lsr #24
    aa50:	mov.w	r2, r2, lsl #8
    aa54:	orr.w	r5, r5, r1, lsr #4
    aa58:	orr.w	r5, r5, r0, lsr #24
    aa5c:	mov.w	r6, r0, lsl #8
    aa60:	and.w	r1, lr, #2147483648	; 0x80000000
    aa64:	cmp	r5, r3
    aa66:	it	eq
    aa68:	cmpeq	r6, r2
    aa6a:	adc.w	r4, r4, #253	; 0xfd
    aa6e:	add.w	r4, r4, #768	; 0x300
    aa72:	bcs.n	aa7a <__aeabi_ddiv+0x6e>
    aa74:	lsrs	r3, r3, #1
    aa76:	mov.w	r2, r2, rrx
    aa7a:	subs	r6, r6, r2
    aa7c:	sbc.w	r5, r5, r3
    aa80:	lsrs	r3, r3, #1
    aa82:	mov.w	r2, r2, rrx
    aa86:	mov.w	r0, #1048576	; 0x100000
    aa8a:	mov.w	ip, #524288	; 0x80000
    aa8e:	subs.w	lr, r6, r2
    aa92:	sbcs.w	lr, r5, r3
    aa96:	ittt	cs
    aa98:	subcs	r6, r6, r2
    aa9a:	movcs	r5, lr
    aa9c:	orrcs.w	r0, r0, ip
    aaa0:	lsrs	r3, r3, #1
    aaa2:	mov.w	r2, r2, rrx
    aaa6:	subs.w	lr, r6, r2
    aaaa:	sbcs.w	lr, r5, r3
    aaae:	ittt	cs
    aab0:	subcs	r6, r6, r2
    aab2:	movcs	r5, lr
    aab4:	orrcs.w	r0, r0, ip, lsr #1
    aab8:	lsrs	r3, r3, #1
    aaba:	mov.w	r2, r2, rrx
    aabe:	subs.w	lr, r6, r2
    aac2:	sbcs.w	lr, r5, r3
    aac6:	ittt	cs
    aac8:	subcs	r6, r6, r2
    aaca:	movcs	r5, lr
    aacc:	orrcs.w	r0, r0, ip, lsr #2
    aad0:	lsrs	r3, r3, #1
    aad2:	mov.w	r2, r2, rrx
    aad6:	subs.w	lr, r6, r2
    aada:	sbcs.w	lr, r5, r3
    aade:	ittt	cs
    aae0:	subcs	r6, r6, r2
    aae2:	movcs	r5, lr
    aae4:	orrcs.w	r0, r0, ip, lsr #3
    aae8:	orrs.w	lr, r5, r6
    aaec:	beq.n	ab20 <__aeabi_ddiv+0x114>
    aaee:	mov.w	r5, r5, lsl #4
    aaf2:	orr.w	r5, r5, r6, lsr #28
    aaf6:	mov.w	r6, r6, lsl #4
    aafa:	mov.w	r3, r3, lsl #3
    aafe:	orr.w	r3, r3, r2, lsr #29
    ab02:	mov.w	r2, r2, lsl #3
    ab06:	movs.w	ip, ip, lsr #4
    ab0a:	bne.n	aa8e <__aeabi_ddiv+0x82>
    ab0c:	tst.w	r1, #1048576	; 0x100000
    ab10:	bne.n	ab2a <__aeabi_ddiv+0x11e>
    ab12:	orr.w	r1, r1, r0
    ab16:	mov.w	r0, #0
    ab1a:	mov.w	ip, #2147483648	; 0x80000000
    ab1e:	b.n	aa8e <__aeabi_ddiv+0x82>
    ab20:	tst.w	r1, #1048576	; 0x100000
    ab24:	itt	eq
    ab26:	orreq	r1, r0
    ab28:	moveq	r0, #0
    ab2a:	subs.w	ip, r4, #253	; 0xfd
    ab2e:	it	hi
    ab30:	cmphi.w	ip, #1792	; 0x700
    ab34:	bhi.w	a896 <__aeabi_dmul+0xde>
    ab38:	subs.w	ip, r5, r3
    ab3c:	itt	eq
    ab3e:	subseq.w	ip, r6, r2
    ab42:	movseq.w	ip, r0, lsr #1
    ab46:	adcs.w	r0, r0, #0
    ab4a:	adc.w	r1, r1, r4, lsl #20
    ab4e:	pop	{r4, r5, r6, pc}
    ab50:	and.w	lr, lr, #2147483648	; 0x80000000
    ab54:	orr.w	r1, lr, r1, lsr #12
    ab58:	adds.w	r4, r4, ip, lsr #1
    ab5c:	ittt	gt
    ab5e:	rsbsgt	r5, r4, ip
    ab62:	orrgt.w	r1, r1, r4, lsl #20
    ab66:	popgt	{r4, r5, r6, pc}
    ab68:	orr.w	r1, r1, #1048576	; 0x100000
    ab6c:	mov.w	lr, #0
    ab70:	subs	r4, #1
    ab72:	b.n	a896 <__aeabi_dmul+0xde>
    ab74:	orr.w	lr, r5, r6
    ab78:	b.n	a896 <__aeabi_dmul+0xde>
    ab7a:	and.w	r5, ip, r3, lsr #20
    ab7e:	teq	r4, ip
    ab82:	it	eq
    ab84:	teqeq	r5, ip
    ab88:	beq.w	aa02 <__aeabi_dmul+0x24a>
    ab8c:	teq	r4, ip
    ab90:	bne.n	aba8 <__aeabi_ddiv+0x19c>
    ab92:	orrs.w	r4, r0, r1, lsl #12
    ab96:	bne.w	aa02 <__aeabi_dmul+0x24a>
    ab9a:	teq	r5, ip
    ab9e:	bne.w	a9ec <__aeabi_dmul+0x234>
    aba2:	mov	r0, r2
    aba4:	mov	r1, r3
    aba6:	b.n	aa02 <__aeabi_dmul+0x24a>
    aba8:	teq	r5, ip
    abac:	bne.n	abbc <__aeabi_ddiv+0x1b0>
    abae:	orrs.w	r5, r2, r3, lsl #12
    abb2:	beq.w	a9b0 <__aeabi_dmul+0x1f8>
    abb6:	mov	r0, r2
    abb8:	mov	r1, r3
    abba:	b.n	aa02 <__aeabi_dmul+0x24a>
    abbc:	orrs.w	r6, r0, r1, lsl #1
    abc0:	it	ne
    abc2:	orrsne.w	r6, r2, r3, lsl #1
    abc6:	bne.w	a954 <__aeabi_dmul+0x19c>
    abca:	orrs.w	r4, r0, r1, lsl #1
    abce:	bne.w	a9ec <__aeabi_dmul+0x234>
    abd2:	orrs.w	r5, r2, r3, lsl #1
    abd6:	bne.w	a9b0 <__aeabi_dmul+0x1f8>
    abda:	b.n	aa02 <__aeabi_dmul+0x24a>

0000abdc <__gedf2>:
    abdc:	mov.w	ip, #4294967295
    abe0:	b.n	abf0 <__cmpdf2+0x4>
    abe2:	nop

0000abe4 <__ledf2>:
    abe4:	mov.w	ip, #1
    abe8:	b.n	abf0 <__cmpdf2+0x4>
    abea:	nop

0000abec <__cmpdf2>:
    abec:	mov.w	ip, #1
    abf0:	str.w	ip, [sp, #-4]!
    abf4:	mov.w	ip, r1, lsl #1
    abf8:	mvns.w	ip, ip, asr #21
    abfc:	mov.w	ip, r3, lsl #1
    ac00:	it	ne
    ac02:	mvnsne.w	ip, ip, asr #21
    ac06:	beq.n	ac40 <__cmpdf2+0x54>
    ac08:	add	sp, #4
    ac0a:	orrs.w	ip, r0, r1, lsl #1
    ac0e:	ite	eq
    ac10:	orrseq.w	ip, r2, r3, lsl #1
    ac14:	teqne	r1, r3
    ac18:	ittt	eq
    ac1a:	teqeq	r0, r2
    ac1e:	moveq	r0, #0
    ac20:	bxeq	lr
    ac22:	cmn.w	r0, #0
    ac26:	teq	r1, r3
    ac2a:	it	pl
    ac2c:	cmppl	r1, r3
    ac2e:	it	eq
    ac30:	cmpeq	r0, r2
    ac32:	ite	cs
    ac34:	asrcs	r0, r3, #31
    ac36:	mvncc.w	r0, r3, asr #31
    ac3a:	orr.w	r0, r0, #1
    ac3e:	bx	lr
    ac40:	mov.w	ip, r1, lsl #1
    ac44:	mvns.w	ip, ip, asr #21
    ac48:	bne.n	ac50 <__cmpdf2+0x64>
    ac4a:	orrs.w	ip, r0, r1, lsl #12
    ac4e:	bne.n	ac60 <__cmpdf2+0x74>
    ac50:	mov.w	ip, r3, lsl #1
    ac54:	mvns.w	ip, ip, asr #21
    ac58:	bne.n	ac08 <__cmpdf2+0x1c>
    ac5a:	orrs.w	ip, r2, r3, lsl #12
    ac5e:	beq.n	ac08 <__cmpdf2+0x1c>
    ac60:	ldr.w	r0, [sp], #4
    ac64:	bx	lr
    ac66:	nop

0000ac68 <__aeabi_cdrcmple>:
    ac68:	mov	ip, r0
    ac6a:	mov	r0, r2
    ac6c:	mov	r2, ip
    ac6e:	mov	ip, r1
    ac70:	mov	r1, r3
    ac72:	mov	r3, ip
    ac74:	b.n	ac78 <__aeabi_cdcmpeq>
    ac76:	nop

0000ac78 <__aeabi_cdcmpeq>:
    ac78:	push	{r0, lr}
    ac7a:	bl	abec <__cmpdf2>
    ac7e:	cmp	r0, #0
    ac80:	it	mi
    ac82:	cmnmi.w	r0, #0
    ac86:	pop	{r0, pc}

0000ac88 <__aeabi_dcmpeq>:
    ac88:	str.w	lr, [sp, #-8]!
    ac8c:	bl	ac78 <__aeabi_cdcmpeq>
    ac90:	ite	eq
    ac92:	moveq	r0, #1
    ac94:	movne	r0, #0
    ac96:	ldr.w	pc, [sp], #8
    ac9a:	nop

0000ac9c <__aeabi_dcmplt>:
    ac9c:	str.w	lr, [sp, #-8]!
    aca0:	bl	ac78 <__aeabi_cdcmpeq>
    aca4:	ite	cc
    aca6:	movcc	r0, #1
    aca8:	movcs	r0, #0
    acaa:	ldr.w	pc, [sp], #8
    acae:	nop

0000acb0 <__aeabi_dcmple>:
    acb0:	str.w	lr, [sp, #-8]!
    acb4:	bl	ac78 <__aeabi_cdcmpeq>
    acb8:	ite	ls
    acba:	movls	r0, #1
    acbc:	movhi	r0, #0
    acbe:	ldr.w	pc, [sp], #8
    acc2:	nop

0000acc4 <__aeabi_dcmpge>:
    acc4:	str.w	lr, [sp, #-8]!
    acc8:	bl	ac68 <__aeabi_cdrcmple>
    accc:	ite	ls
    acce:	movls	r0, #1
    acd0:	movhi	r0, #0
    acd2:	ldr.w	pc, [sp], #8
    acd6:	nop

0000acd8 <__aeabi_dcmpgt>:
    acd8:	str.w	lr, [sp, #-8]!
    acdc:	bl	ac68 <__aeabi_cdrcmple>
    ace0:	ite	cc
    ace2:	movcc	r0, #1
    ace4:	movcs	r0, #0
    ace6:	ldr.w	pc, [sp], #8
    acea:	nop

0000acec <__aeabi_dcmpun>:
    acec:	mov.w	ip, r1, lsl #1
    acf0:	mvns.w	ip, ip, asr #21
    acf4:	bne.n	acfc <__aeabi_dcmpun+0x10>
    acf6:	orrs.w	ip, r0, r1, lsl #12
    acfa:	bne.n	ad12 <__aeabi_dcmpun+0x26>
    acfc:	mov.w	ip, r3, lsl #1
    ad00:	mvns.w	ip, ip, asr #21
    ad04:	bne.n	ad0c <__aeabi_dcmpun+0x20>
    ad06:	orrs.w	ip, r2, r3, lsl #12
    ad0a:	bne.n	ad12 <__aeabi_dcmpun+0x26>
    ad0c:	mov.w	r0, #0
    ad10:	bx	lr
    ad12:	mov.w	r0, #1
    ad16:	bx	lr

0000ad18 <__aeabi_d2iz>:
    ad18:	mov.w	r2, r1, lsl #1
    ad1c:	adds.w	r2, r2, #2097152	; 0x200000
    ad20:	bcs.n	ad4e <__aeabi_d2iz+0x36>
    ad22:	bpl.n	ad48 <__aeabi_d2iz+0x30>
    ad24:	mvn.w	r3, #992	; 0x3e0
    ad28:	subs.w	r2, r3, r2, asr #21
    ad2c:	bls.n	ad54 <__aeabi_d2iz+0x3c>
    ad2e:	mov.w	r3, r1, lsl #11
    ad32:	orr.w	r3, r3, #2147483648	; 0x80000000
    ad36:	orr.w	r3, r3, r0, lsr #21
    ad3a:	tst.w	r1, #2147483648	; 0x80000000
    ad3e:	lsr.w	r0, r3, r2
    ad42:	it	ne
    ad44:	negne	r0, r0
    ad46:	bx	lr
    ad48:	mov.w	r0, #0
    ad4c:	bx	lr
    ad4e:	orrs.w	r0, r0, r1, lsl #12
    ad52:	bne.n	ad60 <__aeabi_d2iz+0x48>
    ad54:	ands.w	r0, r1, #2147483648	; 0x80000000
    ad58:	it	eq
    ad5a:	mvneq.w	r0, #2147483648	; 0x80000000
    ad5e:	bx	lr
    ad60:	mov.w	r0, #0
    ad64:	bx	lr
    ad66:	nop

0000ad68 <__aeabi_d2uiz>:
    ad68:	lsls	r2, r1, #1
    ad6a:	bcs.n	ad90 <__aeabi_d2uiz+0x28>
    ad6c:	adds.w	r2, r2, #2097152	; 0x200000
    ad70:	bcs.n	ad96 <__aeabi_d2uiz+0x2e>
    ad72:	bpl.n	ad90 <__aeabi_d2uiz+0x28>
    ad74:	mvn.w	r3, #992	; 0x3e0
    ad78:	subs.w	r2, r3, r2, asr #21
    ad7c:	bmi.n	ad9c <__aeabi_d2uiz+0x34>
    ad7e:	mov.w	r3, r1, lsl #11
    ad82:	orr.w	r3, r3, #2147483648	; 0x80000000
    ad86:	orr.w	r3, r3, r0, lsr #21
    ad8a:	lsr.w	r0, r3, r2
    ad8e:	bx	lr
    ad90:	mov.w	r0, #0
    ad94:	bx	lr
    ad96:	orrs.w	r0, r0, r1, lsl #12
    ad9a:	bne.n	ada2 <__aeabi_d2uiz+0x3a>
    ad9c:	mov.w	r0, #4294967295
    ada0:	bx	lr
    ada2:	mov.w	r0, #0
    ada6:	bx	lr

0000ada8 <__aeabi_d2f>:
    ada8:	mov.w	r2, r1, lsl #1
    adac:	subs.w	r3, r2, #1879048192	; 0x70000000
    adb0:	itt	cs
    adb2:	subscs.w	ip, r3, #2097152	; 0x200000
    adb6:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    adba:	bls.n	add8 <__aeabi_d2f+0x30>
    adbc:	and.w	ip, r1, #2147483648	; 0x80000000
    adc0:	mov.w	r2, r0, lsl #3
    adc4:	orr.w	r0, ip, r0, lsr #29
    adc8:	cmp.w	r2, #2147483648	; 0x80000000
    adcc:	adc.w	r0, r0, r3, lsl #2
    add0:	it	eq
    add2:	biceq.w	r0, r0, #1
    add6:	bx	lr
    add8:	tst.w	r1, #1073741824	; 0x40000000
    addc:	bne.n	ae22 <__aeabi_d2f+0x7a>
    adde:	adds.w	r2, r3, #48234496	; 0x2e00000
    ade2:	itt	lt
    ade4:	andlt.w	r0, r1, #2147483648	; 0x80000000
    ade8:	bxlt	lr
    adea:	orr.w	r1, r1, #1048576	; 0x100000
    adee:	mov.w	r2, r2, lsr #21
    adf2:	rsb	r2, r2, #24
    adf6:	rsb	ip, r2, #32
    adfa:	lsls.w	r3, r0, ip
    adfe:	lsr.w	r0, r0, r2
    ae02:	it	ne
    ae04:	orrne.w	r0, r0, #1
    ae08:	mov.w	r3, r1, lsl #11
    ae0c:	mov.w	r3, r3, lsr #11
    ae10:	lsl.w	ip, r3, ip
    ae14:	orr.w	r0, r0, ip
    ae18:	lsr.w	r3, r3, r2
    ae1c:	mov.w	r3, r3, lsl #1
    ae20:	b.n	adbc <__aeabi_d2f+0x14>
    ae22:	mvns.w	r3, r2, asr #21
    ae26:	bne.n	ae38 <__aeabi_d2f+0x90>
    ae28:	orrs.w	r3, r0, r1, lsl #12
    ae2c:	ittt	ne
    ae2e:	movne.w	r0, #2130706432	; 0x7f000000
    ae32:	orrne.w	r0, r0, #12582912	; 0xc00000
    ae36:	bxne	lr
    ae38:	and.w	r0, r1, #2147483648	; 0x80000000
    ae3c:	orr.w	r0, r0, #2130706432	; 0x7f000000
    ae40:	orr.w	r0, r0, #8388608	; 0x800000
    ae44:	bx	lr
    ae46:	nop

0000ae48 <__aeabi_frsub>:
    ae48:	eor.w	r0, r0, #2147483648	; 0x80000000
    ae4c:	b.n	ae54 <__addsf3>
    ae4e:	nop

0000ae50 <__aeabi_fsub>:
    ae50:	eor.w	r1, r1, #2147483648	; 0x80000000

0000ae54 <__addsf3>:
    ae54:	lsls	r2, r0, #1
    ae56:	itttt	ne
    ae58:	movsne.w	r3, r1, lsl #1
    ae5c:	teqne	r2, r3
    ae60:	mvnsne.w	ip, r2, asr #24
    ae64:	mvnsne.w	ip, r3, asr #24
    ae68:	beq.n	af40 <__addsf3+0xec>
    ae6a:	mov.w	r2, r2, lsr #24
    ae6e:	rsbs	r3, r2, r3, lsr #24
    ae72:	itttt	gt
    ae74:	addgt	r2, r2, r3
    ae76:	eorgt	r1, r0
    ae78:	eorgt	r0, r1
    ae7a:	eorgt	r1, r0
    ae7c:	it	lt
    ae7e:	neglt	r3, r3
    ae80:	cmp	r3, #25
    ae82:	it	hi
    ae84:	bxhi	lr
    ae86:	tst.w	r0, #2147483648	; 0x80000000
    ae8a:	orr.w	r0, r0, #8388608	; 0x800000
    ae8e:	bic.w	r0, r0, #4278190080	; 0xff000000
    ae92:	it	ne
    ae94:	negne	r0, r0
    ae96:	tst.w	r1, #2147483648	; 0x80000000
    ae9a:	orr.w	r1, r1, #8388608	; 0x800000
    ae9e:	bic.w	r1, r1, #4278190080	; 0xff000000
    aea2:	it	ne
    aea4:	negne	r1, r1
    aea6:	teq	r2, r3
    aeaa:	beq.n	af2c <__addsf3+0xd8>
    aeac:	sub.w	r2, r2, #1
    aeb0:	asr.w	ip, r1, r3
    aeb4:	adds.w	r0, r0, ip
    aeb8:	rsb	r3, r3, #32
    aebc:	lsl.w	r1, r1, r3
    aec0:	and.w	r3, r0, #2147483648	; 0x80000000
    aec4:	bpl.n	aecc <__addsf3+0x78>
    aec6:	negs	r1, r1
    aec8:	sbc.w	r0, r0, r0, lsl #1
    aecc:	cmp.w	r0, #8388608	; 0x800000
    aed0:	bcc.n	aefa <__addsf3+0xa6>
    aed2:	cmp.w	r0, #16777216	; 0x1000000
    aed6:	bcc.n	aee6 <__addsf3+0x92>
    aed8:	lsrs	r0, r0, #1
    aeda:	mov.w	r1, r1, rrx
    aede:	add.w	r2, r2, #1
    aee2:	cmp	r2, #254	; 0xfe
    aee4:	bcs.n	af8a <__addsf3+0x136>
    aee6:	cmp.w	r1, #2147483648	; 0x80000000
    aeea:	adc.w	r0, r0, r2, lsl #23
    aeee:	it	eq
    aef0:	biceq.w	r0, r0, #1
    aef4:	orr.w	r0, r0, r3
    aef8:	bx	lr
    aefa:	lsls	r1, r1, #1
    aefc:	adc.w	r0, r0, r0
    af00:	tst.w	r0, #8388608	; 0x800000
    af04:	sub.w	r2, r2, #1
    af08:	bne.n	aee6 <__addsf3+0x92>
    af0a:	clz	ip, r0
    af0e:	sub.w	ip, ip, #8
    af12:	subs.w	r2, r2, ip
    af16:	lsl.w	r0, r0, ip
    af1a:	itet	ge
    af1c:	addge.w	r0, r0, r2, lsl #23
    af20:	neglt	r2, r2
    af22:	orrge	r0, r3
    af24:	itt	lt
    af26:	lsrlt	r0, r2
    af28:	orrlt	r0, r3
    af2a:	bx	lr
    af2c:	teq	r2, #0
    af30:	eor.w	r1, r1, #8388608	; 0x800000
    af34:	itte	eq
    af36:	eoreq.w	r0, r0, #8388608	; 0x800000
    af3a:	addeq	r2, #1
    af3c:	subne	r3, #1
    af3e:	b.n	aeac <__addsf3+0x58>
    af40:	mov.w	r3, r1, lsl #1
    af44:	mvns.w	ip, r2, asr #24
    af48:	it	ne
    af4a:	mvnsne.w	ip, r3, asr #24
    af4e:	beq.n	af94 <__addsf3+0x140>
    af50:	teq	r2, r3
    af54:	beq.n	af60 <__addsf3+0x10c>
    af56:	teq	r2, #0
    af5a:	it	eq
    af5c:	moveq	r0, r1
    af5e:	bx	lr
    af60:	teq	r0, r1
    af64:	itt	ne
    af66:	movne	r0, #0
    af68:	bxne	lr
    af6a:	tst.w	r2, #4278190080	; 0xff000000
    af6e:	bne.n	af7a <__addsf3+0x126>
    af70:	lsls	r0, r0, #1
    af72:	it	cs
    af74:	orrcs.w	r0, r0, #2147483648	; 0x80000000
    af78:	bx	lr
    af7a:	adds.w	r2, r2, #33554432	; 0x2000000
    af7e:	itt	cc
    af80:	addcc.w	r0, r0, #8388608	; 0x800000
    af84:	bxcc	lr
    af86:	and.w	r3, r0, #2147483648	; 0x80000000
    af8a:	orr.w	r0, r3, #2130706432	; 0x7f000000
    af8e:	orr.w	r0, r0, #8388608	; 0x800000
    af92:	bx	lr
    af94:	mvns.w	r2, r2, asr #24
    af98:	itet	ne
    af9a:	movne	r0, r1
    af9c:	mvnseq.w	r3, r3, asr #24
    afa0:	movne	r1, r0
    afa2:	lsls	r2, r0, #9
    afa4:	itte	eq
    afa6:	movseq.w	r3, r1, lsl #9
    afaa:	teqeq	r0, r1
    afae:	orrne.w	r0, r0, #4194304	; 0x400000
    afb2:	bx	lr

0000afb4 <__aeabi_ui2f>:
    afb4:	mov.w	r3, #0
    afb8:	b.n	afc4 <__aeabi_i2f+0x8>
    afba:	nop

0000afbc <__aeabi_i2f>:
    afbc:	ands.w	r3, r0, #2147483648	; 0x80000000
    afc0:	it	mi
    afc2:	negmi	r0, r0
    afc4:	movs.w	ip, r0
    afc8:	it	eq
    afca:	bxeq	lr
    afcc:	orr.w	r3, r3, #1258291200	; 0x4b000000
    afd0:	mov	r1, r0
    afd2:	mov.w	r0, #0
    afd6:	b.n	b012 <__aeabi_l2f+0x2a>

0000afd8 <__aeabi_ul2f>:
    afd8:	orrs.w	r2, r0, r1
    afdc:	it	eq
    afde:	bxeq	lr
    afe0:	mov.w	r3, #0
    afe4:	b.n	affc <__aeabi_l2f+0x14>
    afe6:	nop

0000afe8 <__aeabi_l2f>:
    afe8:	orrs.w	r2, r0, r1
    afec:	it	eq
    afee:	bxeq	lr
    aff0:	ands.w	r3, r1, #2147483648	; 0x80000000
    aff4:	bpl.n	affc <__aeabi_l2f+0x14>
    aff6:	negs	r0, r0
    aff8:	sbc.w	r1, r1, r1, lsl #1
    affc:	movs.w	ip, r1
    b000:	ittt	eq
    b002:	moveq	ip, r0
    b004:	moveq	r1, r0
    b006:	moveq	r0, #0
    b008:	orr.w	r3, r3, #1526726656	; 0x5b000000
    b00c:	it	eq
    b00e:	subeq.w	r3, r3, #268435456	; 0x10000000
    b012:	sub.w	r3, r3, #8388608	; 0x800000
    b016:	clz	r2, ip
    b01a:	subs	r2, #8
    b01c:	sub.w	r3, r3, r2, lsl #23
    b020:	blt.n	b044 <__aeabi_l2f+0x5c>
    b022:	lsl.w	ip, r1, r2
    b026:	add	r3, ip
    b028:	lsl.w	ip, r0, r2
    b02c:	rsb	r2, r2, #32
    b030:	cmp.w	ip, #2147483648	; 0x80000000
    b034:	lsr.w	r2, r0, r2
    b038:	adc.w	r0, r3, r2
    b03c:	it	eq
    b03e:	biceq.w	r0, r0, #1
    b042:	bx	lr
    b044:	add.w	r2, r2, #32
    b048:	lsl.w	ip, r1, r2
    b04c:	rsb	r2, r2, #32
    b050:	orrs.w	r0, r0, ip, lsl #1
    b054:	lsr.w	r2, r1, r2
    b058:	adc.w	r0, r3, r2
    b05c:	it	eq
    b05e:	biceq.w	r0, r0, ip, lsr #31
    b062:	bx	lr

0000b064 <__aeabi_uldivmod>:
    b064:	cbnz	r3, b07c <__aeabi_uldivmod+0x18>
    b066:	cbnz	r2, b07c <__aeabi_uldivmod+0x18>
    b068:	cmp	r1, #0
    b06a:	it	eq
    b06c:	cmpeq	r0, #0
    b06e:	itt	ne
    b070:	movne.w	r1, #4294967295
    b074:	movne.w	r0, #4294967295
    b078:	b.w	b3e8 <__aeabi_idiv0>
    b07c:	sub.w	ip, sp, #8
    b080:	strd	ip, lr, [sp, #-16]!
    b084:	bl	b104 <__udivmoddi4>
    b088:	ldr.w	lr, [sp, #4]
    b08c:	ldrd	r2, r3, [sp, #8]
    b090:	add	sp, #16
    b092:	bx	lr

0000b094 <__aeabi_f2lz>:
    b094:	vmov	s15, r0
    b098:	vcmpe.f32	s15, #0.0
    b09c:	vmrs	APSR_nzcv, fpscr
    b0a0:	bmi.n	b0a6 <__aeabi_f2lz+0x12>
    b0a2:	b.w	b0b8 <__aeabi_f2ulz>
    b0a6:	push	{r3, lr}
    b0a8:	eor.w	r0, r0, #2147483648	; 0x80000000
    b0ac:	bl	b0b8 <__aeabi_f2ulz>
    b0b0:	negs	r0, r0
    b0b2:	sbc.w	r1, r1, r1, lsl #1
    b0b6:	pop	{r3, pc}

0000b0b8 <__aeabi_f2ulz>:
    b0b8:	push	{r4, r6, r7, lr}
    b0ba:	bl	a710 <__aeabi_f2d>
    b0be:	movs	r2, #0
    b0c0:	ldr	r3, [pc, #56]	; (b0fc <__aeabi_f2ulz+0x44>)
    b0c2:	mov	r6, r0
    b0c4:	mov	r7, r1
    b0c6:	bl	a7b8 <__aeabi_dmul>
    b0ca:	bl	ad68 <__aeabi_d2uiz>
    b0ce:	mov	r4, r0
    b0d0:	bl	a6cc <__aeabi_ui2d>
    b0d4:	movs	r2, #0
    b0d6:	ldr	r3, [pc, #40]	; (b100 <__aeabi_f2ulz+0x48>)
    b0d8:	bl	a7b8 <__aeabi_dmul>
    b0dc:	mov	r2, r0
    b0de:	mov	r3, r1
    b0e0:	mov	r0, r6
    b0e2:	mov	r1, r7
    b0e4:	bl	a450 <__aeabi_dsub>
    b0e8:	bl	ad68 <__aeabi_d2uiz>
    b0ec:	mov	r3, r4
    b0ee:	movs	r2, #0
    b0f0:	orr.w	r2, r2, r0
    b0f4:	mov	r0, r2
    b0f6:	mov	r1, r3
    b0f8:	pop	{r4, r6, r7, pc}
    b0fa:	nop
    b0fc:	.word	0x3df00000
    b100:	.word	0x41f00000

0000b104 <__udivmoddi4>:
    b104:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b108:	mov	ip, r1
    b10a:	mov	r6, r1
    b10c:	mov	r4, r0
    b10e:	ldr	r5, [sp, #32]
    b110:	cmp	r3, #0
    b112:	bne.n	b1b6 <__udivmoddi4+0xb2>
    b114:	cmp	r2, r1
    b116:	mov	r7, r2
    b118:	bls.n	b1f4 <__udivmoddi4+0xf0>
    b11a:	clz	lr, r2
    b11e:	cmp.w	lr, #0
    b122:	beq.n	b13c <__udivmoddi4+0x38>
    b124:	rsb	r4, lr, #32
    b128:	lsr.w	r4, r0, r4
    b12c:	lsl.w	r6, r1, lr
    b130:	orr.w	ip, r4, r6
    b134:	lsl.w	r7, r2, lr
    b138:	lsl.w	r4, r0, lr
    b13c:	mov.w	r9, r7, lsr #16
    b140:	lsrs	r2, r4, #16
    b142:	udiv	r0, ip, r9
    b146:	uxth.w	r8, r7
    b14a:	mls	r6, r9, r0, ip
    b14e:	orr.w	r6, r2, r6, lsl #16
    b152:	mul.w	r3, r0, r8
    b156:	cmp	r3, r6
    b158:	bls.n	b16e <__udivmoddi4+0x6a>
    b15a:	adds	r6, r6, r7
    b15c:	add.w	r2, r0, #4294967295
    b160:	bcs.w	b3a8 <__udivmoddi4+0x2a4>
    b164:	cmp	r3, r6
    b166:	bls.w	b3a8 <__udivmoddi4+0x2a4>
    b16a:	subs	r0, #2
    b16c:	add	r6, r7
    b16e:	subs	r6, r6, r3
    b170:	uxth	r2, r4
    b172:	udiv	r3, r6, r9
    b176:	mls	r6, r9, r3, r6
    b17a:	orr.w	r4, r2, r6, lsl #16
    b17e:	mul.w	r8, r3, r8
    b182:	cmp	r8, r4
    b184:	bls.n	b19a <__udivmoddi4+0x96>
    b186:	adds	r4, r4, r7
    b188:	add.w	r2, r3, #4294967295
    b18c:	bcs.w	b3a4 <__udivmoddi4+0x2a0>
    b190:	cmp	r8, r4
    b192:	bls.w	b3a4 <__udivmoddi4+0x2a0>
    b196:	subs	r3, #2
    b198:	add	r4, r7
    b19a:	rsb	r4, r8, r4
    b19e:	orr.w	r0, r3, r0, lsl #16
    b1a2:	movs	r1, #0
    b1a4:	cmp	r5, #0
    b1a6:	beq.n	b26e <__udivmoddi4+0x16a>
    b1a8:	lsr.w	r4, r4, lr
    b1ac:	movs	r3, #0
    b1ae:	str	r4, [r5, #0]
    b1b0:	str	r3, [r5, #4]
    b1b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b1b6:	cmp	r3, r1
    b1b8:	bls.n	b1ca <__udivmoddi4+0xc6>
    b1ba:	cmp	r5, #0
    b1bc:	beq.n	b26a <__udivmoddi4+0x166>
    b1be:	movs	r1, #0
    b1c0:	stmia.w	r5, {r0, r6}
    b1c4:	mov	r0, r1
    b1c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b1ca:	clz	r1, r3
    b1ce:	cmp	r1, #0
    b1d0:	bne.w	b2f4 <__udivmoddi4+0x1f0>
    b1d4:	cmp	r3, r6
    b1d6:	bcc.n	b1de <__udivmoddi4+0xda>
    b1d8:	cmp	r2, r0
    b1da:	bhi.w	b3ce <__udivmoddi4+0x2ca>
    b1de:	subs	r4, r0, r2
    b1e0:	sbc.w	r6, r6, r3
    b1e4:	movs	r0, #1
    b1e6:	mov	ip, r6
    b1e8:	cmp	r5, #0
    b1ea:	beq.n	b26e <__udivmoddi4+0x16a>
    b1ec:	stmia.w	r5, {r4, ip}
    b1f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b1f4:	cbnz	r2, b1fc <__udivmoddi4+0xf8>
    b1f6:	movs	r7, #1
    b1f8:	udiv	r7, r7, r2
    b1fc:	clz	lr, r7
    b200:	cmp.w	lr, #0
    b204:	bne.n	b272 <__udivmoddi4+0x16e>
    b206:	subs	r3, r6, r7
    b208:	mov.w	r8, r7, lsr #16
    b20c:	uxth.w	ip, r7
    b210:	movs	r1, #1
    b212:	udiv	r0, r3, r8
    b216:	lsrs	r2, r4, #16
    b218:	mls	r6, r8, r0, r3
    b21c:	orr.w	r6, r2, r6, lsl #16
    b220:	mul.w	r3, ip, r0
    b224:	cmp	r3, r6
    b226:	bls.n	b238 <__udivmoddi4+0x134>
    b228:	adds	r6, r6, r7
    b22a:	add.w	r2, r0, #4294967295
    b22e:	bcs.n	b236 <__udivmoddi4+0x132>
    b230:	cmp	r3, r6
    b232:	bhi.w	b3d2 <__udivmoddi4+0x2ce>
    b236:	mov	r0, r2
    b238:	subs	r6, r6, r3
    b23a:	uxth	r2, r4
    b23c:	udiv	r3, r6, r8
    b240:	mls	r6, r8, r3, r6
    b244:	orr.w	r4, r2, r6, lsl #16
    b248:	mul.w	ip, ip, r3
    b24c:	cmp	ip, r4
    b24e:	bls.n	b260 <__udivmoddi4+0x15c>
    b250:	adds	r4, r4, r7
    b252:	add.w	r2, r3, #4294967295
    b256:	bcs.n	b25e <__udivmoddi4+0x15a>
    b258:	cmp	ip, r4
    b25a:	bhi.w	b3c8 <__udivmoddi4+0x2c4>
    b25e:	mov	r3, r2
    b260:	rsb	r4, ip, r4
    b264:	orr.w	r0, r3, r0, lsl #16
    b268:	b.n	b1a4 <__udivmoddi4+0xa0>
    b26a:	mov	r1, r5
    b26c:	mov	r0, r5
    b26e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b272:	rsb	r1, lr, #32
    b276:	lsl.w	r3, r6, lr
    b27a:	lsl.w	r7, r7, lr
    b27e:	lsr.w	r9, r0, r1
    b282:	mov.w	r8, r7, lsr #16
    b286:	lsrs	r6, r1
    b288:	orr.w	r9, r9, r3
    b28c:	udiv	sl, r6, r8
    b290:	mov.w	r4, r9, lsr #16
    b294:	mls	r6, r8, sl, r6
    b298:	uxth.w	ip, r7
    b29c:	orr.w	r3, r4, r6, lsl #16
    b2a0:	mul.w	r2, sl, ip
    b2a4:	cmp	r2, r3
    b2a6:	lsl.w	r4, r0, lr
    b2aa:	bls.n	b2c2 <__udivmoddi4+0x1be>
    b2ac:	adds	r3, r3, r7
    b2ae:	add.w	r1, sl, #4294967295
    b2b2:	bcs.w	b3c4 <__udivmoddi4+0x2c0>
    b2b6:	cmp	r2, r3
    b2b8:	bls.w	b3c4 <__udivmoddi4+0x2c0>
    b2bc:	sub.w	sl, sl, #2
    b2c0:	add	r3, r7
    b2c2:	subs	r3, r3, r2
    b2c4:	uxth.w	r9, r9
    b2c8:	udiv	r1, r3, r8
    b2cc:	mls	r3, r8, r1, r3
    b2d0:	orr.w	r3, r9, r3, lsl #16
    b2d4:	mul.w	r6, r1, ip
    b2d8:	cmp	r6, r3
    b2da:	bls.n	b2ec <__udivmoddi4+0x1e8>
    b2dc:	adds	r3, r3, r7
    b2de:	add.w	r2, r1, #4294967295
    b2e2:	bcs.n	b3bc <__udivmoddi4+0x2b8>
    b2e4:	cmp	r6, r3
    b2e6:	bls.n	b3bc <__udivmoddi4+0x2b8>
    b2e8:	subs	r1, #2
    b2ea:	add	r3, r7
    b2ec:	subs	r3, r3, r6
    b2ee:	orr.w	r1, r1, sl, lsl #16
    b2f2:	b.n	b212 <__udivmoddi4+0x10e>
    b2f4:	rsb	lr, r1, #32
    b2f8:	lsr.w	r4, r2, lr
    b2fc:	lsls	r3, r1
    b2fe:	orrs	r3, r4
    b300:	lsr.w	r7, r0, lr
    b304:	lsl.w	r4, r6, r1
    b308:	mov.w	ip, r3, lsr #16
    b30c:	lsr.w	r6, r6, lr
    b310:	orrs	r4, r7
    b312:	udiv	r9, r6, ip
    b316:	lsrs	r7, r4, #16
    b318:	mls	r6, ip, r9, r6
    b31c:	uxth.w	r8, r3
    b320:	orr.w	r6, r7, r6, lsl #16
    b324:	mul.w	r7, r9, r8
    b328:	cmp	r7, r6
    b32a:	lsl.w	r2, r2, r1
    b32e:	lsl.w	sl, r0, r1
    b332:	bls.n	b346 <__udivmoddi4+0x242>
    b334:	adds	r6, r6, r3
    b336:	add.w	r0, r9, #4294967295
    b33a:	bcs.n	b3c0 <__udivmoddi4+0x2bc>
    b33c:	cmp	r7, r6
    b33e:	bls.n	b3c0 <__udivmoddi4+0x2bc>
    b340:	sub.w	r9, r9, #2
    b344:	add	r6, r3
    b346:	subs	r6, r6, r7
    b348:	uxth	r0, r4
    b34a:	udiv	r4, r6, ip
    b34e:	mls	r6, ip, r4, r6
    b352:	orr.w	r7, r0, r6, lsl #16
    b356:	mul.w	r8, r4, r8
    b35a:	cmp	r8, r7
    b35c:	bls.n	b36e <__udivmoddi4+0x26a>
    b35e:	adds	r7, r7, r3
    b360:	add.w	r0, r4, #4294967295
    b364:	bcs.n	b3b8 <__udivmoddi4+0x2b4>
    b366:	cmp	r8, r7
    b368:	bls.n	b3b8 <__udivmoddi4+0x2b4>
    b36a:	subs	r4, #2
    b36c:	add	r7, r3
    b36e:	orr.w	r0, r4, r9, lsl #16
    b372:	rsb	r7, r8, r7
    b376:	umull	r8, r9, r0, r2
    b37a:	cmp	r7, r9
    b37c:	mov	r4, r8
    b37e:	mov	r6, r9
    b380:	bcc.n	b3ac <__udivmoddi4+0x2a8>
    b382:	beq.n	b3d8 <__udivmoddi4+0x2d4>
    b384:	cbz	r5, b3e0 <__udivmoddi4+0x2dc>
    b386:	subs.w	r3, sl, r4
    b38a:	sbc.w	r7, r7, r6
    b38e:	lsl.w	lr, r7, lr
    b392:	lsrs	r3, r1
    b394:	lsrs	r7, r1
    b396:	orr.w	r3, lr, r3
    b39a:	stmia.w	r5, {r3, r7}
    b39e:	movs	r1, #0
    b3a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b3a4:	mov	r3, r2
    b3a6:	b.n	b19a <__udivmoddi4+0x96>
    b3a8:	mov	r0, r2
    b3aa:	b.n	b16e <__udivmoddi4+0x6a>
    b3ac:	subs.w	r4, r8, r2
    b3b0:	sbc.w	r6, r9, r3
    b3b4:	subs	r0, #1
    b3b6:	b.n	b384 <__udivmoddi4+0x280>
    b3b8:	mov	r4, r0
    b3ba:	b.n	b36e <__udivmoddi4+0x26a>
    b3bc:	mov	r1, r2
    b3be:	b.n	b2ec <__udivmoddi4+0x1e8>
    b3c0:	mov	r9, r0
    b3c2:	b.n	b346 <__udivmoddi4+0x242>
    b3c4:	mov	sl, r1
    b3c6:	b.n	b2c2 <__udivmoddi4+0x1be>
    b3c8:	subs	r3, #2
    b3ca:	add	r4, r7
    b3cc:	b.n	b260 <__udivmoddi4+0x15c>
    b3ce:	mov	r0, r1
    b3d0:	b.n	b1e8 <__udivmoddi4+0xe4>
    b3d2:	subs	r0, #2
    b3d4:	add	r6, r7
    b3d6:	b.n	b238 <__udivmoddi4+0x134>
    b3d8:	cmp	sl, r8
    b3da:	bcc.n	b3ac <__udivmoddi4+0x2a8>
    b3dc:	mov	r6, r7
    b3de:	b.n	b384 <__udivmoddi4+0x280>
    b3e0:	mov	r1, r5
    b3e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b3e6:	nop

0000b3e8 <__aeabi_idiv0>:
    b3e8:	bx	lr
    b3ea:	nop

0000b3ec <__cxa_atexit>:
    b3ec:	mov	r3, r2
    b3ee:	mov	r2, r1
    b3f0:	mov	r1, r0
    b3f2:	movs	r0, #2
    b3f4:	b.w	faa8 <__register_exitproc>

0000b3f8 <__errno>:
    b3f8:	ldr	r3, [pc, #4]	; (b400 <__errno+0x8>)
    b3fa:	ldr	r0, [r3, #0]
    b3fc:	bx	lr
    b3fe:	nop
    b400:	.word	0x20014230

0000b404 <__libc_init_array>:
    b404:	push	{r4, r5, r6, lr}
    b406:	ldr	r6, [pc, #60]	; (b444 <__libc_init_array+0x40>)
    b408:	ldr	r5, [pc, #60]	; (b448 <__libc_init_array+0x44>)
    b40a:	subs	r6, r6, r5
    b40c:	asrs	r6, r6, #2
    b40e:	it	ne
    b410:	movne	r4, #0
    b412:	beq.n	b420 <__libc_init_array+0x1c>
    b414:	adds	r4, #1
    b416:	ldr.w	r3, [r5], #4
    b41a:	blx	r3
    b41c:	cmp	r6, r4
    b41e:	bne.n	b414 <__libc_init_array+0x10>
    b420:	ldr	r6, [pc, #40]	; (b44c <__libc_init_array+0x48>)
    b422:	ldr	r5, [pc, #44]	; (b450 <__libc_init_array+0x4c>)
    b424:	subs	r6, r6, r5
    b426:	bl	13804 <_init>
    b42a:	asrs	r6, r6, #2
    b42c:	it	ne
    b42e:	movne	r4, #0
    b430:	beq.n	b440 <__libc_init_array+0x3c>
    b432:	adds	r4, #1
    b434:	ldr.w	r3, [r5], #4
    b438:	blx	r3
    b43a:	cmp	r6, r4
    b43c:	bne.n	b432 <__libc_init_array+0x2e>
    b43e:	pop	{r4, r5, r6, pc}
    b440:	pop	{r4, r5, r6, pc}
    b442:	nop
    b444:	.word	0x00013810
    b448:	.word	0x00013810
    b44c:	.word	0x00013864
    b450:	.word	0x00013810

0000b454 <__get_current_locale>:
    b454:	ldr	r2, [pc, #12]	; (b464 <__get_current_locale+0x10>)
    b456:	ldr	r3, [pc, #16]	; (b468 <__get_current_locale+0x14>)
    b458:	ldr	r2, [r2, #0]
    b45a:	ldr	r0, [r2, #52]	; 0x34
    b45c:	cmp	r0, #0
    b45e:	it	eq
    b460:	moveq	r0, r3
    b462:	bx	lr
    b464:	.word	0x20014230
    b468:	.word	0x20014234

0000b46c <__locale_mb_cur_max>:
    b46c:	ldr	r3, [pc, #16]	; (b480 <__locale_mb_cur_max+0x14>)
    b46e:	ldr	r2, [pc, #20]	; (b484 <__locale_mb_cur_max+0x18>)
    b470:	ldr	r3, [r3, #0]
    b472:	ldr	r3, [r3, #52]	; 0x34
    b474:	cmp	r3, #0
    b476:	it	eq
    b478:	moveq	r3, r2
    b47a:	ldrb.w	r0, [r3, #296]	; 0x128
    b47e:	bx	lr
    b480:	.word	0x20014230
    b484:	.word	0x20014234

0000b488 <__locale_ctype_ptr_l>:
    b488:	ldr.w	r0, [r0, #236]	; 0xec
    b48c:	bx	lr
    b48e:	nop

0000b490 <__locale_ctype_ptr>:
    b490:	push	{r3, lr}
    b492:	ldr	r3, [pc, #12]	; (b4a0 <__locale_ctype_ptr+0x10>)
    b494:	ldr	r0, [r3, #0]
    b496:	bl	b454 <__get_current_locale>
    b49a:	ldr.w	r0, [r0, #236]	; 0xec
    b49e:	pop	{r3, pc}
    b4a0:	.word	0x20014230

0000b4a4 <malloc>:
    b4a4:	ldr	r3, [pc, #8]	; (b4b0 <malloc+0xc>)
    b4a6:	mov	r1, r0
    b4a8:	ldr	r0, [r3, #0]
    b4aa:	b.w	b4c4 <_malloc_r>
    b4ae:	nop
    b4b0:	.word	0x20014230

0000b4b4 <free>:
    b4b4:	ldr	r3, [pc, #8]	; (b4c0 <free+0xc>)
    b4b6:	mov	r1, r0
    b4b8:	ldr	r0, [r3, #0]
    b4ba:	b.w	10b90 <_free_r>
    b4be:	nop
    b4c0:	.word	0x20014230

0000b4c4 <_malloc_r>:
    b4c4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b4c8:	add.w	r5, r1, #11
    b4cc:	cmp	r5, #22
    b4ce:	sub	sp, #12
    b4d0:	mov	r6, r0
    b4d2:	bls.w	b614 <_malloc_r+0x150>
    b4d6:	bics.w	r5, r5, #7
    b4da:	bmi.w	b65c <_malloc_r+0x198>
    b4de:	cmp	r1, r5
    b4e0:	bhi.w	b65c <_malloc_r+0x198>
    b4e4:	bl	bc2c <__malloc_lock>
    b4e8:	cmp.w	r5, #504	; 0x1f8
    b4ec:	bcc.w	ba28 <_malloc_r+0x564>
    b4f0:	lsrs	r3, r5, #9
    b4f2:	beq.w	b66a <_malloc_r+0x1a6>
    b4f6:	cmp	r3, #4
    b4f8:	bhi.w	b802 <_malloc_r+0x33e>
    b4fc:	lsrs	r0, r5, #6
    b4fe:	add.w	lr, r0, #57	; 0x39
    b502:	mov.w	r3, lr, lsl #1
    b506:	adds	r0, #56	; 0x38
    b508:	ldr	r7, [pc, #784]	; (b81c <_malloc_r+0x358>)
    b50a:	add.w	r3, r7, r3, lsl #2
    b50e:	sub.w	r1, r3, #8
    b512:	ldr	r4, [r3, #4]
    b514:	cmp	r1, r4
    b516:	bne.n	b528 <_malloc_r+0x64>
    b518:	b.n	b674 <_malloc_r+0x1b0>
    b51a:	cmp	r2, #0
    b51c:	bge.w	b678 <_malloc_r+0x1b4>
    b520:	ldr	r4, [r4, #12]
    b522:	cmp	r1, r4
    b524:	beq.w	b674 <_malloc_r+0x1b0>
    b528:	ldr	r3, [r4, #4]
    b52a:	bic.w	r3, r3, #3
    b52e:	subs	r2, r3, r5
    b530:	cmp	r2, #15
    b532:	ble.n	b51a <_malloc_r+0x56>
    b534:	ldr	r1, [pc, #740]	; (b81c <_malloc_r+0x358>)
    b536:	ldr	r4, [r7, #16]
    b538:	add.w	lr, r1, #8
    b53c:	cmp	r4, lr
    b53e:	beq.w	b8a8 <_malloc_r+0x3e4>
    b542:	ldr	r3, [r4, #4]
    b544:	bic.w	r3, r3, #3
    b548:	subs	r2, r3, r5
    b54a:	cmp	r2, #15
    b54c:	bgt.w	b882 <_malloc_r+0x3be>
    b550:	cmp	r2, #0
    b552:	str.w	lr, [r1, #20]
    b556:	str.w	lr, [r1, #16]
    b55a:	bge.w	b69a <_malloc_r+0x1d6>
    b55e:	cmp.w	r3, #512	; 0x200
    b562:	bcs.w	b834 <_malloc_r+0x370>
    b566:	lsrs	r3, r3, #3
    b568:	add.w	ip, r3, #1
    b56c:	movs	r2, #1
    b56e:	asrs	r3, r3, #2
    b570:	lsl.w	r3, r2, r3
    b574:	ldr	r2, [r1, #4]
    b576:	ldr.w	r8, [r1, ip, lsl #3]
    b57a:	str.w	r8, [r4, #8]
    b57e:	add.w	r9, r1, ip, lsl #3
    b582:	orrs	r2, r3
    b584:	sub.w	r3, r9, #8
    b588:	str	r3, [r4, #12]
    b58a:	str	r2, [r1, #4]
    b58c:	str.w	r4, [r1, ip, lsl #3]
    b590:	str.w	r4, [r8, #12]
    b594:	asrs	r3, r0, #2
    b596:	movs	r4, #1
    b598:	lsls	r4, r3
    b59a:	cmp	r4, r2
    b59c:	bhi.w	b6b4 <_malloc_r+0x1f0>
    b5a0:	tst	r4, r2
    b5a2:	bne.n	b5b2 <_malloc_r+0xee>
    b5a4:	bic.w	r0, r0, #3
    b5a8:	lsls	r4, r4, #1
    b5aa:	tst	r4, r2
    b5ac:	add.w	r0, r0, #4
    b5b0:	beq.n	b5a8 <_malloc_r+0xe4>
    b5b2:	add.w	r9, r7, r0, lsl #3
    b5b6:	mov	ip, r9
    b5b8:	mov	r8, r0
    b5ba:	ldr.w	r1, [ip, #12]
    b5be:	cmp	ip, r1
    b5c0:	bne.n	b5d2 <_malloc_r+0x10e>
    b5c2:	b.n	b8ac <_malloc_r+0x3e8>
    b5c4:	cmp	r2, #0
    b5c6:	bge.w	b8cc <_malloc_r+0x408>
    b5ca:	ldr	r1, [r1, #12]
    b5cc:	cmp	ip, r1
    b5ce:	beq.w	b8ac <_malloc_r+0x3e8>
    b5d2:	ldr	r3, [r1, #4]
    b5d4:	bic.w	r3, r3, #3
    b5d8:	subs	r2, r3, r5
    b5da:	cmp	r2, #15
    b5dc:	ble.n	b5c4 <_malloc_r+0x100>
    b5de:	mov	r4, r1
    b5e0:	ldr.w	ip, [r1, #12]
    b5e4:	ldr.w	r8, [r4, #8]!
    b5e8:	adds	r3, r1, r5
    b5ea:	orr.w	r5, r5, #1
    b5ee:	str	r5, [r1, #4]
    b5f0:	orr.w	r1, r2, #1
    b5f4:	str.w	ip, [r8, #12]
    b5f8:	mov	r0, r6
    b5fa:	str.w	r8, [ip, #8]
    b5fe:	str	r3, [r7, #20]
    b600:	str	r3, [r7, #16]
    b602:	str.w	lr, [r3, #12]
    b606:	str.w	lr, [r3, #8]
    b60a:	str	r1, [r3, #4]
    b60c:	str	r2, [r3, r2]
    b60e:	bl	bc30 <__malloc_unlock>
    b612:	b.n	b654 <_malloc_r+0x190>
    b614:	cmp	r1, #16
    b616:	bhi.n	b65c <_malloc_r+0x198>
    b618:	bl	bc2c <__malloc_lock>
    b61c:	movs	r5, #16
    b61e:	movs	r3, #6
    b620:	movs	r0, #2
    b622:	ldr	r7, [pc, #504]	; (b81c <_malloc_r+0x358>)
    b624:	add.w	r3, r7, r3, lsl #2
    b628:	sub.w	r2, r3, #8
    b62c:	ldr	r4, [r3, #4]
    b62e:	cmp	r4, r2
    b630:	beq.w	b8be <_malloc_r+0x3fa>
    b634:	ldr	r3, [r4, #4]
    b636:	ldr	r1, [r4, #12]
    b638:	ldr	r5, [r4, #8]
    b63a:	bic.w	r3, r3, #3
    b63e:	add	r3, r4
    b640:	mov	r0, r6
    b642:	ldr	r2, [r3, #4]
    b644:	str	r1, [r5, #12]
    b646:	orr.w	r2, r2, #1
    b64a:	str	r5, [r1, #8]
    b64c:	str	r2, [r3, #4]
    b64e:	bl	bc30 <__malloc_unlock>
    b652:	adds	r4, #8
    b654:	mov	r0, r4
    b656:	add	sp, #12
    b658:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b65c:	movs	r4, #0
    b65e:	movs	r3, #12
    b660:	mov	r0, r4
    b662:	str	r3, [r6, #0]
    b664:	add	sp, #12
    b666:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b66a:	movs	r3, #128	; 0x80
    b66c:	mov.w	lr, #64	; 0x40
    b670:	movs	r0, #63	; 0x3f
    b672:	b.n	b508 <_malloc_r+0x44>
    b674:	mov	r0, lr
    b676:	b.n	b534 <_malloc_r+0x70>
    b678:	add	r3, r4
    b67a:	ldr	r1, [r4, #12]
    b67c:	ldr	r2, [r3, #4]
    b67e:	ldr	r5, [r4, #8]
    b680:	orr.w	r2, r2, #1
    b684:	str	r1, [r5, #12]
    b686:	mov	r0, r6
    b688:	str	r5, [r1, #8]
    b68a:	str	r2, [r3, #4]
    b68c:	bl	bc30 <__malloc_unlock>
    b690:	adds	r4, #8
    b692:	mov	r0, r4
    b694:	add	sp, #12
    b696:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b69a:	add	r3, r4
    b69c:	mov	r0, r6
    b69e:	ldr	r2, [r3, #4]
    b6a0:	orr.w	r2, r2, #1
    b6a4:	str	r2, [r3, #4]
    b6a6:	bl	bc30 <__malloc_unlock>
    b6aa:	adds	r4, #8
    b6ac:	mov	r0, r4
    b6ae:	add	sp, #12
    b6b0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b6b4:	ldr	r4, [r7, #8]
    b6b6:	ldr	r3, [r4, #4]
    b6b8:	bic.w	r8, r3, #3
    b6bc:	cmp	r8, r5
    b6be:	bcc.n	b6ca <_malloc_r+0x206>
    b6c0:	rsb	r3, r5, r8
    b6c4:	cmp	r3, #15
    b6c6:	bgt.w	b7e2 <_malloc_r+0x31e>
    b6ca:	ldr	r3, [pc, #340]	; (b820 <_malloc_r+0x35c>)
    b6cc:	ldr.w	r9, [pc, #352]	; b830 <_malloc_r+0x36c>
    b6d0:	ldr	r2, [r3, #0]
    b6d2:	ldr.w	r3, [r9]
    b6d6:	adds	r3, #1
    b6d8:	add	r2, r5
    b6da:	add.w	sl, r4, r8
    b6de:	beq.w	b9a2 <_malloc_r+0x4de>
    b6e2:	add.w	r2, r2, #4096	; 0x1000
    b6e6:	adds	r2, #15
    b6e8:	bic.w	r2, r2, #4080	; 0xff0
    b6ec:	bic.w	r2, r2, #15
    b6f0:	mov	r1, r2
    b6f2:	mov	r0, r6
    b6f4:	str	r2, [sp, #4]
    b6f6:	bl	c014 <_sbrk_r>
    b6fa:	cmp.w	r0, #4294967295
    b6fe:	mov	fp, r0
    b700:	ldr	r2, [sp, #4]
    b702:	beq.w	b9b6 <_malloc_r+0x4f2>
    b706:	cmp	sl, r0
    b708:	bhi.w	b904 <_malloc_r+0x440>
    b70c:	ldr	r3, [pc, #276]	; (b824 <_malloc_r+0x360>)
    b70e:	ldr	r1, [r3, #0]
    b710:	cmp	sl, fp
    b712:	add	r1, r2
    b714:	str	r1, [r3, #0]
    b716:	beq.w	b9c0 <_malloc_r+0x4fc>
    b71a:	ldr.w	r0, [r9]
    b71e:	ldr.w	lr, [pc, #272]	; b830 <_malloc_r+0x36c>
    b722:	adds	r0, #1
    b724:	ittet	ne
    b726:	rsbne	sl, sl, fp
    b72a:	addne	r1, sl
    b72c:	streq.w	fp, [lr]
    b730:	strne	r1, [r3, #0]
    b732:	ands.w	r1, fp, #7
    b736:	beq.w	b968 <_malloc_r+0x4a4>
    b73a:	rsb	r0, r1, #8
    b73e:	rsb	r1, r1, #4096	; 0x1000
    b742:	add	fp, r0
    b744:	adds	r1, #8
    b746:	add	r2, fp
    b748:	ubfx	r2, r2, #0, #12
    b74c:	rsb	r9, r2, r1
    b750:	mov	r1, r9
    b752:	mov	r0, r6
    b754:	str	r3, [sp, #4]
    b756:	bl	c014 <_sbrk_r>
    b75a:	adds	r3, r0, #1
    b75c:	ldr	r3, [sp, #4]
    b75e:	beq.w	b9e0 <_malloc_r+0x51c>
    b762:	rsb	r2, fp, r0
    b766:	add	r2, r9
    b768:	orr.w	r2, r2, #1
    b76c:	ldr	r1, [r3, #0]
    b76e:	str.w	fp, [r7, #8]
    b772:	add	r1, r9
    b774:	cmp	r4, r7
    b776:	str.w	r2, [fp, #4]
    b77a:	str	r1, [r3, #0]
    b77c:	ldr.w	r9, [pc, #164]	; b824 <_malloc_r+0x360>
    b780:	beq.n	b7b0 <_malloc_r+0x2ec>
    b782:	cmp.w	r8, #15
    b786:	bls.w	b984 <_malloc_r+0x4c0>
    b78a:	ldr	r2, [r4, #4]
    b78c:	sub.w	r3, r8, #12
    b790:	bic.w	r3, r3, #7
    b794:	adds	r0, r4, r3
    b796:	and.w	r2, r2, #1
    b79a:	mov.w	lr, #5
    b79e:	orrs	r2, r3
    b7a0:	cmp	r3, #15
    b7a2:	str	r2, [r4, #4]
    b7a4:	str.w	lr, [r0, #4]
    b7a8:	str.w	lr, [r0, #8]
    b7ac:	bhi.w	b9e8 <_malloc_r+0x524>
    b7b0:	ldr	r3, [pc, #116]	; (b828 <_malloc_r+0x364>)
    b7b2:	ldr	r4, [r7, #8]
    b7b4:	ldr	r2, [r3, #0]
    b7b6:	cmp	r1, r2
    b7b8:	it	hi
    b7ba:	strhi	r1, [r3, #0]
    b7bc:	ldr	r3, [pc, #108]	; (b82c <_malloc_r+0x368>)
    b7be:	ldr	r2, [r3, #0]
    b7c0:	cmp	r1, r2
    b7c2:	ldr	r2, [r4, #4]
    b7c4:	it	hi
    b7c6:	strhi	r1, [r3, #0]
    b7c8:	bic.w	r2, r2, #3
    b7cc:	cmp	r5, r2
    b7ce:	sub.w	r3, r2, r5
    b7d2:	bhi.n	b7d8 <_malloc_r+0x314>
    b7d4:	cmp	r3, #15
    b7d6:	bgt.n	b7e2 <_malloc_r+0x31e>
    b7d8:	mov	r0, r6
    b7da:	bl	bc30 <__malloc_unlock>
    b7de:	movs	r4, #0
    b7e0:	b.n	b654 <_malloc_r+0x190>
    b7e2:	adds	r2, r4, r5
    b7e4:	orr.w	r3, r3, #1
    b7e8:	orr.w	r5, r5, #1
    b7ec:	str	r5, [r4, #4]
    b7ee:	mov	r0, r6
    b7f0:	str	r2, [r7, #8]
    b7f2:	str	r3, [r2, #4]
    b7f4:	bl	bc30 <__malloc_unlock>
    b7f8:	adds	r4, #8
    b7fa:	mov	r0, r4
    b7fc:	add	sp, #12
    b7fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b802:	cmp	r3, #20
    b804:	bls.n	b8ea <_malloc_r+0x426>
    b806:	cmp	r3, #84	; 0x54
    b808:	bhi.w	b954 <_malloc_r+0x490>
    b80c:	lsrs	r0, r5, #12
    b80e:	add.w	lr, r0, #111	; 0x6f
    b812:	mov.w	r3, lr, lsl #1
    b816:	adds	r0, #110	; 0x6e
    b818:	b.n	b508 <_malloc_r+0x44>
    b81a:	nop
    b81c:	.word	0x200143a0
    b820:	.word	0x2001a0ac
    b824:	.word	0x2001a0b0
    b828:	.word	0x2001a0a8
    b82c:	.word	0x2001a0a4
    b830:	.word	0x200147ac
    b834:	lsrs	r2, r3, #9
    b836:	cmp	r2, #4
    b838:	bls.n	b8f8 <_malloc_r+0x434>
    b83a:	cmp	r2, #20
    b83c:	bhi.w	b9a6 <_malloc_r+0x4e2>
    b840:	add.w	r1, r2, #92	; 0x5c
    b844:	lsls	r1, r1, #1
    b846:	adds	r2, #91	; 0x5b
    b848:	add.w	ip, r7, r1, lsl #2
    b84c:	ldr.w	r1, [r7, r1, lsl #2]
    b850:	ldr.w	r8, [pc, #476]	; ba30 <_malloc_r+0x56c>
    b854:	sub.w	ip, ip, #8
    b858:	cmp	ip, r1
    b85a:	beq.w	b96e <_malloc_r+0x4aa>
    b85e:	ldr	r2, [r1, #4]
    b860:	bic.w	r2, r2, #3
    b864:	cmp	r3, r2
    b866:	bcs.n	b86e <_malloc_r+0x3aa>
    b868:	ldr	r1, [r1, #8]
    b86a:	cmp	ip, r1
    b86c:	bne.n	b85e <_malloc_r+0x39a>
    b86e:	ldr.w	ip, [r1, #12]
    b872:	ldr	r2, [r7, #4]
    b874:	str.w	ip, [r4, #12]
    b878:	str	r1, [r4, #8]
    b87a:	str.w	r4, [ip, #8]
    b87e:	str	r4, [r1, #12]
    b880:	b.n	b594 <_malloc_r+0xd0>
    b882:	adds	r3, r4, r5
    b884:	orr.w	r7, r2, #1
    b888:	orr.w	r5, r5, #1
    b88c:	str	r5, [r4, #4]
    b88e:	mov	r0, r6
    b890:	str	r3, [r1, #20]
    b892:	str	r3, [r1, #16]
    b894:	str.w	lr, [r3, #12]
    b898:	str.w	lr, [r3, #8]
    b89c:	str	r7, [r3, #4]
    b89e:	str	r2, [r3, r2]
    b8a0:	adds	r4, #8
    b8a2:	bl	bc30 <__malloc_unlock>
    b8a6:	b.n	b654 <_malloc_r+0x190>
    b8a8:	ldr	r2, [r1, #4]
    b8aa:	b.n	b594 <_malloc_r+0xd0>
    b8ac:	add.w	r8, r8, #1
    b8b0:	tst.w	r8, #3
    b8b4:	add.w	ip, ip, #8
    b8b8:	bne.w	b5ba <_malloc_r+0xf6>
    b8bc:	b.n	b920 <_malloc_r+0x45c>
    b8be:	ldr	r4, [r3, #12]
    b8c0:	cmp	r3, r4
    b8c2:	it	eq
    b8c4:	addeq	r0, #2
    b8c6:	beq.w	b534 <_malloc_r+0x70>
    b8ca:	b.n	b634 <_malloc_r+0x170>
    b8cc:	add	r3, r1
    b8ce:	mov	r4, r1
    b8d0:	ldr	r2, [r3, #4]
    b8d2:	ldr	r1, [r1, #12]
    b8d4:	ldr.w	r5, [r4, #8]!
    b8d8:	orr.w	r2, r2, #1
    b8dc:	str	r2, [r3, #4]
    b8de:	mov	r0, r6
    b8e0:	str	r1, [r5, #12]
    b8e2:	str	r5, [r1, #8]
    b8e4:	bl	bc30 <__malloc_unlock>
    b8e8:	b.n	b654 <_malloc_r+0x190>
    b8ea:	add.w	lr, r3, #92	; 0x5c
    b8ee:	add.w	r0, r3, #91	; 0x5b
    b8f2:	mov.w	r3, lr, lsl #1
    b8f6:	b.n	b508 <_malloc_r+0x44>
    b8f8:	lsrs	r2, r3, #6
    b8fa:	add.w	r1, r2, #57	; 0x39
    b8fe:	lsls	r1, r1, #1
    b900:	adds	r2, #56	; 0x38
    b902:	b.n	b848 <_malloc_r+0x384>
    b904:	cmp	r4, r7
    b906:	ldr	r3, [pc, #296]	; (ba30 <_malloc_r+0x56c>)
    b908:	beq.w	b70c <_malloc_r+0x248>
    b90c:	ldr	r4, [r3, #8]
    b90e:	ldr	r2, [r4, #4]
    b910:	bic.w	r2, r2, #3
    b914:	b.n	b7cc <_malloc_r+0x308>
    b916:	ldr.w	r3, [r9], #-8
    b91a:	cmp	r9, r3
    b91c:	bne.w	ba24 <_malloc_r+0x560>
    b920:	tst.w	r0, #3
    b924:	add.w	r0, r0, #4294967295
    b928:	bne.n	b916 <_malloc_r+0x452>
    b92a:	ldr	r3, [r7, #4]
    b92c:	bic.w	r3, r3, r4
    b930:	str	r3, [r7, #4]
    b932:	lsls	r4, r4, #1
    b934:	cmp	r4, r3
    b936:	bhi.w	b6b4 <_malloc_r+0x1f0>
    b93a:	cmp	r4, #0
    b93c:	beq.w	b6b4 <_malloc_r+0x1f0>
    b940:	tst	r4, r3
    b942:	mov	r0, r8
    b944:	bne.w	b5b2 <_malloc_r+0xee>
    b948:	lsls	r4, r4, #1
    b94a:	tst	r4, r3
    b94c:	add.w	r0, r0, #4
    b950:	beq.n	b948 <_malloc_r+0x484>
    b952:	b.n	b5b2 <_malloc_r+0xee>
    b954:	cmp.w	r3, #340	; 0x154
    b958:	bhi.n	b98c <_malloc_r+0x4c8>
    b95a:	lsrs	r0, r5, #15
    b95c:	add.w	lr, r0, #120	; 0x78
    b960:	mov.w	r3, lr, lsl #1
    b964:	adds	r0, #119	; 0x77
    b966:	b.n	b508 <_malloc_r+0x44>
    b968:	mov.w	r1, #4096	; 0x1000
    b96c:	b.n	b746 <_malloc_r+0x282>
    b96e:	movs	r1, #1
    b970:	ldr.w	r3, [r8, #4]
    b974:	asrs	r2, r2, #2
    b976:	lsl.w	r2, r1, r2
    b97a:	orrs	r2, r3
    b97c:	str.w	r2, [r8, #4]
    b980:	mov	r1, ip
    b982:	b.n	b874 <_malloc_r+0x3b0>
    b984:	movs	r3, #1
    b986:	str.w	r3, [fp, #4]
    b98a:	b.n	b7d8 <_malloc_r+0x314>
    b98c:	movw	r2, #1364	; 0x554
    b990:	cmp	r3, r2
    b992:	bhi.n	b9d6 <_malloc_r+0x512>
    b994:	lsrs	r0, r5, #18
    b996:	add.w	lr, r0, #125	; 0x7d
    b99a:	mov.w	r3, lr, lsl #1
    b99e:	adds	r0, #124	; 0x7c
    b9a0:	b.n	b508 <_malloc_r+0x44>
    b9a2:	adds	r2, #16
    b9a4:	b.n	b6f0 <_malloc_r+0x22c>
    b9a6:	cmp	r2, #84	; 0x54
    b9a8:	bhi.n	b9f8 <_malloc_r+0x534>
    b9aa:	lsrs	r2, r3, #12
    b9ac:	add.w	r1, r2, #111	; 0x6f
    b9b0:	lsls	r1, r1, #1
    b9b2:	adds	r2, #110	; 0x6e
    b9b4:	b.n	b848 <_malloc_r+0x384>
    b9b6:	ldr	r4, [r7, #8]
    b9b8:	ldr	r2, [r4, #4]
    b9ba:	bic.w	r2, r2, #3
    b9be:	b.n	b7cc <_malloc_r+0x308>
    b9c0:	ubfx	r0, sl, #0, #12
    b9c4:	cmp	r0, #0
    b9c6:	bne.w	b71a <_malloc_r+0x256>
    b9ca:	add	r2, r8
    b9cc:	ldr	r3, [r7, #8]
    b9ce:	orr.w	r2, r2, #1
    b9d2:	str	r2, [r3, #4]
    b9d4:	b.n	b7b0 <_malloc_r+0x2ec>
    b9d6:	movs	r3, #254	; 0xfe
    b9d8:	mov.w	lr, #127	; 0x7f
    b9dc:	movs	r0, #126	; 0x7e
    b9de:	b.n	b508 <_malloc_r+0x44>
    b9e0:	movs	r2, #1
    b9e2:	mov.w	r9, #0
    b9e6:	b.n	b76c <_malloc_r+0x2a8>
    b9e8:	add.w	r1, r4, #8
    b9ec:	mov	r0, r6
    b9ee:	bl	10b90 <_free_r>
    b9f2:	ldr.w	r1, [r9]
    b9f6:	b.n	b7b0 <_malloc_r+0x2ec>
    b9f8:	cmp.w	r2, #340	; 0x154
    b9fc:	bhi.n	ba0a <_malloc_r+0x546>
    b9fe:	lsrs	r2, r3, #15
    ba00:	add.w	r1, r2, #120	; 0x78
    ba04:	lsls	r1, r1, #1
    ba06:	adds	r2, #119	; 0x77
    ba08:	b.n	b848 <_malloc_r+0x384>
    ba0a:	movw	r1, #1364	; 0x554
    ba0e:	cmp	r2, r1
    ba10:	bhi.n	ba1e <_malloc_r+0x55a>
    ba12:	lsrs	r2, r3, #18
    ba14:	add.w	r1, r2, #125	; 0x7d
    ba18:	lsls	r1, r1, #1
    ba1a:	adds	r2, #124	; 0x7c
    ba1c:	b.n	b848 <_malloc_r+0x384>
    ba1e:	movs	r1, #254	; 0xfe
    ba20:	movs	r2, #126	; 0x7e
    ba22:	b.n	b848 <_malloc_r+0x384>
    ba24:	ldr	r3, [r7, #4]
    ba26:	b.n	b932 <_malloc_r+0x46e>
    ba28:	lsrs	r0, r5, #3
    ba2a:	adds	r3, r0, #1
    ba2c:	lsls	r3, r3, #1
    ba2e:	b.n	b622 <_malloc_r+0x15e>
    ba30:	.word	0x200143a0

0000ba34 <__ascii_mbtowc>:
    ba34:	sub	sp, #8
    ba36:	cbz	r1, ba4c <__ascii_mbtowc+0x18>
    ba38:	cbz	r2, ba52 <__ascii_mbtowc+0x1e>
    ba3a:	cbz	r3, ba58 <__ascii_mbtowc+0x24>
    ba3c:	ldrb	r3, [r2, #0]
    ba3e:	str	r3, [r1, #0]
    ba40:	ldrb	r2, [r2, #0]
    ba42:	adds	r0, r2, #0
    ba44:	it	ne
    ba46:	movne	r0, #1
    ba48:	add	sp, #8
    ba4a:	bx	lr
    ba4c:	add	r1, sp, #4
    ba4e:	cmp	r2, #0
    ba50:	bne.n	ba3a <__ascii_mbtowc+0x6>
    ba52:	mov	r0, r2
    ba54:	add	sp, #8
    ba56:	bx	lr
    ba58:	mvn.w	r0, #1
    ba5c:	b.n	ba48 <__ascii_mbtowc+0x14>
    ba5e:	nop

0000ba60 <memchr>:
    ba60:	and.w	r1, r1, #255	; 0xff
    ba64:	cmp	r2, #16
    ba66:	blt.n	bac0 <memchr+0x60>
    ba68:	tst.w	r0, #7
    ba6c:	beq.n	ba80 <memchr+0x20>
    ba6e:	ldrb.w	r3, [r0], #1
    ba72:	subs	r2, #1
    ba74:	cmp	r3, r1
    ba76:	beq.n	bad4 <memchr+0x74>
    ba78:	tst.w	r0, #7
    ba7c:	cbz	r2, bad0 <memchr+0x70>
    ba7e:	bne.n	ba6e <memchr+0xe>
    ba80:	push	{r4, r5, r6, r7}
    ba82:	orr.w	r1, r1, r1, lsl #8
    ba86:	orr.w	r1, r1, r1, lsl #16
    ba8a:	bic.w	r4, r2, #7
    ba8e:	mvns.w	r7, #0
    ba92:	movs	r3, #0
    ba94:	ldrd	r5, r6, [r0], #8
    ba98:	subs	r4, #8
    ba9a:	eor.w	r5, r5, r1
    ba9e:	eor.w	r6, r6, r1
    baa2:	uadd8	r5, r5, r7
    baa6:	sel	r5, r3, r7
    baaa:	uadd8	r6, r6, r7
    baae:	sel	r6, r5, r7
    bab2:	cbnz	r6, bad8 <memchr+0x78>
    bab4:	bne.n	ba94 <memchr+0x34>
    bab6:	pop	{r4, r5, r6, r7}
    bab8:	and.w	r1, r1, #255	; 0xff
    babc:	and.w	r2, r2, #7
    bac0:	cbz	r2, bad0 <memchr+0x70>
    bac2:	ldrb.w	r3, [r0], #1
    bac6:	subs	r2, #1
    bac8:	eor.w	r3, r3, r1
    bacc:	cbz	r3, bad4 <memchr+0x74>
    bace:	bne.n	bac2 <memchr+0x62>
    bad0:	movs	r0, #0
    bad2:	bx	lr
    bad4:	subs	r0, #1
    bad6:	bx	lr
    bad8:	cmp	r5, #0
    bada:	itte	eq
    badc:	moveq	r5, r6
    bade:	subeq	r0, #3
    bae0:	subne	r0, #7
    bae2:	tst.w	r5, #1
    bae6:	bne.n	baf8 <memchr+0x98>
    bae8:	adds	r0, #1
    baea:	tst.w	r5, #256	; 0x100
    baee:	ittt	eq
    baf0:	addeq	r0, #1
    baf2:	tsteq.w	r5, #98304	; 0x18000
    baf6:	addeq	r0, #1
    baf8:	pop	{r4, r5, r6, r7}
    bafa:	subs	r0, #1
    bafc:	bx	lr
    bafe:	nop

0000bb00 <memcmp>:
    bb00:	cmp	r2, #3
    bb02:	push	{r4, r5, r6}
    bb04:	bls.n	bb54 <memcmp+0x54>
    bb06:	orr.w	r3, r0, r1
    bb0a:	lsls	r3, r3, #30
    bb0c:	beq.n	bb32 <memcmp+0x32>
    bb0e:	ldrb	r4, [r0, #0]
    bb10:	ldrb	r5, [r1, #0]
    bb12:	cmp	r4, r5
    bb14:	bne.n	bb5c <memcmp+0x5c>
    bb16:	add	r2, r0
    bb18:	adds	r3, r0, #1
    bb1a:	b.n	bb28 <memcmp+0x28>
    bb1c:	ldrb.w	r4, [r3], #1
    bb20:	ldrb.w	r5, [r1, #1]!
    bb24:	cmp	r4, r5
    bb26:	bne.n	bb5c <memcmp+0x5c>
    bb28:	cmp	r3, r2
    bb2a:	bne.n	bb1c <memcmp+0x1c>
    bb2c:	movs	r0, #0
    bb2e:	pop	{r4, r5, r6}
    bb30:	bx	lr
    bb32:	mov	r4, r1
    bb34:	mov	r3, r0
    bb36:	ldr	r6, [r3, #0]
    bb38:	ldr	r5, [r4, #0]
    bb3a:	cmp	r6, r5
    bb3c:	mov	r0, r3
    bb3e:	mov	r1, r4
    bb40:	add.w	r3, r3, #4
    bb44:	add.w	r4, r4, #4
    bb48:	bne.n	bb0e <memcmp+0xe>
    bb4a:	subs	r2, #4
    bb4c:	cmp	r2, #3
    bb4e:	mov	r0, r3
    bb50:	mov	r1, r4
    bb52:	bhi.n	bb36 <memcmp+0x36>
    bb54:	cmp	r2, #0
    bb56:	bne.n	bb0e <memcmp+0xe>
    bb58:	mov	r0, r2
    bb5a:	b.n	bb2e <memcmp+0x2e>
    bb5c:	subs	r0, r4, r5
    bb5e:	pop	{r4, r5, r6}
    bb60:	bx	lr
    bb62:	nop

0000bb64 <memmove>:
    bb64:	cmp	r0, r1
    bb66:	push	{r4, r5, r6, r7, lr}
    bb68:	bls.n	bb86 <memmove+0x22>
    bb6a:	adds	r3, r1, r2
    bb6c:	cmp	r0, r3
    bb6e:	bcs.n	bb86 <memmove+0x22>
    bb70:	adds	r1, r0, r2
    bb72:	cmp	r2, #0
    bb74:	beq.n	bc1a <memmove+0xb6>
    bb76:	subs	r2, r3, r2
    bb78:	ldrb.w	r4, [r3, #-1]!
    bb7c:	strb.w	r4, [r1, #-1]!
    bb80:	cmp	r3, r2
    bb82:	bne.n	bb78 <memmove+0x14>
    bb84:	pop	{r4, r5, r6, r7, pc}
    bb86:	cmp	r2, #15
    bb88:	bls.n	bc1c <memmove+0xb8>
    bb8a:	orr.w	r3, r1, r0
    bb8e:	lsls	r3, r3, #30
    bb90:	bne.n	bc20 <memmove+0xbc>
    bb92:	add.w	r4, r0, #16
    bb96:	add.w	r3, r1, #16
    bb9a:	mov	r5, r2
    bb9c:	ldr.w	r6, [r3, #-16]
    bba0:	str.w	r6, [r4, #-16]
    bba4:	ldr.w	r6, [r3, #-12]
    bba8:	str.w	r6, [r4, #-12]
    bbac:	ldr.w	r6, [r3, #-8]
    bbb0:	str.w	r6, [r4, #-8]
    bbb4:	subs	r5, #16
    bbb6:	ldr.w	r6, [r3, #-4]
    bbba:	str.w	r6, [r4, #-4]
    bbbe:	cmp	r5, #15
    bbc0:	add.w	r3, r3, #16
    bbc4:	add.w	r4, r4, #16
    bbc8:	bhi.n	bb9c <memmove+0x38>
    bbca:	sub.w	r3, r2, #16
    bbce:	bic.w	r3, r3, #15
    bbd2:	and.w	lr, r2, #15
    bbd6:	adds	r3, #16
    bbd8:	cmp.w	lr, #3
    bbdc:	add	r1, r3
    bbde:	add	r3, r0
    bbe0:	bls.n	bc26 <memmove+0xc2>
    bbe2:	subs	r6, r3, #4
    bbe4:	mov	r5, r1
    bbe6:	mov	r4, lr
    bbe8:	subs	r4, #4
    bbea:	ldr.w	r7, [r5], #4
    bbee:	str.w	r7, [r6, #4]!
    bbf2:	cmp	r4, #3
    bbf4:	bhi.n	bbe8 <memmove+0x84>
    bbf6:	sub.w	r4, lr, #4
    bbfa:	bic.w	r4, r4, #3
    bbfe:	adds	r4, #4
    bc00:	add	r3, r4
    bc02:	add	r1, r4
    bc04:	and.w	r2, r2, #3
    bc08:	cbz	r2, bc24 <memmove+0xc0>
    bc0a:	subs	r3, #1
    bc0c:	add	r2, r1
    bc0e:	ldrb.w	r4, [r1], #1
    bc12:	strb.w	r4, [r3, #1]!
    bc16:	cmp	r2, r1
    bc18:	bne.n	bc0e <memmove+0xaa>
    bc1a:	pop	{r4, r5, r6, r7, pc}
    bc1c:	mov	r3, r0
    bc1e:	b.n	bc08 <memmove+0xa4>
    bc20:	mov	r3, r0
    bc22:	b.n	bc0a <memmove+0xa6>
    bc24:	pop	{r4, r5, r6, r7, pc}
    bc26:	mov	r2, lr
    bc28:	b.n	bc08 <memmove+0xa4>
    bc2a:	nop

0000bc2c <__malloc_lock>:
    bc2c:	bx	lr
    bc2e:	nop

0000bc30 <__malloc_unlock>:
    bc30:	bx	lr
    bc32:	nop

0000bc34 <_realloc_r>:
    bc34:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bc38:	mov	r7, r2
    bc3a:	sub	sp, #12
    bc3c:	cmp	r1, #0
    bc3e:	beq.w	bdc4 <_realloc_r+0x190>
    bc42:	mov	r6, r1
    bc44:	mov	r9, r0
    bc46:	add.w	r5, r7, #11
    bc4a:	bl	bc2c <__malloc_lock>
    bc4e:	ldr.w	lr, [r6, #-4]
    bc52:	cmp	r5, #22
    bc54:	bic.w	r4, lr, #3
    bc58:	sub.w	r8, r6, #8
    bc5c:	bhi.n	bce0 <_realloc_r+0xac>
    bc5e:	movs	r2, #16
    bc60:	mov	r5, r2
    bc62:	cmp	r7, r5
    bc64:	bhi.n	bcea <_realloc_r+0xb6>
    bc66:	cmp	r4, r2
    bc68:	bge.n	bd56 <_realloc_r+0x122>
    bc6a:	ldr	r3, [pc, #804]	; (bf90 <_realloc_r+0x35c>)
    bc6c:	ldr	r1, [r3, #8]
    bc6e:	add.w	r0, r8, r4
    bc72:	cmp	r0, r1
    bc74:	ldr	r1, [r0, #4]
    bc76:	beq.w	be2c <_realloc_r+0x1f8>
    bc7a:	bic.w	r3, r1, #1
    bc7e:	add	r3, r0
    bc80:	ldr	r3, [r3, #4]
    bc82:	lsls	r3, r3, #31
    bc84:	bpl.n	bd82 <_realloc_r+0x14e>
    bc86:	tst.w	lr, #1
    bc8a:	beq.n	bcf8 <_realloc_r+0xc4>
    bc8c:	mov	r1, r7
    bc8e:	mov	r0, r9
    bc90:	bl	b4c4 <_malloc_r>
    bc94:	mov	r7, r0
    bc96:	cbz	r0, bcd2 <_realloc_r+0x9e>
    bc98:	ldr.w	r3, [r6, #-4]
    bc9c:	bic.w	r3, r3, #1
    bca0:	add	r3, r8
    bca2:	sub.w	r2, r0, #8
    bca6:	cmp	r2, r3
    bca8:	beq.w	bf34 <_realloc_r+0x300>
    bcac:	subs	r2, r4, #4
    bcae:	cmp	r2, #36	; 0x24
    bcb0:	bhi.w	bf16 <_realloc_r+0x2e2>
    bcb4:	cmp	r2, #19
    bcb6:	bhi.w	bec2 <_realloc_r+0x28e>
    bcba:	mov	r3, r0
    bcbc:	mov	r2, r6
    bcbe:	ldr	r1, [r2, #0]
    bcc0:	str	r1, [r3, #0]
    bcc2:	ldr	r1, [r2, #4]
    bcc4:	str	r1, [r3, #4]
    bcc6:	ldr	r2, [r2, #8]
    bcc8:	str	r2, [r3, #8]
    bcca:	mov	r1, r6
    bccc:	mov	r0, r9
    bcce:	bl	10b90 <_free_r>
    bcd2:	mov	r0, r9
    bcd4:	bl	bc30 <__malloc_unlock>
    bcd8:	mov	r0, r7
    bcda:	add	sp, #12
    bcdc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bce0:	bic.w	r5, r5, #7
    bce4:	cmp	r5, #0
    bce6:	mov	r2, r5
    bce8:	bge.n	bc62 <_realloc_r+0x2e>
    bcea:	movs	r3, #12
    bcec:	movs	r0, #0
    bcee:	str.w	r3, [r9]
    bcf2:	add	sp, #12
    bcf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bcf8:	ldr.w	r3, [r6, #-8]
    bcfc:	rsb	sl, r3, r8
    bd00:	ldr.w	r3, [sl, #4]
    bd04:	bic.w	ip, r3, #3
    bd08:	add.w	r3, r4, ip
    bd0c:	cmp	r3, r2
    bd0e:	blt.n	bc8c <_realloc_r+0x58>
    bd10:	mov	r7, sl
    bd12:	ldr.w	r1, [sl, #12]
    bd16:	ldr.w	r0, [r7, #8]!
    bd1a:	subs	r2, r4, #4
    bd1c:	cmp	r2, #36	; 0x24
    bd1e:	str	r1, [r0, #12]
    bd20:	str	r0, [r1, #8]
    bd22:	bhi.w	bf54 <_realloc_r+0x320>
    bd26:	cmp	r2, #19
    bd28:	bls.w	bf50 <_realloc_r+0x31c>
    bd2c:	ldr	r1, [r6, #0]
    bd2e:	str.w	r1, [sl, #8]
    bd32:	ldr	r1, [r6, #4]
    bd34:	str.w	r1, [sl, #12]
    bd38:	cmp	r2, #27
    bd3a:	bhi.w	bf94 <_realloc_r+0x360>
    bd3e:	adds	r6, #8
    bd40:	add.w	r2, sl, #16
    bd44:	ldr	r1, [r6, #0]
    bd46:	str	r1, [r2, #0]
    bd48:	ldr	r1, [r6, #4]
    bd4a:	str	r1, [r2, #4]
    bd4c:	ldr	r1, [r6, #8]
    bd4e:	str	r1, [r2, #8]
    bd50:	mov	r6, r7
    bd52:	mov	r4, r3
    bd54:	mov	r8, sl
    bd56:	subs	r3, r4, r5
    bd58:	cmp	r3, #15
    bd5a:	bhi.n	bd98 <_realloc_r+0x164>
    bd5c:	ldr.w	r3, [r8, #4]
    bd60:	and.w	r3, r3, #1
    bd64:	orrs	r3, r4
    bd66:	add	r4, r8
    bd68:	str.w	r3, [r8, #4]
    bd6c:	ldr	r3, [r4, #4]
    bd6e:	orr.w	r3, r3, #1
    bd72:	str	r3, [r4, #4]
    bd74:	mov	r0, r9
    bd76:	bl	bc30 <__malloc_unlock>
    bd7a:	mov	r0, r6
    bd7c:	add	sp, #12
    bd7e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bd82:	bic.w	r1, r1, #3
    bd86:	add	r1, r4
    bd88:	cmp	r1, r2
    bd8a:	blt.n	bdd0 <_realloc_r+0x19c>
    bd8c:	ldr	r3, [r0, #12]
    bd8e:	ldr	r2, [r0, #8]
    bd90:	mov	r4, r1
    bd92:	str	r3, [r2, #12]
    bd94:	str	r2, [r3, #8]
    bd96:	b.n	bd56 <_realloc_r+0x122>
    bd98:	ldr.w	r2, [r8, #4]
    bd9c:	add.w	r1, r8, r5
    bda0:	and.w	r2, r2, #1
    bda4:	orrs	r5, r2
    bda6:	orr.w	r2, r3, #1
    bdaa:	add	r3, r1
    bdac:	str.w	r5, [r8, #4]
    bdb0:	str	r2, [r1, #4]
    bdb2:	ldr	r2, [r3, #4]
    bdb4:	orr.w	r2, r2, #1
    bdb8:	adds	r1, #8
    bdba:	str	r2, [r3, #4]
    bdbc:	mov	r0, r9
    bdbe:	bl	10b90 <_free_r>
    bdc2:	b.n	bd74 <_realloc_r+0x140>
    bdc4:	mov	r1, r2
    bdc6:	add	sp, #12
    bdc8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bdcc:	b.w	b4c4 <_malloc_r>
    bdd0:	tst.w	lr, #1
    bdd4:	bne.w	bc8c <_realloc_r+0x58>
    bdd8:	ldr.w	r3, [r6, #-8]
    bddc:	rsb	sl, r3, r8
    bde0:	ldr.w	r3, [sl, #4]
    bde4:	bic.w	ip, r3, #3
    bde8:	add.w	lr, r1, ip
    bdec:	cmp	lr, r2
    bdee:	blt.n	bd08 <_realloc_r+0xd4>
    bdf0:	ldr	r3, [r0, #12]
    bdf2:	ldr	r2, [r0, #8]
    bdf4:	mov	r7, sl
    bdf6:	str	r3, [r2, #12]
    bdf8:	str	r2, [r3, #8]
    bdfa:	ldr.w	r1, [r7, #8]!
    bdfe:	ldr.w	r3, [sl, #12]
    be02:	str	r3, [r1, #12]
    be04:	subs	r2, r4, #4
    be06:	cmp	r2, #36	; 0x24
    be08:	str	r1, [r3, #8]
    be0a:	bhi.w	bf40 <_realloc_r+0x30c>
    be0e:	cmp	r2, #19
    be10:	bls.n	bed8 <_realloc_r+0x2a4>
    be12:	ldr	r3, [r6, #0]
    be14:	str.w	r3, [sl, #8]
    be18:	ldr	r3, [r6, #4]
    be1a:	str.w	r3, [sl, #12]
    be1e:	cmp	r2, #27
    be20:	bhi.w	bf64 <_realloc_r+0x330>
    be24:	adds	r6, #8
    be26:	add.w	r3, sl, #16
    be2a:	b.n	beda <_realloc_r+0x2a6>
    be2c:	bic.w	fp, r1, #3
    be30:	add	fp, r4
    be32:	add.w	r0, r5, #16
    be36:	cmp	fp, r0
    be38:	bge.n	beee <_realloc_r+0x2ba>
    be3a:	tst.w	lr, #1
    be3e:	bne.w	bc8c <_realloc_r+0x58>
    be42:	ldr.w	r1, [r6, #-8]
    be46:	rsb	sl, r1, r8
    be4a:	ldr.w	r1, [sl, #4]
    be4e:	bic.w	ip, r1, #3
    be52:	add	fp, ip
    be54:	cmp	r0, fp
    be56:	bgt.w	bd08 <_realloc_r+0xd4>
    be5a:	mov	r7, sl
    be5c:	ldr.w	r1, [sl, #12]
    be60:	ldr.w	r0, [r7, #8]!
    be64:	subs	r2, r4, #4
    be66:	cmp	r2, #36	; 0x24
    be68:	str	r1, [r0, #12]
    be6a:	str	r0, [r1, #8]
    be6c:	bhi.w	bfd8 <_realloc_r+0x3a4>
    be70:	cmp	r2, #19
    be72:	bls.w	bfc0 <_realloc_r+0x38c>
    be76:	ldr	r1, [r6, #0]
    be78:	str.w	r1, [sl, #8]
    be7c:	ldr	r1, [r6, #4]
    be7e:	str.w	r1, [sl, #12]
    be82:	cmp	r2, #27
    be84:	bhi.w	bfe6 <_realloc_r+0x3b2>
    be88:	adds	r6, #8
    be8a:	add.w	r2, sl, #16
    be8e:	ldr	r1, [r6, #0]
    be90:	str	r1, [r2, #0]
    be92:	ldr	r1, [r6, #4]
    be94:	str	r1, [r2, #4]
    be96:	ldr	r1, [r6, #8]
    be98:	str	r1, [r2, #8]
    be9a:	add.w	r1, sl, r5
    be9e:	rsb	r2, r5, fp
    bea2:	orr.w	r2, r2, #1
    bea6:	str	r1, [r3, #8]
    bea8:	str	r2, [r1, #4]
    beaa:	ldr.w	r3, [sl, #4]
    beae:	and.w	r3, r3, #1
    beb2:	orrs	r5, r3
    beb4:	mov	r0, r9
    beb6:	str.w	r5, [sl, #4]
    beba:	bl	bc30 <__malloc_unlock>
    bebe:	mov	r0, r7
    bec0:	b.n	bd7c <_realloc_r+0x148>
    bec2:	ldr	r3, [r6, #0]
    bec4:	str	r3, [r0, #0]
    bec6:	ldr	r3, [r6, #4]
    bec8:	str	r3, [r0, #4]
    beca:	cmp	r2, #27
    becc:	bhi.n	bf1e <_realloc_r+0x2ea>
    bece:	add.w	r3, r0, #8
    bed2:	add.w	r2, r6, #8
    bed6:	b.n	bcbe <_realloc_r+0x8a>
    bed8:	mov	r3, r7
    beda:	ldr	r2, [r6, #0]
    bedc:	str	r2, [r3, #0]
    bede:	ldr	r2, [r6, #4]
    bee0:	str	r2, [r3, #4]
    bee2:	ldr	r2, [r6, #8]
    bee4:	str	r2, [r3, #8]
    bee6:	mov	r6, r7
    bee8:	mov	r4, lr
    beea:	mov	r8, sl
    beec:	b.n	bd56 <_realloc_r+0x122>
    beee:	add.w	r1, r8, r5
    bef2:	rsb	fp, r5, fp
    bef6:	orr.w	r2, fp, #1
    befa:	str	r1, [r3, #8]
    befc:	str	r2, [r1, #4]
    befe:	ldr.w	r3, [r6, #-4]
    bf02:	and.w	r3, r3, #1
    bf06:	orrs	r5, r3
    bf08:	mov	r0, r9
    bf0a:	str.w	r5, [r6, #-4]
    bf0e:	bl	bc30 <__malloc_unlock>
    bf12:	mov	r0, r6
    bf14:	b.n	bd7c <_realloc_r+0x148>
    bf16:	mov	r1, r6
    bf18:	bl	bb64 <memmove>
    bf1c:	b.n	bcca <_realloc_r+0x96>
    bf1e:	ldr	r3, [r6, #8]
    bf20:	str	r3, [r0, #8]
    bf22:	ldr	r3, [r6, #12]
    bf24:	str	r3, [r0, #12]
    bf26:	cmp	r2, #36	; 0x24
    bf28:	beq.n	bf7c <_realloc_r+0x348>
    bf2a:	add.w	r3, r0, #16
    bf2e:	add.w	r2, r6, #16
    bf32:	b.n	bcbe <_realloc_r+0x8a>
    bf34:	ldr.w	r3, [r0, #-4]
    bf38:	bic.w	r3, r3, #3
    bf3c:	add	r4, r3
    bf3e:	b.n	bd56 <_realloc_r+0x122>
    bf40:	mov	r1, r6
    bf42:	mov	r0, r7
    bf44:	mov	r4, lr
    bf46:	mov	r8, sl
    bf48:	bl	bb64 <memmove>
    bf4c:	mov	r6, r7
    bf4e:	b.n	bd56 <_realloc_r+0x122>
    bf50:	mov	r2, r7
    bf52:	b.n	bd44 <_realloc_r+0x110>
    bf54:	mov	r1, r6
    bf56:	mov	r0, r7
    bf58:	mov	r4, r3
    bf5a:	mov	r8, sl
    bf5c:	bl	bb64 <memmove>
    bf60:	mov	r6, r7
    bf62:	b.n	bd56 <_realloc_r+0x122>
    bf64:	ldr	r3, [r6, #8]
    bf66:	str.w	r3, [sl, #16]
    bf6a:	ldr	r3, [r6, #12]
    bf6c:	str.w	r3, [sl, #20]
    bf70:	cmp	r2, #36	; 0x24
    bf72:	beq.n	bfac <_realloc_r+0x378>
    bf74:	adds	r6, #16
    bf76:	add.w	r3, sl, #24
    bf7a:	b.n	beda <_realloc_r+0x2a6>
    bf7c:	ldr	r3, [r6, #16]
    bf7e:	str	r3, [r0, #16]
    bf80:	ldr	r3, [r6, #20]
    bf82:	str	r3, [r0, #20]
    bf84:	add.w	r2, r6, #24
    bf88:	add.w	r3, r0, #24
    bf8c:	b.n	bcbe <_realloc_r+0x8a>
    bf8e:	nop
    bf90:	.word	0x200143a0
    bf94:	ldr	r1, [r6, #8]
    bf96:	str.w	r1, [sl, #16]
    bf9a:	ldr	r1, [r6, #12]
    bf9c:	str.w	r1, [sl, #20]
    bfa0:	cmp	r2, #36	; 0x24
    bfa2:	beq.n	bfc4 <_realloc_r+0x390>
    bfa4:	adds	r6, #16
    bfa6:	add.w	r2, sl, #24
    bfaa:	b.n	bd44 <_realloc_r+0x110>
    bfac:	ldr	r3, [r6, #16]
    bfae:	str.w	r3, [sl, #24]
    bfb2:	ldr	r3, [r6, #20]
    bfb4:	str.w	r3, [sl, #28]
    bfb8:	adds	r6, #24
    bfba:	add.w	r3, sl, #32
    bfbe:	b.n	beda <_realloc_r+0x2a6>
    bfc0:	mov	r2, r7
    bfc2:	b.n	be8e <_realloc_r+0x25a>
    bfc4:	ldr	r2, [r6, #16]
    bfc6:	str.w	r2, [sl, #24]
    bfca:	ldr	r2, [r6, #20]
    bfcc:	str.w	r2, [sl, #28]
    bfd0:	adds	r6, #24
    bfd2:	add.w	r2, sl, #32
    bfd6:	b.n	bd44 <_realloc_r+0x110>
    bfd8:	mov	r1, r6
    bfda:	mov	r0, r7
    bfdc:	str	r3, [sp, #4]
    bfde:	bl	bb64 <memmove>
    bfe2:	ldr	r3, [sp, #4]
    bfe4:	b.n	be9a <_realloc_r+0x266>
    bfe6:	ldr	r1, [r6, #8]
    bfe8:	str.w	r1, [sl, #16]
    bfec:	ldr	r1, [r6, #12]
    bfee:	str.w	r1, [sl, #20]
    bff2:	cmp	r2, #36	; 0x24
    bff4:	beq.n	bffe <_realloc_r+0x3ca>
    bff6:	adds	r6, #16
    bff8:	add.w	r2, sl, #24
    bffc:	b.n	be8e <_realloc_r+0x25a>
    bffe:	ldr	r2, [r6, #16]
    c000:	str.w	r2, [sl, #24]
    c004:	ldr	r2, [r6, #20]
    c006:	str.w	r2, [sl, #28]
    c00a:	adds	r6, #24
    c00c:	add.w	r2, sl, #32
    c010:	b.n	be8e <_realloc_r+0x25a>
    c012:	nop

0000c014 <_sbrk_r>:
    c014:	push	{r3, r4, r5, lr}
    c016:	ldr	r4, [pc, #28]	; (c034 <_sbrk_r+0x20>)
    c018:	movs	r3, #0
    c01a:	mov	r5, r0
    c01c:	mov	r0, r1
    c01e:	str	r3, [r4, #0]
    c020:	bl	90f0 <_sbrk>
    c024:	adds	r3, r0, #1
    c026:	beq.n	c02a <_sbrk_r+0x16>
    c028:	pop	{r3, r4, r5, pc}
    c02a:	ldr	r3, [r4, #0]
    c02c:	cmp	r3, #0
    c02e:	beq.n	c028 <_sbrk_r+0x14>
    c030:	str	r3, [r5, #0]
    c032:	pop	{r3, r4, r5, pc}
    c034:	.word	0x2001a0ec

0000c038 <sprintf>:
    c038:	push	{r1, r2, r3}
    c03a:	push	{r4, r5, r6, r7, lr}
    c03c:	sub	sp, #112	; 0x70
    c03e:	add	r3, sp, #132	; 0x84
    c040:	ldr	r1, [pc, #60]	; (c080 <sprintf+0x48>)
    c042:	ldr.w	r2, [r3], #4
    c046:	str	r3, [sp, #4]
    c048:	mov	r5, r0
    c04a:	mvn.w	r4, #2147483648	; 0x80000000
    c04e:	ldr	r0, [r1, #0]
    c050:	str	r5, [sp, #8]
    c052:	mov.w	r7, #520	; 0x208
    c056:	movw	r6, #65535	; 0xffff
    c05a:	add	r1, sp, #8
    c05c:	str	r5, [sp, #24]
    c05e:	strh.w	r7, [sp, #20]
    c062:	str	r4, [sp, #16]
    c064:	str	r4, [sp, #28]
    c066:	strh.w	r6, [sp, #22]
    c06a:	bl	d490 <_svfprintf_r>
    c06e:	ldr	r3, [sp, #8]
    c070:	movs	r2, #0
    c072:	strb	r2, [r3, #0]
    c074:	add	sp, #112	; 0x70
    c076:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    c07a:	add	sp, #12
    c07c:	bx	lr
    c07e:	nop
    c080:	.word	0x20014230

0000c084 <sscanf>:
    c084:	push	{r1, r2, r3}
    c086:	push	{r4, r5, r6, r7, lr}
    c088:	sub	sp, #112	; 0x70
    c08a:	add	r4, sp, #132	; 0x84
    c08c:	mov.w	r2, #516	; 0x204
    c090:	ldr.w	r6, [r4], #4
    c094:	strh.w	r2, [sp, #20]
    c098:	str	r0, [sp, #8]
    c09a:	str	r0, [sp, #24]
    c09c:	bl	c280 <strlen>
    c0a0:	ldr	r3, [pc, #48]	; (c0d4 <sscanf+0x50>)
    c0a2:	str	r4, [sp, #4]
    c0a4:	mov	r5, r0
    c0a6:	mov	r2, r6
    c0a8:	ldr	r7, [pc, #44]	; (c0d8 <sscanf+0x54>)
    c0aa:	ldr	r0, [r3, #0]
    c0ac:	str	r5, [sp, #12]
    c0ae:	mov	r3, r4
    c0b0:	movw	r6, #65535	; 0xffff
    c0b4:	movs	r4, #0
    c0b6:	add	r1, sp, #8
    c0b8:	str	r5, [sp, #28]
    c0ba:	str	r7, [sp, #40]	; 0x28
    c0bc:	str	r4, [sp, #56]	; 0x38
    c0be:	str	r4, [sp, #76]	; 0x4c
    c0c0:	strh.w	r6, [sp, #22]
    c0c4:	bl	eb74 <__ssvfscanf_r>
    c0c8:	add	sp, #112	; 0x70
    c0ca:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    c0ce:	add	sp, #12
    c0d0:	bx	lr
    c0d2:	nop
    c0d4:	.word	0x20014230
    c0d8:	.word	0x0000c0dd

0000c0dc <__seofread>:
    c0dc:	movs	r0, #0
    c0de:	bx	lr

0000c0e0 <strchr>:
    c0e0:	push	{r4, r5, r6}
    c0e2:	ands.w	r4, r1, #255	; 0xff
    c0e6:	beq.n	c152 <strchr+0x72>
    c0e8:	lsls	r5, r0, #30
    c0ea:	beq.n	c10c <strchr+0x2c>
    c0ec:	ldrb	r3, [r0, #0]
    c0ee:	cmp	r3, #0
    c0f0:	beq.n	c1a8 <strchr+0xc8>
    c0f2:	cmp	r4, r3
    c0f4:	beq.n	c14e <strchr+0x6e>
    c0f6:	adds	r3, r0, #1
    c0f8:	b.n	c106 <strchr+0x26>
    c0fa:	ldrb.w	r2, [r3], #1
    c0fe:	cmp	r2, #0
    c100:	beq.n	c1a2 <strchr+0xc2>
    c102:	cmp	r4, r2
    c104:	beq.n	c14e <strchr+0x6e>
    c106:	lsls	r2, r3, #30
    c108:	mov	r0, r3
    c10a:	bne.n	c0fa <strchr+0x1a>
    c10c:	lsls	r6, r1, #8
    c10e:	and.w	r6, r6, #65280	; 0xff00
    c112:	orrs	r6, r4
    c114:	ldr	r3, [r0, #0]
    c116:	orr.w	r6, r6, r6, lsl #16
    c11a:	b.n	c120 <strchr+0x40>
    c11c:	ldr.w	r3, [r0, #4]!
    c120:	eor.w	r5, r6, r3
    c124:	sub.w	r2, r5, #16843009	; 0x1010101
    c128:	sub.w	r1, r3, #16843009	; 0x1010101
    c12c:	bic.w	r2, r2, r5
    c130:	bic.w	r3, r1, r3
    c134:	orrs	r3, r2
    c136:	tst.w	r3, #2155905152	; 0x80808080
    c13a:	beq.n	c11c <strchr+0x3c>
    c13c:	ldrb	r3, [r0, #0]
    c13e:	cbnz	r3, c14a <strchr+0x6a>
    c140:	b.n	c1a8 <strchr+0xc8>
    c142:	ldrb.w	r3, [r0, #1]!
    c146:	cmp	r3, #0
    c148:	beq.n	c1a8 <strchr+0xc8>
    c14a:	cmp	r4, r3
    c14c:	bne.n	c142 <strchr+0x62>
    c14e:	pop	{r4, r5, r6}
    c150:	bx	lr
    c152:	lsls	r4, r0, #30
    c154:	beq.n	c16e <strchr+0x8e>
    c156:	ldrb	r3, [r0, #0]
    c158:	cmp	r3, #0
    c15a:	beq.n	c14e <strchr+0x6e>
    c15c:	adds	r3, r0, #1
    c15e:	b.n	c168 <strchr+0x88>
    c160:	ldrb	r2, [r0, #0]
    c162:	adds	r3, #1
    c164:	cmp	r2, #0
    c166:	beq.n	c14e <strchr+0x6e>
    c168:	lsls	r1, r3, #30
    c16a:	mov	r0, r3
    c16c:	bne.n	c160 <strchr+0x80>
    c16e:	ldr	r2, [r0, #0]
    c170:	sub.w	r3, r2, #16843009	; 0x1010101
    c174:	bic.w	r3, r3, r2
    c178:	tst.w	r3, #2155905152	; 0x80808080
    c17c:	bne.n	c190 <strchr+0xb0>
    c17e:	ldr.w	r2, [r0, #4]!
    c182:	sub.w	r3, r2, #16843009	; 0x1010101
    c186:	bic.w	r3, r3, r2
    c18a:	tst.w	r3, #2155905152	; 0x80808080
    c18e:	beq.n	c17e <strchr+0x9e>
    c190:	ldrb	r3, [r0, #0]
    c192:	cmp	r3, #0
    c194:	beq.n	c14e <strchr+0x6e>
    c196:	ldrb.w	r3, [r0, #1]!
    c19a:	cmp	r3, #0
    c19c:	bne.n	c196 <strchr+0xb6>
    c19e:	pop	{r4, r5, r6}
    c1a0:	bx	lr
    c1a2:	mov	r0, r2
    c1a4:	pop	{r4, r5, r6}
    c1a6:	bx	lr
    c1a8:	mov	r0, r3
    c1aa:	pop	{r4, r5, r6}
    c1ac:	bx	lr
    c1ae:	nop

0000c1b0 <strcpy>:
    c1b0:	eor.w	r2, r0, r1
    c1b4:	mov	ip, r0
    c1b6:	tst.w	r2, #3
    c1ba:	bne.n	c25c <strcpy+0xac>
    c1bc:	tst.w	r1, #3
    c1c0:	bne.n	c228 <strcpy+0x78>
    c1c2:	str.w	r4, [sp, #-4]!
    c1c6:	tst.w	r1, #4
    c1ca:	ldr.w	r3, [r1], #4
    c1ce:	beq.n	c1e8 <strcpy+0x38>
    c1d0:	sub.w	r2, r3, #16843009	; 0x1010101
    c1d4:	bics	r2, r3
    c1d6:	tst.w	r2, #2155905152	; 0x80808080
    c1da:	itt	eq
    c1dc:	streq.w	r3, [ip], #4
    c1e0:	ldreq.w	r3, [r1], #4
    c1e4:	bne.n	c214 <strcpy+0x64>
    c1e6:	nop
    c1e8:	ldr.w	r4, [r1], #4
    c1ec:	sub.w	r2, r3, #16843009	; 0x1010101
    c1f0:	bics	r2, r3
    c1f2:	tst.w	r2, #2155905152	; 0x80808080
    c1f6:	sub.w	r2, r4, #16843009	; 0x1010101
    c1fa:	bne.n	c214 <strcpy+0x64>
    c1fc:	str.w	r3, [ip], #4
    c200:	bics	r2, r4
    c202:	tst.w	r2, #2155905152	; 0x80808080
    c206:	itt	eq
    c208:	ldreq.w	r3, [r1], #4
    c20c:	streq.w	r4, [ip], #4
    c210:	beq.n	c1e8 <strcpy+0x38>
    c212:	mov	r3, r4
    c214:	strb.w	r3, [ip], #1
    c218:	tst.w	r3, #255	; 0xff
    c21c:	mov.w	r3, r3, ror #8
    c220:	bne.n	c214 <strcpy+0x64>
    c222:	ldr.w	r4, [sp], #4
    c226:	bx	lr
    c228:	tst.w	r1, #1
    c22c:	beq.n	c23c <strcpy+0x8c>
    c22e:	ldrb.w	r2, [r1], #1
    c232:	strb.w	r2, [ip], #1
    c236:	cmp	r2, #0
    c238:	it	eq
    c23a:	bxeq	lr
    c23c:	tst.w	r1, #2
    c240:	beq.n	c1c2 <strcpy+0x12>
    c242:	ldrh.w	r2, [r1], #2
    c246:	tst.w	r2, #255	; 0xff
    c24a:	itet	ne
    c24c:	strhne.w	r2, [ip], #2
    c250:	strbeq.w	r2, [ip]
    c254:	tstne.w	r2, #65280	; 0xff00
    c258:	bne.n	c1c2 <strcpy+0x12>
    c25a:	bx	lr
    c25c:	ldrb.w	r2, [r1], #1
    c260:	strb.w	r2, [ip], #1
    c264:	cmp	r2, #0
    c266:	bne.n	c25c <strcpy+0xac>
    c268:	bx	lr
    c26a:	nop
    c26c:			; <UNDEFINED> instruction: 0xffffffff
    c270:			; <UNDEFINED> instruction: 0xffffffff
    c274:			; <UNDEFINED> instruction: 0xffffffff
    c278:			; <UNDEFINED> instruction: 0xffffffff
    c27c:			; <UNDEFINED> instruction: 0xffffffff

0000c280 <strlen>:
    c280:	pld	[r0]
    c284:	strd	r4, r5, [sp, #-8]!
    c288:	bic.w	r1, r0, #7
    c28c:	mvn.w	ip, #0
    c290:	ands.w	r4, r0, #7
    c294:	pld	[r1, #32]
    c298:	bne.w	c32e <strlen+0xae>
    c29c:	mov.w	r4, #0
    c2a0:	mvn.w	r0, #7
    c2a4:	ldrd	r2, r3, [r1]
    c2a8:	pld	[r1, #64]	; 0x40
    c2ac:	add.w	r0, r0, #8
    c2b0:	uadd8	r2, r2, ip
    c2b4:	sel	r2, r4, ip
    c2b8:	uadd8	r3, r3, ip
    c2bc:	sel	r3, r2, ip
    c2c0:	cbnz	r3, c316 <strlen+0x96>
    c2c2:	ldrd	r2, r3, [r1, #8]
    c2c6:	uadd8	r2, r2, ip
    c2ca:	add.w	r0, r0, #8
    c2ce:	sel	r2, r4, ip
    c2d2:	uadd8	r3, r3, ip
    c2d6:	sel	r3, r2, ip
    c2da:	cbnz	r3, c316 <strlen+0x96>
    c2dc:	ldrd	r2, r3, [r1, #16]
    c2e0:	uadd8	r2, r2, ip
    c2e4:	add.w	r0, r0, #8
    c2e8:	sel	r2, r4, ip
    c2ec:	uadd8	r3, r3, ip
    c2f0:	sel	r3, r2, ip
    c2f4:	cbnz	r3, c316 <strlen+0x96>
    c2f6:	ldrd	r2, r3, [r1, #24]
    c2fa:	add.w	r1, r1, #32
    c2fe:	uadd8	r2, r2, ip
    c302:	add.w	r0, r0, #8
    c306:	sel	r2, r4, ip
    c30a:	uadd8	r3, r3, ip
    c30e:	sel	r3, r2, ip
    c312:	cmp	r3, #0
    c314:	beq.n	c2a4 <strlen+0x24>
    c316:	cmp	r2, #0
    c318:	itt	eq
    c31a:	addeq	r0, #4
    c31c:	moveq	r2, r3
    c31e:	rev	r2, r2
    c320:	clz	r2, r2
    c324:	ldrd	r4, r5, [sp], #8
    c328:	add.w	r0, r0, r2, lsr #3
    c32c:	bx	lr
    c32e:	ldrd	r2, r3, [r1]
    c332:	and.w	r5, r4, #3
    c336:	rsb	r0, r4, #0
    c33a:	mov.w	r5, r5, lsl #3
    c33e:	tst.w	r4, #4
    c342:	pld	[r1, #64]	; 0x40
    c346:	lsl.w	r5, ip, r5
    c34a:	orn	r2, r2, r5
    c34e:	itt	ne
    c350:	ornne	r3, r3, r5
    c354:	movne	r2, ip
    c356:	mov.w	r4, #0
    c35a:	b.n	c2b0 <strlen+0x30>

0000c35c <strncmp>:
    c35c:	cmp	r2, #0
    c35e:	beq.n	c3e4 <strncmp+0x88>
    c360:	orr.w	r3, r0, r1
    c364:	ands.w	r3, r3, #3
    c368:	push	{r4, r5, r6, r7}
    c36a:	bne.n	c3b8 <strncmp+0x5c>
    c36c:	cmp	r2, #3
    c36e:	bls.n	c3b8 <strncmp+0x5c>
    c370:	ldr	r4, [r0, #0]
    c372:	ldr	r5, [r1, #0]
    c374:	cmp	r4, r5
    c376:	bne.n	c3b8 <strncmp+0x5c>
    c378:	subs	r2, #4
    c37a:	beq.n	c3e8 <strncmp+0x8c>
    c37c:	sub.w	r5, r4, #16843009	; 0x1010101
    c380:	bic.w	r4, r5, r4
    c384:	tst.w	r4, #2155905152	; 0x80808080
    c388:	bne.n	c3ee <strncmp+0x92>
    c38a:	adds	r7, r0, #4
    c38c:	adds	r5, r1, #4
    c38e:	b.n	c3ac <strncmp+0x50>
    c390:	ldr.w	r3, [r7], #4
    c394:	ldr	r6, [r1, #0]
    c396:	sub.w	r4, r3, #16843009	; 0x1010101
    c39a:	cmp	r3, r6
    c39c:	bic.w	r4, r4, r3
    c3a0:	bne.n	c3b8 <strncmp+0x5c>
    c3a2:	subs	r2, #4
    c3a4:	beq.n	c3e8 <strncmp+0x8c>
    c3a6:	tst.w	r4, #2155905152	; 0x80808080
    c3aa:	bne.n	c3f4 <strncmp+0x98>
    c3ac:	cmp	r2, #3
    c3ae:	mov	r1, r5
    c3b0:	mov	r0, r7
    c3b2:	add.w	r5, r5, #4
    c3b6:	bhi.n	c390 <strncmp+0x34>
    c3b8:	ldrb	r3, [r0, #0]
    c3ba:	ldrb	r4, [r1, #0]
    c3bc:	cmp	r4, r3
    c3be:	add.w	r2, r2, #4294967295
    c3c2:	bne.n	c3de <strncmp+0x82>
    c3c4:	cbz	r2, c3e8 <strncmp+0x8c>
    c3c6:	cbnz	r4, c3ce <strncmp+0x72>
    c3c8:	b.n	c3f8 <strncmp+0x9c>
    c3ca:	cbz	r2, c3e8 <strncmp+0x8c>
    c3cc:	cbz	r3, c3ee <strncmp+0x92>
    c3ce:	ldrb.w	r3, [r0, #1]!
    c3d2:	ldrb.w	r4, [r1, #1]!
    c3d6:	cmp	r3, r4
    c3d8:	add.w	r2, r2, #4294967295
    c3dc:	beq.n	c3ca <strncmp+0x6e>
    c3de:	subs	r0, r3, r4
    c3e0:	pop	{r4, r5, r6, r7}
    c3e2:	bx	lr
    c3e4:	mov	r0, r2
    c3e6:	bx	lr
    c3e8:	mov	r0, r2
    c3ea:	pop	{r4, r5, r6, r7}
    c3ec:	bx	lr
    c3ee:	mov	r0, r3
    c3f0:	pop	{r4, r5, r6, r7}
    c3f2:	bx	lr
    c3f4:	movs	r0, #0
    c3f6:	b.n	c3e0 <strncmp+0x84>
    c3f8:	mov	r0, r4
    c3fa:	b.n	c3e0 <strncmp+0x84>

0000c3fc <sulp>:
    c3fc:	push	{r4, r5, r6, lr}
    c3fe:	mov	r4, r0
    c400:	mov	r5, r1
    c402:	vmov	d0, r4, r5
    c406:	mov	r6, r2
    c408:	bl	11b60 <__ulp>
    c40c:	vmov	r0, r1, d0
    c410:	cbz	r6, c432 <sulp+0x36>
    c412:	ubfx	r3, r5, #20, #11
    c416:	rsb	r3, r3, #107	; 0x6b
    c41a:	cmp	r3, #0
    c41c:	ble.n	c432 <sulp+0x36>
    c41e:	lsls	r3, r3, #20
    c420:	add.w	r5, r3, #1069547520	; 0x3fc00000
    c424:	movs	r4, #0
    c426:	add.w	r5, r5, #3145728	; 0x300000
    c42a:	mov	r2, r4
    c42c:	mov	r3, r5
    c42e:	bl	a7b8 <__aeabi_dmul>
    c432:	pop	{r4, r5, r6, pc}
    c434:			; <UNDEFINED> instruction: 0xffffffff

0000c438 <_strtod_l>:
    c438:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c43c:	mov	r5, r3
    c43e:	sub	sp, #132	; 0x84
    c440:	movs	r3, #0
    c442:	mov	fp, r0
    c444:	mov	r0, r5
    c446:	mov	r6, r1
    c448:	str	r2, [sp, #24]
    c44a:	str	r3, [sp, #112]	; 0x70
    c44c:	bl	114e4 <__localeconv_l>
    c450:	movs	r4, #0
    c452:	movs	r3, #0
    c454:	mov	sl, r0
    c456:	ldr	r0, [r0, #0]
    c458:	strd	r3, r4, [sp, #16]
    c45c:	bl	c280 <strlen>
    c460:	str	r6, [sp, #108]	; 0x6c
    c462:	mov	r9, r0
    c464:	mov	r2, r6
    c466:	mov	r4, r2
    c468:	ldrb.w	r7, [r2], #1
    c46c:	cmp	r7, #45	; 0x2d
    c46e:	bhi.w	c5d0 <_strtod_l+0x198>
    c472:	tbb	[pc, r7]
    c476:	.short	0xad17
    c478:	.word	0xadadadad
    c47c:	.word	0x81adadad
    c480:	.word	0x81818181
    c484:	.word	0xadadadad
    c488:	.word	0xadadadad
    c48c:	.word	0xadadadad
    c490:	.word	0xadadadad
    c494:	.word	0xad81adad
    c498:	.word	0xadadadad
    c49c:	.word	0xadadadad
    c4a0:	.word	0x7ead2bad
    c4a4:	ldr	r3, [sp, #24]
    c4a6:	mov.w	r8, #0
    c4aa:	mov.w	r9, #0
    c4ae:	cbz	r3, c4c2 <_strtod_l+0x8a>
    c4b0:	movs	r3, #0
    c4b2:	str	r3, [sp, #28]
    c4b4:	ldr	r3, [sp, #24]
    c4b6:	str	r6, [r3, #0]
    c4b8:	ldr	r3, [sp, #28]
    c4ba:	cbz	r3, c4c2 <_strtod_l+0x8a>
    c4bc:	add.w	r3, r9, #2147483648	; 0x80000000
    c4c0:	mov	r9, r3
    c4c2:	vmov	d0, r8, r9
    c4c6:	add	sp, #132	; 0x84
    c4c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c4cc:	movs	r3, #0
    c4ce:	str	r3, [sp, #28]
    c4d0:	adds	r2, r4, #1
    c4d2:	str	r2, [sp, #108]	; 0x6c
    c4d4:	ldrb	r7, [r4, #1]
    c4d6:	cmp	r7, #0
    c4d8:	beq.n	c4a4 <_strtod_l+0x6c>
    c4da:	cmp	r7, #48	; 0x30
    c4dc:	mov	r4, r2
    c4de:	beq.n	c5d8 <_strtod_l+0x1a0>
    c4e0:	movs	r3, #0
    c4e2:	str	r4, [sp, #32]
    c4e4:	str	r3, [sp, #40]	; 0x28
    c4e6:	sub.w	r3, r7, #48	; 0x30
    c4ea:	cmp	r3, #9
    c4ec:	bhi.w	ccfe <_strtod_l+0x8c6>
    c4f0:	mov.w	r8, #0
    c4f4:	mov	r0, r4
    c4f6:	mov	r5, r8
    c4f8:	mov	r4, r8
    c4fa:	cmp	r4, #8
    c4fc:	it	gt
    c4fe:	addgt.w	r8, r8, r8, lsl #2
    c502:	add.w	r3, r5, r5, lsl #2
    c506:	add.w	r0, r0, #1
    c50a:	add.w	r3, r7, r3, lsl #1
    c50e:	str	r0, [sp, #108]	; 0x6c
    c510:	itt	gt
    c512:	addgt.w	r7, r7, r8, lsl #1
    c516:	subgt.w	r8, r7, #48	; 0x30
    c51a:	ldrb	r7, [r0, #0]
    c51c:	it	le
    c51e:	suble.w	r5, r3, #48	; 0x30
    c522:	sub.w	r3, r7, #48	; 0x30
    c526:	cmp	r3, #9
    c528:	add.w	r4, r4, #1
    c52c:	bls.n	c4fa <_strtod_l+0xc2>
    c52e:	ldr.w	r1, [sl]
    c532:	mov	r2, r9
    c534:	bl	c35c <strncmp>
    c538:	cbz	r0, c57c <_strtod_l+0x144>
    c53a:	movs	r0, #0
    c53c:	mov	r3, r7
    c53e:	mov	r9, r0
    c540:	mov	r7, r0
    c542:	mov	sl, r4
    c544:	cmp	r3, #101	; 0x65
    c546:	beq.w	c6ae <_strtod_l+0x276>
    c54a:	cmp	r3, #69	; 0x45
    c54c:	beq.w	c6ae <_strtod_l+0x276>
    c550:	movs	r2, #0
    c552:	cmp	r4, #0
    c554:	bne.n	c5fc <_strtod_l+0x1c4>
    c556:	cbnz	r0, c560 <_strtod_l+0x128>
    c558:	ldr	r2, [sp, #40]	; 0x28
    c55a:	cmp	r2, #0
    c55c:	beq.w	cb02 <_strtod_l+0x6ca>
    c560:	mov.w	r8, #0
    c564:	mov.w	r9, #0
    c568:	ldr	r3, [sp, #24]
    c56a:	cmp	r3, #0
    c56c:	beq.n	c4b8 <_strtod_l+0x80>
    c56e:	ldr	r6, [sp, #108]	; 0x6c
    c570:	b.n	c4b4 <_strtod_l+0x7c>
    c572:	movs	r3, #1
    c574:	str	r3, [sp, #28]
    c576:	b.n	c4d0 <_strtod_l+0x98>
    c578:	str	r2, [sp, #108]	; 0x6c
    c57a:	b.n	c466 <_strtod_l+0x2e>
    c57c:	ldr	r3, [sp, #108]	; 0x6c
    c57e:	add.w	r2, r3, r9
    c582:	str	r2, [sp, #108]	; 0x6c
    c584:	ldrb.w	r3, [r3, r9]
    c588:	mov	r7, r0
    c58a:	mov	sl, r4
    c58c:	sub.w	r2, r3, #48	; 0x30
    c590:	cmp	r2, #9
    c592:	bhi.w	ca88 <_strtod_l+0x650>
    c596:	adds	r1, r0, #1
    c598:	mov	r3, r2
    c59a:	cmp	r2, #0
    c59c:	beq.w	d2de <_strtod_l+0xea6>
    c5a0:	cmp	r1, #1
    c5a2:	add	r7, r1
    c5a4:	it	ne
    c5a6:	addne	r0, r0, r4
    c5a8:	bne.n	c5b6 <_strtod_l+0x17e>
    c5aa:	b.w	d2d6 <_strtod_l+0xe9e>
    c5ae:	lsls	r5, r1, #1
    c5b0:	cmp	r4, r0
    c5b2:	beq.w	cf2c <_strtod_l+0xaf4>
    c5b6:	adds	r4, #1
    c5b8:	subs	r1, r4, #1
    c5ba:	cmp	r1, #8
    c5bc:	add.w	r1, r5, r5, lsl #2
    c5c0:	ble.n	c5ae <_strtod_l+0x176>
    c5c2:	cmp	r4, #16
    c5c4:	itt	le
    c5c6:	addle.w	r8, r8, r8, lsl #2
    c5ca:	movle.w	r8, r8, lsl #1
    c5ce:	b.n	c5b0 <_strtod_l+0x178>
    c5d0:	movs	r3, #0
    c5d2:	cmp	r7, #48	; 0x30
    c5d4:	str	r3, [sp, #28]
    c5d6:	bne.n	c4e0 <_strtod_l+0xa8>
    c5d8:	ldrb	r3, [r4, #1]
    c5da:	cmp	r3, #88	; 0x58
    c5dc:	beq.w	ccc6 <_strtod_l+0x88e>
    c5e0:	cmp	r3, #120	; 0x78
    c5e2:	beq.w	ccc6 <_strtod_l+0x88e>
    c5e6:	adds	r4, #1
    c5e8:	str	r4, [sp, #108]	; 0x6c
    c5ea:	ldrb	r7, [r4, #0]
    c5ec:	cmp	r7, #48	; 0x30
    c5ee:	beq.n	c5e6 <_strtod_l+0x1ae>
    c5f0:	cmp	r7, #0
    c5f2:	beq.n	c560 <_strtod_l+0x128>
    c5f4:	movs	r3, #1
    c5f6:	str	r4, [sp, #32]
    c5f8:	str	r3, [sp, #40]	; 0x28
    c5fa:	b.n	c4e6 <_strtod_l+0xae>
    c5fc:	cmp	r4, #16
    c5fe:	sub.w	r3, r2, r7
    c602:	mov	r0, r5
    c604:	mov	r9, r4
    c606:	str	r3, [sp, #44]	; 0x2c
    c608:	it	ge
    c60a:	movge.w	r9, #16
    c60e:	bl	a6cc <__aeabi_ui2d>
    c612:	cmp.w	sl, #0
    c616:	it	eq
    c618:	moveq	sl, r4
    c61a:	cmp.w	r9, #9
    c61e:	strd	r0, r1, [sp, #16]
    c622:	ble.n	c64c <_strtod_l+0x214>
    c624:	ldr	r3, [pc, #292]	; (c74c <_strtod_l+0x314>)
    c626:	add.w	r3, r3, r9, lsl #3
    c62a:	ldrd	r2, r3, [r3, #-72]	; 0x48
    c62e:	bl	a7b8 <__aeabi_dmul>
    c632:	mov	r6, r0
    c634:	mov	r0, r8
    c636:	mov	r7, r1
    c638:	bl	a6cc <__aeabi_ui2d>
    c63c:	mov	r2, r0
    c63e:	mov	r3, r1
    c640:	mov	r0, r6
    c642:	mov	r1, r7
    c644:	bl	a454 <__adddf3>
    c648:	strd	r0, r1, [sp, #16]
    c64c:	cmp	r4, #15
    c64e:	bgt.w	c75c <_strtod_l+0x324>
    c652:	ldr	r3, [sp, #44]	; 0x2c
    c654:	cmp	r3, #0
    c656:	beq.n	c6a8 <_strtod_l+0x270>
    c658:	ble.w	d094 <_strtod_l+0xc5c>
    c65c:	ldr	r3, [sp, #44]	; 0x2c
    c65e:	cmp	r3, #22
    c660:	bgt.w	cf60 <_strtod_l+0xb28>
    c664:	ldr	r7, [pc, #228]	; (c74c <_strtod_l+0x314>)
    c666:	add.w	r7, r7, r3, lsl #3
    c66a:	ldrd	r0, r1, [r7]
    c66e:	ldrd	r2, r3, [sp, #16]
    c672:	bl	a7b8 <__aeabi_dmul>
    c676:	mov	r8, r0
    c678:	mov	r9, r1
    c67a:	b.n	c568 <_strtod_l+0x130>
    c67c:	add	r0, sp, #108	; 0x6c
    c67e:	ldr	r1, [pc, #208]	; (c750 <_strtod_l+0x318>)
    c680:	bl	11318 <__match>
    c684:	cmp	r0, #0
    c686:	beq.w	c4a4 <_strtod_l+0x6c>
    c68a:	ldr	r3, [sp, #108]	; 0x6c
    c68c:	ldr	r1, [pc, #196]	; (c754 <_strtod_l+0x31c>)
    c68e:	subs	r3, #1
    c690:	add	r0, sp, #108	; 0x6c
    c692:	str	r3, [sp, #108]	; 0x6c
    c694:	bl	11318 <__match>
    c698:	cbnz	r0, c6a0 <_strtod_l+0x268>
    c69a:	ldr	r3, [sp, #108]	; 0x6c
    c69c:	adds	r3, #1
    c69e:	str	r3, [sp, #108]	; 0x6c
    c6a0:	ldr	r3, [pc, #180]	; (c758 <_strtod_l+0x320>)
    c6a2:	str	r3, [sp, #20]
    c6a4:	movs	r3, #0
    c6a6:	str	r3, [sp, #16]
    c6a8:	ldrd	r8, r9, [sp, #16]
    c6ac:	b.n	c568 <_strtod_l+0x130>
    c6ae:	cmp	r4, #0
    c6b0:	beq.w	ca48 <_strtod_l+0x610>
    c6b4:	ldr	r6, [sp, #108]	; 0x6c
    c6b6:	adds	r3, r6, #1
    c6b8:	str	r3, [sp, #108]	; 0x6c
    c6ba:	ldrb	r3, [r6, #1]
    c6bc:	cmp	r3, #43	; 0x2b
    c6be:	beq.w	cc7c <_strtod_l+0x844>
    c6c2:	cmp	r3, #45	; 0x2d
    c6c4:	beq.w	caf2 <_strtod_l+0x6ba>
    c6c8:	mov.w	ip, #0
    c6cc:	sub.w	r2, r3, #48	; 0x30
    c6d0:	cmp	r2, #9
    c6d2:	bhi.w	cc76 <_strtod_l+0x83e>
    c6d6:	cmp	r3, #48	; 0x30
    c6d8:	bne.n	c6e6 <_strtod_l+0x2ae>
    c6da:	ldr	r2, [sp, #108]	; 0x6c
    c6dc:	adds	r2, #1
    c6de:	str	r2, [sp, #108]	; 0x6c
    c6e0:	ldrb	r3, [r2, #0]
    c6e2:	cmp	r3, #48	; 0x30
    c6e4:	beq.n	c6dc <_strtod_l+0x2a4>
    c6e6:	sub.w	r2, r3, #49	; 0x31
    c6ea:	cmp	r2, #8
    c6ec:	bhi.w	c550 <_strtod_l+0x118>
    c6f0:	ldr	r2, [sp, #108]	; 0x6c
    c6f2:	str	r2, [sp, #48]	; 0x30
    c6f4:	adds	r1, r2, #1
    c6f6:	subs	r3, #48	; 0x30
    c6f8:	str	r1, [sp, #108]	; 0x6c
    c6fa:	str	r3, [sp, #44]	; 0x2c
    c6fc:	ldrb	r3, [r2, #1]
    c6fe:	sub.w	lr, r3, #48	; 0x30
    c702:	cmp.w	lr, #9
    c706:	bhi.n	c728 <_strtod_l+0x2f0>
    c708:	ldr	r2, [sp, #44]	; 0x2c
    c70a:	adds	r1, #1
    c70c:	str	r1, [sp, #108]	; 0x6c
    c70e:	add.w	r2, r2, r2, lsl #2
    c712:	add.w	r2, r3, r2, lsl #1
    c716:	ldrb	r3, [r1, #0]
    c718:	sub.w	lr, r3, #48	; 0x30
    c71c:	cmp.w	lr, #9
    c720:	sub.w	r2, r2, #48	; 0x30
    c724:	bls.n	c70a <_strtod_l+0x2d2>
    c726:	str	r2, [sp, #44]	; 0x2c
    c728:	ldr	r2, [sp, #48]	; 0x30
    c72a:	subs	r1, r1, r2
    c72c:	cmp	r1, #8
    c72e:	bgt.w	cf4e <_strtod_l+0xb16>
    c732:	ldr	r2, [sp, #44]	; 0x2c
    c734:	movw	r1, #19999	; 0x4e1f
    c738:	cmp	r2, r1
    c73a:	it	ge
    c73c:	movge	r2, r1
    c73e:	cmp.w	ip, #0
    c742:	beq.w	c552 <_strtod_l+0x11a>
    c746:	negs	r2, r2
    c748:	b.n	c552 <_strtod_l+0x11a>
    c74a:	nop
    c74c:	.word	0x00013708
    c750:	.word	0x00013410
    c754:	.word	0x00013414
    c758:	.word	0x7ff00000
    c75c:	ldr	r3, [sp, #44]	; 0x2c
    c75e:	rsb	r9, r9, r4
    c762:	add	r9, r3
    c764:	cmp.w	r9, #0
    c768:	ble.w	ce7a <_strtod_l+0xa42>
    c76c:	ands.w	r1, r9, #15
    c770:	beq.n	c788 <_strtod_l+0x350>
    c772:	ldr	r3, [pc, #756]	; (ca68 <_strtod_l+0x630>)
    c774:	add.w	r1, r3, r1, lsl #3
    c778:	ldrd	r0, r1, [r1]
    c77c:	ldrd	r2, r3, [sp, #16]
    c780:	bl	a7b8 <__aeabi_dmul>
    c784:	strd	r0, r1, [sp, #16]
    c788:	bics.w	r6, r9, #15
    c78c:	bne.w	cbb0 <_strtod_l+0x778>
    c790:	movs	r3, #0
    c792:	str	r3, [sp, #40]	; 0x28
    c794:	str	r5, [sp, #0]
    c796:	mov	r3, r4
    c798:	mov	r2, sl
    c79a:	ldr	r1, [sp, #32]
    c79c:	mov	r0, fp
    c79e:	bl	11640 <__s2b>
    c7a2:	str	r0, [sp, #72]	; 0x48
    c7a4:	cmp	r0, #0
    c7a6:	beq.w	cdf6 <_strtod_l+0x9be>
    c7aa:	ldr	r2, [sp, #44]	; 0x2c
    c7ac:	movs	r7, #0
    c7ae:	cmp	r2, #0
    c7b0:	rsb	r3, r2, #0
    c7b4:	it	ge
    c7b6:	movge	r3, r7
    c7b8:	str	r3, [sp, #48]	; 0x30
    c7ba:	bic.w	r3, r2, r2, asr #31
    c7be:	str	r3, [sp, #44]	; 0x2c
    c7c0:	mov	sl, r7
    c7c2:	ldr	r4, [sp, #72]	; 0x48
    c7c4:	mov	r0, fp
    c7c6:	ldr	r1, [r4, #4]
    c7c8:	bl	11560 <_Balloc>
    c7cc:	mov	r6, r0
    c7ce:	cmp	r0, #0
    c7d0:	beq.w	cc88 <_strtod_l+0x850>
    c7d4:	ldr	r2, [r4, #16]
    c7d6:	vldr	d7, [sp, #16]
    c7da:	adds	r2, #2
    c7dc:	lsls	r2, r2, #2
    c7de:	add.w	r1, r4, #12
    c7e2:	adds	r0, #12
    c7e4:	vstr	d7, [sp, #32]
    c7e8:	bl	8b4c <memcpy>
    c7ec:	vldr	d0, [sp, #32]
    c7f0:	add	r2, sp, #120	; 0x78
    c7f2:	add	r1, sp, #116	; 0x74
    c7f4:	mov	r0, fp
    c7f6:	bl	11c84 <__d2b>
    c7fa:	str	r0, [sp, #112]	; 0x70
    c7fc:	cmp	r0, #0
    c7fe:	beq.w	cc8a <_strtod_l+0x852>
    c802:	movs	r1, #1
    c804:	mov	r0, fp
    c806:	bl	11774 <__i2b>
    c80a:	mov	sl, r0
    c80c:	cmp	r0, #0
    c80e:	beq.w	cc88 <_strtod_l+0x850>
    c812:	ldr	r2, [sp, #116]	; 0x74
    c814:	cmp	r2, #0
    c816:	blt.w	ca80 <_strtod_l+0x648>
    c81a:	ldr	r3, [sp, #48]	; 0x30
    c81c:	ldr	r4, [sp, #44]	; 0x2c
    c81e:	adds	r5, r3, r2
    c820:	ldr	r0, [sp, #40]	; 0x28
    c822:	ldr	r3, [sp, #120]	; 0x78
    c824:	ldr	r1, [pc, #580]	; (ca6c <_strtod_l+0x634>)
    c826:	subs	r2, r2, r0
    c828:	add	r2, r3
    c82a:	subs	r2, #1
    c82c:	cmp	r2, r1
    c82e:	rsb	r3, r3, #54	; 0x36
    c832:	bge.w	ca12 <_strtod_l+0x5da>
    c836:	subs	r1, r1, r2
    c838:	cmp	r1, #31
    c83a:	sub.w	r3, r3, r1
    c83e:	bgt.w	ca8e <_strtod_l+0x656>
    c842:	movs	r2, #1
    c844:	lsls	r2, r1
    c846:	str	r2, [sp, #56]	; 0x38
    c848:	movs	r2, #0
    c84a:	str	r2, [sp, #76]	; 0x4c
    c84c:	add.w	r9, r5, r3
    c850:	add	r4, r3
    c852:	ldr	r3, [sp, #40]	; 0x28
    c854:	cmp	r5, r9
    c856:	mov	r2, r5
    c858:	add	r4, r3
    c85a:	it	ge
    c85c:	movge	r2, r9
    c85e:	cmp	r2, r4
    c860:	it	ge
    c862:	movge	r2, r4
    c864:	cmp	r2, #0
    c866:	ble.n	c870 <_strtod_l+0x438>
    c868:	rsb	r9, r2, r9
    c86c:	subs	r4, r4, r2
    c86e:	subs	r5, r5, r2
    c870:	ldr	r3, [sp, #48]	; 0x30
    c872:	cbz	r3, c8a4 <_strtod_l+0x46c>
    c874:	mov	r1, sl
    c876:	mov	r2, r3
    c878:	mov	r0, fp
    c87a:	bl	118b8 <__pow5mult>
    c87e:	mov	sl, r0
    c880:	cmp	r0, #0
    c882:	beq.w	cc88 <_strtod_l+0x850>
    c886:	mov	r1, r0
    c888:	ldr	r2, [sp, #112]	; 0x70
    c88a:	mov	r0, fp
    c88c:	bl	11788 <__multiply>
    c890:	cmp	r0, #0
    c892:	beq.w	cc88 <_strtod_l+0x850>
    c896:	str	r0, [sp, #52]	; 0x34
    c898:	ldr	r1, [sp, #112]	; 0x70
    c89a:	mov	r0, fp
    c89c:	bl	115ac <_Bfree>
    c8a0:	ldr	r2, [sp, #52]	; 0x34
    c8a2:	str	r2, [sp, #112]	; 0x70
    c8a4:	cmp.w	r9, #0
    c8a8:	ble.n	c8bc <_strtod_l+0x484>
    c8aa:	mov	r2, r9
    c8ac:	ldr	r1, [sp, #112]	; 0x70
    c8ae:	mov	r0, fp
    c8b0:	bl	11958 <__lshift>
    c8b4:	str	r0, [sp, #112]	; 0x70
    c8b6:	cmp	r0, #0
    c8b8:	beq.w	cc8a <_strtod_l+0x852>
    c8bc:	ldr	r3, [sp, #44]	; 0x2c
    c8be:	cbz	r3, c8d2 <_strtod_l+0x49a>
    c8c0:	mov	r1, r6
    c8c2:	ldr	r2, [sp, #44]	; 0x2c
    c8c4:	mov	r0, fp
    c8c6:	bl	118b8 <__pow5mult>
    c8ca:	mov	r6, r0
    c8cc:	cmp	r0, #0
    c8ce:	beq.w	cc88 <_strtod_l+0x850>
    c8d2:	cmp	r4, #0
    c8d4:	ble.n	c8e8 <_strtod_l+0x4b0>
    c8d6:	mov	r1, r6
    c8d8:	mov	r2, r4
    c8da:	mov	r0, fp
    c8dc:	bl	11958 <__lshift>
    c8e0:	mov	r6, r0
    c8e2:	cmp	r0, #0
    c8e4:	beq.w	cc88 <_strtod_l+0x850>
    c8e8:	cmp	r5, #0
    c8ea:	ble.n	c8fe <_strtod_l+0x4c6>
    c8ec:	mov	r1, sl
    c8ee:	mov	r2, r5
    c8f0:	mov	r0, fp
    c8f2:	bl	11958 <__lshift>
    c8f6:	mov	sl, r0
    c8f8:	cmp	r0, #0
    c8fa:	beq.w	cc88 <_strtod_l+0x850>
    c8fe:	mov	r2, r6
    c900:	ldr	r1, [sp, #112]	; 0x70
    c902:	mov	r0, fp
    c904:	bl	11a4c <__mdiff>
    c908:	mov	r7, r0
    c90a:	cmp	r0, #0
    c90c:	beq.w	cc88 <_strtod_l+0x850>
    c910:	movs	r3, #0
    c912:	ldr	r2, [r0, #12]
    c914:	str	r3, [r0, #12]
    c916:	mov	r1, sl
    c918:	str	r2, [sp, #52]	; 0x34
    c91a:	bl	11a08 <__mcmp>
    c91e:	cmp	r0, #0
    c920:	blt.w	d13e <_strtod_l+0xd06>
    c924:	beq.w	d0b8 <_strtod_l+0xc80>
    c928:	mov	r1, sl
    c92a:	mov	r0, r7
    c92c:	bl	11d40 <__ratio>
    c930:	vmov	r4, r5, d0
    c934:	movs	r2, #0
    c936:	mov.w	r3, #1073741824	; 0x40000000
    c93a:	vmov	r0, s0
    c93e:	mov	r1, r5
    c940:	bl	acb0 <__aeabi_dcmple>
    c944:	cmp	r0, #0
    c946:	beq.n	ca1c <_strtod_l+0x5e4>
    c948:	ldr	r3, [sp, #52]	; 0x34
    c94a:	cmp	r3, #0
    c94c:	beq.w	ca9e <_strtod_l+0x666>
    c950:	vldr	d7, [pc, #260]	; ca58 <_strtod_l+0x620>
    c954:	ldr	r3, [sp, #20]
    c956:	ldr	r5, [pc, #280]	; (ca70 <_strtod_l+0x638>)
    c958:	vstr	d7, [sp, #56]	; 0x38
    c95c:	movs	r4, #0
    c95e:	mov	r8, r3
    c960:	ldr.w	r9, [pc, #276]	; ca78 <_strtod_l+0x640>
    c964:	ldr	r3, [pc, #268]	; (ca74 <_strtod_l+0x63c>)
    c966:	and.w	r9, r8, r9
    c96a:	cmp	r9, r3
    c96c:	beq.w	cd9c <_strtod_l+0x964>
    c970:	ldr	r3, [sp, #40]	; 0x28
    c972:	cbz	r3, c9c0 <_strtod_l+0x588>
    c974:	cmp.w	r9, #111149056	; 0x6a00000
    c978:	bhi.n	c9c0 <_strtod_l+0x588>
    c97a:	add	r3, pc, #228	; (adr r3, ca60 <_strtod_l+0x628>)
    c97c:	ldrd	r2, r3, [r3]
    c980:	ldrd	r0, r1, [sp, #56]	; 0x38
    c984:	bl	acb0 <__aeabi_dcmple>
    c988:	cbz	r0, c9b8 <_strtod_l+0x580>
    c98a:	ldrd	r0, r1, [sp, #56]	; 0x38
    c98e:	bl	ad68 <__aeabi_d2uiz>
    c992:	cmp	r0, #0
    c994:	beq.w	d018 <_strtod_l+0xbe0>
    c998:	bl	a6cc <__aeabi_ui2d>
    c99c:	strd	r0, r1, [sp, #56]	; 0x38
    c9a0:	ldr	r3, [sp, #52]	; 0x34
    c9a2:	cmp	r3, #0
    c9a4:	bne.w	d00e <_strtod_l+0xbd6>
    c9a8:	ldrd	r1, r2, [sp, #56]	; 0x38
    c9ac:	add.w	r3, r2, #2147483648	; 0x80000000
    c9b0:	str	r1, [sp, #80]	; 0x50
    c9b2:	str	r3, [sp, #84]	; 0x54
    c9b4:	ldrd	r4, r5, [sp, #80]	; 0x50
    c9b8:	add.w	r3, r5, #112197632	; 0x6b00000
    c9bc:	rsb	r5, r9, r3
    c9c0:	vldr	d0, [sp, #32]
    c9c4:	bl	11b60 <__ulp>
    c9c8:	mov	r0, r4
    c9ca:	vmov	r2, r3, d0
    c9ce:	mov	r1, r5
    c9d0:	bl	a7b8 <__aeabi_dmul>
    c9d4:	ldrd	r2, r3, [sp, #32]
    c9d8:	bl	a454 <__adddf3>
    c9dc:	strd	r0, r1, [sp, #16]
    c9e0:	mov	r4, r1
    c9e2:	ldr	r3, [sp, #40]	; 0x28
    c9e4:	cbnz	r3, c9f0 <_strtod_l+0x5b8>
    c9e6:	ldr	r3, [pc, #144]	; (ca78 <_strtod_l+0x640>)
    c9e8:	ands	r3, r4
    c9ea:	cmp	r9, r3
    c9ec:	beq.w	ce0c <_strtod_l+0x9d4>
    c9f0:	ldr	r1, [sp, #112]	; 0x70
    c9f2:	mov	r0, fp
    c9f4:	bl	115ac <_Bfree>
    c9f8:	mov	r1, r6
    c9fa:	mov	r0, fp
    c9fc:	bl	115ac <_Bfree>
    ca00:	mov	r1, sl
    ca02:	mov	r0, fp
    ca04:	bl	115ac <_Bfree>
    ca08:	mov	r1, r7
    ca0a:	mov	r0, fp
    ca0c:	bl	115ac <_Bfree>
    ca10:	b.n	c7c2 <_strtod_l+0x38a>
    ca12:	movs	r2, #0
    ca14:	str	r2, [sp, #76]	; 0x4c
    ca16:	movs	r2, #1
    ca18:	str	r2, [sp, #56]	; 0x38
    ca1a:	b.n	c84c <_strtod_l+0x414>
    ca1c:	ldr	r3, [pc, #92]	; (ca7c <_strtod_l+0x644>)
    ca1e:	mov	r0, r4
    ca20:	mov	r1, r5
    ca22:	movs	r2, #0
    ca24:	bl	a7b8 <__aeabi_dmul>
    ca28:	ldr	r3, [sp, #52]	; 0x34
    ca2a:	strd	r0, r1, [sp, #56]	; 0x38
    ca2e:	cmp	r3, #0
    ca30:	bne.n	cae8 <_strtod_l+0x6b0>
    ca32:	add.w	r3, r1, #2147483648	; 0x80000000
    ca36:	str	r0, [sp, #64]	; 0x40
    ca38:	str	r3, [sp, #68]	; 0x44
    ca3a:	ldr	r3, [sp, #20]
    ca3c:	ldrd	r4, r5, [sp, #64]	; 0x40
    ca40:	mov	r8, r3
    ca42:	b.n	c960 <_strtod_l+0x528>
    ca44:	mov.w	r9, #1
    ca48:	cmp	r0, #0
    ca4a:	bne.n	cafe <_strtod_l+0x6c6>
    ca4c:	ldr	r3, [sp, #40]	; 0x28
    ca4e:	cmp	r3, #0
    ca50:	beq.w	c4a4 <_strtod_l+0x6c>
    ca54:	mov	r4, r0
    ca56:	b.n	c6b4 <_strtod_l+0x27c>
    ca58:	.word	0x00000000
    ca5c:	.word	0x3ff00000
    ca60:	.word	0xffc00000
    ca64:	.word	0x41dfffff
    ca68:	.word	0x00013708
    ca6c:	.word	0xfffffc02
    ca70:	.word	0x3ff00000
    ca74:	.word	0x7fe00000
    ca78:	.word	0x7ff00000
    ca7c:	.word	0x3fe00000
    ca80:	ldr	r3, [sp, #44]	; 0x2c
    ca82:	ldr	r5, [sp, #48]	; 0x30
    ca84:	subs	r4, r3, r2
    ca86:	b.n	c820 <_strtod_l+0x3e8>
    ca88:	mov.w	r9, #1
    ca8c:	b.n	c544 <_strtod_l+0x10c>
    ca8e:	ldr	r1, [pc, #736]	; (cd70 <_strtod_l+0x938>)
    ca90:	subs	r1, r1, r2
    ca92:	movs	r2, #1
    ca94:	lsl.w	r1, r2, r1
    ca98:	str	r1, [sp, #76]	; 0x4c
    ca9a:	str	r2, [sp, #56]	; 0x38
    ca9c:	b.n	c84c <_strtod_l+0x414>
    ca9e:	ldrd	r1, r2, [sp, #16]
    caa2:	cmp	r1, #0
    caa4:	bne.w	cc3a <_strtod_l+0x802>
    caa8:	ubfx	r3, r2, #0, #20
    caac:	mov	r8, r2
    caae:	cmp	r3, #0
    cab0:	bne.w	cc46 <_strtod_l+0x80e>
    cab4:	movs	r2, #0
    cab6:	ldr	r3, [pc, #700]	; (cd74 <_strtod_l+0x93c>)
    cab8:	mov	r0, r4
    caba:	mov	r1, r5
    cabc:	bl	ac9c <__aeabi_dcmplt>
    cac0:	cmp	r0, #0
    cac2:	bne.w	d1c2 <_strtod_l+0xd8a>
    cac6:	movs	r2, #0
    cac8:	ldr	r3, [pc, #684]	; (cd78 <_strtod_l+0x940>)
    caca:	mov	r0, r4
    cacc:	mov	r1, r5
    cace:	bl	a7b8 <__aeabi_dmul>
    cad2:	mov	r2, r1
    cad4:	mov	r1, r0
    cad6:	strd	r1, r2, [sp, #56]	; 0x38
    cada:	add.w	r3, r2, #2147483648	; 0x80000000
    cade:	str	r0, [sp, #96]	; 0x60
    cae0:	str	r3, [sp, #100]	; 0x64
    cae2:	ldrd	r4, r5, [sp, #96]	; 0x60
    cae6:	b.n	c960 <_strtod_l+0x528>
    cae8:	vldr	d7, [sp, #56]	; 0x38
    caec:	vstr	d7, [sp, #64]	; 0x40
    caf0:	b.n	ca3a <_strtod_l+0x602>
    caf2:	mov.w	ip, #1
    caf6:	adds	r3, r6, #2
    caf8:	str	r3, [sp, #108]	; 0x6c
    cafa:	ldrb	r3, [r6, #2]
    cafc:	b.n	c6cc <_strtod_l+0x294>
    cafe:	movs	r4, #0
    cb00:	b.n	c6b4 <_strtod_l+0x27c>
    cb02:	cmp.w	r9, #0
    cb06:	bne.w	c4a4 <_strtod_l+0x6c>
    cb0a:	subs	r3, #73	; 0x49
    cb0c:	cmp	r3, #37	; 0x25
    cb0e:	bhi.w	c4a4 <_strtod_l+0x6c>
    cb12:	add	r2, pc, #4	; (adr r2, cb18 <_strtod_l+0x6e0>)
    cb14:	ldr.w	pc, [r2, r3, lsl #2]
    cb18:	.word	0x0000c67d
    cb1c:	.word	0x0000c4a5
    cb20:	.word	0x0000c4a5
    cb24:	.word	0x0000c4a5
    cb28:	.word	0x0000c4a5
    cb2c:	.word	0x0000cc55
    cb30:	.word	0x0000c4a5
    cb34:	.word	0x0000c4a5
    cb38:	.word	0x0000c4a5
    cb3c:	.word	0x0000c4a5
    cb40:	.word	0x0000c4a5
    cb44:	.word	0x0000c4a5
    cb48:	.word	0x0000c4a5
    cb4c:	.word	0x0000c4a5
    cb50:	.word	0x0000c4a5
    cb54:	.word	0x0000c4a5
    cb58:	.word	0x0000c4a5
    cb5c:	.word	0x0000c4a5
    cb60:	.word	0x0000c4a5
    cb64:	.word	0x0000c4a5
    cb68:	.word	0x0000c4a5
    cb6c:	.word	0x0000c4a5
    cb70:	.word	0x0000c4a5
    cb74:	.word	0x0000c4a5
    cb78:	.word	0x0000c4a5
    cb7c:	.word	0x0000c4a5
    cb80:	.word	0x0000c4a5
    cb84:	.word	0x0000c4a5
    cb88:	.word	0x0000c4a5
    cb8c:	.word	0x0000c4a5
    cb90:	.word	0x0000c4a5
    cb94:	.word	0x0000c4a5
    cb98:	.word	0x0000c67d
    cb9c:	.word	0x0000c4a5
    cba0:	.word	0x0000c4a5
    cba4:	.word	0x0000c4a5
    cba8:	.word	0x0000c4a5
    cbac:	.word	0x0000cc55
    cbb0:	cmp.w	r6, #308	; 0x134
    cbb4:	bgt.w	cdf6 <_strtod_l+0x9be>
    cbb8:	asrs	r6, r6, #4
    cbba:	cmp	r6, #1
    cbbc:	ldr.w	r9, [pc, #472]	; cd98 <_strtod_l+0x960>
    cbc0:	ble.w	d1f6 <_strtod_l+0xdbe>
    cbc4:	ldrd	r0, r1, [sp, #16]
    cbc8:	movs	r3, #0
    cbca:	mov	r7, r9
    cbcc:	mov	r8, r3
    cbce:	tst.w	r6, #1
    cbd2:	add.w	r8, r8, #1
    cbd6:	mov.w	r6, r6, asr #1
    cbda:	beq.n	cbe6 <_strtod_l+0x7ae>
    cbdc:	ldrd	r2, r3, [r7]
    cbe0:	bl	a7b8 <__aeabi_dmul>
    cbe4:	movs	r3, #1
    cbe6:	cmp	r6, #1
    cbe8:	add.w	r7, r7, #8
    cbec:	bne.n	cbce <_strtod_l+0x796>
    cbee:	cmp	r3, #0
    cbf0:	bne.w	d2ba <_strtod_l+0xe82>
    cbf4:	ldr	r3, [sp, #20]
    cbf6:	sub.w	r3, r3, #55574528	; 0x3500000
    cbfa:	str	r3, [sp, #20]
    cbfc:	add.w	r8, r9, r8, lsl #3
    cc00:	ldrd	r2, r3, [sp, #16]
    cc04:	ldrd	r0, r1, [r8]
    cc08:	bl	a7b8 <__aeabi_dmul>
    cc0c:	bic.w	r3, r1, #2147483648	; 0x80000000
    cc10:	lsrs	r3, r3, #20
    cc12:	ldr	r2, [pc, #360]	; (cd7c <_strtod_l+0x944>)
    cc14:	lsls	r3, r3, #20
    cc16:	cmp	r3, r2
    cc18:	strd	r0, r1, [sp, #16]
    cc1c:	bhi.w	cdf6 <_strtod_l+0x9be>
    cc20:	sub.w	r2, r2, #1048576	; 0x100000
    cc24:	cmp	r3, r2
    cc26:	bls.w	d1b8 <_strtod_l+0xd80>
    cc2a:	ldr	r3, [pc, #340]	; (cd80 <_strtod_l+0x948>)
    cc2c:	str	r3, [sp, #20]
    cc2e:	movs	r3, #0
    cc30:	str	r3, [sp, #40]	; 0x28
    cc32:	mov.w	r3, #4294967295
    cc36:	str	r3, [sp, #16]
    cc38:	b.n	c794 <_strtod_l+0x35c>
    cc3a:	ldrd	r1, r2, [sp, #16]
    cc3e:	cmp	r1, #1
    cc40:	beq.w	d022 <_strtod_l+0xbea>
    cc44:	mov	r8, r2
    cc46:	vldr	d7, [pc, #288]	; cd68 <_strtod_l+0x930>
    cc4a:	movs	r4, #0
    cc4c:	ldr	r5, [pc, #308]	; (cd84 <_strtod_l+0x94c>)
    cc4e:	vstr	d7, [sp, #56]	; 0x38
    cc52:	b.n	c960 <_strtod_l+0x528>
    cc54:	add	r0, sp, #108	; 0x6c
    cc56:	ldr	r1, [pc, #304]	; (cd88 <_strtod_l+0x950>)
    cc58:	bl	11318 <__match>
    cc5c:	cmp	r0, #0
    cc5e:	beq.w	c4a4 <_strtod_l+0x6c>
    cc62:	ldr	r3, [sp, #108]	; 0x6c
    cc64:	ldrb	r3, [r3, #0]
    cc66:	cmp	r3, #40	; 0x28
    cc68:	beq.w	d270 <_strtod_l+0xe38>
    cc6c:	ldr	r3, [pc, #284]	; (cd8c <_strtod_l+0x954>)
    cc6e:	str	r3, [sp, #20]
    cc70:	movs	r3, #0
    cc72:	str	r3, [sp, #16]
    cc74:	b.n	c6a8 <_strtod_l+0x270>
    cc76:	str	r6, [sp, #108]	; 0x6c
    cc78:	movs	r2, #0
    cc7a:	b.n	c552 <_strtod_l+0x11a>
    cc7c:	mov.w	ip, #0
    cc80:	b.n	caf6 <_strtod_l+0x6be>
    cc82:	adds	r3, #1
    cc84:	bne.w	d256 <_strtod_l+0xe1e>
    cc88:	ldr	r0, [sp, #112]	; 0x70
    cc8a:	ldr	r3, [pc, #260]	; (cd90 <_strtod_l+0x958>)
    cc8c:	str	r3, [sp, #20]
    cc8e:	movs	r2, #0
    cc90:	str	r2, [sp, #16]
    cc92:	ldrd	r8, r9, [sp, #16]
    cc96:	movs	r3, #34	; 0x22
    cc98:	str.w	r3, [fp]
    cc9c:	mov	r1, r0
    cc9e:	mov	r0, fp
    cca0:	bl	115ac <_Bfree>
    cca4:	mov	r1, r6
    cca6:	mov	r0, fp
    cca8:	bl	115ac <_Bfree>
    ccac:	mov	r1, sl
    ccae:	mov	r0, fp
    ccb0:	bl	115ac <_Bfree>
    ccb4:	ldr	r1, [sp, #72]	; 0x48
    ccb6:	mov	r0, fp
    ccb8:	bl	115ac <_Bfree>
    ccbc:	mov	r1, r7
    ccbe:	mov	r0, fp
    ccc0:	bl	115ac <_Bfree>
    ccc4:	b.n	c568 <_strtod_l+0x130>
    ccc6:	ldr	r2, [sp, #28]
    ccc8:	str	r5, [sp, #8]
    ccca:	add	r3, sp, #112	; 0x70
    cccc:	str	r2, [sp, #4]
    ccce:	str	r3, [sp, #0]
    ccd0:	ldr	r2, [pc, #192]	; (cd94 <_strtod_l+0x95c>)
    ccd2:	add	r3, sp, #116	; 0x74
    ccd4:	add	r1, sp, #108	; 0x6c
    ccd6:	mov	r0, fp
    ccd8:	bl	10e08 <__gethex>
    ccdc:	ands.w	r6, r0, #7
    cce0:	mov	r5, r0
    cce2:	beq.w	c560 <_strtod_l+0x128>
    cce6:	cmp	r6, #6
    cce8:	bne.w	cf98 <_strtod_l+0xb60>
    ccec:	adds	r4, #1
    ccee:	movs	r3, #0
    ccf0:	str	r4, [sp, #108]	; 0x6c
    ccf2:	mov.w	r8, #0
    ccf6:	mov.w	r9, #0
    ccfa:	str	r3, [sp, #28]
    ccfc:	b.n	c568 <_strtod_l+0x130>
    ccfe:	ldr.w	r1, [sl]
    cd02:	mov	r0, r4
    cd04:	mov	r2, r9
    cd06:	bl	c35c <strncmp>
    cd0a:	cbz	r0, cd20 <_strtod_l+0x8e8>
    cd0c:	mov.w	sl, #0
    cd10:	mov	r3, r7
    cd12:	mov	r8, sl
    cd14:	mov	r5, sl
    cd16:	mov	r0, sl
    cd18:	mov	r7, sl
    cd1a:	mov	r4, sl
    cd1c:	mov	r9, sl
    cd1e:	b.n	c544 <_strtod_l+0x10c>
    cd20:	ldr	r3, [sp, #108]	; 0x6c
    cd22:	add.w	r2, r3, r9
    cd26:	str	r2, [sp, #108]	; 0x6c
    cd28:	ldrb.w	r3, [r3, r9]
    cd2c:	cmp	r3, #48	; 0x30
    cd2e:	bne.n	cd3e <_strtod_l+0x906>
    cd30:	adds	r2, #1
    cd32:	str	r2, [sp, #108]	; 0x6c
    cd34:	ldrb	r3, [r2, #0]
    cd36:	cmp	r3, #48	; 0x30
    cd38:	add.w	r0, r0, #1
    cd3c:	beq.n	cd30 <_strtod_l+0x8f8>
    cd3e:	sub.w	r2, r3, #49	; 0x31
    cd42:	cmp	r2, #8
    cd44:	bls.w	d040 <_strtod_l+0xc08>
    cd48:	mov.w	sl, #0
    cd4c:	cmp	r3, #101	; 0x65
    cd4e:	mov	r8, sl
    cd50:	mov	r5, sl
    cd52:	mov	r7, sl
    cd54:	beq.w	ca44 <_strtod_l+0x60c>
    cd58:	mov	r4, sl
    cd5a:	mov.w	r9, #1
    cd5e:	b.w	c54a <_strtod_l+0x112>
    cd62:	nop
    cd64:	nop.w
    cd68:	.word	0x00000000
    cd6c:	.word	0x3ff00000
    cd70:	.word	0xfffffbe2
    cd74:	.word	0x3ff00000
    cd78:	.word	0x3fe00000
    cd7c:	.word	0x7ca00000
    cd80:	.word	0x7fefffff
    cd84:	.word	0xbff00000
    cd88:	.word	0x0001341c
    cd8c:	.word	0xfff80000
    cd90:	.word	0x7ff00000
    cd94:	.word	0x000133fc
    cd98:	.word	0x000137d0
    cd9c:	sub.w	r3, r8, #55574528	; 0x3500000
    cda0:	str	r3, [sp, #20]
    cda2:	vldr	d7, [sp, #16]
    cda6:	vmov.f32	s0, s14
    cdaa:	vmov.f32	s1, s15
    cdae:	bl	11b60 <__ulp>
    cdb2:	mov	r0, r4
    cdb4:	vmov	r2, r3, d0
    cdb8:	mov	r1, r5
    cdba:	bl	a7b8 <__aeabi_dmul>
    cdbe:	ldrd	r2, r3, [sp, #16]
    cdc2:	bl	a454 <__adddf3>
    cdc6:	bic.w	r3, r1, #2147483648	; 0x80000000
    cdca:	strd	r0, r1, [sp, #16]
    cdce:	lsrs	r3, r3, #20
    cdd0:	ldr	r2, [pc, #684]	; (d080 <_strtod_l+0xc48>)
    cdd2:	ldrd	r0, r1, [sp, #32]
    cdd6:	lsls	r3, r3, #20
    cdd8:	cmp	r3, r2
    cdda:	strd	r0, r1, [sp, #88]	; 0x58
    cdde:	bls.w	cf56 <_strtod_l+0xb1e>
    cde2:	ldr	r3, [pc, #672]	; (d084 <_strtod_l+0xc4c>)
    cde4:	cmp	r1, r3
    cde6:	beq.w	d1ae <_strtod_l+0xd76>
    cdea:	ldr	r3, [pc, #664]	; (d084 <_strtod_l+0xc4c>)
    cdec:	str	r3, [sp, #20]
    cdee:	mov.w	r3, #4294967295
    cdf2:	str	r3, [sp, #16]
    cdf4:	b.n	c9f0 <_strtod_l+0x5b8>
    cdf6:	ldr	r3, [pc, #656]	; (d088 <_strtod_l+0xc50>)
    cdf8:	str	r3, [sp, #20]
    cdfa:	movs	r2, #0
    cdfc:	movs	r3, #34	; 0x22
    cdfe:	str	r2, [sp, #16]
    ce00:	ldrd	r8, r9, [sp, #16]
    ce04:	str.w	r3, [fp]
    ce08:	b.w	c568 <_strtod_l+0x130>
    ce0c:	ldrd	r8, r9, [sp, #56]	; 0x38
    ce10:	mov	r1, r9
    ce12:	mov	r0, r8
    ce14:	bl	ad18 <__aeabi_d2iz>
    ce18:	bl	a6ec <__aeabi_i2d>
    ce1c:	mov	r3, r1
    ce1e:	mov	r2, r0
    ce20:	mov	r1, r9
    ce22:	mov	r0, r8
    ce24:	bl	a450 <__aeabi_dsub>
    ce28:	ldr	r3, [sp, #52]	; 0x34
    ce2a:	mov	r8, r0
    ce2c:	mov	r9, r1
    ce2e:	cbnz	r3, ce52 <_strtod_l+0xa1a>
    ce30:	ldr	r3, [sp, #16]
    ce32:	cbnz	r3, ce52 <_strtod_l+0xa1a>
    ce34:	ubfx	r4, r4, #0, #20
    ce38:	cbnz	r4, ce52 <_strtod_l+0xa1a>
    ce3a:	add	r3, pc, #548	; (adr r3, d060 <_strtod_l+0xc28>)
    ce3c:	ldrd	r2, r3, [r3]
    ce40:	bl	ac9c <__aeabi_dcmplt>
    ce44:	cmp	r0, #0
    ce46:	beq.w	c9f0 <_strtod_l+0x5b8>
    ce4a:	ldrd	r8, r9, [sp, #16]
    ce4e:	ldr	r0, [sp, #112]	; 0x70
    ce50:	b.n	cc9c <_strtod_l+0x864>
    ce52:	add	r3, pc, #532	; (adr r3, d068 <_strtod_l+0xc30>)
    ce54:	ldrd	r2, r3, [r3]
    ce58:	mov	r0, r8
    ce5a:	mov	r1, r9
    ce5c:	bl	ac9c <__aeabi_dcmplt>
    ce60:	cmp	r0, #0
    ce62:	bne.n	ce4a <_strtod_l+0xa12>
    ce64:	mov	r0, r8
    ce66:	mov	r1, r9
    ce68:	add	r3, pc, #516	; (adr r3, d070 <_strtod_l+0xc38>)
    ce6a:	ldrd	r2, r3, [r3]
    ce6e:	bl	acd8 <__aeabi_dcmpgt>
    ce72:	cmp	r0, #0
    ce74:	beq.w	c9f0 <_strtod_l+0x5b8>
    ce78:	b.n	ce4a <_strtod_l+0xa12>
    ce7a:	beq.w	c790 <_strtod_l+0x358>
    ce7e:	rsb	r6, r9, #0
    ce82:	ands.w	r2, r6, #15
    ce86:	beq.n	ce9e <_strtod_l+0xa66>
    ce88:	ldr	r3, [pc, #512]	; (d08c <_strtod_l+0xc54>)
    ce8a:	add.w	r3, r3, r2, lsl #3
    ce8e:	ldrd	r0, r1, [sp, #16]
    ce92:	ldrd	r2, r3, [r3]
    ce96:	bl	aa0c <__aeabi_ddiv>
    ce9a:	strd	r0, r1, [sp, #16]
    ce9e:	asrs	r6, r6, #4
    cea0:	beq.w	c790 <_strtod_l+0x358>
    cea4:	cmp	r6, #31
    cea6:	bgt.n	cf1a <_strtod_l+0xae2>
    cea8:	ands.w	r3, r6, #16
    ceac:	beq.w	d220 <_strtod_l+0xde8>
    ceb0:	movs	r3, #106	; 0x6a
    ceb2:	cmp	r6, #0
    ceb4:	str	r3, [sp, #40]	; 0x28
    ceb6:	ble.n	cee0 <_strtod_l+0xaa8>
    ceb8:	ldrd	r0, r1, [sp, #16]
    cebc:	ldr	r7, [pc, #464]	; (d090 <_strtod_l+0xc58>)
    cebe:	movs	r3, #0
    cec0:	lsls	r2, r6, #31
    cec2:	bpl.n	cece <_strtod_l+0xa96>
    cec4:	ldrd	r2, r3, [r7]
    cec8:	bl	a7b8 <__aeabi_dmul>
    cecc:	movs	r3, #1
    cece:	asrs	r6, r6, #1
    ced0:	add.w	r7, r7, #8
    ced4:	bne.n	cec0 <_strtod_l+0xa88>
    ced6:	cmp	r3, #0
    ced8:	bne.w	d2c0 <_strtod_l+0xe88>
    cedc:	ldr	r3, [sp, #40]	; 0x28
    cede:	cbz	r3, cf08 <_strtod_l+0xad0>
    cee0:	ldrd	r1, r2, [sp, #16]
    cee4:	ubfx	r3, r2, #20, #11
    cee8:	rsb	r3, r3, #107	; 0x6b
    ceec:	cmp	r3, #0
    ceee:	mov	r1, r2
    cef0:	ble.n	cf08 <_strtod_l+0xad0>
    cef2:	cmp	r3, #31
    cef4:	ble.w	d2aa <_strtod_l+0xe72>
    cef8:	movs	r2, #0
    cefa:	cmp	r3, #52	; 0x34
    cefc:	str	r2, [sp, #16]
    cefe:	ble.w	d2c6 <_strtod_l+0xe8e>
    cf02:	mov.w	r3, #57671680	; 0x3700000
    cf06:	str	r3, [sp, #20]
    cf08:	movs	r2, #0
    cf0a:	movs	r3, #0
    cf0c:	ldrd	r0, r1, [sp, #16]
    cf10:	bl	ac88 <__aeabi_dcmpeq>
    cf14:	cmp	r0, #0
    cf16:	beq.w	c794 <_strtod_l+0x35c>
    cf1a:	movs	r3, #34	; 0x22
    cf1c:	str.w	r3, [fp]
    cf20:	mov.w	r8, #0
    cf24:	mov.w	r9, #0
    cf28:	b.w	c568 <_strtod_l+0x130>
    cf2c:	ldr	r1, [sp, #108]	; 0x6c
    cf2e:	adds	r4, #1
    cf30:	cmp	r0, #8
    cf32:	ble.w	d052 <_strtod_l+0xc1a>
    cf36:	cmp	r4, #16
    cf38:	itt	le
    cf3a:	addle.w	r8, r8, r8, lsl #2
    cf3e:	addle.w	r8, r2, r8, lsl #1
    cf42:	movs	r0, #0
    cf44:	adds	r3, r1, #1
    cf46:	str	r3, [sp, #108]	; 0x6c
    cf48:	ldrb	r3, [r1, #1]
    cf4a:	b.w	c58c <_strtod_l+0x154>
    cf4e:	movw	r2, #19999	; 0x4e1f
    cf52:	b.w	c73e <_strtod_l+0x306>
    cf56:	ldr	r3, [sp, #20]
    cf58:	add.w	r4, r3, #55574528	; 0x3500000
    cf5c:	str	r4, [sp, #20]
    cf5e:	b.n	c9e2 <_strtod_l+0x5aa>
    cf60:	ldr	r6, [sp, #44]	; 0x2c
    cf62:	rsb	r3, r4, #37	; 0x25
    cf66:	cmp	r6, r3
    cf68:	bgt.w	c75c <_strtod_l+0x324>
    cf6c:	ldr	r5, [pc, #284]	; (d08c <_strtod_l+0xc54>)
    cf6e:	rsb	r4, r4, #15
    cf72:	add.w	r1, r5, r4, lsl #3
    cf76:	subs	r4, r6, r4
    cf78:	ldrd	r2, r3, [sp, #16]
    cf7c:	ldrd	r0, r1, [r1]
    cf80:	add.w	r5, r5, r4, lsl #3
    cf84:	bl	a7b8 <__aeabi_dmul>
    cf88:	ldrd	r2, r3, [r5]
    cf8c:	bl	a7b8 <__aeabi_dmul>
    cf90:	mov	r8, r0
    cf92:	mov	r9, r1
    cf94:	b.w	c568 <_strtod_l+0x130>
    cf98:	ldr	r2, [sp, #112]	; 0x70
    cf9a:	cbz	r2, cfac <_strtod_l+0xb74>
    cf9c:	movs	r1, #53	; 0x35
    cf9e:	add	r0, sp, #120	; 0x78
    cfa0:	bl	11da0 <__copybits>
    cfa4:	mov	r0, fp
    cfa6:	ldr	r1, [sp, #112]	; 0x70
    cfa8:	bl	115ac <_Bfree>
    cfac:	cmp	r6, #6
    cfae:	bhi.n	cfc8 <_strtod_l+0xb90>
    cfb0:	tbb	[pc, r6]
    cfb4:	.word	0x1318211d
    cfb8:	.short	0x2104
    cfba:	.byte	0x1d
    cfbb:	.byte	0x00
    cfbc:	mvn.w	r3, #2147483648	; 0x80000000
    cfc0:	str	r3, [sp, #20]
    cfc2:	mov.w	r3, #4294967295
    cfc6:	str	r3, [sp, #16]
    cfc8:	lsls	r1, r5, #28
    cfca:	bpl.w	c6a8 <_strtod_l+0x270>
    cfce:	ldr	r3, [sp, #20]
    cfd0:	orr.w	r3, r3, #2147483648	; 0x80000000
    cfd4:	str	r3, [sp, #20]
    cfd6:	b.w	c6a8 <_strtod_l+0x270>
    cfda:	ldr	r3, [pc, #172]	; (d088 <_strtod_l+0xc50>)
    cfdc:	str	r3, [sp, #20]
    cfde:	movs	r3, #0
    cfe0:	str	r3, [sp, #16]
    cfe2:	b.n	cfc8 <_strtod_l+0xb90>
    cfe4:	ldr	r3, [sp, #120]	; 0x78
    cfe6:	str	r3, [sp, #16]
    cfe8:	ldr	r3, [sp, #124]	; 0x7c
    cfea:	str	r3, [sp, #20]
    cfec:	b.n	cfc8 <_strtod_l+0xb90>
    cfee:	movs	r3, #0
    cff0:	str	r3, [sp, #20]
    cff2:	str	r3, [sp, #16]
    cff4:	b.n	cfc8 <_strtod_l+0xb90>
    cff6:	ldr	r2, [sp, #116]	; 0x74
    cff8:	ldr	r3, [sp, #124]	; 0x7c
    cffa:	ldr	r1, [sp, #120]	; 0x78
    cffc:	str	r1, [sp, #16]
    cffe:	addw	r2, r2, #1075	; 0x433
    d002:	bic.w	r3, r3, #1048576	; 0x100000
    d006:	orr.w	r3, r3, r2, lsl #20
    d00a:	str	r3, [sp, #20]
    d00c:	b.n	cfc8 <_strtod_l+0xb90>
    d00e:	vldr	d7, [sp, #56]	; 0x38
    d012:	vstr	d7, [sp, #80]	; 0x50
    d016:	b.n	c9b4 <_strtod_l+0x57c>
    d018:	vldr	d7, [pc, #92]	; d078 <_strtod_l+0xc40>
    d01c:	vstr	d7, [sp, #56]	; 0x38
    d020:	b.n	c9a0 <_strtod_l+0x568>
    d022:	ldrd	r1, r2, [sp, #16]
    d026:	mov	r8, r2
    d028:	cmp	r2, #0
    d02a:	bne.w	cc46 <_strtod_l+0x80e>
    d02e:	movs	r3, #34	; 0x22
    d030:	str.w	r3, [fp]
    d034:	ldr	r0, [sp, #112]	; 0x70
    d036:	mov.w	r8, #0
    d03a:	mov.w	r9, #0
    d03e:	b.n	cc9c <_strtod_l+0x864>
    d040:	ldr	r2, [sp, #108]	; 0x6c
    d042:	str	r2, [sp, #32]
    d044:	movs	r5, #0
    d046:	subs	r3, #48	; 0x30
    d048:	adds	r7, r0, #1
    d04a:	mov	r1, r2
    d04c:	mov	sl, r5
    d04e:	mov	r8, r5
    d050:	movs	r4, #1
    d052:	add.w	r5, r5, r5, lsl #2
    d056:	add.w	r5, r3, r5, lsl #1
    d05a:	movs	r0, #0
    d05c:	b.n	cf44 <_strtod_l+0xb0c>
    d05e:	nop
    d060:	.word	0x94a03595
    d064:	.word	0x3fcfffff
    d068:	.word	0x94a03595
    d06c:	.word	0x3fdfffff
    d070:	.word	0x35afe535
    d074:	.word	0x3fe00000
    d078:	.word	0x00000000
    d07c:	.word	0x3ff00000
    d080:	.word	0x7c9fffff
    d084:	.word	0x7fefffff
    d088:	.word	0x7ff00000
    d08c:	.word	0x00013708
    d090:	.word	0x00013438
    d094:	ldr	r1, [sp, #44]	; 0x2c
    d096:	cmn.w	r1, #22
    d09a:	blt.w	c75c <_strtod_l+0x324>
    d09e:	ldr	r2, [pc, #600]	; (d2f8 <_strtod_l+0xec0>)
    d0a0:	sub.w	r2, r2, r1, lsl #3
    d0a4:	ldrd	r2, r3, [r2]
    d0a8:	ldrd	r0, r1, [sp, #16]
    d0ac:	bl	aa0c <__aeabi_ddiv>
    d0b0:	mov	r8, r0
    d0b2:	mov	r9, r1
    d0b4:	b.w	c568 <_strtod_l+0x130>
    d0b8:	ldr	r3, [sp, #52]	; 0x34
    d0ba:	ldrd	r8, r9, [sp, #32]
    d0be:	cmp	r3, #0
    d0c0:	beq.w	d1d4 <_strtod_l+0xd9c>
    d0c4:	ldrd	r4, r5, [sp, #16]
    d0c8:	ldr	r3, [pc, #560]	; (d2fc <_strtod_l+0xec4>)
    d0ca:	ubfx	r1, r5, #0, #20
    d0ce:	cmp	r1, r3
    d0d0:	mov	r2, r5
    d0d2:	beq.w	d22a <_strtod_l+0xdf2>
    d0d6:	ldr	r3, [sp, #76]	; 0x4c
    d0d8:	cmp	r3, #0
    d0da:	beq.w	d1ec <_strtod_l+0xdb4>
    d0de:	ldr	r2, [sp, #20]
    d0e0:	tst	r3, r2
    d0e2:	beq.n	d106 <_strtod_l+0xcce>
    d0e4:	ldr	r3, [sp, #52]	; 0x34
    d0e6:	ldr	r2, [sp, #40]	; 0x28
    d0e8:	ldrd	r0, r1, [sp, #16]
    d0ec:	cmp	r3, #0
    d0ee:	beq.w	d1fc <_strtod_l+0xdc4>
    d0f2:	bl	c3fc <sulp>
    d0f6:	mov	r2, r0
    d0f8:	mov	r3, r1
    d0fa:	mov	r0, r8
    d0fc:	mov	r1, r9
    d0fe:	bl	a454 <__adddf3>
    d102:	mov	r8, r0
    d104:	mov	r9, r1
    d106:	ldr	r3, [sp, #40]	; 0x28
    d108:	cbz	r3, d13a <_strtod_l+0xd02>
    d10a:	ldr	r3, [pc, #500]	; (d300 <_strtod_l+0xec8>)
    d10c:	str	r3, [sp, #92]	; 0x5c
    d10e:	movs	r3, #0
    d110:	str	r3, [sp, #88]	; 0x58
    d112:	ldrd	r2, r3, [sp, #88]	; 0x58
    d116:	mov	r0, r8
    d118:	mov	r1, r9
    d11a:	bl	a7b8 <__aeabi_dmul>
    d11e:	mov	r3, r0
    d120:	mov	r4, r1
    d122:	mov	r8, r0
    d124:	mov	r9, r1
    d126:	strd	r3, r4, [sp, #16]
    d12a:	cbnz	r1, d13a <_strtod_l+0xd02>
    d12c:	ldr	r3, [sp, #16]
    d12e:	cbnz	r3, d13a <_strtod_l+0xd02>
    d130:	movs	r3, #34	; 0x22
    d132:	ldr	r0, [sp, #112]	; 0x70
    d134:	str.w	r3, [fp]
    d138:	b.n	cc9c <_strtod_l+0x864>
    d13a:	ldr	r0, [sp, #112]	; 0x70
    d13c:	b.n	cc9c <_strtod_l+0x864>
    d13e:	ldr	r3, [sp, #52]	; 0x34
    d140:	ldrd	r8, r9, [sp, #32]
    d144:	cmp	r3, #0
    d146:	bne.n	d106 <_strtod_l+0xcce>
    d148:	ldrd	r1, r2, [sp, #16]
    d14c:	cmp	r1, #0
    d14e:	bne.n	d106 <_strtod_l+0xcce>
    d150:	ubfx	r3, r2, #0, #20
    d154:	mov	r4, r2
    d156:	cmp	r3, #0
    d158:	bne.n	d106 <_strtod_l+0xcce>
    d15a:	bic.w	r3, r2, #2147483648	; 0x80000000
    d15e:	lsrs	r3, r3, #20
    d160:	lsls	r3, r3, #20
    d162:	cmp.w	r3, #112197632	; 0x6b00000
    d166:	bls.n	d106 <_strtod_l+0xcce>
    d168:	ldr	r3, [r7, #20]
    d16a:	cbnz	r3, d172 <_strtod_l+0xd3a>
    d16c:	ldr	r3, [r7, #16]
    d16e:	cmp	r3, #1
    d170:	ble.n	d106 <_strtod_l+0xcce>
    d172:	mov	r1, r7
    d174:	movs	r2, #1
    d176:	mov	r0, fp
    d178:	bl	11958 <__lshift>
    d17c:	mov	r1, sl
    d17e:	mov	r7, r0
    d180:	bl	11a08 <__mcmp>
    d184:	cmp	r0, #0
    d186:	ble.n	d106 <_strtod_l+0xcce>
    d188:	ldr	r3, [sp, #40]	; 0x28
    d18a:	cmp	r3, #0
    d18c:	bne.w	d294 <_strtod_l+0xe5c>
    d190:	ldr	r3, [pc, #368]	; (d304 <_strtod_l+0xecc>)
    d192:	ands	r3, r4
    d194:	sub.w	r3, r3, #1048576	; 0x100000
    d198:	mvn.w	r3, r3, lsr #20
    d19c:	mvn.w	r3, r3, lsl #20
    d1a0:	str	r3, [sp, #20]
    d1a2:	mov.w	r3, #4294967295
    d1a6:	str	r3, [sp, #16]
    d1a8:	ldrd	r8, r9, [sp, #16]
    d1ac:	b.n	d106 <_strtod_l+0xcce>
    d1ae:	ldr	r3, [sp, #88]	; 0x58
    d1b0:	adds	r3, #1
    d1b2:	bne.w	cdea <_strtod_l+0x9b2>
    d1b6:	b.n	cc88 <_strtod_l+0x850>
    d1b8:	add.w	r3, r1, #55574528	; 0x3500000
    d1bc:	str	r3, [sp, #20]
    d1be:	b.w	c790 <_strtod_l+0x358>
    d1c2:	vldr	d7, [pc, #292]	; d2e8 <_strtod_l+0xeb0>
    d1c6:	vstr	d7, [sp, #96]	; 0x60
    d1ca:	vldr	d7, [pc, #292]	; d2f0 <_strtod_l+0xeb8>
    d1ce:	vstr	d7, [sp, #56]	; 0x38
    d1d2:	b.n	cae2 <_strtod_l+0x6aa>
    d1d4:	ldrd	r1, r2, [sp, #16]
    d1d8:	ubfx	r3, r2, #0, #20
    d1dc:	mov	r4, r2
    d1de:	cmp	r3, #0
    d1e0:	bne.w	d0d6 <_strtod_l+0xc9e>
    d1e4:	cmp	r1, #0
    d1e6:	bne.w	d0d6 <_strtod_l+0xc9e>
    d1ea:	b.n	d188 <_strtod_l+0xd50>
    d1ec:	ldr	r3, [sp, #56]	; 0x38
    d1ee:	ldr	r2, [sp, #16]
    d1f0:	tst	r3, r2
    d1f2:	beq.n	d106 <_strtod_l+0xcce>
    d1f4:	b.n	d0e4 <_strtod_l+0xcac>
    d1f6:	mov.w	r8, #0
    d1fa:	b.n	cbf4 <_strtod_l+0x7bc>
    d1fc:	bl	c3fc <sulp>
    d200:	mov	r2, r0
    d202:	mov	r3, r1
    d204:	mov	r0, r8
    d206:	mov	r1, r9
    d208:	bl	a450 <__aeabi_dsub>
    d20c:	movs	r2, #0
    d20e:	movs	r3, #0
    d210:	mov	r8, r0
    d212:	mov	r9, r1
    d214:	bl	ac88 <__aeabi_dcmpeq>
    d218:	cmp	r0, #0
    d21a:	bne.w	d02e <_strtod_l+0xbf6>
    d21e:	b.n	d106 <_strtod_l+0xcce>
    d220:	cmp	r6, #0
    d222:	str	r3, [sp, #40]	; 0x28
    d224:	bgt.w	ceb8 <_strtod_l+0xa80>
    d228:	b.n	cf08 <_strtod_l+0xad0>
    d22a:	ldr	r3, [sp, #40]	; 0x28
    d22c:	ldr	r1, [sp, #16]
    d22e:	cbz	r3, d26a <_strtod_l+0xe32>
    d230:	ldr	r3, [pc, #208]	; (d304 <_strtod_l+0xecc>)
    d232:	ands	r3, r5
    d234:	cmp.w	r3, #111149056	; 0x6a00000
    d238:	bhi.n	d26a <_strtod_l+0xe32>
    d23a:	lsrs	r3, r3, #20
    d23c:	rsb	r3, r3, #107	; 0x6b
    d240:	mov.w	r0, #4294967295
    d244:	lsl.w	r3, r0, r3
    d248:	cmp	r3, r1
    d24a:	bne.w	d0d6 <_strtod_l+0xc9e>
    d24e:	ldr	r1, [pc, #184]	; (d308 <_strtod_l+0xed0>)
    d250:	cmp	r2, r1
    d252:	beq.w	cc82 <_strtod_l+0x84a>
    d256:	ldr	r3, [pc, #172]	; (d304 <_strtod_l+0xecc>)
    d258:	ands	r3, r2
    d25a:	add.w	r3, r3, #1048576	; 0x100000
    d25e:	str	r3, [sp, #20]
    d260:	movs	r3, #0
    d262:	str	r3, [sp, #16]
    d264:	ldrd	r8, r9, [sp, #16]
    d268:	b.n	d106 <_strtod_l+0xcce>
    d26a:	mov.w	r3, #4294967295
    d26e:	b.n	d248 <_strtod_l+0xe10>
    d270:	add	r0, sp, #108	; 0x6c
    d272:	add	r2, sp, #120	; 0x78
    d274:	ldr	r1, [pc, #148]	; (d30c <_strtod_l+0xed4>)
    d276:	bl	11348 <__hexnan>
    d27a:	cmp	r0, #5
    d27c:	bne.w	cc6c <_strtod_l+0x834>
    d280:	ldr	r3, [sp, #124]	; 0x7c
    d282:	orr.w	r3, r3, #2139095040	; 0x7f800000
    d286:	orr.w	r3, r3, #7340032	; 0x700000
    d28a:	str	r3, [sp, #20]
    d28c:	ldr	r3, [sp, #120]	; 0x78
    d28e:	str	r3, [sp, #16]
    d290:	b.w	c6a8 <_strtod_l+0x270>
    d294:	ldr	r3, [pc, #108]	; (d304 <_strtod_l+0xecc>)
    d296:	ands	r3, r4
    d298:	cmp.w	r3, #112197632	; 0x6b00000
    d29c:	bgt.w	d194 <_strtod_l+0xd5c>
    d2a0:	cmp.w	r3, #57671680	; 0x3700000
    d2a4:	bgt.w	d10a <_strtod_l+0xcd2>
    d2a8:	b.n	d02e <_strtod_l+0xbf6>
    d2aa:	mov.w	r2, #4294967295
    d2ae:	lsl.w	r3, r2, r3
    d2b2:	ldr	r2, [sp, #16]
    d2b4:	ands	r2, r3
    d2b6:	str	r2, [sp, #16]
    d2b8:	b.n	cf08 <_strtod_l+0xad0>
    d2ba:	strd	r0, r1, [sp, #16]
    d2be:	b.n	cbf4 <_strtod_l+0x7bc>
    d2c0:	strd	r0, r1, [sp, #16]
    d2c4:	b.n	cedc <_strtod_l+0xaa4>
    d2c6:	subs	r3, #32
    d2c8:	mov.w	r2, #4294967295
    d2cc:	lsl.w	r3, r2, r3
    d2d0:	ands	r3, r1
    d2d2:	str	r3, [sp, #20]
    d2d4:	b.n	cf08 <_strtod_l+0xad0>
    d2d6:	mov	r0, r4
    d2d8:	ldr	r1, [sp, #108]	; 0x6c
    d2da:	adds	r4, #1
    d2dc:	b.n	cf30 <_strtod_l+0xaf8>
    d2de:	mov	r0, r1
    d2e0:	ldr	r1, [sp, #108]	; 0x6c
    d2e2:	b.n	cf44 <_strtod_l+0xb0c>
    d2e4:	nop.w
    d2e8:	.word	0x00000000
    d2ec:	.word	0xbfe00000
    d2f0:	.word	0x00000000
    d2f4:	.word	0x3fe00000
    d2f8:	.word	0x00013708
    d2fc:	.word	0x000fffff
    d300:	.word	0x39500000
    d304:	.word	0x7ff00000
    d308:	.word	0x7fefffff
    d30c:	.word	0x00013420

0000d310 <_strtod_r>:
    d310:	ldr	r3, [pc, #20]	; (d328 <_strtod_r+0x18>)
    d312:	ldr	r3, [r3, #0]
    d314:	push	{r4}
    d316:	ldr	r3, [r3, #52]	; 0x34
    d318:	ldr	r4, [pc, #16]	; (d32c <_strtod_r+0x1c>)
    d31a:	cmp	r3, #0
    d31c:	it	eq
    d31e:	moveq	r3, r4
    d320:	ldr.w	r4, [sp], #4
    d324:	b.w	c438 <_strtod_l>
    d328:	.word	0x20014230
    d32c:	.word	0x20014234

0000d330 <_strtol_l.isra.0>:
    d330:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d334:	ldr.w	r9, [sp, #40]	; 0x28
    d338:	mov	r7, r1
    d33a:	mov	r8, r0
    d33c:	mov	r6, r2
    d33e:	mov	r5, r3
    d340:	mov	fp, r1
    d342:	b.n	d346 <_strtol_l.isra.0+0x16>
    d344:	mov	fp, r4
    d346:	mov	r4, fp
    d348:	mov	r0, r9
    d34a:	ldrb.w	sl, [r4], #1
    d34e:	bl	b488 <__locale_ctype_ptr_l>
    d352:	add	r0, sl
    d354:	ldrb	r1, [r0, #1]
    d356:	and.w	r1, r1, #8
    d35a:	and.w	ip, r1, #255	; 0xff
    d35e:	cmp	r1, #0
    d360:	bne.n	d344 <_strtol_l.isra.0+0x14>
    d362:	mov	r2, sl
    d364:	cmp	r2, #45	; 0x2d
    d366:	beq.n	d42c <_strtol_l.isra.0+0xfc>
    d368:	cmp	r2, #43	; 0x2b
    d36a:	itt	eq
    d36c:	ldrbeq.w	r2, [fp, #1]
    d370:	addeq.w	r4, fp, #2
    d374:	cmp	r5, #0
    d376:	beq.n	d400 <_strtol_l.isra.0+0xd0>
    d378:	cmp	r5, #16
    d37a:	beq.n	d448 <_strtol_l.isra.0+0x118>
    d37c:	mov	r9, r5
    d37e:	cmp.w	ip, #0
    d382:	ite	eq
    d384:	mvneq.w	sl, #2147483648	; 0x80000000
    d388:	movne.w	sl, #2147483648	; 0x80000000
    d38c:	movs	r1, #0
    d38e:	udiv	lr, sl, r9
    d392:	mov	r0, r1
    d394:	mls	sl, r9, lr, sl
    d398:	b.n	d3a6 <_strtol_l.isra.0+0x76>
    d39a:	beq.n	d3f0 <_strtol_l.isra.0+0xc0>
    d39c:	mla	r0, r9, r0, r3
    d3a0:	movs	r1, #1
    d3a2:	ldrb.w	r2, [r4], #1
    d3a6:	sub.w	r3, r2, #48	; 0x30
    d3aa:	cmp	r3, #9
    d3ac:	bls.n	d3ba <_strtol_l.isra.0+0x8a>
    d3ae:	sub.w	r3, r2, #65	; 0x41
    d3b2:	cmp	r3, #25
    d3b4:	bhi.n	d3cc <_strtol_l.isra.0+0x9c>
    d3b6:	sub.w	r3, r2, #55	; 0x37
    d3ba:	cmp	r5, r3
    d3bc:	ble.n	d3dc <_strtol_l.isra.0+0xac>
    d3be:	adds	r2, r1, #1
    d3c0:	beq.n	d3a2 <_strtol_l.isra.0+0x72>
    d3c2:	cmp	lr, r0
    d3c4:	bcs.n	d39a <_strtol_l.isra.0+0x6a>
    d3c6:	mov.w	r1, #4294967295
    d3ca:	b.n	d3a2 <_strtol_l.isra.0+0x72>
    d3cc:	sub.w	r3, r2, #97	; 0x61
    d3d0:	cmp	r3, #25
    d3d2:	bhi.n	d3dc <_strtol_l.isra.0+0xac>
    d3d4:	sub.w	r3, r2, #87	; 0x57
    d3d8:	cmp	r5, r3
    d3da:	bgt.n	d3be <_strtol_l.isra.0+0x8e>
    d3dc:	adds	r3, r1, #1
    d3de:	beq.n	d40c <_strtol_l.isra.0+0xdc>
    d3e0:	cmp.w	ip, #0
    d3e4:	bne.n	d408 <_strtol_l.isra.0+0xd8>
    d3e6:	cbz	r6, d3fc <_strtol_l.isra.0+0xcc>
    d3e8:	cbnz	r1, d424 <_strtol_l.isra.0+0xf4>
    d3ea:	str	r7, [r6, #0]
    d3ec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d3f0:	cmp	sl, r3
    d3f2:	bge.n	d39c <_strtol_l.isra.0+0x6c>
    d3f4:	mov	r0, lr
    d3f6:	mov.w	r1, #4294967295
    d3fa:	b.n	d3a2 <_strtol_l.isra.0+0x72>
    d3fc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d400:	cmp	r2, #48	; 0x30
    d402:	beq.n	d43a <_strtol_l.isra.0+0x10a>
    d404:	movs	r5, #10
    d406:	b.n	d37c <_strtol_l.isra.0+0x4c>
    d408:	negs	r0, r0
    d40a:	b.n	d3e6 <_strtol_l.isra.0+0xb6>
    d40c:	cmp.w	ip, #0
    d410:	mov.w	r3, #34	; 0x22
    d414:	ite	eq
    d416:	mvneq.w	r0, #2147483648	; 0x80000000
    d41a:	movne.w	r0, #2147483648	; 0x80000000
    d41e:	str.w	r3, [r8]
    d422:	cbz	r6, d462 <_strtol_l.isra.0+0x132>
    d424:	subs	r7, r4, #1
    d426:	str	r7, [r6, #0]
    d428:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d42c:	add.w	r4, fp, #2
    d430:	ldrb.w	r2, [fp, #1]
    d434:	mov.w	ip, #1
    d438:	b.n	d374 <_strtol_l.isra.0+0x44>
    d43a:	ldrb	r3, [r4, #0]
    d43c:	and.w	r3, r3, #223	; 0xdf
    d440:	cmp	r3, #88	; 0x58
    d442:	beq.n	d456 <_strtol_l.isra.0+0x126>
    d444:	movs	r5, #8
    d446:	b.n	d37c <_strtol_l.isra.0+0x4c>
    d448:	cmp	r2, #48	; 0x30
    d44a:	bne.n	d37c <_strtol_l.isra.0+0x4c>
    d44c:	ldrb	r3, [r4, #0]
    d44e:	and.w	r3, r3, #223	; 0xdf
    d452:	cmp	r3, #88	; 0x58
    d454:	bne.n	d37c <_strtol_l.isra.0+0x4c>
    d456:	mov.w	r9, #16
    d45a:	ldrb	r2, [r4, #1]
    d45c:	mov	r5, r9
    d45e:	adds	r4, #2
    d460:	b.n	d37e <_strtol_l.isra.0+0x4e>
    d462:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d466:	nop

0000d468 <_strtol_r>:
    d468:	push	{r4, r5, lr}
    d46a:	ldr	r4, [pc, #24]	; (d484 <_strtol_r+0x1c>)
    d46c:	ldr	r5, [pc, #24]	; (d488 <_strtol_r+0x20>)
    d46e:	ldr	r4, [r4, #0]
    d470:	ldr	r4, [r4, #52]	; 0x34
    d472:	sub	sp, #12
    d474:	cmp	r4, #0
    d476:	it	eq
    d478:	moveq	r4, r5
    d47a:	str	r4, [sp, #0]
    d47c:	bl	d330 <_strtol_l.isra.0>
    d480:	add	sp, #12
    d482:	pop	{r4, r5, pc}
    d484:	.word	0x20014230
    d488:	.word	0x20014234
    d48c:	.word	0xffffffff

0000d490 <_svfprintf_r>:
    d490:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d494:	sub	sp, #260	; 0x104
    d496:	mov	r4, r1
    d498:	str	r1, [sp, #20]
    d49a:	mov	r5, r2
    d49c:	str	r3, [sp, #40]	; 0x28
    d49e:	str	r0, [sp, #24]
    d4a0:	bl	114e8 <_localeconv_r>
    d4a4:	ldr	r3, [r0, #0]
    d4a6:	str	r3, [sp, #76]	; 0x4c
    d4a8:	mov	r0, r3
    d4aa:	bl	c280 <strlen>
    d4ae:	ldrh	r3, [r4, #12]
    d4b0:	str	r0, [sp, #72]	; 0x48
    d4b2:	lsls	r6, r3, #24
    d4b4:	bpl.n	d4be <_svfprintf_r+0x2e>
    d4b6:	ldr	r3, [r4, #16]
    d4b8:	cmp	r3, #0
    d4ba:	beq.w	e720 <_svfprintf_r+0x1290>
    d4be:	vldr	d7, [pc, #664]	; d758 <_svfprintf_r+0x2c8>
    d4c2:	movs	r3, #0
    d4c4:	vstr	d7, [sp, #64]	; 0x40
    d4c8:	str	r3, [sp, #56]	; 0x38
    d4ca:	str	r3, [sp, #148]	; 0x94
    d4cc:	str	r3, [sp, #144]	; 0x90
    d4ce:	str	r3, [sp, #84]	; 0x54
    d4d0:	str	r3, [sp, #28]
    d4d2:	ldr.w	sl, [pc, #656]	; d764 <_svfprintf_r+0x2d4>
    d4d6:	add	r3, sp, #192	; 0xc0
    d4d8:	str	r3, [sp, #140]	; 0x8c
    d4da:	mov	r9, r3
    d4dc:	mov	r8, r5
    d4de:	ldrb.w	r3, [r8]
    d4e2:	mov	r4, r8
    d4e4:	cbz	r3, d522 <_svfprintf_r+0x92>
    d4e6:	cmp	r3, #37	; 0x25
    d4e8:	bne.n	d4f0 <_svfprintf_r+0x60>
    d4ea:	b.n	d522 <_svfprintf_r+0x92>
    d4ec:	cmp	r3, #37	; 0x25
    d4ee:	beq.n	d4f8 <_svfprintf_r+0x68>
    d4f0:	ldrb.w	r3, [r4, #1]!
    d4f4:	cmp	r3, #0
    d4f6:	bne.n	d4ec <_svfprintf_r+0x5c>
    d4f8:	rsb	r5, r8, r4
    d4fc:	cbz	r5, d522 <_svfprintf_r+0x92>
    d4fe:	ldr	r3, [sp, #144]	; 0x90
    d500:	ldr	r2, [sp, #148]	; 0x94
    d502:	str.w	r8, [r9]
    d506:	adds	r3, #1
    d508:	add	r2, r5
    d50a:	cmp	r3, #7
    d50c:	str.w	r5, [r9, #4]
    d510:	str	r2, [sp, #148]	; 0x94
    d512:	str	r3, [sp, #144]	; 0x90
    d514:	bgt.w	d664 <_svfprintf_r+0x1d4>
    d518:	add.w	r9, r9, #8
    d51c:	ldr	r3, [sp, #28]
    d51e:	add	r3, r5
    d520:	str	r3, [sp, #28]
    d522:	ldrb	r3, [r4, #0]
    d524:	cmp	r3, #0
    d526:	beq.w	d676 <_svfprintf_r+0x1e6>
    d52a:	movs	r3, #0
    d52c:	mov	r2, r3
    d52e:	strb.w	r3, [sp, #111]	; 0x6f
    d532:	mov	r1, r3
    d534:	str	r3, [sp, #32]
    d536:	str	r3, [sp, #12]
    d538:	mov.w	fp, #4294967295
    d53c:	ldrb	r3, [r4, #1]
    d53e:	add.w	r8, r4, #1
    d542:	mov	r5, fp
    d544:	add.w	r8, r8, #1
    d548:	sub.w	r0, r3, #32
    d54c:	cmp	r0, #88	; 0x58
    d54e:	bhi.w	ddba <_svfprintf_r+0x92a>
    d552:	tbh	[pc, r0, lsl #1]
    d556:	.short	0x03a0
    d558:	.word	0x04320432
    d55c:	.word	0x043203a8
    d560:	.word	0x04320432
    d564:	.word	0x04320432
    d568:	.word	0x03af0432
    d56c:	.word	0x043203bd
    d570:	.word	0x00e2005d
    d574:	.word	0x01090432
    d578:	.word	0x01100110
    d57c:	.word	0x01100110
    d580:	.word	0x01100110
    d584:	.word	0x01100110
    d588:	.word	0x04320110
    d58c:	.word	0x04320432
    d590:	.word	0x04320432
    d594:	.word	0x04320432
    d598:	.word	0x04320432
    d59c:	.word	0x01200432
    d5a0:	.word	0x04320286
    d5a4:	.word	0x04320286
    d5a8:	.word	0x04320432
    d5ac:	.word	0x02d40432
    d5b0:	.word	0x04320432
    d5b4:	.word	0x043202e5
    d5b8:	.word	0x04320432
    d5bc:	.word	0x04320432
    d5c0:	.word	0x0432030f
    d5c4:	.word	0x033d0432
    d5c8:	.word	0x04320432
    d5cc:	.word	0x04320432
    d5d0:	.word	0x04320432
    d5d4:	.word	0x04320432
    d5d8:	.word	0x04320432
    d5dc:	.word	0x0391037e
    d5e0:	.word	0x02860286
    d5e4:	.word	0x03990286
    d5e8:	.word	0x04320391
    d5ec:	.word	0x04070432
    d5f0:	.word	0x04120432
    d5f4:	.word	0x006400a3
    d5f8:	.word	0x043203c2
    d5fc:	.word	0x043203c9
    d600:	.word	0x043203ea
    d604:	.word	0x03f20432
    d608:	ldr	r0, [sp, #32]
    d60a:	str	r3, [sp, #40]	; 0x28
    d60c:	negs	r0, r0
    d60e:	str	r0, [sp, #32]
    d610:	ldr	r3, [sp, #12]
    d612:	orr.w	r3, r3, #4
    d616:	str	r3, [sp, #12]
    d618:	ldrb.w	r3, [r8]
    d61c:	b.n	d544 <_svfprintf_r+0xb4>
    d61e:	ldr	r0, [sp, #40]	; 0x28
    d620:	mov	fp, r5
    d622:	movs	r1, #0
    d624:	ldr	r4, [r0, #0]
    d626:	strb.w	r1, [sp, #111]	; 0x6f
    d62a:	adds	r7, r0, #4
    d62c:	ldr	r0, [sp, #12]
    d62e:	movs	r3, #48	; 0x30
    d630:	movs	r2, #120	; 0x78
    d632:	cmp	fp, r1
    d634:	strb.w	r3, [sp, #112]	; 0x70
    d638:	mov.w	r5, #0
    d63c:	strb.w	r2, [sp, #113]	; 0x71
    d640:	orr.w	r3, r0, #2
    d644:	blt.w	ddf4 <_svfprintf_r+0x964>
    d648:	bic.w	r3, r0, #128	; 0x80
    d64c:	orr.w	r3, r3, #2
    d650:	str	r3, [sp, #12]
    d652:	orrs.w	r3, r4, r5
    d656:	str	r7, [sp, #40]	; 0x28
    d658:	beq.w	dda0 <_svfprintf_r+0x910>
    d65c:	mov	r7, r1
    d65e:	str	r2, [sp, #52]	; 0x34
    d660:	ldr	r0, [pc, #252]	; (d760 <_svfprintf_r+0x2d0>)
    d662:	b.n	dc32 <_svfprintf_r+0x7a2>
    d664:	add	r2, sp, #140	; 0x8c
    d666:	ldr	r1, [sp, #20]
    d668:	ldr	r0, [sp, #24]
    d66a:	bl	12428 <__ssprint_r>
    d66e:	cbnz	r0, d684 <_svfprintf_r+0x1f4>
    d670:	add.w	r9, sp, #192	; 0xc0
    d674:	b.n	d51c <_svfprintf_r+0x8c>
    d676:	ldr	r3, [sp, #148]	; 0x94
    d678:	cbz	r3, d684 <_svfprintf_r+0x1f4>
    d67a:	ldr	r0, [sp, #24]
    d67c:	ldr	r1, [sp, #20]
    d67e:	add	r2, sp, #140	; 0x8c
    d680:	bl	12428 <__ssprint_r>
    d684:	ldr	r3, [sp, #20]
    d686:	ldrh	r3, [r3, #12]
    d688:	tst.w	r3, #64	; 0x40
    d68c:	ldr	r3, [sp, #28]
    d68e:	it	ne
    d690:	movne.w	r3, #4294967295
    d694:	mov	r0, r3
    d696:	add	sp, #260	; 0x104
    d698:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d69c:	str	r3, [sp, #52]	; 0x34
    d69e:	mov	fp, r5
    d6a0:	cmp	r2, #0
    d6a2:	bne.w	eb0c <_svfprintf_r+0x167c>
    d6a6:	ldr	r2, [sp, #12]
    d6a8:	ands.w	r3, r2, #32
    d6ac:	beq.w	db3c <_svfprintf_r+0x6ac>
    d6b0:	ldr	r7, [sp, #40]	; 0x28
    d6b2:	adds	r7, #7
    d6b4:	bic.w	r3, r7, #7
    d6b8:	movs	r7, #0
    d6ba:	add.w	r1, r3, #8
    d6be:	cmp	fp, r7
    d6c0:	str	r1, [sp, #40]	; 0x28
    d6c2:	ldrd	r4, r5, [r3]
    d6c6:	strb.w	r7, [sp, #111]	; 0x6f
    d6ca:	blt.w	e592 <_svfprintf_r+0x1102>
    d6ce:	bic.w	r3, r2, #128	; 0x80
    d6d2:	str	r3, [sp, #12]
    d6d4:	orrs.w	r3, r4, r5
    d6d8:	beq.w	dde4 <_svfprintf_r+0x954>
    d6dc:	add	r6, sp, #192	; 0xc0
    d6de:	lsrs	r2, r4, #3
    d6e0:	orr.w	r2, r2, r5, lsl #29
    d6e4:	lsrs	r1, r5, #3
    d6e6:	and.w	r3, r4, #7
    d6ea:	mov	r5, r1
    d6ec:	mov	r4, r2
    d6ee:	adds	r3, #48	; 0x30
    d6f0:	orrs.w	r2, r4, r5
    d6f4:	strb.w	r3, [r6, #-1]!
    d6f8:	bne.n	d6de <_svfprintf_r+0x24e>
    d6fa:	ldr	r2, [sp, #12]
    d6fc:	lsls	r1, r2, #31
    d6fe:	bpl.w	d820 <_svfprintf_r+0x390>
    d702:	cmp	r3, #48	; 0x30
    d704:	beq.w	d820 <_svfprintf_r+0x390>
    d708:	movs	r2, #48	; 0x30
    d70a:	subs	r3, r6, #1
    d70c:	strb.w	r2, [r6, #-1]
    d710:	add	r2, sp, #192	; 0xc0
    d712:	subs	r2, r2, r3
    d714:	str	r2, [sp, #36]	; 0x24
    d716:	mov	r6, r3
    d718:	b.n	d826 <_svfprintf_r+0x396>
    d71a:	ldrb.w	r3, [r8]
    d71e:	cmp	r3, #42	; 0x2a
    d720:	add.w	r4, r8, #1
    d724:	beq.w	eaf0 <_svfprintf_r+0x1660>
    d728:	sub.w	r0, r3, #48	; 0x30
    d72c:	cmp	r0, #9
    d72e:	it	ls
    d730:	movls	r5, #0
    d732:	bhi.w	ea42 <_svfprintf_r+0x15b2>
    d736:	ldrb.w	r3, [r4], #1
    d73a:	add.w	r5, r5, r5, lsl #2
    d73e:	add.w	r5, r0, r5, lsl #1
    d742:	sub.w	r0, r3, #48	; 0x30
    d746:	cmp	r0, #9
    d748:	bls.n	d736 <_svfprintf_r+0x2a6>
    d74a:	orr.w	r5, r5, r5, asr #31
    d74e:	mov	r8, r4
    d750:	b.n	d548 <_svfprintf_r+0xb8>
    d752:	nop
    d754:	nop.w
	...
    d760:	.word	0x00013494
    d764:	.word	0x00013460
    d768:	ldr	r3, [sp, #12]
    d76a:	orr.w	r3, r3, #128	; 0x80
    d76e:	str	r3, [sp, #12]
    d770:	ldrb.w	r3, [r8]
    d774:	b.n	d544 <_svfprintf_r+0xb4>
    d776:	sub.w	r0, r3, #48	; 0x30
    d77a:	movs	r3, #0
    d77c:	mov	r4, r3
    d77e:	ldrb.w	r3, [r8], #1
    d782:	add.w	r4, r4, r4, lsl #2
    d786:	add.w	r4, r0, r4, lsl #1
    d78a:	sub.w	r0, r3, #48	; 0x30
    d78e:	cmp	r0, #9
    d790:	bls.n	d77e <_svfprintf_r+0x2ee>
    d792:	str	r4, [sp, #32]
    d794:	b.n	d548 <_svfprintf_r+0xb8>
    d796:	str	r3, [sp, #52]	; 0x34
    d798:	mov	fp, r5
    d79a:	cmp	r2, #0
    d79c:	bne.w	eb28 <_svfprintf_r+0x1698>
    d7a0:	ldr	r3, [sp, #12]
    d7a2:	orr.w	r3, r3, #16
    d7a6:	str	r3, [sp, #12]
    d7a8:	ldr	r3, [sp, #12]
    d7aa:	lsls	r4, r3, #26
    d7ac:	bpl.w	e21e <_svfprintf_r+0xd8e>
    d7b0:	ldr	r7, [sp, #40]	; 0x28
    d7b2:	adds	r7, #7
    d7b4:	bic.w	r7, r7, #7
    d7b8:	ldrd	r2, r3, [r7]
    d7bc:	add.w	r1, r7, #8
    d7c0:	str	r1, [sp, #40]	; 0x28
    d7c2:	mov	r4, r2
    d7c4:	mov	r5, r3
    d7c6:	cmp	r2, #0
    d7c8:	sbcs.w	r3, r3, #0
    d7cc:	blt.w	e294 <_svfprintf_r+0xe04>
    d7d0:	cmp.w	fp, #0
    d7d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d7d8:	blt.w	e25a <_svfprintf_r+0xdca>
    d7dc:	ldr	r3, [sp, #12]
    d7de:	bic.w	r3, r3, #128	; 0x80
    d7e2:	str	r3, [sp, #12]
    d7e4:	orrs.w	r3, r4, r5
    d7e8:	beq.w	dbbc <_svfprintf_r+0x72c>
    d7ec:	cmp	r5, #0
    d7ee:	it	eq
    d7f0:	cmpeq	r4, #10
    d7f2:	bcc.w	dbc6 <_svfprintf_r+0x736>
    d7f6:	add	r6, sp, #192	; 0xc0
    d7f8:	mov	r0, r4
    d7fa:	mov	r1, r5
    d7fc:	movs	r2, #10
    d7fe:	movs	r3, #0
    d800:	bl	b064 <__aeabi_uldivmod>
    d804:	adds	r2, #48	; 0x30
    d806:	strb.w	r2, [r6, #-1]!
    d80a:	mov	r0, r4
    d80c:	mov	r1, r5
    d80e:	movs	r3, #0
    d810:	movs	r2, #10
    d812:	bl	b064 <__aeabi_uldivmod>
    d816:	mov	r4, r0
    d818:	mov	r5, r1
    d81a:	orrs.w	r3, r4, r5
    d81e:	bne.n	d7f8 <_svfprintf_r+0x368>
    d820:	add	r3, sp, #192	; 0xc0
    d822:	subs	r3, r3, r6
    d824:	str	r3, [sp, #36]	; 0x24
    d826:	ldr	r3, [sp, #36]	; 0x24
    d828:	cmp	r3, fp
    d82a:	it	lt
    d82c:	movlt	r3, fp
    d82e:	str	r3, [sp, #16]
    d830:	movs	r3, #0
    d832:	str	r3, [sp, #60]	; 0x3c
    d834:	cbz	r7, d83c <_svfprintf_r+0x3ac>
    d836:	ldr	r3, [sp, #16]
    d838:	adds	r3, #1
    d83a:	str	r3, [sp, #16]
    d83c:	ldr	r3, [sp, #12]
    d83e:	ands.w	r3, r3, #2
    d842:	str	r3, [sp, #44]	; 0x2c
    d844:	beq.n	d84c <_svfprintf_r+0x3bc>
    d846:	ldr	r3, [sp, #16]
    d848:	adds	r3, #2
    d84a:	str	r3, [sp, #16]
    d84c:	ldr	r3, [sp, #12]
    d84e:	ands.w	r3, r3, #132	; 0x84
    d852:	str	r3, [sp, #48]	; 0x30
    d854:	bne.w	de0e <_svfprintf_r+0x97e>
    d858:	ldr	r3, [sp, #32]
    d85a:	ldr	r2, [sp, #16]
    d85c:	subs	r5, r3, r2
    d85e:	cmp	r5, #0
    d860:	ble.w	de0e <_svfprintf_r+0x97e>
    d864:	cmp	r5, #16
    d866:	ldr	r1, [sp, #148]	; 0x94
    d868:	ldr	r2, [sp, #144]	; 0x90
    d86a:	ldr	r7, [pc, #672]	; (db0c <_svfprintf_r+0x67c>)
    d86c:	ble.n	d8be <_svfprintf_r+0x42e>
    d86e:	str	r6, [sp, #80]	; 0x50
    d870:	mov	r0, r9
    d872:	movs	r4, #16
    d874:	mov	r9, r7
    d876:	ldr	r6, [sp, #20]
    d878:	mov	r7, r5
    d87a:	ldr	r5, [sp, #24]
    d87c:	b.n	d888 <_svfprintf_r+0x3f8>
    d87e:	subs	r7, #16
    d880:	cmp	r7, #16
    d882:	add.w	r0, r0, #8
    d886:	ble.n	d8b6 <_svfprintf_r+0x426>
    d888:	adds	r2, #1
    d88a:	ldr	r3, [pc, #640]	; (db0c <_svfprintf_r+0x67c>)
    d88c:	str	r2, [sp, #144]	; 0x90
    d88e:	adds	r1, #16
    d890:	cmp	r2, #7
    d892:	str	r1, [sp, #148]	; 0x94
    d894:	stmia.w	r0, {r3, r4}
    d898:	ble.n	d87e <_svfprintf_r+0x3ee>
    d89a:	add	r2, sp, #140	; 0x8c
    d89c:	mov	r1, r6
    d89e:	mov	r0, r5
    d8a0:	bl	12428 <__ssprint_r>
    d8a4:	cmp	r0, #0
    d8a6:	bne.w	d684 <_svfprintf_r+0x1f4>
    d8aa:	subs	r7, #16
    d8ac:	cmp	r7, #16
    d8ae:	ldr	r1, [sp, #148]	; 0x94
    d8b0:	ldr	r2, [sp, #144]	; 0x90
    d8b2:	add	r0, sp, #192	; 0xc0
    d8b4:	bgt.n	d888 <_svfprintf_r+0x3f8>
    d8b6:	ldr	r6, [sp, #80]	; 0x50
    d8b8:	mov	r5, r7
    d8ba:	mov	r7, r9
    d8bc:	mov	r9, r0
    d8be:	adds	r2, #1
    d8c0:	adds	r4, r5, r1
    d8c2:	cmp	r2, #7
    d8c4:	str	r4, [sp, #148]	; 0x94
    d8c6:	str	r2, [sp, #144]	; 0x90
    d8c8:	str.w	r7, [r9]
    d8cc:	str.w	r5, [r9, #4]
    d8d0:	bgt.w	e12e <_svfprintf_r+0xc9e>
    d8d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d8d8:	add.w	r9, r9, #8
    d8dc:	cbz	r7, d8fc <_svfprintf_r+0x46c>
    d8de:	ldr	r3, [sp, #144]	; 0x90
    d8e0:	adds	r3, #1
    d8e2:	adds	r4, #1
    d8e4:	add.w	r1, sp, #111	; 0x6f
    d8e8:	movs	r2, #1
    d8ea:	cmp	r3, #7
    d8ec:	str	r4, [sp, #148]	; 0x94
    d8ee:	str	r3, [sp, #144]	; 0x90
    d8f0:	stmia.w	r9, {r1, r2}
    d8f4:	bgt.w	e042 <_svfprintf_r+0xbb2>
    d8f8:	add.w	r9, r9, #8
    d8fc:	ldr	r3, [sp, #44]	; 0x2c
    d8fe:	cbz	r3, d91c <_svfprintf_r+0x48c>
    d900:	ldr	r3, [sp, #144]	; 0x90
    d902:	adds	r3, #1
    d904:	adds	r4, #2
    d906:	add	r1, sp, #112	; 0x70
    d908:	movs	r2, #2
    d90a:	cmp	r3, #7
    d90c:	str	r4, [sp, #148]	; 0x94
    d90e:	str	r3, [sp, #144]	; 0x90
    d910:	stmia.w	r9, {r1, r2}
    d914:	bgt.w	e05a <_svfprintf_r+0xbca>
    d918:	add.w	r9, r9, #8
    d91c:	ldr	r3, [sp, #48]	; 0x30
    d91e:	cmp	r3, #128	; 0x80
    d920:	beq.w	dee6 <_svfprintf_r+0xa56>
    d924:	ldr	r3, [sp, #36]	; 0x24
    d926:	rsb	r7, r3, fp
    d92a:	cmp	r7, #0
    d92c:	ble.n	d996 <_svfprintf_r+0x506>
    d92e:	ldr	r2, [pc, #480]	; (db10 <_svfprintf_r+0x680>)
    d930:	ldr	r3, [sp, #144]	; 0x90
    d932:	str	r2, [sp, #44]	; 0x2c
    d934:	cmp	r7, #16
    d936:	ble.n	d97e <_svfprintf_r+0x4ee>
    d938:	mov	r2, r4
    d93a:	mov.w	fp, #16
    d93e:	ldr	r5, [sp, #24]
    d940:	ldr	r4, [sp, #20]
    d942:	b.n	d94e <_svfprintf_r+0x4be>
    d944:	subs	r7, #16
    d946:	cmp	r7, #16
    d948:	add.w	r9, r9, #8
    d94c:	ble.n	d97c <_svfprintf_r+0x4ec>
    d94e:	adds	r3, #1
    d950:	adds	r2, #16
    d952:	cmp	r3, #7
    d954:	str	r2, [sp, #148]	; 0x94
    d956:	str	r3, [sp, #144]	; 0x90
    d958:	stmia.w	r9, {sl, fp}
    d95c:	ble.n	d944 <_svfprintf_r+0x4b4>
    d95e:	add	r2, sp, #140	; 0x8c
    d960:	mov	r1, r4
    d962:	mov	r0, r5
    d964:	bl	12428 <__ssprint_r>
    d968:	cmp	r0, #0
    d96a:	bne.w	d684 <_svfprintf_r+0x1f4>
    d96e:	subs	r7, #16
    d970:	cmp	r7, #16
    d972:	ldr	r2, [sp, #148]	; 0x94
    d974:	ldr	r3, [sp, #144]	; 0x90
    d976:	add.w	r9, sp, #192	; 0xc0
    d97a:	bgt.n	d94e <_svfprintf_r+0x4be>
    d97c:	mov	r4, r2
    d97e:	adds	r3, #1
    d980:	ldr	r2, [sp, #44]	; 0x2c
    d982:	str	r3, [sp, #144]	; 0x90
    d984:	add	r4, r7
    d986:	cmp	r3, #7
    d988:	str	r4, [sp, #148]	; 0x94
    d98a:	stmia.w	r9, {r2, r7}
    d98e:	bgt.w	e02a <_svfprintf_r+0xb9a>
    d992:	add.w	r9, r9, #8
    d996:	ldr	r3, [sp, #12]
    d998:	lsls	r2, r3, #23
    d99a:	bmi.w	de12 <_svfprintf_r+0x982>
    d99e:	ldr	r3, [sp, #144]	; 0x90
    d9a0:	ldr	r1, [sp, #36]	; 0x24
    d9a2:	str.w	r6, [r9]
    d9a6:	adds	r3, #1
    d9a8:	add	r4, r1
    d9aa:	cmp	r3, #7
    d9ac:	str	r4, [sp, #148]	; 0x94
    d9ae:	str.w	r1, [r9, #4]
    d9b2:	str	r3, [sp, #144]	; 0x90
    d9b4:	bgt.w	dffe <_svfprintf_r+0xb6e>
    d9b8:	add.w	r9, r9, #8
    d9bc:	ldr	r3, [sp, #12]
    d9be:	lsls	r1, r3, #29
    d9c0:	bpl.n	da42 <_svfprintf_r+0x5b2>
    d9c2:	ldr	r3, [sp, #32]
    d9c4:	ldr	r2, [sp, #16]
    d9c6:	subs	r5, r3, r2
    d9c8:	cmp	r5, #0
    d9ca:	ble.n	da42 <_svfprintf_r+0x5b2>
    d9cc:	cmp	r5, #16
    d9ce:	ldr	r3, [sp, #144]	; 0x90
    d9d0:	ldr	r7, [pc, #312]	; (db0c <_svfprintf_r+0x67c>)
    d9d2:	ble.n	da1c <_svfprintf_r+0x58c>
    d9d4:	mov	r2, r4
    d9d6:	movs	r6, #16
    d9d8:	ldr.w	fp, [sp, #24]
    d9dc:	ldr	r4, [sp, #20]
    d9de:	b.n	d9ea <_svfprintf_r+0x55a>
    d9e0:	subs	r5, #16
    d9e2:	cmp	r5, #16
    d9e4:	add.w	r9, r9, #8
    d9e8:	ble.n	da1a <_svfprintf_r+0x58a>
    d9ea:	adds	r3, #1
    d9ec:	ldr	r1, [pc, #284]	; (db0c <_svfprintf_r+0x67c>)
    d9ee:	str	r3, [sp, #144]	; 0x90
    d9f0:	adds	r2, #16
    d9f2:	cmp	r3, #7
    d9f4:	str	r2, [sp, #148]	; 0x94
    d9f6:	stmia.w	r9, {r1, r6}
    d9fa:	ble.n	d9e0 <_svfprintf_r+0x550>
    d9fc:	add	r2, sp, #140	; 0x8c
    d9fe:	mov	r1, r4
    da00:	mov	r0, fp
    da02:	bl	12428 <__ssprint_r>
    da06:	cmp	r0, #0
    da08:	bne.w	d684 <_svfprintf_r+0x1f4>
    da0c:	subs	r5, #16
    da0e:	cmp	r5, #16
    da10:	ldr	r2, [sp, #148]	; 0x94
    da12:	ldr	r3, [sp, #144]	; 0x90
    da14:	add.w	r9, sp, #192	; 0xc0
    da18:	bgt.n	d9ea <_svfprintf_r+0x55a>
    da1a:	mov	r4, r2
    da1c:	adds	r3, #1
    da1e:	add	r4, r5
    da20:	cmp	r3, #7
    da22:	str	r4, [sp, #148]	; 0x94
    da24:	str	r3, [sp, #144]	; 0x90
    da26:	str.w	r7, [r9]
    da2a:	str.w	r5, [r9, #4]
    da2e:	ble.n	da42 <_svfprintf_r+0x5b2>
    da30:	add	r2, sp, #140	; 0x8c
    da32:	ldr	r1, [sp, #20]
    da34:	ldr	r0, [sp, #24]
    da36:	bl	12428 <__ssprint_r>
    da3a:	cmp	r0, #0
    da3c:	bne.w	d684 <_svfprintf_r+0x1f4>
    da40:	ldr	r4, [sp, #148]	; 0x94
    da42:	ldr	r3, [sp, #28]
    da44:	ldr	r2, [sp, #32]
    da46:	ldr	r1, [sp, #16]
    da48:	cmp	r2, r1
    da4a:	ite	ge
    da4c:	addge	r3, r3, r2
    da4e:	addlt	r3, r3, r1
    da50:	str	r3, [sp, #28]
    da52:	cmp	r4, #0
    da54:	bne.w	e016 <_svfprintf_r+0xb86>
    da58:	movs	r3, #0
    da5a:	str	r3, [sp, #144]	; 0x90
    da5c:	add.w	r9, sp, #192	; 0xc0
    da60:	b.n	d4de <_svfprintf_r+0x4e>
    da62:	str	r3, [sp, #52]	; 0x34
    da64:	mov	fp, r5
    da66:	cmp	r2, #0
    da68:	bne.w	eb30 <_svfprintf_r+0x16a0>
    da6c:	ldr	r3, [sp, #12]
    da6e:	ldr	r7, [sp, #40]	; 0x28
    da70:	lsls	r2, r3, #28
    da72:	add.w	r7, r7, #7
    da76:	bpl.w	e562 <_svfprintf_r+0x10d2>
    da7a:	bic.w	r3, r7, #7
    da7e:	vldr	d7, [r3]
    da82:	vstr	d7, [sp, #64]	; 0x40
    da86:	add.w	r2, r3, #8
    da8a:	str	r2, [sp, #40]	; 0x28
    da8c:	ldrd	r1, r2, [sp, #64]	; 0x40
    da90:	bic.w	r3, r2, #2147483648	; 0x80000000
    da94:	str	r1, [sp, #88]	; 0x58
    da96:	str	r3, [sp, #92]	; 0x5c
    da98:	ldrd	r4, r5, [sp, #88]	; 0x58
    da9c:	mov.w	r2, #4294967295
    daa0:	mov	r0, r4
    daa2:	mov	r1, r5
    daa4:	ldr	r3, [pc, #108]	; (db14 <_svfprintf_r+0x684>)
    daa6:	bl	acec <__aeabi_dcmpun>
    daaa:	cmp	r0, #0
    daac:	bne.w	e464 <_svfprintf_r+0xfd4>
    dab0:	mov.w	r2, #4294967295
    dab4:	ldr	r3, [pc, #92]	; (db14 <_svfprintf_r+0x684>)
    dab6:	mov	r0, r4
    dab8:	mov	r1, r5
    daba:	bl	acb0 <__aeabi_dcmple>
    dabe:	cmp	r0, #0
    dac0:	bne.w	e464 <_svfprintf_r+0xfd4>
    dac4:	movs	r2, #0
    dac6:	movs	r3, #0
    dac8:	ldrd	r0, r1, [sp, #64]	; 0x40
    dacc:	bl	ac9c <__aeabi_dcmplt>
    dad0:	cmp	r0, #0
    dad2:	bne.w	e97a <_svfprintf_r+0x14ea>
    dad6:	ldrb.w	r7, [sp, #111]	; 0x6f
    dada:	ldr	r6, [pc, #60]	; (db18 <_svfprintf_r+0x688>)
    dadc:	ldr	r3, [pc, #60]	; (db1c <_svfprintf_r+0x68c>)
    dade:	ldr	r1, [sp, #12]
    dae0:	bic.w	r1, r1, #128	; 0x80
    dae4:	str	r1, [sp, #12]
    dae6:	ldr	r1, [sp, #52]	; 0x34
    dae8:	movs	r2, #3
    daea:	mov.w	fp, #0
    daee:	str	r2, [sp, #16]
    daf0:	cmp	r1, #71	; 0x47
    daf2:	it	le
    daf4:	movle	r6, r3
    daf6:	str	r2, [sp, #36]	; 0x24
    daf8:	str.w	fp, [sp, #60]	; 0x3c
    dafc:	b.n	d834 <_svfprintf_r+0x3a4>
    dafe:	ldr	r3, [sp, #12]
    db00:	orr.w	r3, r3, #8
    db04:	str	r3, [sp, #12]
    db06:	ldrb.w	r3, [r8]
    db0a:	b.n	d544 <_svfprintf_r+0xb4>
    db0c:	.word	0x000134b4
    db10:	.word	0x00013460
    db14:	.word	0x7fefffff
    db18:	.word	0x00013474
    db1c:	.word	0x00013470
    db20:	str	r3, [sp, #52]	; 0x34
    db22:	mov	fp, r5
    db24:	cmp	r2, #0
    db26:	bne.w	eb48 <_svfprintf_r+0x16b8>
    db2a:	ldr	r3, [sp, #12]
    db2c:	orr.w	r3, r3, #16
    db30:	str	r3, [sp, #12]
    db32:	ldr	r2, [sp, #12]
    db34:	ands.w	r3, r2, #32
    db38:	bne.w	d6b0 <_svfprintf_r+0x220>
    db3c:	ldr	r1, [sp, #12]
    db3e:	ands.w	r2, r1, #16
    db42:	beq.w	e3fc <_svfprintf_r+0xf6c>
    db46:	ldr	r0, [sp, #40]	; 0x28
    db48:	strb.w	r3, [sp, #111]	; 0x6f
    db4c:	cmp.w	fp, #0
    db50:	ldr	r4, [r0, #0]
    db52:	add.w	r7, r0, #4
    db56:	mov.w	r5, #0
    db5a:	blt.w	e590 <_svfprintf_r+0x1100>
    db5e:	mov	r2, r1
    db60:	bic.w	r2, r2, #128	; 0x80
    db64:	str	r2, [sp, #12]
    db66:	orrs.w	r2, r4, r5
    db6a:	str	r7, [sp, #40]	; 0x28
    db6c:	beq.w	dde4 <_svfprintf_r+0x954>
    db70:	mov	r7, r3
    db72:	b.n	d6dc <_svfprintf_r+0x24c>
    db74:	str	r3, [sp, #52]	; 0x34
    db76:	mov	fp, r5
    db78:	cmp	r2, #0
    db7a:	bne.w	eb40 <_svfprintf_r+0x16b0>
    db7e:	ldr	r3, [sp, #12]
    db80:	orr.w	r3, r3, #16
    db84:	str	r3, [sp, #12]
    db86:	ldr	r2, [sp, #12]
    db88:	ands.w	r3, r2, #32
    db8c:	beq.w	e1e8 <_svfprintf_r+0xd58>
    db90:	ldr	r7, [sp, #40]	; 0x28
    db92:	adds	r7, #7
    db94:	bic.w	r3, r7, #7
    db98:	movs	r7, #0
    db9a:	add.w	r1, r3, #8
    db9e:	cmp	fp, r7
    dba0:	str	r1, [sp, #40]	; 0x28
    dba2:	ldrd	r4, r5, [r3]
    dba6:	strb.w	r7, [sp, #111]	; 0x6f
    dbaa:	blt.w	e25a <_svfprintf_r+0xdca>
    dbae:	bic.w	r3, r2, #128	; 0x80
    dbb2:	str	r3, [sp, #12]
    dbb4:	orrs.w	r3, r4, r5
    dbb8:	bne.w	d7ec <_svfprintf_r+0x35c>
    dbbc:	cmp.w	fp, #0
    dbc0:	beq.w	ddae <_svfprintf_r+0x91e>
    dbc4:	movs	r4, #0
    dbc6:	add	r6, sp, #256	; 0x100
    dbc8:	adds	r4, #48	; 0x30
    dbca:	strb.w	r4, [r6, #-65]!
    dbce:	b.n	d820 <_svfprintf_r+0x390>
    dbd0:	str	r3, [sp, #52]	; 0x34
    dbd2:	mov	fp, r5
    dbd4:	cmp	r2, #0
    dbd6:	bne.w	eb38 <_svfprintf_r+0x16a8>
    dbda:	ldr	r3, [sp, #12]
    dbdc:	ldr	r0, [pc, #700]	; (de9c <_svfprintf_r+0xa0c>)
    dbde:	lsls	r5, r3, #26
    dbe0:	bpl.w	dd4e <_svfprintf_r+0x8be>
    dbe4:	ldr	r7, [sp, #40]	; 0x28
    dbe6:	adds	r7, #7
    dbe8:	bic.w	r3, r7, #7
    dbec:	ldrd	r4, r5, [r3]
    dbf0:	add.w	r2, r3, #8
    dbf4:	str	r2, [sp, #40]	; 0x28
    dbf6:	ldr	r2, [sp, #12]
    dbf8:	ands.w	r7, r2, #1
    dbfc:	beq.w	e072 <_svfprintf_r+0xbe2>
    dc00:	orrs.w	r3, r4, r5
    dc04:	beq.w	e60c <_svfprintf_r+0x117c>
    dc08:	ldrb.w	r2, [sp, #52]	; 0x34
    dc0c:	strb.w	r2, [sp, #113]	; 0x71
    dc10:	movs	r7, #0
    dc12:	ldr	r2, [sp, #12]
    dc14:	strb.w	r7, [sp, #111]	; 0x6f
    dc18:	movs	r3, #48	; 0x30
    dc1a:	cmp	fp, r7
    dc1c:	strb.w	r3, [sp, #112]	; 0x70
    dc20:	orr.w	r3, r2, #2
    dc24:	blt.w	e984 <_svfprintf_r+0x14f4>
    dc28:	bic.w	r3, r2, #128	; 0x80
    dc2c:	orr.w	r3, r3, #2
    dc30:	str	r3, [sp, #12]
    dc32:	add	r6, sp, #192	; 0xc0
    dc34:	lsrs	r3, r4, #4
    dc36:	and.w	r1, r4, #15
    dc3a:	orr.w	r3, r3, r5, lsl #28
    dc3e:	lsrs	r2, r5, #4
    dc40:	mov	r4, r3
    dc42:	mov	r5, r2
    dc44:	ldrb	r3, [r0, r1]
    dc46:	strb.w	r3, [r6, #-1]!
    dc4a:	orrs.w	r3, r4, r5
    dc4e:	bne.n	dc34 <_svfprintf_r+0x7a4>
    dc50:	b.n	d820 <_svfprintf_r+0x390>
    dc52:	ldr	r1, [sp, #40]	; 0x28
    dc54:	str	r3, [sp, #52]	; 0x34
    dc56:	ldr	r2, [r1, #0]
    dc58:	strb.w	r2, [sp, #152]	; 0x98
    dc5c:	movs	r3, #0
    dc5e:	mov	r2, r1
    dc60:	mov	r7, r3
    dc62:	strb.w	r3, [sp, #111]	; 0x6f
    dc66:	adds	r2, #4
    dc68:	movs	r3, #1
    dc6a:	str	r3, [sp, #16]
    dc6c:	mov	fp, r7
    dc6e:	str	r7, [sp, #60]	; 0x3c
    dc70:	str	r2, [sp, #40]	; 0x28
    dc72:	str	r3, [sp, #36]	; 0x24
    dc74:	add	r6, sp, #152	; 0x98
    dc76:	b.n	d83c <_svfprintf_r+0x3ac>
    dc78:	str	r3, [sp, #52]	; 0x34
    dc7a:	mov	fp, r5
    dc7c:	cmp	r2, #0
    dc7e:	beq.w	d7a8 <_svfprintf_r+0x318>
    dc82:	strb.w	r1, [sp, #111]	; 0x6f
    dc86:	b.n	d7a8 <_svfprintf_r+0x318>
    dc88:	ldr	r3, [sp, #12]
    dc8a:	orr.w	r3, r3, #64	; 0x40
    dc8e:	str	r3, [sp, #12]
    dc90:	ldrb.w	r3, [r8]
    dc94:	b.n	d544 <_svfprintf_r+0xb4>
    dc96:	ldrb.w	r3, [r8]
    dc9a:	cmp	r1, #0
    dc9c:	bne.w	d544 <_svfprintf_r+0xb4>
    dca0:	movs	r2, #1
    dca2:	movs	r1, #32
    dca4:	b.n	d544 <_svfprintf_r+0xb4>
    dca6:	ldr	r3, [sp, #12]
    dca8:	orr.w	r3, r3, #1
    dcac:	str	r3, [sp, #12]
    dcae:	ldrb.w	r3, [r8]
    dcb2:	b.n	d544 <_svfprintf_r+0xb4>
    dcb4:	ldr	r4, [sp, #40]	; 0x28
    dcb6:	ldr	r3, [r4, #0]
    dcb8:	str	r3, [sp, #32]
    dcba:	mov	r0, r3
    dcbc:	cmp	r0, #0
    dcbe:	mov	r3, r4
    dcc0:	add.w	r3, r3, #4
    dcc4:	blt.w	d608 <_svfprintf_r+0x178>
    dcc8:	str	r3, [sp, #40]	; 0x28
    dcca:	ldrb.w	r3, [r8]
    dcce:	b.n	d544 <_svfprintf_r+0xb4>
    dcd0:	ldrb.w	r3, [r8]
    dcd4:	movs	r2, #1
    dcd6:	movs	r1, #43	; 0x2b
    dcd8:	b.n	d544 <_svfprintf_r+0xb4>
    dcda:	ldr	r3, [sp, #12]
    dcdc:	orr.w	r3, r3, #32
    dce0:	str	r3, [sp, #12]
    dce2:	ldrb.w	r3, [r8]
    dce6:	b.n	d544 <_svfprintf_r+0xb4>
    dce8:	ldr	r2, [sp, #40]	; 0x28
    dcea:	str	r3, [sp, #52]	; 0x34
    dcec:	ldr	r6, [r2, #0]
    dcee:	movs	r4, #0
    dcf0:	strb.w	r4, [sp, #111]	; 0x6f
    dcf4:	adds	r7, r2, #4
    dcf6:	cmp	r6, #0
    dcf8:	beq.w	e934 <_svfprintf_r+0x14a4>
    dcfc:	cmp	r5, #0
    dcfe:	blt.w	e7c4 <_svfprintf_r+0x1334>
    dd02:	mov	r2, r5
    dd04:	mov	r1, r4
    dd06:	mov	r0, r6
    dd08:	bl	ba60 <memchr>
    dd0c:	cmp	r0, #0
    dd0e:	beq.w	e9d8 <_svfprintf_r+0x1548>
    dd12:	subs	r3, r0, r6
    dd14:	str	r3, [sp, #36]	; 0x24
    dd16:	mov	fp, r4
    dd18:	bic.w	r3, r3, r3, asr #31
    dd1c:	str	r7, [sp, #40]	; 0x28
    dd1e:	str	r3, [sp, #16]
    dd20:	str.w	fp, [sp, #60]	; 0x3c
    dd24:	ldrb.w	r7, [sp, #111]	; 0x6f
    dd28:	b.n	d834 <_svfprintf_r+0x3a4>
    dd2a:	str	r3, [sp, #52]	; 0x34
    dd2c:	mov	fp, r5
    dd2e:	cmp	r2, #0
    dd30:	beq.w	db86 <_svfprintf_r+0x6f6>
    dd34:	strb.w	r1, [sp, #111]	; 0x6f
    dd38:	b.n	db86 <_svfprintf_r+0x6f6>
    dd3a:	str	r3, [sp, #52]	; 0x34
    dd3c:	mov	fp, r5
    dd3e:	cmp	r2, #0
    dd40:	bne.w	eb60 <_svfprintf_r+0x16d0>
    dd44:	ldr	r3, [sp, #12]
    dd46:	ldr	r0, [pc, #344]	; (dea0 <_svfprintf_r+0xa10>)
    dd48:	lsls	r5, r3, #26
    dd4a:	bmi.w	dbe4 <_svfprintf_r+0x754>
    dd4e:	ldr	r3, [sp, #12]
    dd50:	lsls	r4, r3, #27
    dd52:	bpl.w	e5d2 <_svfprintf_r+0x1142>
    dd56:	ldr	r2, [sp, #40]	; 0x28
    dd58:	mov	r3, r2
    dd5a:	adds	r3, #4
    dd5c:	ldr	r4, [r2, #0]
    dd5e:	str	r3, [sp, #40]	; 0x28
    dd60:	movs	r5, #0
    dd62:	b.n	dbf6 <_svfprintf_r+0x766>
    dd64:	ldrb.w	r3, [r8]
    dd68:	cmp	r3, #108	; 0x6c
    dd6a:	beq.w	e6f2 <_svfprintf_r+0x1262>
    dd6e:	ldr	r0, [sp, #12]
    dd70:	orr.w	r0, r0, #16
    dd74:	str	r0, [sp, #12]
    dd76:	b.w	d544 <_svfprintf_r+0xb4>
    dd7a:	cmp	r2, #0
    dd7c:	bne.w	eb58 <_svfprintf_r+0x16c8>
    dd80:	ldr	r3, [sp, #12]
    dd82:	lsls	r3, r3, #26
    dd84:	bpl.w	e436 <_svfprintf_r+0xfa6>
    dd88:	ldr	r2, [sp, #40]	; 0x28
    dd8a:	ldr	r1, [sp, #28]
    dd8c:	ldr	r3, [r2, #0]
    dd8e:	asrs	r5, r1, #31
    dd90:	mov	r0, r1
    dd92:	adds	r2, #4
    dd94:	mov	r1, r5
    dd96:	str	r2, [sp, #40]	; 0x28
    dd98:	strd	r0, r1, [r3]
    dd9c:	b.w	d4de <_svfprintf_r+0x4e>
    dda0:	ldr	r0, [pc, #252]	; (dea0 <_svfprintf_r+0xa10>)
    dda2:	str	r2, [sp, #52]	; 0x34
    dda4:	cmp.w	fp, #0
    dda8:	bne.w	e094 <_svfprintf_r+0xc04>
    ddac:	mov	r7, fp
    ddae:	mov.w	fp, #0
    ddb2:	str.w	fp, [sp, #36]	; 0x24
    ddb6:	add	r6, sp, #192	; 0xc0
    ddb8:	b.n	d826 <_svfprintf_r+0x396>
    ddba:	str	r3, [sp, #52]	; 0x34
    ddbc:	cmp	r2, #0
    ddbe:	bne.w	eb50 <_svfprintf_r+0x16c0>
    ddc2:	ldr	r2, [sp, #52]	; 0x34
    ddc4:	cmp	r2, #0
    ddc6:	beq.w	d676 <_svfprintf_r+0x1e6>
    ddca:	movs	r3, #0
    ddcc:	movs	r1, #1
    ddce:	mov	r7, r3
    ddd0:	str	r1, [sp, #16]
    ddd2:	strb.w	r2, [sp, #152]	; 0x98
    ddd6:	strb.w	r3, [sp, #111]	; 0x6f
    ddda:	mov	fp, r3
    dddc:	str	r3, [sp, #60]	; 0x3c
    ddde:	str	r1, [sp, #36]	; 0x24
    dde0:	add	r6, sp, #152	; 0x98
    dde2:	b.n	d83c <_svfprintf_r+0x3ac>
    dde4:	cmp.w	fp, #0
    dde8:	beq.w	ea08 <_svfprintf_r+0x1578>
    ddec:	movs	r7, #0
    ddee:	movs	r4, #0
    ddf0:	movs	r5, #0
    ddf2:	b.n	d6dc <_svfprintf_r+0x24c>
    ddf4:	ldr	r0, [pc, #168]	; (dea0 <_svfprintf_r+0xa10>)
    ddf6:	str	r3, [sp, #12]
    ddf8:	str	r2, [sp, #52]	; 0x34
    ddfa:	orrs.w	r3, r4, r5
    ddfe:	str	r7, [sp, #40]	; 0x28
    de00:	mov.w	r7, #0
    de04:	bne.w	dc32 <_svfprintf_r+0x7a2>
    de08:	movs	r4, #0
    de0a:	movs	r5, #0
    de0c:	b.n	dc32 <_svfprintf_r+0x7a2>
    de0e:	ldr	r4, [sp, #148]	; 0x94
    de10:	b.n	d8dc <_svfprintf_r+0x44c>
    de12:	ldr	r3, [sp, #52]	; 0x34
    de14:	cmp	r3, #101	; 0x65
    de16:	ble.w	df6e <_svfprintf_r+0xade>
    de1a:	movs	r2, #0
    de1c:	movs	r3, #0
    de1e:	ldrd	r0, r1, [sp, #64]	; 0x40
    de22:	bl	ac88 <__aeabi_dcmpeq>
    de26:	cmp	r0, #0
    de28:	beq.w	e098 <_svfprintf_r+0xc08>
    de2c:	ldr	r3, [sp, #144]	; 0x90
    de2e:	ldr	r2, [pc, #116]	; (dea4 <_svfprintf_r+0xa14>)
    de30:	str.w	r2, [r9]
    de34:	adds	r3, #1
    de36:	adds	r4, #1
    de38:	movs	r2, #1
    de3a:	cmp	r3, #7
    de3c:	str	r4, [sp, #148]	; 0x94
    de3e:	str	r3, [sp, #144]	; 0x90
    de40:	str.w	r2, [r9, #4]
    de44:	bgt.w	e624 <_svfprintf_r+0x1194>
    de48:	add.w	r9, r9, #8
    de4c:	ldr	r3, [sp, #116]	; 0x74
    de4e:	ldr	r2, [sp, #56]	; 0x38
    de50:	cmp	r3, r2
    de52:	blt.n	de5c <_svfprintf_r+0x9cc>
    de54:	ldr	r3, [sp, #12]
    de56:	lsls	r3, r3, #31
    de58:	bpl.w	d9bc <_svfprintf_r+0x52c>
    de5c:	ldr	r3, [sp, #144]	; 0x90
    de5e:	ldr	r1, [sp, #72]	; 0x48
    de60:	ldr	r2, [sp, #76]	; 0x4c
    de62:	str.w	r2, [r9]
    de66:	adds	r3, #1
    de68:	add	r4, r1
    de6a:	cmp	r3, #7
    de6c:	str	r4, [sp, #148]	; 0x94
    de6e:	str.w	r1, [r9, #4]
    de72:	str	r3, [sp, #144]	; 0x90
    de74:	bgt.w	e706 <_svfprintf_r+0x1276>
    de78:	add.w	r9, r9, #8
    de7c:	ldr	r3, [sp, #56]	; 0x38
    de7e:	subs	r5, r3, #1
    de80:	cmp	r5, #0
    de82:	ble.w	d9bc <_svfprintf_r+0x52c>
    de86:	ldr	r2, [pc, #32]	; (dea8 <_svfprintf_r+0xa18>)
    de88:	ldr	r3, [sp, #144]	; 0x90
    de8a:	str	r2, [sp, #44]	; 0x2c
    de8c:	cmp	r5, #16
    de8e:	ble.w	e264 <_svfprintf_r+0xdd4>
    de92:	movs	r6, #16
    de94:	ldr	r7, [sp, #24]
    de96:	ldr.w	fp, [sp, #20]
    de9a:	b.n	deb8 <_svfprintf_r+0xa28>
    de9c:	.word	0x00013480
    dea0:	.word	0x00013494
    dea4:	.word	0x000134b0
    dea8:	.word	0x00013460
    deac:	add.w	r9, r9, #8
    deb0:	subs	r5, #16
    deb2:	cmp	r5, #16
    deb4:	ble.w	e264 <_svfprintf_r+0xdd4>
    deb8:	adds	r3, #1
    deba:	adds	r4, #16
    debc:	cmp	r3, #7
    debe:	str	r4, [sp, #148]	; 0x94
    dec0:	str	r3, [sp, #144]	; 0x90
    dec2:	str.w	sl, [r9]
    dec6:	str.w	r6, [r9, #4]
    deca:	ble.n	deac <_svfprintf_r+0xa1c>
    decc:	add	r2, sp, #140	; 0x8c
    dece:	mov	r1, fp
    ded0:	mov	r0, r7
    ded2:	bl	12428 <__ssprint_r>
    ded6:	cmp	r0, #0
    ded8:	bne.w	d684 <_svfprintf_r+0x1f4>
    dedc:	ldr	r4, [sp, #148]	; 0x94
    dede:	ldr	r3, [sp, #144]	; 0x90
    dee0:	add.w	r9, sp, #192	; 0xc0
    dee4:	b.n	deb0 <_svfprintf_r+0xa20>
    dee6:	ldr	r3, [sp, #32]
    dee8:	ldr	r2, [sp, #16]
    deea:	subs	r7, r3, r2
    deec:	cmp	r7, #0
    deee:	ble.w	d924 <_svfprintf_r+0x494>
    def2:	ldr	r2, [pc, #752]	; (e1e4 <_svfprintf_r+0xd54>)
    def4:	ldr	r3, [sp, #144]	; 0x90
    def6:	str	r2, [sp, #44]	; 0x2c
    def8:	cmp	r7, #16
    defa:	ble.n	df54 <_svfprintf_r+0xac4>
    defc:	mov	r2, r9
    defe:	mov	r1, r4
    df00:	mov	r9, r7
    df02:	movs	r5, #16
    df04:	mov	r7, r6
    df06:	ldr	r4, [sp, #24]
    df08:	ldr	r6, [sp, #20]
    df0a:	b.n	df1a <_svfprintf_r+0xa8a>
    df0c:	sub.w	r9, r9, #16
    df10:	cmp.w	r9, #16
    df14:	add.w	r2, r2, #8
    df18:	ble.n	df4c <_svfprintf_r+0xabc>
    df1a:	adds	r3, #1
    df1c:	adds	r1, #16
    df1e:	cmp	r3, #7
    df20:	str	r1, [sp, #148]	; 0x94
    df22:	str	r3, [sp, #144]	; 0x90
    df24:	str.w	sl, [r2]
    df28:	str	r5, [r2, #4]
    df2a:	ble.n	df0c <_svfprintf_r+0xa7c>
    df2c:	add	r2, sp, #140	; 0x8c
    df2e:	mov	r1, r6
    df30:	mov	r0, r4
    df32:	bl	12428 <__ssprint_r>
    df36:	cmp	r0, #0
    df38:	bne.w	d684 <_svfprintf_r+0x1f4>
    df3c:	sub.w	r9, r9, #16
    df40:	cmp.w	r9, #16
    df44:	ldr	r1, [sp, #148]	; 0x94
    df46:	ldr	r3, [sp, #144]	; 0x90
    df48:	add	r2, sp, #192	; 0xc0
    df4a:	bgt.n	df1a <_svfprintf_r+0xa8a>
    df4c:	mov	r6, r7
    df4e:	mov	r4, r1
    df50:	mov	r7, r9
    df52:	mov	r9, r2
    df54:	adds	r3, #1
    df56:	ldr	r2, [sp, #44]	; 0x2c
    df58:	str	r3, [sp, #144]	; 0x90
    df5a:	add	r4, r7
    df5c:	cmp	r3, #7
    df5e:	str	r4, [sp, #148]	; 0x94
    df60:	stmia.w	r9, {r2, r7}
    df64:	bgt.w	e3e2 <_svfprintf_r+0xf52>
    df68:	add.w	r9, r9, #8
    df6c:	b.n	d924 <_svfprintf_r+0x494>
    df6e:	ldr	r3, [sp, #56]	; 0x38
    df70:	ldr	r5, [sp, #144]	; 0x90
    df72:	cmp	r3, #1
    df74:	ble.w	e38c <_svfprintf_r+0xefc>
    df78:	adds	r5, #1
    df7a:	adds	r4, #1
    df7c:	movs	r3, #1
    df7e:	cmp	r5, #7
    df80:	str	r4, [sp, #148]	; 0x94
    df82:	str	r5, [sp, #144]	; 0x90
    df84:	str.w	r6, [r9]
    df88:	str.w	r3, [r9, #4]
    df8c:	bgt.w	e3ae <_svfprintf_r+0xf1e>
    df90:	add.w	r9, r9, #8
    df94:	ldr	r2, [sp, #72]	; 0x48
    df96:	ldr	r3, [sp, #76]	; 0x4c
    df98:	str.w	r3, [r9]
    df9c:	adds	r5, #1
    df9e:	add	r4, r2
    dfa0:	cmp	r5, #7
    dfa2:	str	r4, [sp, #148]	; 0x94
    dfa4:	str	r5, [sp, #144]	; 0x90
    dfa6:	str.w	r2, [r9, #4]
    dfaa:	bgt.w	e3c8 <_svfprintf_r+0xf38>
    dfae:	add.w	r9, r9, #8
    dfb2:	movs	r3, #0
    dfb4:	movs	r2, #0
    dfb6:	ldrd	r0, r1, [sp, #64]	; 0x40
    dfba:	bl	ac88 <__aeabi_dcmpeq>
    dfbe:	ldr	r3, [sp, #56]	; 0x38
    dfc0:	cmp	r0, #0
    dfc2:	bne.w	e14c <_svfprintf_r+0xcbc>
    dfc6:	subs	r3, #1
    dfc8:	adds	r5, #1
    dfca:	adds	r6, #1
    dfcc:	add	r4, r3
    dfce:	cmp	r5, #7
    dfd0:	str	r5, [sp, #144]	; 0x90
    dfd2:	str	r4, [sp, #148]	; 0x94
    dfd4:	str.w	r6, [r9]
    dfd8:	str.w	r3, [r9, #4]
    dfdc:	bgt.w	e1ca <_svfprintf_r+0xd3a>
    dfe0:	add.w	r9, r9, #8
    dfe4:	ldr	r2, [sp, #84]	; 0x54
    dfe6:	str.w	r2, [r9, #4]
    dfea:	adds	r5, #1
    dfec:	add	r4, r2
    dfee:	add	r3, sp, #124	; 0x7c
    dff0:	cmp	r5, #7
    dff2:	str	r4, [sp, #148]	; 0x94
    dff4:	str	r5, [sp, #144]	; 0x90
    dff6:	str.w	r3, [r9]
    dffa:	ble.w	d9b8 <_svfprintf_r+0x528>
    dffe:	add	r2, sp, #140	; 0x8c
    e000:	ldr	r1, [sp, #20]
    e002:	ldr	r0, [sp, #24]
    e004:	bl	12428 <__ssprint_r>
    e008:	cmp	r0, #0
    e00a:	bne.w	d684 <_svfprintf_r+0x1f4>
    e00e:	ldr	r4, [sp, #148]	; 0x94
    e010:	add.w	r9, sp, #192	; 0xc0
    e014:	b.n	d9bc <_svfprintf_r+0x52c>
    e016:	add	r2, sp, #140	; 0x8c
    e018:	ldr	r1, [sp, #20]
    e01a:	ldr	r0, [sp, #24]
    e01c:	bl	12428 <__ssprint_r>
    e020:	cmp	r0, #0
    e022:	beq.w	da58 <_svfprintf_r+0x5c8>
    e026:	b.w	d684 <_svfprintf_r+0x1f4>
    e02a:	add	r2, sp, #140	; 0x8c
    e02c:	ldr	r1, [sp, #20]
    e02e:	ldr	r0, [sp, #24]
    e030:	bl	12428 <__ssprint_r>
    e034:	cmp	r0, #0
    e036:	bne.w	d684 <_svfprintf_r+0x1f4>
    e03a:	ldr	r4, [sp, #148]	; 0x94
    e03c:	add.w	r9, sp, #192	; 0xc0
    e040:	b.n	d996 <_svfprintf_r+0x506>
    e042:	add	r2, sp, #140	; 0x8c
    e044:	ldr	r1, [sp, #20]
    e046:	ldr	r0, [sp, #24]
    e048:	bl	12428 <__ssprint_r>
    e04c:	cmp	r0, #0
    e04e:	bne.w	d684 <_svfprintf_r+0x1f4>
    e052:	ldr	r4, [sp, #148]	; 0x94
    e054:	add.w	r9, sp, #192	; 0xc0
    e058:	b.n	d8fc <_svfprintf_r+0x46c>
    e05a:	add	r2, sp, #140	; 0x8c
    e05c:	ldr	r1, [sp, #20]
    e05e:	ldr	r0, [sp, #24]
    e060:	bl	12428 <__ssprint_r>
    e064:	cmp	r0, #0
    e066:	bne.w	d684 <_svfprintf_r+0x1f4>
    e06a:	ldr	r4, [sp, #148]	; 0x94
    e06c:	add.w	r9, sp, #192	; 0xc0
    e070:	b.n	d91c <_svfprintf_r+0x48c>
    e072:	cmp.w	fp, #0
    e076:	strb.w	r7, [sp, #111]	; 0x6f
    e07a:	blt.w	e63c <_svfprintf_r+0x11ac>
    e07e:	bic.w	r3, r2, #128	; 0x80
    e082:	str	r3, [sp, #12]
    e084:	orrs.w	r3, r4, r5
    e088:	bne.w	dc32 <_svfprintf_r+0x7a2>
    e08c:	cmp.w	fp, #0
    e090:	beq.w	ddac <_svfprintf_r+0x91c>
    e094:	movs	r7, #0
    e096:	b.n	de08 <_svfprintf_r+0x978>
    e098:	ldr	r5, [sp, #116]	; 0x74
    e09a:	cmp	r5, #0
    e09c:	ble.w	e642 <_svfprintf_r+0x11b2>
    e0a0:	ldr	r3, [sp, #60]	; 0x3c
    e0a2:	ldr	r2, [sp, #56]	; 0x38
    e0a4:	cmp	r3, r2
    e0a6:	it	ge
    e0a8:	movge	r3, r2
    e0aa:	cmp	r3, #0
    e0ac:	mov	r5, r3
    e0ae:	ble.n	e0cc <_svfprintf_r+0xc3c>
    e0b0:	ldr	r3, [sp, #144]	; 0x90
    e0b2:	str.w	r6, [r9]
    e0b6:	adds	r3, #1
    e0b8:	add	r4, r5
    e0ba:	cmp	r3, #7
    e0bc:	str	r4, [sp, #148]	; 0x94
    e0be:	str.w	r5, [r9, #4]
    e0c2:	str	r3, [sp, #144]	; 0x90
    e0c4:	bgt.w	e81a <_svfprintf_r+0x138a>
    e0c8:	add.w	r9, r9, #8
    e0cc:	ldr	r3, [sp, #60]	; 0x3c
    e0ce:	cmp	r5, #0
    e0d0:	it	ge
    e0d2:	subge	r3, r3, r5
    e0d4:	cmp	r3, #0
    e0d6:	mov	r5, r3
    e0d8:	ble.w	e2cc <_svfprintf_r+0xe3c>
    e0dc:	ldr	r2, [pc, #260]	; (e1e4 <_svfprintf_r+0xd54>)
    e0de:	ldr	r3, [sp, #144]	; 0x90
    e0e0:	str	r2, [sp, #44]	; 0x2c
    e0e2:	cmp	r5, #16
    e0e4:	ble.w	e5ee <_svfprintf_r+0x115e>
    e0e8:	mov	r2, r4
    e0ea:	movs	r7, #16
    e0ec:	ldr.w	fp, [sp, #24]
    e0f0:	ldr	r4, [sp, #20]
    e0f2:	b.n	e100 <_svfprintf_r+0xc70>
    e0f4:	add.w	r9, r9, #8
    e0f8:	subs	r5, #16
    e0fa:	cmp	r5, #16
    e0fc:	ble.w	e5ec <_svfprintf_r+0x115c>
    e100:	adds	r3, #1
    e102:	adds	r2, #16
    e104:	cmp	r3, #7
    e106:	str	r2, [sp, #148]	; 0x94
    e108:	str	r3, [sp, #144]	; 0x90
    e10a:	str.w	sl, [r9]
    e10e:	str.w	r7, [r9, #4]
    e112:	ble.n	e0f4 <_svfprintf_r+0xc64>
    e114:	add	r2, sp, #140	; 0x8c
    e116:	mov	r1, r4
    e118:	mov	r0, fp
    e11a:	bl	12428 <__ssprint_r>
    e11e:	cmp	r0, #0
    e120:	bne.w	d684 <_svfprintf_r+0x1f4>
    e124:	ldr	r2, [sp, #148]	; 0x94
    e126:	ldr	r3, [sp, #144]	; 0x90
    e128:	add.w	r9, sp, #192	; 0xc0
    e12c:	b.n	e0f8 <_svfprintf_r+0xc68>
    e12e:	add	r2, sp, #140	; 0x8c
    e130:	ldr	r1, [sp, #20]
    e132:	ldr	r0, [sp, #24]
    e134:	bl	12428 <__ssprint_r>
    e138:	cmp	r0, #0
    e13a:	bne.w	d684 <_svfprintf_r+0x1f4>
    e13e:	ldrb.w	r7, [sp, #111]	; 0x6f
    e142:	ldr	r4, [sp, #148]	; 0x94
    e144:	add.w	r9, sp, #192	; 0xc0
    e148:	b.w	d8dc <_svfprintf_r+0x44c>
    e14c:	subs	r6, r3, #1
    e14e:	cmp	r6, #0
    e150:	ble.w	dfe4 <_svfprintf_r+0xb54>
    e154:	ldr	r3, [pc, #140]	; (e1e4 <_svfprintf_r+0xd54>)
    e156:	str	r3, [sp, #44]	; 0x2c
    e158:	cmp	r6, #16
    e15a:	ble.n	e1b6 <_svfprintf_r+0xd26>
    e15c:	str.w	r8, [sp, #36]	; 0x24
    e160:	movs	r7, #16
    e162:	mov	r8, r6
    e164:	ldr.w	fp, [sp, #24]
    e168:	ldr	r6, [sp, #20]
    e16a:	b.n	e17a <_svfprintf_r+0xcea>
    e16c:	sub.w	r8, r8, #16
    e170:	cmp.w	r8, #16
    e174:	add.w	r9, r9, #8
    e178:	ble.n	e1b0 <_svfprintf_r+0xd20>
    e17a:	adds	r5, #1
    e17c:	adds	r4, #16
    e17e:	cmp	r5, #7
    e180:	str	r4, [sp, #148]	; 0x94
    e182:	str	r5, [sp, #144]	; 0x90
    e184:	str.w	sl, [r9]
    e188:	str.w	r7, [r9, #4]
    e18c:	ble.n	e16c <_svfprintf_r+0xcdc>
    e18e:	add	r2, sp, #140	; 0x8c
    e190:	mov	r1, r6
    e192:	mov	r0, fp
    e194:	bl	12428 <__ssprint_r>
    e198:	cmp	r0, #0
    e19a:	bne.w	d684 <_svfprintf_r+0x1f4>
    e19e:	sub.w	r8, r8, #16
    e1a2:	cmp.w	r8, #16
    e1a6:	ldr	r4, [sp, #148]	; 0x94
    e1a8:	ldr	r5, [sp, #144]	; 0x90
    e1aa:	add.w	r9, sp, #192	; 0xc0
    e1ae:	bgt.n	e17a <_svfprintf_r+0xcea>
    e1b0:	mov	r6, r8
    e1b2:	ldr.w	r8, [sp, #36]	; 0x24
    e1b6:	ldr	r3, [sp, #44]	; 0x2c
    e1b8:	adds	r5, #1
    e1ba:	add	r4, r6
    e1bc:	cmp	r5, #7
    e1be:	str	r4, [sp, #148]	; 0x94
    e1c0:	str	r5, [sp, #144]	; 0x90
    e1c2:	stmia.w	r9, {r3, r6}
    e1c6:	ble.w	dfe0 <_svfprintf_r+0xb50>
    e1ca:	add	r2, sp, #140	; 0x8c
    e1cc:	ldr	r1, [sp, #20]
    e1ce:	ldr	r0, [sp, #24]
    e1d0:	bl	12428 <__ssprint_r>
    e1d4:	cmp	r0, #0
    e1d6:	bne.w	d684 <_svfprintf_r+0x1f4>
    e1da:	ldr	r4, [sp, #148]	; 0x94
    e1dc:	ldr	r5, [sp, #144]	; 0x90
    e1de:	add.w	r9, sp, #192	; 0xc0
    e1e2:	b.n	dfe4 <_svfprintf_r+0xb54>
    e1e4:	.word	0x00013460
    e1e8:	ldr	r1, [sp, #12]
    e1ea:	ands.w	r2, r1, #16
    e1ee:	beq.w	e598 <_svfprintf_r+0x1108>
    e1f2:	ldr	r0, [sp, #40]	; 0x28
    e1f4:	strb.w	r3, [sp, #111]	; 0x6f
    e1f8:	cmp.w	fp, #0
    e1fc:	ldr	r4, [r0, #0]
    e1fe:	add.w	r7, r0, #4
    e202:	mov.w	r5, #0
    e206:	blt.n	e256 <_svfprintf_r+0xdc6>
    e208:	mov	r2, r1
    e20a:	bic.w	r2, r2, #128	; 0x80
    e20e:	str	r2, [sp, #12]
    e210:	orrs.w	r2, r4, r5
    e214:	str	r7, [sp, #40]	; 0x28
    e216:	mov	r7, r3
    e218:	bne.w	d7ec <_svfprintf_r+0x35c>
    e21c:	b.n	dbbc <_svfprintf_r+0x72c>
    e21e:	ldr	r3, [sp, #12]
    e220:	lsls	r0, r3, #27
    e222:	bmi.n	e27a <_svfprintf_r+0xdea>
    e224:	ldr	r3, [sp, #12]
    e226:	lsls	r1, r3, #25
    e228:	bpl.n	e27a <_svfprintf_r+0xdea>
    e22a:	ldr	r1, [sp, #40]	; 0x28
    e22c:	ldrsh.w	r4, [r1]
    e230:	adds	r1, #4
    e232:	asrs	r5, r4, #31
    e234:	mov	r2, r4
    e236:	mov	r3, r5
    e238:	str	r1, [sp, #40]	; 0x28
    e23a:	b.w	d7c6 <_svfprintf_r+0x336>
    e23e:	ldr	r1, [sp, #40]	; 0x28
    e240:	strb.w	r3, [sp, #111]	; 0x6f
    e244:	cmp.w	fp, #0
    e248:	ldr	r4, [r1, #0]
    e24a:	add.w	r7, r1, #4
    e24e:	mov.w	r5, #0
    e252:	bge.w	e6ee <_svfprintf_r+0x125e>
    e256:	str	r7, [sp, #40]	; 0x28
    e258:	mov	r7, r3
    e25a:	orrs.w	r3, r4, r5
    e25e:	bne.w	d7ec <_svfprintf_r+0x35c>
    e262:	b.n	dbc6 <_svfprintf_r+0x736>
    e264:	adds	r3, #1
    e266:	ldr	r2, [sp, #44]	; 0x2c
    e268:	str	r3, [sp, #144]	; 0x90
    e26a:	add	r4, r5
    e26c:	cmp	r3, #7
    e26e:	str	r4, [sp, #148]	; 0x94
    e270:	stmia.w	r9, {r2, r5}
    e274:	ble.w	d9b8 <_svfprintf_r+0x528>
    e278:	b.n	dffe <_svfprintf_r+0xb6e>
    e27a:	ldr	r2, [sp, #40]	; 0x28
    e27c:	ldr	r4, [r2, #0]
    e27e:	mov	r3, r2
    e280:	adds	r3, #4
    e282:	asrs	r5, r4, #31
    e284:	mov	r2, r4
    e286:	str	r3, [sp, #40]	; 0x28
    e288:	cmp	r2, #0
    e28a:	mov	r3, r5
    e28c:	sbcs.w	r3, r3, #0
    e290:	bge.w	d7d0 <_svfprintf_r+0x340>
    e294:	negs	r4, r4
    e296:	mov.w	r7, #45	; 0x2d
    e29a:	sbc.w	r5, r5, r5, lsl #1
    e29e:	cmp.w	fp, #0
    e2a2:	strb.w	r7, [sp, #111]	; 0x6f
    e2a6:	blt.w	d7ec <_svfprintf_r+0x35c>
    e2aa:	ldr	r3, [sp, #12]
    e2ac:	bic.w	r3, r3, #128	; 0x80
    e2b0:	str	r3, [sp, #12]
    e2b2:	b.w	d7ec <_svfprintf_r+0x35c>
    e2b6:	add	r2, sp, #140	; 0x8c
    e2b8:	ldr	r1, [sp, #20]
    e2ba:	ldr	r0, [sp, #24]
    e2bc:	bl	12428 <__ssprint_r>
    e2c0:	cmp	r0, #0
    e2c2:	bne.w	d684 <_svfprintf_r+0x1f4>
    e2c6:	ldr	r4, [sp, #148]	; 0x94
    e2c8:	add.w	r9, sp, #192	; 0xc0
    e2cc:	ldr	r2, [sp, #60]	; 0x3c
    e2ce:	ldr	r3, [sp, #116]	; 0x74
    e2d0:	add	r2, r6
    e2d2:	mov	r7, r2
    e2d4:	ldr	r2, [sp, #56]	; 0x38
    e2d6:	cmp	r3, r2
    e2d8:	blt.n	e36a <_svfprintf_r+0xeda>
    e2da:	ldr	r2, [sp, #12]
    e2dc:	lsls	r5, r2, #31
    e2de:	bmi.n	e36a <_svfprintf_r+0xeda>
    e2e0:	ldr	r1, [sp, #56]	; 0x38
    e2e2:	add	r6, r1
    e2e4:	subs	r5, r6, r7
    e2e6:	subs	r3, r1, r3
    e2e8:	cmp	r5, r3
    e2ea:	it	ge
    e2ec:	movge	r5, r3
    e2ee:	cmp	r5, #0
    e2f0:	mov	r6, r5
    e2f2:	ble.n	e310 <_svfprintf_r+0xe80>
    e2f4:	ldr	r2, [sp, #144]	; 0x90
    e2f6:	str.w	r7, [r9]
    e2fa:	adds	r2, #1
    e2fc:	add	r4, r5
    e2fe:	cmp	r2, #7
    e300:	str	r4, [sp, #148]	; 0x94
    e302:	str.w	r5, [r9, #4]
    e306:	str	r2, [sp, #144]	; 0x90
    e308:	bgt.w	e908 <_svfprintf_r+0x1478>
    e30c:	add.w	r9, r9, #8
    e310:	cmp	r6, #0
    e312:	ite	ge
    e314:	subge	r5, r3, r6
    e316:	movlt	r5, r3
    e318:	cmp	r5, #0
    e31a:	ble.w	d9bc <_svfprintf_r+0x52c>
    e31e:	ldr	r2, [pc, #744]	; (e608 <_svfprintf_r+0x1178>)
    e320:	ldr	r3, [sp, #144]	; 0x90
    e322:	str	r2, [sp, #44]	; 0x2c
    e324:	cmp	r5, #16
    e326:	ble.n	e264 <_svfprintf_r+0xdd4>
    e328:	movs	r6, #16
    e32a:	ldr	r7, [sp, #24]
    e32c:	ldr.w	fp, [sp, #20]
    e330:	b.n	e33c <_svfprintf_r+0xeac>
    e332:	add.w	r9, r9, #8
    e336:	subs	r5, #16
    e338:	cmp	r5, #16
    e33a:	ble.n	e264 <_svfprintf_r+0xdd4>
    e33c:	adds	r3, #1
    e33e:	adds	r4, #16
    e340:	cmp	r3, #7
    e342:	str	r4, [sp, #148]	; 0x94
    e344:	str	r3, [sp, #144]	; 0x90
    e346:	str.w	sl, [r9]
    e34a:	str.w	r6, [r9, #4]
    e34e:	ble.n	e332 <_svfprintf_r+0xea2>
    e350:	add	r2, sp, #140	; 0x8c
    e352:	mov	r1, fp
    e354:	mov	r0, r7
    e356:	bl	12428 <__ssprint_r>
    e35a:	cmp	r0, #0
    e35c:	bne.w	d684 <_svfprintf_r+0x1f4>
    e360:	ldr	r4, [sp, #148]	; 0x94
    e362:	ldr	r3, [sp, #144]	; 0x90
    e364:	add.w	r9, sp, #192	; 0xc0
    e368:	b.n	e336 <_svfprintf_r+0xea6>
    e36a:	ldr	r2, [sp, #144]	; 0x90
    e36c:	ldr	r0, [sp, #72]	; 0x48
    e36e:	ldr	r1, [sp, #76]	; 0x4c
    e370:	str.w	r1, [r9]
    e374:	adds	r2, #1
    e376:	add	r4, r0
    e378:	cmp	r2, #7
    e37a:	str	r4, [sp, #148]	; 0x94
    e37c:	str.w	r0, [r9, #4]
    e380:	str	r2, [sp, #144]	; 0x90
    e382:	bgt.w	e8ee <_svfprintf_r+0x145e>
    e386:	add.w	r9, r9, #8
    e38a:	b.n	e2e0 <_svfprintf_r+0xe50>
    e38c:	ldr	r3, [sp, #12]
    e38e:	lsls	r0, r3, #31
    e390:	bmi.w	df78 <_svfprintf_r+0xae8>
    e394:	adds	r5, #1
    e396:	adds	r4, #1
    e398:	movs	r3, #1
    e39a:	cmp	r5, #7
    e39c:	str	r4, [sp, #148]	; 0x94
    e39e:	str	r5, [sp, #144]	; 0x90
    e3a0:	str.w	r6, [r9]
    e3a4:	str.w	r3, [r9, #4]
    e3a8:	ble.w	dfe0 <_svfprintf_r+0xb50>
    e3ac:	b.n	e1ca <_svfprintf_r+0xd3a>
    e3ae:	add	r2, sp, #140	; 0x8c
    e3b0:	ldr	r1, [sp, #20]
    e3b2:	ldr	r0, [sp, #24]
    e3b4:	bl	12428 <__ssprint_r>
    e3b8:	cmp	r0, #0
    e3ba:	bne.w	d684 <_svfprintf_r+0x1f4>
    e3be:	ldr	r4, [sp, #148]	; 0x94
    e3c0:	ldr	r5, [sp, #144]	; 0x90
    e3c2:	add.w	r9, sp, #192	; 0xc0
    e3c6:	b.n	df94 <_svfprintf_r+0xb04>
    e3c8:	add	r2, sp, #140	; 0x8c
    e3ca:	ldr	r1, [sp, #20]
    e3cc:	ldr	r0, [sp, #24]
    e3ce:	bl	12428 <__ssprint_r>
    e3d2:	cmp	r0, #0
    e3d4:	bne.w	d684 <_svfprintf_r+0x1f4>
    e3d8:	ldr	r4, [sp, #148]	; 0x94
    e3da:	ldr	r5, [sp, #144]	; 0x90
    e3dc:	add.w	r9, sp, #192	; 0xc0
    e3e0:	b.n	dfb2 <_svfprintf_r+0xb22>
    e3e2:	add	r2, sp, #140	; 0x8c
    e3e4:	ldr	r1, [sp, #20]
    e3e6:	ldr	r0, [sp, #24]
    e3e8:	bl	12428 <__ssprint_r>
    e3ec:	cmp	r0, #0
    e3ee:	bne.w	d684 <_svfprintf_r+0x1f4>
    e3f2:	ldr	r4, [sp, #148]	; 0x94
    e3f4:	add.w	r9, sp, #192	; 0xc0
    e3f8:	b.w	d924 <_svfprintf_r+0x494>
    e3fc:	ldr	r1, [sp, #12]
    e3fe:	ands.w	r3, r1, #64	; 0x40
    e402:	beq.w	e578 <_svfprintf_r+0x10e8>
    e406:	ldr	r0, [sp, #40]	; 0x28
    e408:	strb.w	r2, [sp, #111]	; 0x6f
    e40c:	mov	r3, r0
    e40e:	cmp.w	fp, #0
    e412:	add.w	r3, r3, #4
    e416:	ldrh	r4, [r0, #0]
    e418:	mov.w	r5, #0
    e41c:	blt.w	e7a0 <_svfprintf_r+0x1310>
    e420:	bic.w	r1, r1, #128	; 0x80
    e424:	str	r1, [sp, #12]
    e426:	orrs.w	r1, r4, r5
    e42a:	str	r3, [sp, #40]	; 0x28
    e42c:	beq.w	dde4 <_svfprintf_r+0x954>
    e430:	mov	r7, r2
    e432:	b.w	d6dc <_svfprintf_r+0x24c>
    e436:	ldr	r3, [sp, #12]
    e438:	lsls	r7, r3, #27
    e43a:	bmi.n	e454 <_svfprintf_r+0xfc4>
    e43c:	ldr	r3, [sp, #12]
    e43e:	lsls	r6, r3, #25
    e440:	bpl.n	e454 <_svfprintf_r+0xfc4>
    e442:	ldr	r2, [sp, #40]	; 0x28
    e444:	ldr	r3, [r2, #0]
    e446:	adds	r2, #4
    e448:	str	r2, [sp, #40]	; 0x28
    e44a:	ldrh.w	r2, [sp, #28]
    e44e:	strh	r2, [r3, #0]
    e450:	b.w	d4de <_svfprintf_r+0x4e>
    e454:	ldr	r2, [sp, #40]	; 0x28
    e456:	ldr	r3, [r2, #0]
    e458:	adds	r2, #4
    e45a:	str	r2, [sp, #40]	; 0x28
    e45c:	ldr	r2, [sp, #28]
    e45e:	str	r2, [r3, #0]
    e460:	b.w	d4de <_svfprintf_r+0x4e>
    e464:	ldrd	r0, r1, [sp, #64]	; 0x40
    e468:	mov	r2, r0
    e46a:	mov	r3, r1
    e46c:	bl	acec <__aeabi_dcmpun>
    e470:	cmp	r0, #0
    e472:	bne.w	ea70 <_svfprintf_r+0x15e0>
    e476:	ldr	r3, [sp, #52]	; 0x34
    e478:	cmp.w	fp, #4294967295
    e47c:	bic.w	r7, r3, #32
    e480:	beq.w	e952 <_svfprintf_r+0x14c2>
    e484:	cmp	r7, #71	; 0x47
    e486:	beq.w	e78e <_svfprintf_r+0x12fe>
    e48a:	ldr	r3, [sp, #68]	; 0x44
    e48c:	ldr	r2, [sp, #12]
    e48e:	cmp	r3, #0
    e490:	orr.w	r2, r2, #256	; 0x100
    e494:	str	r2, [sp, #44]	; 0x2c
    e496:	blt.w	e98a <_svfprintf_r+0x14fa>
    e49a:	vldr	d7, [sp, #64]	; 0x40
    e49e:	vstr	d7, [sp, #96]	; 0x60
    e4a2:	movs	r3, #0
    e4a4:	str	r3, [sp, #16]
    e4a6:	ldr	r3, [sp, #52]	; 0x34
    e4a8:	cmp	r3, #102	; 0x66
    e4aa:	beq.w	e958 <_svfprintf_r+0x14c8>
    e4ae:	cmp	r3, #70	; 0x46
    e4b0:	beq.w	e73e <_svfprintf_r+0x12ae>
    e4b4:	cmp	r7, #69	; 0x45
    e4b6:	ite	eq
    e4b8:	addeq.w	r5, fp, #1
    e4bc:	movne	r5, fp
    e4be:	add	r2, sp, #132	; 0x84
    e4c0:	add	r3, sp, #120	; 0x78
    e4c2:	str	r2, [sp, #4]
    e4c4:	str	r3, [sp, #0]
    e4c6:	mov	r2, r5
    e4c8:	add	r3, sp, #116	; 0x74
    e4ca:	movs	r1, #2
    e4cc:	vldr	d0, [sp, #96]	; 0x60
    e4d0:	ldr	r0, [sp, #24]
    e4d2:	bl	fc98 <_dtoa_r>
    e4d6:	ldr	r3, [sp, #52]	; 0x34
    e4d8:	cmp	r3, #103	; 0x67
    e4da:	mov	r6, r0
    e4dc:	bne.w	e9b6 <_svfprintf_r+0x1526>
    e4e0:	ldr	r3, [sp, #12]
    e4e2:	lsls	r2, r3, #31
    e4e4:	bpl.w	ea5a <_svfprintf_r+0x15ca>
    e4e8:	adds	r4, r6, r5
    e4ea:	movs	r2, #0
    e4ec:	movs	r3, #0
    e4ee:	ldrd	r0, r1, [sp, #96]	; 0x60
    e4f2:	bl	ac88 <__aeabi_dcmpeq>
    e4f6:	cmp	r0, #0
    e4f8:	bne.w	e816 <_svfprintf_r+0x1386>
    e4fc:	ldr	r3, [sp, #132]	; 0x84
    e4fe:	cmp	r4, r3
    e500:	bls.n	e510 <_svfprintf_r+0x1080>
    e502:	movs	r1, #48	; 0x30
    e504:	adds	r2, r3, #1
    e506:	str	r2, [sp, #132]	; 0x84
    e508:	strb	r1, [r3, #0]
    e50a:	ldr	r3, [sp, #132]	; 0x84
    e50c:	cmp	r4, r3
    e50e:	bhi.n	e504 <_svfprintf_r+0x1074>
    e510:	subs	r3, r3, r6
    e512:	cmp	r7, #71	; 0x47
    e514:	str	r3, [sp, #56]	; 0x38
    e516:	beq.w	e808 <_svfprintf_r+0x1378>
    e51a:	ldr	r3, [sp, #52]	; 0x34
    e51c:	cmp	r3, #101	; 0x65
    e51e:	ble.w	e9d4 <_svfprintf_r+0x1544>
    e522:	ldr	r3, [sp, #52]	; 0x34
    e524:	cmp	r3, #102	; 0x66
    e526:	ldr	r3, [sp, #116]	; 0x74
    e528:	str	r3, [sp, #60]	; 0x3c
    e52a:	beq.w	e9ee <_svfprintf_r+0x155e>
    e52e:	ldr	r2, [sp, #60]	; 0x3c
    e530:	ldr	r1, [sp, #56]	; 0x38
    e532:	cmp	r2, r1
    e534:	blt.w	e99c <_svfprintf_r+0x150c>
    e538:	ldr	r3, [sp, #12]
    e53a:	lsls	r1, r3, #31
    e53c:	bmi.w	ea5e <_svfprintf_r+0x15ce>
    e540:	bic.w	r3, r2, r2, asr #31
    e544:	str	r2, [sp, #36]	; 0x24
    e546:	movs	r2, #103	; 0x67
    e548:	str	r2, [sp, #52]	; 0x34
    e54a:	ldr	r2, [sp, #16]
    e54c:	cmp	r2, #0
    e54e:	bne.w	e7b0 <_svfprintf_r+0x1320>
    e552:	str	r3, [sp, #16]
    e554:	ldr	r3, [sp, #44]	; 0x2c
    e556:	str	r3, [sp, #12]
    e558:	mov	fp, r2
    e55a:	ldrb.w	r7, [sp, #111]	; 0x6f
    e55e:	b.w	d834 <_svfprintf_r+0x3a4>
    e562:	bic.w	r7, r7, #7
    e566:	vldr	d7, [r7]
    e56a:	add.w	r3, r7, #8
    e56e:	vstr	d7, [sp, #64]	; 0x40
    e572:	str	r3, [sp, #40]	; 0x28
    e574:	b.w	da8c <_svfprintf_r+0x5fc>
    e578:	ldr	r1, [sp, #40]	; 0x28
    e57a:	strb.w	r3, [sp, #111]	; 0x6f
    e57e:	cmp.w	fp, #0
    e582:	ldr	r4, [r1, #0]
    e584:	add.w	r7, r1, #4
    e588:	mov.w	r5, #0
    e58c:	bge.w	e6e8 <_svfprintf_r+0x1258>
    e590:	str	r7, [sp, #40]	; 0x28
    e592:	movs	r7, #0
    e594:	b.w	d6dc <_svfprintf_r+0x24c>
    e598:	ldr	r1, [sp, #12]
    e59a:	ands.w	r3, r1, #64	; 0x40
    e59e:	beq.w	e23e <_svfprintf_r+0xdae>
    e5a2:	ldr	r0, [sp, #40]	; 0x28
    e5a4:	strb.w	r2, [sp, #111]	; 0x6f
    e5a8:	mov	r3, r0
    e5aa:	cmp.w	fp, #0
    e5ae:	add.w	r3, r3, #4
    e5b2:	ldrh	r4, [r0, #0]
    e5b4:	mov.w	r5, #0
    e5b8:	blt.w	e79a <_svfprintf_r+0x130a>
    e5bc:	bic.w	r1, r1, #128	; 0x80
    e5c0:	str	r1, [sp, #12]
    e5c2:	orrs.w	r1, r4, r5
    e5c6:	str	r3, [sp, #40]	; 0x28
    e5c8:	mov	r7, r2
    e5ca:	bne.w	d7ec <_svfprintf_r+0x35c>
    e5ce:	b.w	dbbc <_svfprintf_r+0x72c>
    e5d2:	ldr	r3, [sp, #12]
    e5d4:	ldr	r2, [sp, #40]	; 0x28
    e5d6:	tst.w	r3, #64	; 0x40
    e5da:	mov	r3, r2
    e5dc:	beq.w	e7a4 <_svfprintf_r+0x1314>
    e5e0:	adds	r3, #4
    e5e2:	ldrh	r4, [r2, #0]
    e5e4:	str	r3, [sp, #40]	; 0x28
    e5e6:	movs	r5, #0
    e5e8:	b.w	dbf6 <_svfprintf_r+0x766>
    e5ec:	mov	r4, r2
    e5ee:	adds	r3, #1
    e5f0:	ldr	r2, [sp, #44]	; 0x2c
    e5f2:	str	r3, [sp, #144]	; 0x90
    e5f4:	add	r4, r5
    e5f6:	cmp	r3, #7
    e5f8:	str	r4, [sp, #148]	; 0x94
    e5fa:	stmia.w	r9, {r2, r5}
    e5fe:	bgt.w	e2b6 <_svfprintf_r+0xe26>
    e602:	add.w	r9, r9, #8
    e606:	b.n	e2cc <_svfprintf_r+0xe3c>
    e608:	.word	0x00013460
    e60c:	movs	r7, #0
    e60e:	cmp	fp, r7
    e610:	strb.w	r7, [sp, #111]	; 0x6f
    e614:	blt.w	de08 <_svfprintf_r+0x978>
    e618:	ldr	r3, [sp, #12]
    e61a:	bic.w	r3, r3, #128	; 0x80
    e61e:	str	r3, [sp, #12]
    e620:	b.w	dda4 <_svfprintf_r+0x914>
    e624:	add	r2, sp, #140	; 0x8c
    e626:	ldr	r1, [sp, #20]
    e628:	ldr	r0, [sp, #24]
    e62a:	bl	12428 <__ssprint_r>
    e62e:	cmp	r0, #0
    e630:	bne.w	d684 <_svfprintf_r+0x1f4>
    e634:	ldr	r4, [sp, #148]	; 0x94
    e636:	add.w	r9, sp, #192	; 0xc0
    e63a:	b.n	de4c <_svfprintf_r+0x9bc>
    e63c:	ldr	r7, [sp, #40]	; 0x28
    e63e:	b.w	ddfa <_svfprintf_r+0x96a>
    e642:	ldr	r3, [sp, #144]	; 0x90
    e644:	ldr	r2, [pc, #736]	; (e928 <_svfprintf_r+0x1498>)
    e646:	str.w	r2, [r9]
    e64a:	adds	r3, #1
    e64c:	adds	r4, #1
    e64e:	movs	r2, #1
    e650:	cmp	r3, #7
    e652:	str	r4, [sp, #148]	; 0x94
    e654:	str	r3, [sp, #144]	; 0x90
    e656:	str.w	r2, [r9, #4]
    e65a:	bgt.w	e774 <_svfprintf_r+0x12e4>
    e65e:	add.w	r9, r9, #8
    e662:	cbnz	r5, e670 <_svfprintf_r+0x11e0>
    e664:	ldr	r3, [sp, #56]	; 0x38
    e666:	cbnz	r3, e670 <_svfprintf_r+0x11e0>
    e668:	ldr	r3, [sp, #12]
    e66a:	lsls	r7, r3, #31
    e66c:	bpl.w	d9bc <_svfprintf_r+0x52c>
    e670:	ldr	r3, [sp, #144]	; 0x90
    e672:	ldr	r1, [sp, #72]	; 0x48
    e674:	ldr	r2, [sp, #76]	; 0x4c
    e676:	str.w	r2, [r9]
    e67a:	adds	r3, #1
    e67c:	add	r4, r1
    e67e:	cmp	r3, #7
    e680:	str	r4, [sp, #148]	; 0x94
    e682:	str.w	r1, [r9, #4]
    e686:	str	r3, [sp, #144]	; 0x90
    e688:	bgt.w	ea26 <_svfprintf_r+0x1596>
    e68c:	add.w	r9, r9, #8
    e690:	negs	r5, r5
    e692:	cmp	r5, #0
    e694:	ble.w	e7ec <_svfprintf_r+0x135c>
    e698:	ldr	r2, [pc, #656]	; (e92c <_svfprintf_r+0x149c>)
    e69a:	str	r2, [sp, #44]	; 0x2c
    e69c:	cmp	r5, #16
    e69e:	ble.w	e834 <_svfprintf_r+0x13a4>
    e6a2:	mov	r2, r4
    e6a4:	movs	r7, #16
    e6a6:	ldr.w	fp, [sp, #24]
    e6aa:	ldr	r4, [sp, #20]
    e6ac:	b.n	e6ba <_svfprintf_r+0x122a>
    e6ae:	add.w	r9, r9, #8
    e6b2:	subs	r5, #16
    e6b4:	cmp	r5, #16
    e6b6:	ble.w	e832 <_svfprintf_r+0x13a2>
    e6ba:	adds	r3, #1
    e6bc:	adds	r2, #16
    e6be:	cmp	r3, #7
    e6c0:	str	r2, [sp, #148]	; 0x94
    e6c2:	str	r3, [sp, #144]	; 0x90
    e6c4:	str.w	sl, [r9]
    e6c8:	str.w	r7, [r9, #4]
    e6cc:	ble.n	e6ae <_svfprintf_r+0x121e>
    e6ce:	add	r2, sp, #140	; 0x8c
    e6d0:	mov	r1, r4
    e6d2:	mov	r0, fp
    e6d4:	bl	12428 <__ssprint_r>
    e6d8:	cmp	r0, #0
    e6da:	bne.w	d684 <_svfprintf_r+0x1f4>
    e6de:	ldr	r2, [sp, #148]	; 0x94
    e6e0:	ldr	r3, [sp, #144]	; 0x90
    e6e2:	add.w	r9, sp, #192	; 0xc0
    e6e6:	b.n	e6b2 <_svfprintf_r+0x1222>
    e6e8:	ldr	r2, [sp, #12]
    e6ea:	b.w	db60 <_svfprintf_r+0x6d0>
    e6ee:	ldr	r2, [sp, #12]
    e6f0:	b.n	e20a <_svfprintf_r+0xd7a>
    e6f2:	ldr	r3, [sp, #12]
    e6f4:	orr.w	r3, r3, #32
    e6f8:	str	r3, [sp, #12]
    e6fa:	add.w	r8, r8, #1
    e6fe:	ldrb.w	r3, [r8]
    e702:	b.w	d544 <_svfprintf_r+0xb4>
    e706:	add	r2, sp, #140	; 0x8c
    e708:	ldr	r1, [sp, #20]
    e70a:	ldr	r0, [sp, #24]
    e70c:	bl	12428 <__ssprint_r>
    e710:	cmp	r0, #0
    e712:	bne.w	d684 <_svfprintf_r+0x1f4>
    e716:	ldr	r4, [sp, #148]	; 0x94
    e718:	add.w	r9, sp, #192	; 0xc0
    e71c:	b.w	de7c <_svfprintf_r+0x9ec>
    e720:	movs	r1, #64	; 0x40
    e722:	ldr	r0, [sp, #24]
    e724:	bl	b4c4 <_malloc_r>
    e728:	ldr	r2, [sp, #20]
    e72a:	str	r0, [r2, #0]
    e72c:	str	r0, [r2, #16]
    e72e:	cmp	r0, #0
    e730:	beq.w	eb1a <_svfprintf_r+0x168a>
    e734:	ldr	r2, [sp, #20]
    e736:	movs	r3, #64	; 0x40
    e738:	str	r3, [r2, #20]
    e73a:	b.w	d4be <_svfprintf_r+0x2e>
    e73e:	add	r2, sp, #132	; 0x84
    e740:	add	r3, sp, #120	; 0x78
    e742:	str	r2, [sp, #4]
    e744:	str	r3, [sp, #0]
    e746:	mov	r2, fp
    e748:	add	r3, sp, #116	; 0x74
    e74a:	movs	r1, #3
    e74c:	vldr	d0, [sp, #96]	; 0x60
    e750:	ldr	r0, [sp, #24]
    e752:	bl	fc98 <_dtoa_r>
    e756:	mov	r5, fp
    e758:	mov	r6, r0
    e75a:	ldr	r3, [sp, #52]	; 0x34
    e75c:	cmp	r3, #70	; 0x46
    e75e:	add.w	r4, r6, r5
    e762:	bne.w	e4ea <_svfprintf_r+0x105a>
    e766:	ldrb	r3, [r6, #0]
    e768:	cmp	r3, #48	; 0x30
    e76a:	beq.w	ea7c <_svfprintf_r+0x15ec>
    e76e:	ldr	r5, [sp, #116]	; 0x74
    e770:	add	r4, r5
    e772:	b.n	e4ea <_svfprintf_r+0x105a>
    e774:	add	r2, sp, #140	; 0x8c
    e776:	ldr	r1, [sp, #20]
    e778:	ldr	r0, [sp, #24]
    e77a:	bl	12428 <__ssprint_r>
    e77e:	cmp	r0, #0
    e780:	bne.w	d684 <_svfprintf_r+0x1f4>
    e784:	ldr	r5, [sp, #116]	; 0x74
    e786:	ldr	r4, [sp, #148]	; 0x94
    e788:	add.w	r9, sp, #192	; 0xc0
    e78c:	b.n	e662 <_svfprintf_r+0x11d2>
    e78e:	cmp.w	fp, #0
    e792:	it	eq
    e794:	moveq.w	fp, #1
    e798:	b.n	e48a <_svfprintf_r+0xffa>
    e79a:	str	r3, [sp, #40]	; 0x28
    e79c:	mov	r7, r2
    e79e:	b.n	e25a <_svfprintf_r+0xdca>
    e7a0:	str	r3, [sp, #40]	; 0x28
    e7a2:	b.n	e592 <_svfprintf_r+0x1102>
    e7a4:	adds	r3, #4
    e7a6:	ldr	r4, [r2, #0]
    e7a8:	str	r3, [sp, #40]	; 0x28
    e7aa:	movs	r5, #0
    e7ac:	b.w	dbf6 <_svfprintf_r+0x766>
    e7b0:	movs	r7, #45	; 0x2d
    e7b2:	str	r3, [sp, #16]
    e7b4:	ldr	r3, [sp, #44]	; 0x2c
    e7b6:	str	r3, [sp, #12]
    e7b8:	strb.w	r7, [sp, #111]	; 0x6f
    e7bc:	mov.w	fp, #0
    e7c0:	b.w	d836 <_svfprintf_r+0x3a6>
    e7c4:	mov	r0, r6
    e7c6:	bl	c280 <strlen>
    e7ca:	mov	fp, r4
    e7cc:	mov	r3, r0
    e7ce:	str	r0, [sp, #36]	; 0x24
    e7d0:	b.w	dd18 <_svfprintf_r+0x888>
    e7d4:	add	r2, sp, #140	; 0x8c
    e7d6:	ldr	r1, [sp, #20]
    e7d8:	ldr	r0, [sp, #24]
    e7da:	bl	12428 <__ssprint_r>
    e7de:	cmp	r0, #0
    e7e0:	bne.w	d684 <_svfprintf_r+0x1f4>
    e7e4:	ldr	r4, [sp, #148]	; 0x94
    e7e6:	ldr	r3, [sp, #144]	; 0x90
    e7e8:	add.w	r9, sp, #192	; 0xc0
    e7ec:	ldr	r1, [sp, #56]	; 0x38
    e7ee:	str.w	r6, [r9]
    e7f2:	adds	r3, #1
    e7f4:	add	r4, r1
    e7f6:	cmp	r3, #7
    e7f8:	str	r4, [sp, #148]	; 0x94
    e7fa:	str	r3, [sp, #144]	; 0x90
    e7fc:	str.w	r1, [r9, #4]
    e800:	ble.w	d9b8 <_svfprintf_r+0x528>
    e804:	b.w	dffe <_svfprintf_r+0xb6e>
    e808:	ldr	r3, [sp, #116]	; 0x74
    e80a:	adds	r5, r3, #3
    e80c:	blt.n	e84c <_svfprintf_r+0x13bc>
    e80e:	cmp	fp, r3
    e810:	blt.n	e84c <_svfprintf_r+0x13bc>
    e812:	str	r3, [sp, #60]	; 0x3c
    e814:	b.n	e52e <_svfprintf_r+0x109e>
    e816:	mov	r3, r4
    e818:	b.n	e510 <_svfprintf_r+0x1080>
    e81a:	add	r2, sp, #140	; 0x8c
    e81c:	ldr	r1, [sp, #20]
    e81e:	ldr	r0, [sp, #24]
    e820:	bl	12428 <__ssprint_r>
    e824:	cmp	r0, #0
    e826:	bne.w	d684 <_svfprintf_r+0x1f4>
    e82a:	ldr	r4, [sp, #148]	; 0x94
    e82c:	add.w	r9, sp, #192	; 0xc0
    e830:	b.n	e0cc <_svfprintf_r+0xc3c>
    e832:	mov	r4, r2
    e834:	adds	r3, #1
    e836:	ldr	r2, [sp, #44]	; 0x2c
    e838:	str	r3, [sp, #144]	; 0x90
    e83a:	add	r4, r5
    e83c:	cmp	r3, #7
    e83e:	str	r4, [sp, #148]	; 0x94
    e840:	stmia.w	r9, {r2, r5}
    e844:	bgt.n	e7d4 <_svfprintf_r+0x1344>
    e846:	add.w	r9, r9, #8
    e84a:	b.n	e7ec <_svfprintf_r+0x135c>
    e84c:	ldr	r2, [sp, #52]	; 0x34
    e84e:	subs	r2, #2
    e850:	str	r2, [sp, #52]	; 0x34
    e852:	subs	r3, #1
    e854:	cmp	r3, #0
    e856:	ldrb.w	r2, [sp, #52]	; 0x34
    e85a:	str	r3, [sp, #116]	; 0x74
    e85c:	it	lt
    e85e:	neglt	r3, r3
    e860:	strb.w	r2, [sp, #124]	; 0x7c
    e864:	ite	lt
    e866:	movlt	r2, #45	; 0x2d
    e868:	movge	r2, #43	; 0x2b
    e86a:	cmp	r3, #9
    e86c:	strb.w	r2, [sp, #125]	; 0x7d
    e870:	ble.w	ea4a <_svfprintf_r+0x15ba>
    e874:	add.w	r0, sp, #139	; 0x8b
    e878:	mov	r4, r0
    e87a:	ldr	r2, [pc, #180]	; (e930 <_svfprintf_r+0x14a0>)
    e87c:	smull	r2, r1, r2, r3
    e880:	asrs	r2, r3, #31
    e882:	rsb	r2, r2, r1, asr #2
    e886:	add.w	r1, r2, r2, lsl #2
    e88a:	sub.w	r3, r3, r1, lsl #1
    e88e:	add.w	r1, r3, #48	; 0x30
    e892:	cmp	r2, #9
    e894:	mov	r3, r2
    e896:	strb.w	r1, [r4, #-1]!
    e89a:	bgt.n	e87a <_svfprintf_r+0x13ea>
    e89c:	mov	r1, r4
    e89e:	adds	r3, #48	; 0x30
    e8a0:	uxtb	r2, r3
    e8a2:	strb.w	r2, [r1, #-1]!
    e8a6:	cmp	r0, r1
    e8a8:	bls.w	eb14 <_svfprintf_r+0x1684>
    e8ac:	add.w	r1, sp, #126	; 0x7e
    e8b0:	mov	r3, r4
    e8b2:	b.n	e8b8 <_svfprintf_r+0x1428>
    e8b4:	ldrb.w	r2, [r3], #1
    e8b8:	strb.w	r2, [r1], #1
    e8bc:	cmp	r0, r3
    e8be:	bne.n	e8b4 <_svfprintf_r+0x1424>
    e8c0:	adds	r3, r0, #1
    e8c2:	subs	r3, r3, r4
    e8c4:	add.w	r2, sp, #126	; 0x7e
    e8c8:	add	r3, r2
    e8ca:	add	r2, sp, #124	; 0x7c
    e8cc:	subs	r3, r3, r2
    e8ce:	ldr	r2, [sp, #56]	; 0x38
    e8d0:	str	r3, [sp, #84]	; 0x54
    e8d2:	cmp	r2, #1
    e8d4:	add	r3, r2
    e8d6:	str	r3, [sp, #36]	; 0x24
    e8d8:	ble.w	eaaa <_svfprintf_r+0x161a>
    e8dc:	ldr	r3, [sp, #36]	; 0x24
    e8de:	ldr	r2, [sp, #72]	; 0x48
    e8e0:	add	r3, r2
    e8e2:	movs	r2, #0
    e8e4:	str	r3, [sp, #36]	; 0x24
    e8e6:	str	r2, [sp, #60]	; 0x3c
    e8e8:	bic.w	r3, r3, r3, asr #31
    e8ec:	b.n	e54a <_svfprintf_r+0x10ba>
    e8ee:	add	r2, sp, #140	; 0x8c
    e8f0:	ldr	r1, [sp, #20]
    e8f2:	ldr	r0, [sp, #24]
    e8f4:	bl	12428 <__ssprint_r>
    e8f8:	cmp	r0, #0
    e8fa:	bne.w	d684 <_svfprintf_r+0x1f4>
    e8fe:	ldr	r3, [sp, #116]	; 0x74
    e900:	ldr	r4, [sp, #148]	; 0x94
    e902:	add.w	r9, sp, #192	; 0xc0
    e906:	b.n	e2e0 <_svfprintf_r+0xe50>
    e908:	add	r2, sp, #140	; 0x8c
    e90a:	ldr	r1, [sp, #20]
    e90c:	ldr	r0, [sp, #24]
    e90e:	bl	12428 <__ssprint_r>
    e912:	cmp	r0, #0
    e914:	bne.w	d684 <_svfprintf_r+0x1f4>
    e918:	ldr	r3, [sp, #116]	; 0x74
    e91a:	ldr	r2, [sp, #56]	; 0x38
    e91c:	ldr	r4, [sp, #148]	; 0x94
    e91e:	subs	r3, r2, r3
    e920:	add.w	r9, sp, #192	; 0xc0
    e924:	b.n	e310 <_svfprintf_r+0xe80>
    e926:	nop
    e928:	.word	0x000134b0
    e92c:	.word	0x00013460
    e930:	.word	0x66666667
    e934:	cmp	r5, #6
    e936:	mov	r3, r5
    e938:	it	cs
    e93a:	movcs	r3, #6
    e93c:	str	r3, [sp, #36]	; 0x24
    e93e:	bic.w	r3, r3, r3, asr #31
    e942:	mov	fp, r6
    e944:	str	r7, [sp, #40]	; 0x28
    e946:	str	r6, [sp, #60]	; 0x3c
    e948:	mov	r7, r6
    e94a:	str	r3, [sp, #16]
    e94c:	ldr	r6, [pc, #536]	; (eb68 <_svfprintf_r+0x16d8>)
    e94e:	b.w	d834 <_svfprintf_r+0x3a4>
    e952:	mov.w	fp, #6
    e956:	b.n	e48a <_svfprintf_r+0xffa>
    e958:	add	r2, sp, #132	; 0x84
    e95a:	add	r3, sp, #120	; 0x78
    e95c:	str	r2, [sp, #4]
    e95e:	str	r3, [sp, #0]
    e960:	mov	r2, fp
    e962:	add	r3, sp, #116	; 0x74
    e964:	movs	r1, #3
    e966:	vldr	d0, [sp, #96]	; 0x60
    e96a:	ldr	r0, [sp, #24]
    e96c:	bl	fc98 <_dtoa_r>
    e970:	mov	r5, fp
    e972:	mov	r6, r0
    e974:	add.w	r4, r0, fp
    e978:	b.n	e766 <_svfprintf_r+0x12d6>
    e97a:	movs	r7, #45	; 0x2d
    e97c:	strb.w	r7, [sp, #111]	; 0x6f
    e980:	b.w	dada <_svfprintf_r+0x64a>
    e984:	str	r3, [sp, #12]
    e986:	b.w	dc32 <_svfprintf_r+0x7a2>
    e98a:	ldrd	r1, r2, [sp, #64]	; 0x40
    e98e:	add.w	r3, r2, #2147483648	; 0x80000000
    e992:	str	r3, [sp, #100]	; 0x64
    e994:	movs	r3, #45	; 0x2d
    e996:	str	r1, [sp, #96]	; 0x60
    e998:	str	r3, [sp, #16]
    e99a:	b.n	e4a6 <_svfprintf_r+0x1016>
    e99c:	ldr	r2, [sp, #72]	; 0x48
    e99e:	ldr	r3, [sp, #56]	; 0x38
    e9a0:	add	r3, r2
    e9a2:	ldr	r2, [sp, #60]	; 0x3c
    e9a4:	str	r3, [sp, #36]	; 0x24
    e9a6:	cmp	r2, #0
    e9a8:	ble.w	eabe <_svfprintf_r+0x162e>
    e9ac:	movs	r2, #103	; 0x67
    e9ae:	bic.w	r3, r3, r3, asr #31
    e9b2:	str	r2, [sp, #52]	; 0x34
    e9b4:	b.n	e54a <_svfprintf_r+0x10ba>
    e9b6:	ldr	r3, [sp, #52]	; 0x34
    e9b8:	cmp	r3, #71	; 0x47
    e9ba:	bne.w	e4e8 <_svfprintf_r+0x1058>
    e9be:	ldr	r3, [sp, #12]
    e9c0:	lsls	r3, r3, #31
    e9c2:	bmi.w	e75a <_svfprintf_r+0x12ca>
    e9c6:	ldr	r3, [sp, #132]	; 0x84
    e9c8:	cmp	r7, #71	; 0x47
    e9ca:	sub.w	r3, r3, r6
    e9ce:	str	r3, [sp, #56]	; 0x38
    e9d0:	beq.w	e808 <_svfprintf_r+0x1378>
    e9d4:	ldr	r3, [sp, #116]	; 0x74
    e9d6:	b.n	e852 <_svfprintf_r+0x13c2>
    e9d8:	bic.w	r3, r5, r5, asr #31
    e9dc:	str	r7, [sp, #40]	; 0x28
    e9de:	str	r3, [sp, #16]
    e9e0:	str	r5, [sp, #36]	; 0x24
    e9e2:	mov	fp, r0
    e9e4:	str	r0, [sp, #60]	; 0x3c
    e9e6:	ldrb.w	r7, [sp, #111]	; 0x6f
    e9ea:	b.w	d834 <_svfprintf_r+0x3a4>
    e9ee:	cmp	r3, #0
    e9f0:	ble.n	eace <_svfprintf_r+0x163e>
    e9f2:	cmp.w	fp, #0
    e9f6:	bne.n	ea98 <_svfprintf_r+0x1608>
    e9f8:	ldr	r2, [sp, #12]
    e9fa:	lsls	r4, r2, #31
    e9fc:	bmi.n	ea98 <_svfprintf_r+0x1608>
    e9fe:	mov	r2, r3
    ea00:	str	r2, [sp, #36]	; 0x24
    ea02:	bic.w	r3, r3, r3, asr #31
    ea06:	b.n	e54a <_svfprintf_r+0x10ba>
    ea08:	ldr	r3, [sp, #12]
    ea0a:	lsls	r3, r3, #31
    ea0c:	mov	r7, fp
    ea0e:	bpl.n	ea1c <_svfprintf_r+0x158c>
    ea10:	add	r6, sp, #256	; 0x100
    ea12:	movs	r3, #48	; 0x30
    ea14:	strb.w	r3, [r6, #-65]!
    ea18:	b.w	d820 <_svfprintf_r+0x390>
    ea1c:	str.w	fp, [sp, #36]	; 0x24
    ea20:	add	r6, sp, #192	; 0xc0
    ea22:	b.w	d826 <_svfprintf_r+0x396>
    ea26:	add	r2, sp, #140	; 0x8c
    ea28:	ldr	r1, [sp, #20]
    ea2a:	ldr	r0, [sp, #24]
    ea2c:	bl	12428 <__ssprint_r>
    ea30:	cmp	r0, #0
    ea32:	bne.w	d684 <_svfprintf_r+0x1f4>
    ea36:	ldr	r5, [sp, #116]	; 0x74
    ea38:	ldr	r4, [sp, #148]	; 0x94
    ea3a:	ldr	r3, [sp, #144]	; 0x90
    ea3c:	add.w	r9, sp, #192	; 0xc0
    ea40:	b.n	e690 <_svfprintf_r+0x1200>
    ea42:	mov	r8, r4
    ea44:	movs	r5, #0
    ea46:	b.w	d548 <_svfprintf_r+0xb8>
    ea4a:	adds	r3, #48	; 0x30
    ea4c:	movs	r2, #48	; 0x30
    ea4e:	strb.w	r3, [sp, #127]	; 0x7f
    ea52:	strb.w	r2, [sp, #126]	; 0x7e
    ea56:	add	r3, sp, #128	; 0x80
    ea58:	b.n	e8ca <_svfprintf_r+0x143a>
    ea5a:	ldr	r3, [sp, #132]	; 0x84
    ea5c:	b.n	e510 <_svfprintf_r+0x1080>
    ea5e:	ldr	r2, [sp, #72]	; 0x48
    ea60:	ldr	r3, [sp, #60]	; 0x3c
    ea62:	add	r3, r2
    ea64:	movs	r2, #103	; 0x67
    ea66:	str	r3, [sp, #36]	; 0x24
    ea68:	str	r2, [sp, #52]	; 0x34
    ea6a:	bic.w	r3, r3, r3, asr #31
    ea6e:	b.n	e54a <_svfprintf_r+0x10ba>
    ea70:	ldr	r6, [pc, #248]	; (eb6c <_svfprintf_r+0x16dc>)
    ea72:	ldr	r3, [pc, #252]	; (eb70 <_svfprintf_r+0x16e0>)
    ea74:	ldrb.w	r7, [sp, #111]	; 0x6f
    ea78:	b.w	dade <_svfprintf_r+0x64e>
    ea7c:	movs	r2, #0
    ea7e:	movs	r3, #0
    ea80:	ldrd	r0, r1, [sp, #96]	; 0x60
    ea84:	bl	ac88 <__aeabi_dcmpeq>
    ea88:	cmp	r0, #0
    ea8a:	bne.w	e76e <_svfprintf_r+0x12de>
    ea8e:	rsb	r5, r5, #1
    ea92:	str	r5, [sp, #116]	; 0x74
    ea94:	add	r4, r5
    ea96:	b.n	e4ea <_svfprintf_r+0x105a>
    ea98:	ldr	r3, [sp, #60]	; 0x3c
    ea9a:	ldr	r2, [sp, #72]	; 0x48
    ea9c:	adds	r5, r3, r2
    ea9e:	add.w	r3, r5, fp
    eaa2:	str	r3, [sp, #36]	; 0x24
    eaa4:	bic.w	r3, r3, r3, asr #31
    eaa8:	b.n	e54a <_svfprintf_r+0x10ba>
    eaaa:	ldr	r3, [sp, #12]
    eaac:	ands.w	r3, r3, #1
    eab0:	bne.w	e8dc <_svfprintf_r+0x144c>
    eab4:	str	r3, [sp, #60]	; 0x3c
    eab6:	ldr	r3, [sp, #36]	; 0x24
    eab8:	bic.w	r3, r3, r3, asr #31
    eabc:	b.n	e54a <_svfprintf_r+0x10ba>
    eabe:	ldr	r3, [sp, #60]	; 0x3c
    eac0:	ldr	r2, [sp, #36]	; 0x24
    eac2:	rsb	r3, r3, #1
    eac6:	add	r2, r3
    eac8:	mov	r3, r2
    eaca:	str	r2, [sp, #36]	; 0x24
    eacc:	b.n	e9ac <_svfprintf_r+0x151c>
    eace:	cmp.w	fp, #0
    ead2:	bne.n	eada <_svfprintf_r+0x164a>
    ead4:	ldr	r3, [sp, #12]
    ead6:	lsls	r0, r3, #31
    ead8:	bpl.n	eaea <_svfprintf_r+0x165a>
    eada:	ldr	r3, [sp, #72]	; 0x48
    eadc:	adds	r5, r3, #1
    eade:	add.w	r3, r5, fp
    eae2:	str	r3, [sp, #36]	; 0x24
    eae4:	bic.w	r3, r3, r3, asr #31
    eae8:	b.n	e54a <_svfprintf_r+0x10ba>
    eaea:	movs	r3, #1
    eaec:	str	r3, [sp, #36]	; 0x24
    eaee:	b.n	e54a <_svfprintf_r+0x10ba>
    eaf0:	ldr	r0, [sp, #40]	; 0x28
    eaf2:	ldrb.w	r3, [r8, #1]
    eaf6:	ldr	r5, [r0, #0]
    eaf8:	adds	r0, #4
    eafa:	cmp	r5, #0
    eafc:	str	r0, [sp, #40]	; 0x28
    eafe:	mov	r8, r4
    eb00:	bge.w	d544 <_svfprintf_r+0xb4>
    eb04:	mov.w	r5, #4294967295
    eb08:	b.w	d544 <_svfprintf_r+0xb4>
    eb0c:	strb.w	r1, [sp, #111]	; 0x6f
    eb10:	b.w	d6a6 <_svfprintf_r+0x216>
    eb14:	add.w	r3, sp, #126	; 0x7e
    eb18:	b.n	e8ca <_svfprintf_r+0x143a>
    eb1a:	ldr	r2, [sp, #24]
    eb1c:	movs	r3, #12
    eb1e:	str	r3, [r2, #0]
    eb20:	mov.w	r0, #4294967295
    eb24:	b.w	d696 <_svfprintf_r+0x206>
    eb28:	strb.w	r1, [sp, #111]	; 0x6f
    eb2c:	b.w	d7a0 <_svfprintf_r+0x310>
    eb30:	strb.w	r1, [sp, #111]	; 0x6f
    eb34:	b.w	da6c <_svfprintf_r+0x5dc>
    eb38:	strb.w	r1, [sp, #111]	; 0x6f
    eb3c:	b.w	dbda <_svfprintf_r+0x74a>
    eb40:	strb.w	r1, [sp, #111]	; 0x6f
    eb44:	b.w	db7e <_svfprintf_r+0x6ee>
    eb48:	strb.w	r1, [sp, #111]	; 0x6f
    eb4c:	b.w	db2a <_svfprintf_r+0x69a>
    eb50:	strb.w	r1, [sp, #111]	; 0x6f
    eb54:	b.w	ddc2 <_svfprintf_r+0x932>
    eb58:	strb.w	r1, [sp, #111]	; 0x6f
    eb5c:	b.w	dd80 <_svfprintf_r+0x8f0>
    eb60:	strb.w	r1, [sp, #111]	; 0x6f
    eb64:	b.w	dd44 <_svfprintf_r+0x8b4>
    eb68:	.word	0x000134a8
    eb6c:	.word	0x0001347c
    eb70:	.word	0x00013478

0000eb74 <__ssvfscanf_r>:
    eb74:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eb78:	mov	fp, r1
    eb7a:	ldrsh.w	r1, [r1, #12]
    eb7e:	sub.w	sp, sp, #692	; 0x2b4
    eb82:	mov	sl, r0
    eb84:	lsls	r0, r1, #18
    eb86:	mov	r4, r2
    eb88:	str	r3, [sp, #20]
    eb8a:	bmi.n	eba0 <__ssvfscanf_r+0x2c>
    eb8c:	ldr.w	r3, [fp, #100]	; 0x64
    eb90:	orr.w	r1, r1, #8192	; 0x2000
    eb94:	bic.w	r3, r3, #8192	; 0x2000
    eb98:	strh.w	r1, [fp, #12]
    eb9c:	str.w	r3, [fp, #100]	; 0x64
    eba0:	mov	r6, r4
    eba2:	movs	r3, #0
    eba4:	str	r3, [sp, #28]
    eba6:	str	r3, [sp, #16]
    eba8:	mov	r7, r3
    ebaa:	str	r3, [sp, #24]
    ebac:	ldrb.w	r3, [r6], #1
    ebb0:	str	r3, [sp, #68]	; 0x44
    ebb2:	cbz	r3, ec10 <__ssvfscanf_r+0x9c>
    ebb4:	bl	b490 <__locale_ctype_ptr>
    ebb8:	ldr	r2, [sp, #68]	; 0x44
    ebba:	add	r0, r2
    ebbc:	ldrb	r3, [r0, #1]
    ebbe:	and.w	r3, r3, #8
    ebc2:	and.w	r5, r3, #255	; 0xff
    ebc6:	cbz	r3, ec1a <__ssvfscanf_r+0xa6>
    ebc8:	ldr.w	r3, [fp, #4]
    ebcc:	b.n	ebf2 <__ssvfscanf_r+0x7e>
    ebce:	bl	b490 <__locale_ctype_ptr>
    ebd2:	ldr.w	r3, [fp]
    ebd6:	ldrb	r2, [r3, #0]
    ebd8:	add	r0, r2
    ebda:	adds	r3, #1
    ebdc:	ldrb	r2, [r0, #1]
    ebde:	lsls	r1, r2, #28
    ebe0:	bpl.n	ec02 <__ssvfscanf_r+0x8e>
    ebe2:	ldr.w	r2, [fp, #4]
    ebe6:	str.w	r3, [fp]
    ebea:	subs	r3, r2, #1
    ebec:	adds	r7, #1
    ebee:	str.w	r3, [fp, #4]
    ebf2:	cmp	r3, #0
    ebf4:	bgt.n	ebce <__ssvfscanf_r+0x5a>
    ebf6:	mov	r1, fp
    ebf8:	mov	r0, sl
    ebfa:	bl	125ac <__ssrefill_r>
    ebfe:	cmp	r0, #0
    ec00:	beq.n	ebce <__ssvfscanf_r+0x5a>
    ec02:	mov	r4, r6
    ec04:	mov	r6, r4
    ec06:	ldrb.w	r3, [r6], #1
    ec0a:	str	r3, [sp, #68]	; 0x44
    ec0c:	cmp	r3, #0
    ec0e:	bne.n	ebb4 <__ssvfscanf_r+0x40>
    ec10:	ldr	r0, [sp, #24]
    ec12:	add.w	sp, sp, #692	; 0x2b4
    ec16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ec1a:	cmp	r2, #37	; 0x25
    ec1c:	bne.w	ed28 <__ssvfscanf_r+0x1b4>
    ec20:	ldrb.w	r8, [r4, #1]
    ec24:	mov	r4, r5
    ec26:	adds	r3, r6, #1
    ec28:	cmp.w	r8, #120	; 0x78
    ec2c:	bhi.w	f0b6 <__ssvfscanf_r+0x542>
    ec30:	tbh	[pc, r8, lsl #1]
    ec34:	.word	0x02410092
    ec38:	.word	0x02410241
    ec3c:	.word	0x02410241
    ec40:	.word	0x02410241
    ec44:	.word	0x02410241
    ec48:	.word	0x02410241
    ec4c:	.word	0x02410241
    ec50:	.word	0x02410241
    ec54:	.word	0x02410241
    ec58:	.word	0x02410241
    ec5c:	.word	0x02410241
    ec60:	.word	0x02410241
    ec64:	.word	0x02410241
    ec68:	.word	0x02410241
    ec6c:	.word	0x02410241
    ec70:	.word	0x02410241
    ec74:	.word	0x02410241
    ec78:	.word	0x02410241
    ec7c:	.word	0x00790241
    ec80:	.word	0x02410241
    ec84:	.word	0x02410241
    ec88:	.word	0x024101d8
    ec8c:	.word	0x02410241
    ec90:	.word	0x02410241
    ec94:	.word	0x01cf01cf
    ec98:	.word	0x01cf01cf
    ec9c:	.word	0x01cf01cf
    eca0:	.word	0x01cf01cf
    eca4:	.word	0x01cf01cf
    eca8:	.word	0x02410241
    ecac:	.word	0x02410241
    ecb0:	.word	0x02410241
    ecb4:	.word	0x02410241
    ecb8:	.word	0x02410241
    ecbc:	.word	0x01b901c1
    ecc0:	.word	0x01b90241
    ecc4:	.word	0x02410241
    ecc8:	.word	0x02410241
    eccc:	.word	0x024101b3
    ecd0:	.word	0x01a30241
    ecd4:	.word	0x02410241
    ecd8:	.word	0x02410241
    ecdc:	.word	0x02410241
    ece0:	.word	0x02410241
    ece4:	.word	0x02410193
    ece8:	.word	0x01510241
    ecec:	.word	0x02410241
    ecf0:	.word	0x02410241
    ecf4:	.word	0x02410241
    ecf8:	.word	0x01220241
    ecfc:	.word	0x01b90188
    ed00:	.word	0x01b901b9
    ed04:	.word	0x0098011c
    ed08:	.word	0x02410241
    ed0c:	.word	0x024100d5
    ed10:	.word	0x0101010d
    ed14:	.word	0x024100f3
    ed18:	.word	0x00eb0241
    ed1c:	.word	0x00df0241
    ed20:	.word	0x02410241
    ed24:	.short	0x0193
    ed26:	mov	r6, r3
    ed28:	ldr.w	r3, [fp, #4]
    ed2c:	cmp	r3, #0
    ed2e:	ble.w	f1d8 <__ssvfscanf_r+0x664>
    ed32:	ldr.w	r3, [fp]
    ed36:	ldrb.w	r2, [r6, #-1]
    ed3a:	ldrb	r1, [r3, #0]
    ed3c:	cmp	r1, r2
    ed3e:	bne.w	ec10 <__ssvfscanf_r+0x9c>
    ed42:	ldr.w	r2, [fp, #4]
    ed46:	adds	r3, #1
    ed48:	subs	r2, #1
    ed4a:	str.w	r3, [fp]
    ed4e:	adds	r7, #1
    ed50:	str.w	r2, [fp, #4]
    ed54:	mov	r4, r6
    ed56:	b.n	ec04 <__ssvfscanf_r+0x90>
    ed58:	mov.w	r0, #4294967295
    ed5c:	add.w	sp, sp, #692	; 0x2b4
    ed60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ed64:	str	r3, [sp, #12]
    ed66:	ldr.w	r3, [fp, #4]
    ed6a:	cmp	r3, #0
    ed6c:	ble.w	f236 <__ssvfscanf_r+0x6c2>
    ed70:	ldr	r3, [pc, #736]	; (f054 <__ssvfscanf_r+0x4e0>)
    ed72:	str	r3, [sp, #28]
    ed74:	movs	r3, #0
    ed76:	str	r3, [sp, #16]
    ed78:	movs	r6, #3
    ed7a:	b.n	ed80 <__ssvfscanf_r+0x20c>
    ed7c:	str.w	lr, [fp]
    ed80:	bl	b490 <__locale_ctype_ptr>
    ed84:	ldr.w	r2, [fp]
    ed88:	ldrb	r1, [r2, #0]
    ed8a:	add	r0, r1
    ed8c:	add.w	lr, r2, #1
    ed90:	ldrb	r3, [r0, #1]
    ed92:	and.w	r3, r3, #8
    ed96:	and.w	r8, r3, #255	; 0xff
    ed9a:	cmp	r3, #0
    ed9c:	beq.w	f29e <__ssvfscanf_r+0x72a>
    eda0:	ldr.w	r3, [fp, #4]
    eda4:	subs	r3, #1
    eda6:	cmp	r3, #0
    eda8:	add.w	r7, r7, #1
    edac:	str.w	r3, [fp, #4]
    edb0:	bgt.n	ed7c <__ssvfscanf_r+0x208>
    edb2:	mov	r1, fp
    edb4:	mov	r0, sl
    edb6:	bl	125ac <__ssrefill_r>
    edba:	cmp	r0, #0
    edbc:	beq.n	ed80 <__ssvfscanf_r+0x20c>
    edbe:	ldr	r2, [sp, #24]
    edc0:	cmp	r2, #0
    edc2:	beq.n	ed58 <__ssvfscanf_r+0x1e4>
    edc4:	ldrh.w	r3, [fp, #12]
    edc8:	tst.w	r3, #64	; 0x40
    edcc:	mov	r3, r2
    edce:	it	ne
    edd0:	movne.w	r3, #4294967295
    edd4:	mov	r0, r3
    edd6:	add.w	sp, sp, #692	; 0x2b4
    edda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    edde:	ldrb.w	r8, [r6, #1]
    ede2:	cmp.w	r8, #108	; 0x6c
    ede6:	beq.w	f1ee <__ssvfscanf_r+0x67a>
    edea:	orr.w	r5, r5, #1
    edee:	mov	r6, r3
    edf0:	b.n	ec26 <__ssvfscanf_r+0xb2>
    edf2:	str	r3, [sp, #12]
    edf4:	ldr.w	r3, [fp, #4]
    edf8:	cmp	r3, #0
    edfa:	ble.w	f28e <__ssvfscanf_r+0x71a>
    edfe:	ldr	r3, [pc, #600]	; (f058 <__ssvfscanf_r+0x4e4>)
    ee00:	str	r3, [sp, #28]
    ee02:	movs	r3, #10
    ee04:	str	r3, [sp, #16]
    ee06:	movs	r6, #3
    ee08:	b.n	ed80 <__ssvfscanf_r+0x20c>
    ee0a:	str	r3, [sp, #12]
    ee0c:	ldr.w	r3, [fp, #4]
    ee10:	cmp	r3, #0
    ee12:	ble.w	f27e <__ssvfscanf_r+0x70a>
    ee16:	movs	r6, #2
    ee18:	b.n	ed80 <__ssvfscanf_r+0x20c>
    ee1a:	str	r3, [sp, #12]
    ee1c:	ldr.w	r3, [fp, #4]
    ee20:	cmp	r3, #0
    ee22:	orr.w	r5, r5, #544	; 0x220
    ee26:	ble.w	ef6a <__ssvfscanf_r+0x3f6>
    ee2a:	ldr	r3, [pc, #556]	; (f058 <__ssvfscanf_r+0x4e4>)
    ee2c:	str	r3, [sp, #28]
    ee2e:	movs	r3, #16
    ee30:	str	r3, [sp, #16]
    ee32:	movs	r6, #3
    ee34:	b.n	ed80 <__ssvfscanf_r+0x20c>
    ee36:	str	r3, [sp, #12]
    ee38:	ldr.w	r3, [fp, #4]
    ee3c:	cmp	r3, #0
    ee3e:	ble.w	ef8a <__ssvfscanf_r+0x416>
    ee42:	ldr	r3, [pc, #532]	; (f058 <__ssvfscanf_r+0x4e4>)
    ee44:	str	r3, [sp, #28]
    ee46:	movs	r3, #8
    ee48:	str	r3, [sp, #16]
    ee4a:	movs	r6, #3
    ee4c:	b.n	ed80 <__ssvfscanf_r+0x20c>
    ee4e:	lsls	r2, r5, #27
    ee50:	mov	r6, r3
    ee52:	str	r3, [sp, #12]
    ee54:	bmi.w	f03c <__ssvfscanf_r+0x4c8>
    ee58:	lsls	r3, r5, #29
    ee5a:	bpl.w	f206 <__ssvfscanf_r+0x692>
    ee5e:	ldr	r1, [sp, #20]
    ee60:	ldr	r3, [r1, #0]
    ee62:	strh	r7, [r3, #0]
    ee64:	adds	r3, r1, #4
    ee66:	str	r3, [sp, #20]
    ee68:	mov	r4, r6
    ee6a:	b.n	ec04 <__ssvfscanf_r+0x90>
    ee6c:	ldrb.w	r8, [r6, #1]
    ee70:	orr.w	r5, r5, #4
    ee74:	mov	r6, r3
    ee76:	b.n	ec26 <__ssvfscanf_r+0xb2>
    ee78:	str	r3, [sp, #12]
    ee7a:	ldr.w	r3, [fp, #4]
    ee7e:	cmp	r3, #0
    ee80:	ble.w	f25e <__ssvfscanf_r+0x6ea>
    ee84:	cmp	r4, #0
    ee86:	it	eq
    ee88:	moveq	r4, #1
    ee8a:	ands.w	r3, r5, #1
    ee8e:	bne.w	f0d6 <__ssvfscanf_r+0x562>
    ee92:	lsls	r2, r5, #27
    ee94:	bpl.w	f1ae <__ssvfscanf_r+0x63a>
    ee98:	mov	r5, r3
    ee9a:	b.n	eeb0 <__ssvfscanf_r+0x33c>
    ee9c:	add	r3, r2
    ee9e:	str.w	r3, [fp]
    eea2:	add	r5, r2
    eea4:	subs	r4, r4, r2
    eea6:	bl	125ac <__ssrefill_r>
    eeaa:	cmp	r0, #0
    eeac:	bne.w	f1a6 <__ssvfscanf_r+0x632>
    eeb0:	ldr.w	r2, [fp, #4]
    eeb4:	ldr.w	r3, [fp]
    eeb8:	cmp	r2, r4
    eeba:	mov	r1, fp
    eebc:	mov	r0, sl
    eebe:	blt.n	ee9c <__ssvfscanf_r+0x328>
    eec0:	subs	r2, r2, r4
    eec2:	add	r3, r4
    eec4:	str.w	r2, [fp, #4]
    eec8:	add	r5, r4
    eeca:	str.w	r3, [fp]
    eece:	ldr	r6, [sp, #12]
    eed0:	add	r7, r5
    eed2:	mov	r4, r6
    eed4:	b.n	ec04 <__ssvfscanf_r+0x90>
    eed6:	add.w	r9, sp, #80	; 0x50
    eeda:	mov	r1, r3
    eedc:	mov	r0, r9
    eede:	bl	11e48 <__sccl>
    eee2:	ldr.w	r3, [fp, #4]
    eee6:	cmp	r3, #0
    eee8:	mov	r6, r0
    eeea:	ble.w	f24e <__ssvfscanf_r+0x6da>
    eeee:	cmp	r4, #0
    eef0:	ldr.w	r2, [fp]
    eef4:	it	eq
    eef6:	moveq.w	r4, #4294967295
    eefa:	lsls	r3, r5, #27
    eefc:	ldrb	r1, [r2, #0]
    eefe:	bpl.w	f042 <__ssvfscanf_r+0x4ce>
    ef02:	mov	r8, r4
    ef04:	movs	r5, #0
    ef06:	b.n	ef0a <__ssvfscanf_r+0x396>
    ef08:	ldrb	r1, [r2, #0]
    ef0a:	ldrb.w	r3, [r9, r1]
    ef0e:	adds	r2, #1
    ef10:	cmp	r3, #0
    ef12:	beq.w	f19c <__ssvfscanf_r+0x628>
    ef16:	ldr.w	r3, [fp, #4]
    ef1a:	str.w	r2, [fp]
    ef1e:	adds	r5, #1
    ef20:	subs	r3, #1
    ef22:	cmp	r5, r4
    ef24:	str.w	r3, [fp, #4]
    ef28:	beq.w	f196 <__ssvfscanf_r+0x622>
    ef2c:	cmp	r3, #0
    ef2e:	bgt.n	ef08 <__ssvfscanf_r+0x394>
    ef30:	mov	r1, fp
    ef32:	mov	r0, sl
    ef34:	bl	125ac <__ssrefill_r>
    ef38:	cmp	r0, #0
    ef3a:	bne.w	f194 <__ssvfscanf_r+0x620>
    ef3e:	ldr.w	r2, [fp]
    ef42:	b.n	ef08 <__ssvfscanf_r+0x394>
    ef44:	str	r3, [sp, #12]
    ef46:	ldr.w	r3, [fp, #4]
    ef4a:	cmp	r3, #0
    ef4c:	ble.n	efc4 <__ssvfscanf_r+0x450>
    ef4e:	ldr	r3, [pc, #260]	; (f054 <__ssvfscanf_r+0x4e0>)
    ef50:	str	r3, [sp, #28]
    ef52:	movs	r3, #10
    ef54:	str	r3, [sp, #16]
    ef56:	movs	r6, #3
    ef58:	b.n	ed80 <__ssvfscanf_r+0x20c>
    ef5a:	str	r3, [sp, #12]
    ef5c:	ldr.w	r3, [fp, #4]
    ef60:	cmp	r3, #0
    ef62:	orr.w	r5, r5, #512	; 0x200
    ef66:	bgt.w	ee2a <__ssvfscanf_r+0x2b6>
    ef6a:	mov	r1, fp
    ef6c:	mov	r0, sl
    ef6e:	bl	125ac <__ssrefill_r>
    ef72:	cmp	r0, #0
    ef74:	beq.w	ee2a <__ssvfscanf_r+0x2b6>
    ef78:	b.n	edbe <__ssvfscanf_r+0x24a>
    ef7a:	str	r3, [sp, #12]
    ef7c:	ldr.w	r3, [fp, #4]
    ef80:	cmp	r3, #0
    ef82:	orr.w	r5, r5, #1
    ef86:	bgt.w	ee42 <__ssvfscanf_r+0x2ce>
    ef8a:	mov	r1, fp
    ef8c:	mov	r0, sl
    ef8e:	bl	125ac <__ssrefill_r>
    ef92:	cmp	r0, #0
    ef94:	beq.w	ee42 <__ssvfscanf_r+0x2ce>
    ef98:	b.n	edbe <__ssvfscanf_r+0x24a>
    ef9a:	ldrb.w	r8, [r6, #1]
    ef9e:	orr.w	r5, r5, #2
    efa2:	mov	r6, r3
    efa4:	b.n	ec26 <__ssvfscanf_r+0xb2>
    efa6:	str	r3, [sp, #12]
    efa8:	ldr.w	r3, [fp, #4]
    efac:	cmp	r3, #0
    efae:	ble.w	f26e <__ssvfscanf_r+0x6fa>
    efb2:	movs	r6, #4
    efb4:	b.n	ed80 <__ssvfscanf_r+0x20c>
    efb6:	str	r3, [sp, #12]
    efb8:	ldr.w	r3, [fp, #4]
    efbc:	cmp	r3, #0
    efbe:	orr.w	r5, r5, #1
    efc2:	bgt.n	ef4e <__ssvfscanf_r+0x3da>
    efc4:	mov	r1, fp
    efc6:	mov	r0, sl
    efc8:	bl	125ac <__ssrefill_r>
    efcc:	cmp	r0, #0
    efce:	beq.n	ef4e <__ssvfscanf_r+0x3da>
    efd0:	b.n	edbe <__ssvfscanf_r+0x24a>
    efd2:	add.w	r4, r4, r4, lsl #2
    efd6:	add.w	r4, r8, r4, lsl #1
    efda:	subs	r4, #48	; 0x30
    efdc:	ldrb.w	r8, [r6, #1]
    efe0:	mov	r6, r3
    efe2:	b.n	ec26 <__ssvfscanf_r+0xb2>
    efe4:	ldrb.w	r8, [r6, #1]
    efe8:	orr.w	r5, r5, #16
    efec:	mov	r6, r3
    efee:	b.n	ec26 <__ssvfscanf_r+0xb2>
    eff0:	add	r3, sp, #72	; 0x48
    eff2:	mov	r1, r8
    eff4:	mov	r0, r3
    eff6:	movs	r2, #8
    eff8:	str	r3, [sp, #32]
    effa:	bl	8cf4 <memset>
    effe:	ands.w	r9, r5, #16
    f002:	bne.w	f8c8 <__ssvfscanf_r+0xd54>
    f006:	ldr	r2, [sp, #20]
    f008:	mov	r3, r2
    f00a:	adds	r3, #4
    f00c:	ldr.w	r8, [r2]
    f010:	str	r3, [sp, #20]
    f012:	movs	r6, #0
    f014:	bl	b490 <__locale_ctype_ptr>
    f018:	ldr.w	r3, [fp]
    f01c:	ldrb	r3, [r3, #0]
    f01e:	add	r0, r3
    f020:	ldrb	r3, [r0, #1]
    f022:	lsls	r0, r3, #28
    f024:	bmi.n	f02c <__ssvfscanf_r+0x4b8>
    f026:	cmp	r4, #0
    f028:	bne.w	f82c <__ssvfscanf_r+0xcb8>
    f02c:	cmp.w	r9, #0
    f030:	bne.n	f03c <__ssvfscanf_r+0x4c8>
    f032:	str.w	r9, [r8]
    f036:	ldr	r3, [sp, #24]
    f038:	adds	r3, #1
    f03a:	str	r3, [sp, #24]
    f03c:	ldr	r6, [sp, #12]
    f03e:	mov	r4, r6
    f040:	b.n	ec04 <__ssvfscanf_r+0x90>
    f042:	ldr	r0, [sp, #20]
    f044:	ldr	r5, [r0, #0]
    f046:	mov	r3, r0
    f048:	adds	r3, #4
    f04a:	add.w	r8, r5, r4
    f04e:	str	r3, [sp, #12]
    f050:	mov	r4, r5
    f052:	b.n	f062 <__ssvfscanf_r+0x4ee>
    f054:	.word	0x0000d469
    f058:	.word	0x000121f5
    f05c:	ldr.w	r2, [fp]
    f060:	ldrb	r1, [r2, #0]
    f062:	ldrb.w	r3, [r9, r1]
    f066:	adds	r0, r2, #1
    f068:	cbz	r3, f09c <__ssvfscanf_r+0x528>
    f06a:	ldr.w	r3, [fp, #4]
    f06e:	str.w	r0, [fp]
    f072:	subs	r3, #1
    f074:	str.w	r3, [fp, #4]
    f078:	ldrb	r3, [r2, #0]
    f07a:	strb.w	r3, [r4], #1
    f07e:	cmp	r8, r4
    f080:	beq.n	f09c <__ssvfscanf_r+0x528>
    f082:	ldr.w	r3, [fp, #4]
    f086:	cmp	r3, #0
    f088:	bgt.n	f05c <__ssvfscanf_r+0x4e8>
    f08a:	mov	r1, fp
    f08c:	mov	r0, sl
    f08e:	bl	125ac <__ssrefill_r>
    f092:	cmp	r0, #0
    f094:	beq.n	f05c <__ssvfscanf_r+0x4e8>
    f096:	cmp	r5, r4
    f098:	beq.w	edbe <__ssvfscanf_r+0x24a>
    f09c:	subs	r5, r4, r5
    f09e:	beq.w	ec10 <__ssvfscanf_r+0x9c>
    f0a2:	ldr	r2, [sp, #24]
    f0a4:	adds	r2, #1
    f0a6:	movs	r3, #0
    f0a8:	str	r2, [sp, #24]
    f0aa:	ldr	r2, [sp, #12]
    f0ac:	str	r2, [sp, #20]
    f0ae:	strb	r3, [r4, #0]
    f0b0:	add	r7, r5
    f0b2:	mov	r4, r6
    f0b4:	b.n	ec04 <__ssvfscanf_r+0x90>
    f0b6:	str	r3, [sp, #12]
    f0b8:	bl	b490 <__locale_ctype_ptr>
    f0bc:	add	r0, r8
    f0be:	ldrb	r3, [r0, #1]
    f0c0:	and.w	r3, r3, #3
    f0c4:	cmp	r3, #1
    f0c6:	ldr.w	r3, [fp, #4]
    f0ca:	beq.w	f1fa <__ssvfscanf_r+0x686>
    f0ce:	cmp	r3, #0
    f0d0:	bgt.w	ef4e <__ssvfscanf_r+0x3da>
    f0d4:	b.n	efc4 <__ssvfscanf_r+0x450>
    f0d6:	add	r3, sp, #72	; 0x48
    f0d8:	mov	r0, r3
    f0da:	movs	r2, #8
    f0dc:	movs	r1, #0
    f0de:	str	r3, [sp, #32]
    f0e0:	bl	8cf4 <memset>
    f0e4:	ands.w	r3, r5, #16
    f0e8:	str	r3, [sp, #40]	; 0x28
    f0ea:	bne.n	f1e8 <__ssvfscanf_r+0x674>
    f0ec:	ldr	r2, [sp, #20]
    f0ee:	mov	r3, r2
    f0f0:	adds	r3, #4
    f0f2:	ldr.w	r9, [r2]
    f0f6:	str	r3, [sp, #20]
    f0f8:	movs	r5, #0
    f0fa:	add.w	r8, sp, #336	; 0x150
    f0fe:	bl	b46c <__locale_mb_cur_max>
    f102:	cmp	r0, r5
    f104:	beq.w	edbe <__ssvfscanf_r+0x24a>
    f108:	ldmia.w	fp, {r2, r3}
    f10c:	ldrb.w	r0, [r2], #1
    f110:	str.w	r2, [fp]
    f114:	subs	r3, #1
    f116:	ldr	r2, [sp, #32]
    f118:	str	r2, [sp, #0]
    f11a:	adds	r6, r5, #1
    f11c:	str.w	r3, [fp, #4]
    f120:	mov	r1, r9
    f122:	strb.w	r0, [r8, r5]
    f126:	mov	r3, r6
    f128:	mov	r2, r8
    f12a:	mov	r0, sl
    f12c:	bl	11504 <_mbrtowc_r>
    f130:	adds	r1, r0, #1
    f132:	beq.w	edbe <__ssvfscanf_r+0x24a>
    f136:	cbnz	r0, f162 <__ssvfscanf_r+0x5ee>
    f138:	ldr	r3, [sp, #40]	; 0x28
    f13a:	cbnz	r3, f182 <__ssvfscanf_r+0x60e>
    f13c:	str.w	r3, [r9]
    f140:	add	r7, r6
    f142:	subs	r4, #1
    f144:	add.w	r9, r9, #4
    f148:	ldr.w	r3, [fp, #4]
    f14c:	cmp	r3, #0
    f14e:	mov.w	r5, #0
    f152:	ble.n	f170 <__ssvfscanf_r+0x5fc>
    f154:	cmp	r4, #0
    f156:	bne.n	f0fe <__ssvfscanf_r+0x58a>
    f158:	ldr	r3, [sp, #40]	; 0x28
    f15a:	cmp	r3, #0
    f15c:	beq.w	f036 <__ssvfscanf_r+0x4c2>
    f160:	b.n	f03c <__ssvfscanf_r+0x4c8>
    f162:	adds	r0, #2
    f164:	bne.n	f188 <__ssvfscanf_r+0x614>
    f166:	ldr.w	r3, [fp, #4]
    f16a:	cmp	r3, #0
    f16c:	mov	r5, r6
    f16e:	bgt.n	f0fe <__ssvfscanf_r+0x58a>
    f170:	mov	r1, fp
    f172:	mov	r0, sl
    f174:	bl	125ac <__ssrefill_r>
    f178:	cmp	r0, #0
    f17a:	beq.n	f154 <__ssvfscanf_r+0x5e0>
    f17c:	cmp	r5, #0
    f17e:	beq.n	f158 <__ssvfscanf_r+0x5e4>
    f180:	b.n	edbe <__ssvfscanf_r+0x24a>
    f182:	add	r7, r6
    f184:	subs	r4, #1
    f186:	b.n	f148 <__ssvfscanf_r+0x5d4>
    f188:	ldr	r3, [sp, #40]	; 0x28
    f18a:	add	r7, r6
    f18c:	subs	r4, #1
    f18e:	cmp	r3, #0
    f190:	bne.n	f148 <__ssvfscanf_r+0x5d4>
    f192:	b.n	f144 <__ssvfscanf_r+0x5d0>
    f194:	mov	r8, r5
    f196:	mov	r5, r8
    f198:	add	r7, r5
    f19a:	b.n	f0b2 <__ssvfscanf_r+0x53e>
    f19c:	cmp	r5, #0
    f19e:	beq.w	ec10 <__ssvfscanf_r+0x9c>
    f1a2:	add	r7, r5
    f1a4:	b.n	f0b2 <__ssvfscanf_r+0x53e>
    f1a6:	cmp	r5, #0
    f1a8:	bne.w	eece <__ssvfscanf_r+0x35a>
    f1ac:	b.n	edbe <__ssvfscanf_r+0x24a>
    f1ae:	ldr	r5, [sp, #20]
    f1b0:	mov	r3, r4
    f1b2:	ldr	r1, [r5, #0]
    f1b4:	str.w	fp, [sp]
    f1b8:	movs	r2, #1
    f1ba:	mov	r0, sl
    f1bc:	bl	125e8 <_sfread_r>
    f1c0:	adds	r6, r5, #4
    f1c2:	cmp	r0, #0
    f1c4:	beq.w	edbe <__ssvfscanf_r+0x24a>
    f1c8:	ldr	r3, [sp, #24]
    f1ca:	str	r6, [sp, #20]
    f1cc:	ldr	r6, [sp, #12]
    f1ce:	adds	r3, #1
    f1d0:	add	r7, r0
    f1d2:	str	r3, [sp, #24]
    f1d4:	mov	r4, r6
    f1d6:	b.n	ec04 <__ssvfscanf_r+0x90>
    f1d8:	mov	r1, fp
    f1da:	mov	r0, sl
    f1dc:	bl	125ac <__ssrefill_r>
    f1e0:	cmp	r0, #0
    f1e2:	beq.w	ed32 <__ssvfscanf_r+0x1be>
    f1e6:	b.n	edbe <__ssvfscanf_r+0x24a>
    f1e8:	mov.w	r9, #0
    f1ec:	b.n	f0f8 <__ssvfscanf_r+0x584>
    f1ee:	ldrb.w	r8, [r6, #2]
    f1f2:	orr.w	r5, r5, #2
    f1f6:	adds	r6, #2
    f1f8:	b.n	ec26 <__ssvfscanf_r+0xb2>
    f1fa:	cmp	r3, #0
    f1fc:	orr.w	r5, r5, #1
    f200:	bgt.w	ef4e <__ssvfscanf_r+0x3da>
    f204:	b.n	efc4 <__ssvfscanf_r+0x450>
    f206:	lsls	r4, r5, #31
    f208:	bmi.n	f224 <__ssvfscanf_r+0x6b0>
    f20a:	lsls	r0, r5, #30
    f20c:	bpl.n	f224 <__ssvfscanf_r+0x6b0>
    f20e:	ldr	r2, [sp, #20]
    f210:	ldr	r6, [sp, #12]
    f212:	ldr	r3, [r2, #0]
    f214:	mov	r0, r7
    f216:	asrs	r1, r7, #31
    f218:	adds	r2, #4
    f21a:	str	r2, [sp, #20]
    f21c:	strd	r0, r1, [r3]
    f220:	mov	r4, r6
    f222:	b.n	ec04 <__ssvfscanf_r+0x90>
    f224:	ldr	r2, [sp, #20]
    f226:	ldr	r6, [sp, #12]
    f228:	ldr	r3, [r2, #0]
    f22a:	str	r7, [r3, #0]
    f22c:	mov	r3, r2
    f22e:	adds	r3, #4
    f230:	str	r3, [sp, #20]
    f232:	mov	r4, r6
    f234:	b.n	ec04 <__ssvfscanf_r+0x90>
    f236:	mov	r1, fp
    f238:	mov	r0, sl
    f23a:	bl	125ac <__ssrefill_r>
    f23e:	cmp	r0, #0
    f240:	bne.w	edbe <__ssvfscanf_r+0x24a>
    f244:	ldr	r3, [pc, #504]	; (f440 <__ssvfscanf_r+0x8cc>)
    f246:	str	r0, [sp, #16]
    f248:	str	r3, [sp, #28]
    f24a:	movs	r6, #3
    f24c:	b.n	ed80 <__ssvfscanf_r+0x20c>
    f24e:	mov	r1, fp
    f250:	mov	r0, sl
    f252:	bl	125ac <__ssrefill_r>
    f256:	cmp	r0, #0
    f258:	beq.w	eeee <__ssvfscanf_r+0x37a>
    f25c:	b.n	edbe <__ssvfscanf_r+0x24a>
    f25e:	mov	r1, fp
    f260:	mov	r0, sl
    f262:	bl	125ac <__ssrefill_r>
    f266:	cmp	r0, #0
    f268:	beq.w	ee84 <__ssvfscanf_r+0x310>
    f26c:	b.n	edbe <__ssvfscanf_r+0x24a>
    f26e:	mov	r1, fp
    f270:	mov	r0, sl
    f272:	bl	125ac <__ssrefill_r>
    f276:	cmp	r0, #0
    f278:	beq.w	efb2 <__ssvfscanf_r+0x43e>
    f27c:	b.n	edbe <__ssvfscanf_r+0x24a>
    f27e:	mov	r1, fp
    f280:	mov	r0, sl
    f282:	bl	125ac <__ssrefill_r>
    f286:	cmp	r0, #0
    f288:	beq.w	ee16 <__ssvfscanf_r+0x2a2>
    f28c:	b.n	edbe <__ssvfscanf_r+0x24a>
    f28e:	mov	r1, fp
    f290:	mov	r0, sl
    f292:	bl	125ac <__ssrefill_r>
    f296:	cmp	r0, #0
    f298:	beq.w	edfe <__ssvfscanf_r+0x28a>
    f29c:	b.n	edbe <__ssvfscanf_r+0x24a>
    f29e:	cmp	r6, #3
    f2a0:	beq.w	f5e2 <__ssvfscanf_r+0xa6e>
    f2a4:	cmp	r6, #4
    f2a6:	bne.w	f724 <__ssvfscanf_r+0xbb0>
    f2aa:	mov	r0, sl
    f2ac:	bl	114e8 <_localeconv_r>
    f2b0:	subs	r3, r4, #1
    f2b2:	ldr	r2, [r0, #0]
    f2b4:	str	r2, [sp, #48]	; 0x30
    f2b6:	cmp.w	r3, #348	; 0x15c
    f2ba:	bls.w	f78c <__ssvfscanf_r+0xc18>
    f2be:	mvn.w	r1, #348	; 0x15c
    f2c2:	adds	r3, r4, r1
    f2c4:	str	r3, [sp, #56]	; 0x38
    f2c6:	movw	r4, #349	; 0x15d
    f2ca:	add	r3, sp, #336	; 0x150
    f2cc:	mov.w	r8, #0
    f2d0:	mov	r2, r3
    f2d2:	str	r3, [sp, #40]	; 0x28
    f2d4:	orr.w	r5, r5, #1920	; 0x780
    f2d8:	mov	r3, r8
    f2da:	str.w	r8, [sp, #60]	; 0x3c
    f2de:	str.w	r8, [sp, #52]	; 0x34
    f2e2:	mov	r6, r8
    f2e4:	str.w	r8, [sp, #44]	; 0x2c
    f2e8:	mov	r9, r2
    f2ea:	ldr.w	r0, [fp]
    f2ee:	ldrb	r1, [r0, #0]
    f2f0:	sub.w	lr, r1, #43	; 0x2b
    f2f4:	cmp.w	lr, #78	; 0x4e
    f2f8:	bhi.w	f592 <__ssvfscanf_r+0xa1e>
    f2fc:	tbh	[pc, lr, lsl #1]
    f300:	.word	0x0149007a
    f304:	.word	0x0149007a
    f308:	.word	0x006e0149
    f30c:	.word	0x004f004f
    f310:	.word	0x004f004f
    f314:	.word	0x004f004f
    f318:	.word	0x004f004f
    f31c:	.word	0x0149004f
    f320:	.word	0x01490149
    f324:	.word	0x01490149
    f328:	.word	0x01490149
    f32c:	.word	0x01490144
    f330:	.word	0x01490149
    f334:	.word	0x0125012c
    f338:	.word	0x01490149
    f33c:	.word	0x014900a2
    f340:	.word	0x01490149
    f344:	.word	0x008b0149
    f348:	.word	0x01490149
    f34c:	.word	0x01490149
    f350:	.word	0x00850149
    f354:	.word	0x01490149
    f358:	.word	0x01490149
    f35c:	.word	0x0149007f
    f360:	.word	0x01490149
    f364:	.word	0x01490149
    f368:	.word	0x01490149
    f36c:	.word	0x01490144
    f370:	.word	0x01490149
    f374:	.word	0x0125012c
    f378:	.word	0x01490149
    f37c:	.word	0x014900a2
    f380:	.word	0x01490149
    f384:	.word	0x008b0149
    f388:	.word	0x01490149
    f38c:	.word	0x01490149
    f390:	.word	0x00850149
    f394:	.word	0x01490149
    f398:	.word	0x01490149
    f39c:	.short	0x007f
    f39e:	cmn.w	r3, r8
    f3a2:	bne.n	f3d2 <__ssvfscanf_r+0x85e>
    f3a4:	bic.w	r5, r5, #384	; 0x180
    f3a8:	strb.w	r1, [r9]
    f3ac:	add.w	r9, r9, #1
    f3b0:	ldr.w	r1, [fp, #4]
    f3b4:	subs	r1, #1
    f3b6:	cmp	r1, #0
    f3b8:	add.w	r4, r4, #4294967295
    f3bc:	add.w	r7, r7, #1
    f3c0:	str.w	r1, [fp, #4]
    f3c4:	ble.w	f5ac <__ssvfscanf_r+0xa38>
    f3c8:	adds	r0, #1
    f3ca:	str.w	r0, [fp]
    f3ce:	cmp	r4, #0
    f3d0:	bne.n	f2ea <__ssvfscanf_r+0x776>
    f3d2:	cmp	r6, #0
    f3d4:	beq.n	f45c <__ssvfscanf_r+0x8e8>
    f3d6:	bic.w	r5, r5, #256	; 0x100
    f3da:	b.n	f45c <__ssvfscanf_r+0x8e8>
    f3dc:	lsls	r2, r5, #23
    f3de:	bpl.n	f39e <__ssvfscanf_r+0x82a>
    f3e0:	ldr	r2, [sp, #56]	; 0x38
    f3e2:	bic.w	r5, r5, #128	; 0x80
    f3e6:	adds	r6, #1
    f3e8:	cmp	r2, #0
    f3ea:	beq.n	f3b0 <__ssvfscanf_r+0x83c>
    f3ec:	subs	r2, #1
    f3ee:	str	r2, [sp, #56]	; 0x38
    f3f0:	adds	r4, #1
    f3f2:	b.n	f3b0 <__ssvfscanf_r+0x83c>
    f3f4:	lsls	r2, r5, #24
    f3f6:	bpl.n	f3d2 <__ssvfscanf_r+0x85e>
    f3f8:	bic.w	r5, r5, #128	; 0x80
    f3fc:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f3fe:	cmp.w	r8, #7
    f402:	bne.n	f3d2 <__ssvfscanf_r+0x85e>
    f404:	mov.w	r8, #8
    f408:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f40a:	cmp.w	r8, #6
    f40e:	bne.n	f3d2 <__ssvfscanf_r+0x85e>
    f410:	mov.w	r8, #7
    f414:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f416:	cmp	r3, #0
    f418:	bne.w	f5d8 <__ssvfscanf_r+0xa64>
    f41c:	cbnz	r6, f42a <__ssvfscanf_r+0x8b6>
    f41e:	and.w	lr, r5, #1792	; 0x700
    f422:	cmp.w	lr, #1792	; 0x700
    f426:	beq.w	f8b0 <__ssvfscanf_r+0xd3c>
    f42a:	cmp.w	r8, #1
    f42e:	beq.n	f436 <__ssvfscanf_r+0x8c2>
    f430:	cmp.w	r8, #4
    f434:	bne.n	f3d2 <__ssvfscanf_r+0x85e>
    f436:	add.w	r8, r8, #1
    f43a:	uxtb.w	r8, r8
    f43e:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f440:	.word	0x0000d469
    f444:	cmp.w	r8, #0
    f448:	bne.w	f5c6 <__ssvfscanf_r+0xa52>
    f44c:	cmp	r6, #0
    f44e:	bne.n	f3d6 <__ssvfscanf_r+0x862>
    f450:	and.w	lr, r5, #1792	; 0x700
    f454:	cmp.w	lr, #1792	; 0x700
    f458:	beq.w	f8d0 <__ssvfscanf_r+0xd5c>
    f45c:	subs	r3, #1
    f45e:	cmp	r3, #1
    f460:	bls.w	f966 <__ssvfscanf_r+0xdf2>
    f464:	add.w	r3, r8, #4294967295
    f468:	cmp	r3, #6
    f46a:	bhi.n	f49a <__ssvfscanf_r+0x926>
    f46c:	cmp.w	r8, #2
    f470:	bls.w	f9b4 <__ssvfscanf_r+0xe40>
    f474:	cmp.w	r8, #3
    f478:	beq.n	f49a <__ssvfscanf_r+0x926>
    f47a:	sub.w	r4, r8, #4
    f47e:	uxtb	r4, r4
    f480:	mvn.w	r8, r4
    f484:	add	r8, r9
    f486:	ldrb.w	r1, [r9, #-1]!
    f48a:	mov	r2, fp
    f48c:	mov	r0, sl
    f48e:	bl	12528 <_sungetc_r>
    f492:	cmp	r8, r9
    f494:	bne.n	f486 <__ssvfscanf_r+0x912>
    f496:	subs	r7, #1
    f498:	subs	r7, r7, r4
    f49a:	lsls	r1, r5, #23
    f49c:	bpl.n	f4d8 <__ssvfscanf_r+0x964>
    f49e:	lsls	r2, r5, #21
    f4a0:	bmi.w	f98a <__ssvfscanf_r+0xe16>
    f4a4:	ldrb.w	r1, [r9, #-1]
    f4a8:	cmp	r1, #101	; 0x65
    f4aa:	add.w	r4, r9, #4294967295
    f4ae:	add.w	r8, r7, #4294967295
    f4b2:	beq.n	f4cc <__ssvfscanf_r+0x958>
    f4b4:	cmp	r1, #69	; 0x45
    f4b6:	beq.n	f4cc <__ssvfscanf_r+0x958>
    f4b8:	mov	r2, fp
    f4ba:	mov	r0, sl
    f4bc:	bl	12528 <_sungetc_r>
    f4c0:	ldrb.w	r1, [r9, #-2]
    f4c4:	sub.w	r8, r7, #2
    f4c8:	sub.w	r4, r9, #2
    f4cc:	mov	r2, fp
    f4ce:	mov	r0, sl
    f4d0:	bl	12528 <_sungetc_r>
    f4d4:	mov	r7, r8
    f4d6:	mov	r9, r4
    f4d8:	ands.w	r2, r5, #16
    f4dc:	bne.w	f03c <__ssvfscanf_r+0x4c8>
    f4e0:	and.w	r3, r5, #1536	; 0x600
    f4e4:	cmp.w	r3, #1024	; 0x400
    f4e8:	strb.w	r2, [r9]
    f4ec:	beq.w	f8da <__ssvfscanf_r+0xd66>
    f4f0:	ldr	r3, [sp, #52]	; 0x34
    f4f2:	cmp	r3, #0
    f4f4:	bne.w	f8fc <__ssvfscanf_r+0xd88>
    f4f8:	ldr	r1, [sp, #40]	; 0x28
    f4fa:	movs	r2, #0
    f4fc:	mov	r0, sl
    f4fe:	bl	d310 <_strtod_r>
    f502:	lsls	r3, r5, #31
    f504:	bmi.w	f792 <__ssvfscanf_r+0xc1e>
    f508:	ands.w	r5, r5, #2
    f50c:	bne.w	f792 <__ssvfscanf_r+0xc1e>
    f510:	vmov	r2, r3, d0
    f514:	vmov	r0, r1, d0
    f518:	vstr	d0, [sp, #32]
    f51c:	bl	acec <__aeabi_dcmpun>
    f520:	ldr	r4, [sp, #20]
    f522:	vldr	d0, [sp, #32]
    f526:	adds	r6, r4, #4
    f528:	ldr	r4, [r4, #0]
    f52a:	cmp	r0, #0
    f52c:	bne.w	f9e8 <__ssvfscanf_r+0xe74>
    f530:	vmov	r0, r1, d0
    f534:	bl	ada8 <__aeabi_d2f>
    f538:	str	r6, [sp, #20]
    f53a:	str	r0, [r4, #0]
    f53c:	ldr	r3, [sp, #24]
    f53e:	ldr	r6, [sp, #12]
    f540:	adds	r3, #1
    f542:	str	r3, [sp, #24]
    f544:	mov	r4, r6
    f546:	b.w	ec04 <__ssvfscanf_r+0x90>
    f54a:	cmp.w	r8, #2
    f54e:	bne.w	f3d2 <__ssvfscanf_r+0x85e>
    f552:	mov.w	r8, #3
    f556:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f558:	and.w	lr, r5, #1280	; 0x500
    f55c:	cmp.w	lr, #1024	; 0x400
    f560:	beq.n	f56e <__ssvfscanf_r+0x9fa>
    f562:	lsls	r2, r5, #21
    f564:	bpl.w	f3d2 <__ssvfscanf_r+0x85e>
    f568:	cmp	r6, #0
    f56a:	beq.w	f45c <__ssvfscanf_r+0x8e8>
    f56e:	lsls	r2, r5, #22
    f570:	bmi.n	f57c <__ssvfscanf_r+0xa08>
    f572:	ldr	r2, [sp, #44]	; 0x2c
    f574:	str.w	r9, [sp, #60]	; 0x3c
    f578:	subs	r2, r6, r2
    f57a:	str	r2, [sp, #52]	; 0x34
    f57c:	bic.w	r5, r5, #1920	; 0x780
    f580:	orr.w	r5, r5, #384	; 0x180
    f584:	movs	r6, #0
    f586:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f588:	cmp	r3, #1
    f58a:	bne.w	f3d2 <__ssvfscanf_r+0x85e>
    f58e:	movs	r3, #2
    f590:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f592:	ldr	r2, [sp, #48]	; 0x30
    f594:	ldrb.w	lr, [r2]
    f598:	cmp	lr, r1
    f59a:	bne.w	f3d2 <__ssvfscanf_r+0x85e>
    f59e:	lsls	r2, r5, #22
    f5a0:	bpl.w	f3d2 <__ssvfscanf_r+0x85e>
    f5a4:	bic.w	r5, r5, #640	; 0x280
    f5a8:	str	r6, [sp, #44]	; 0x2c
    f5aa:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f5ac:	mov	r1, fp
    f5ae:	mov	r0, sl
    f5b0:	str	r3, [sp, #32]
    f5b2:	bl	125ac <__ssrefill_r>
    f5b6:	ldr	r3, [sp, #32]
    f5b8:	cmp	r0, #0
    f5ba:	bne.w	f3d2 <__ssvfscanf_r+0x85e>
    f5be:	cmp	r4, #0
    f5c0:	bne.w	f2ea <__ssvfscanf_r+0x776>
    f5c4:	b.n	f3d2 <__ssvfscanf_r+0x85e>
    f5c6:	cmp.w	r8, #3
    f5ca:	beq.w	f436 <__ssvfscanf_r+0x8c2>
    f5ce:	cmp.w	r8, #5
    f5d2:	beq.w	f436 <__ssvfscanf_r+0x8c2>
    f5d6:	b.n	f3d2 <__ssvfscanf_r+0x85e>
    f5d8:	cmp	r3, #2
    f5da:	bne.w	f42a <__ssvfscanf_r+0x8b6>
    f5de:	movs	r3, #3
    f5e0:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f5e2:	subs	r3, r4, #1
    f5e4:	cmp.w	r3, #348	; 0x15c
    f5e8:	itte	hi
    f5ea:	mvnhi.w	r0, #348	; 0x15c
    f5ee:	addhi.w	r9, r4, r0
    f5f2:	movls	r9, r8
    f5f4:	add	r3, sp, #336	; 0x150
    f5f6:	mov	r0, r2
    f5f8:	mov	r2, r7
    f5fa:	mov	r7, r9
    f5fc:	ldr.w	r9, [sp, #16]
    f600:	str	r3, [sp, #40]	; 0x28
    f602:	it	hi
    f604:	movwhi	r4, #349	; 0x15d
    f608:	orr.w	r5, r5, #3456	; 0xd80
    f60c:	mov	r6, r3
    f60e:	mov.w	r8, #0
    f612:	sub.w	r3, r1, #43	; 0x2b
    f616:	cmp	r3, #77	; 0x4d
    f618:	bhi.n	f6be <__ssvfscanf_r+0xb4a>
    f61a:	tbb	[pc, r3]
    f61e:	.short	0x507e
    f620:	.word	0x6f50507e
    f624:	.word	0x69696969
    f628:	.word	0x4a696969
    f62c:	.word	0x5050504a
    f630:	.word	0x50505050
    f634:	.word	0x44444444
    f638:	.word	0x50504444
    f63c:	.word	0x50505050
    f640:	.word	0x50505050
    f644:	.word	0x50505050
    f648:	.word	0x27505050
    f64c:	.word	0x50505050
    f650:	.word	0x50505050
    f654:	.word	0x44444444
    f658:	.word	0x50504444
    f65c:	.word	0x50505050
    f660:	.word	0x50505050
    f664:	.word	0x50505050
    f668:	.word	0x27505050
    f66c:	and.w	r3, r5, #1536	; 0x600
    f670:	cmp.w	r3, #512	; 0x200
    f674:	bne.n	f6be <__ssvfscanf_r+0xb4a>
    f676:	bic.w	r5, r5, #512	; 0x200
    f67a:	orr.w	r5, r5, #1280	; 0x500
    f67e:	mov.w	r9, #16
    f682:	strb	r1, [r6, #0]
    f684:	adds	r6, #1
    f686:	ldr.w	r3, [fp, #4]
    f68a:	subs	r3, #1
    f68c:	cmp	r3, #0
    f68e:	str.w	r3, [fp, #4]
    f692:	ble.n	f77a <__ssvfscanf_r+0xc06>
    f694:	adds	r0, #1
    f696:	str.w	r0, [fp]
    f69a:	subs	r4, #1
    f69c:	beq.n	f6be <__ssvfscanf_r+0xb4a>
    f69e:	ldr.w	r0, [fp]
    f6a2:	ldrb	r1, [r0, #0]
    f6a4:	b.n	f612 <__ssvfscanf_r+0xa9e>
    f6a6:	cmp.w	r9, #10
    f6aa:	ble.n	f6be <__ssvfscanf_r+0xb4a>
    f6ac:	bic.w	r5, r5, #2944	; 0xb80
    f6b0:	b.n	f682 <__ssvfscanf_r+0xb0e>
    f6b2:	ldr	r3, [pc, #756]	; (f9a8 <__ssvfscanf_r+0xe34>)
    f6b4:	ldrsh.w	r9, [r3, r9, lsl #1]
    f6b8:	cmp.w	r9, #8
    f6bc:	bgt.n	f6ac <__ssvfscanf_r+0xb38>
    f6be:	lsls	r1, r5, #23
    f6c0:	mov	r7, r2
    f6c2:	str.w	r9, [sp, #16]
    f6c6:	bpl.n	f6d8 <__ssvfscanf_r+0xb64>
    f6c8:	ldr	r3, [sp, #40]	; 0x28
    f6ca:	cmp	r6, r3
    f6cc:	bhi.w	f8b8 <__ssvfscanf_r+0xd44>
    f6d0:	ldr	r3, [sp, #40]	; 0x28
    f6d2:	cmp	r6, r3
    f6d4:	beq.w	ec10 <__ssvfscanf_r+0x9c>
    f6d8:	ands.w	r4, r5, #16
    f6dc:	beq.w	f804 <__ssvfscanf_r+0xc90>
    f6e0:	ldr	r3, [sp, #40]	; 0x28
    f6e2:	subs	r6, r6, r3
    f6e4:	add	r6, r8
    f6e6:	add	r7, r6
    f6e8:	ldr	r6, [sp, #12]
    f6ea:	mov	r4, r6
    f6ec:	b.w	ec04 <__ssvfscanf_r+0x90>
    f6f0:	ldr	r3, [pc, #692]	; (f9a8 <__ssvfscanf_r+0xe34>)
    f6f2:	bic.w	r5, r5, #2944	; 0xb80
    f6f6:	ldrsh.w	r9, [r3, r9, lsl #1]
    f6fa:	b.n	f682 <__ssvfscanf_r+0xb0e>
    f6fc:	lsls	r3, r5, #20
    f6fe:	bpl.n	f682 <__ssvfscanf_r+0xb0e>
    f700:	cmp.w	r9, #0
    f704:	bne.n	f70e <__ssvfscanf_r+0xb9a>
    f706:	orr.w	r5, r5, #512	; 0x200
    f70a:	mov.w	r9, #8
    f70e:	lsls	r3, r5, #21
    f710:	bpl.w	f894 <__ssvfscanf_r+0xd20>
    f714:	bic.w	r5, r5, #1408	; 0x580
    f718:	b.n	f682 <__ssvfscanf_r+0xb0e>
    f71a:	lsls	r3, r5, #24
    f71c:	bpl.n	f6be <__ssvfscanf_r+0xb4a>
    f71e:	bic.w	r5, r5, #128	; 0x80
    f722:	b.n	f682 <__ssvfscanf_r+0xb0e>
    f724:	cmp	r4, #0
    f726:	it	eq
    f728:	moveq.w	r4, #4294967295
    f72c:	ands.w	r3, r5, #1
    f730:	bne.w	eff0 <__ssvfscanf_r+0x47c>
    f734:	lsls	r1, r5, #27
    f736:	bpl.n	f7a0 <__ssvfscanf_r+0xc2c>
    f738:	mov	r5, r3
    f73a:	bl	b490 <__locale_ctype_ptr>
    f73e:	ldr.w	r3, [fp]
    f742:	ldrb	r2, [r3, #0]
    f744:	add	r0, r2
    f746:	adds	r3, #1
    f748:	ldrb	r2, [r0, #1]
    f74a:	lsls	r2, r2, #28
    f74c:	bmi.w	eece <__ssvfscanf_r+0x35a>
    f750:	ldr.w	r2, [fp, #4]
    f754:	str.w	r3, [fp]
    f758:	adds	r5, #1
    f75a:	subs	r3, r2, #1
    f75c:	cmp	r4, r5
    f75e:	str.w	r3, [fp, #4]
    f762:	beq.w	eece <__ssvfscanf_r+0x35a>
    f766:	cmp	r3, #0
    f768:	bgt.n	f73a <__ssvfscanf_r+0xbc6>
    f76a:	mov	r1, fp
    f76c:	mov	r0, sl
    f76e:	bl	125ac <__ssrefill_r>
    f772:	cmp	r0, #0
    f774:	beq.n	f73a <__ssvfscanf_r+0xbc6>
    f776:	b.w	eece <__ssvfscanf_r+0x35a>
    f77a:	mov	r1, fp
    f77c:	mov	r0, sl
    f77e:	str	r2, [sp, #16]
    f780:	bl	125ac <__ssrefill_r>
    f784:	ldr	r2, [sp, #16]
    f786:	cmp	r0, #0
    f788:	beq.n	f69a <__ssvfscanf_r+0xb26>
    f78a:	b.n	f6be <__ssvfscanf_r+0xb4a>
    f78c:	str.w	r8, [sp, #56]	; 0x38
    f790:	b.n	f2ca <__ssvfscanf_r+0x756>
    f792:	ldr	r2, [sp, #20]
    f794:	ldr	r3, [r2, #0]
    f796:	adds	r2, #4
    f798:	str	r2, [sp, #20]
    f79a:	vstr	d0, [r3]
    f79e:	b.n	f53c <__ssvfscanf_r+0x9c8>
    f7a0:	ldr	r2, [sp, #20]
    f7a2:	ldr	r5, [r2, #0]
    f7a4:	adds	r6, r2, #4
    f7a6:	add	r4, r5
    f7a8:	mov	r8, r5
    f7aa:	bl	b490 <__locale_ctype_ptr>
    f7ae:	ldr.w	r2, [fp]
    f7b2:	ldrb	r3, [r2, #0]
    f7b4:	add	r0, r3
    f7b6:	adds	r1, r2, #1
    f7b8:	ldrb	r3, [r0, #1]
    f7ba:	lsls	r3, r3, #28
    f7bc:	bmi.n	f7ea <__ssvfscanf_r+0xc76>
    f7be:	ldr.w	r3, [fp, #4]
    f7c2:	str.w	r1, [fp]
    f7c6:	subs	r3, #1
    f7c8:	str.w	r3, [fp, #4]
    f7cc:	ldrb	r3, [r2, #0]
    f7ce:	strb.w	r3, [r8], #1
    f7d2:	cmp	r4, r8
    f7d4:	beq.n	f7ec <__ssvfscanf_r+0xc78>
    f7d6:	ldr.w	r3, [fp, #4]
    f7da:	cmp	r3, #0
    f7dc:	bgt.n	f7aa <__ssvfscanf_r+0xc36>
    f7de:	mov	r1, fp
    f7e0:	mov	r0, sl
    f7e2:	bl	125ac <__ssrefill_r>
    f7e6:	cmp	r0, #0
    f7e8:	beq.n	f7aa <__ssvfscanf_r+0xc36>
    f7ea:	mov	r4, r8
    f7ec:	ldr	r2, [sp, #24]
    f7ee:	str	r6, [sp, #20]
    f7f0:	ldr	r6, [sp, #12]
    f7f2:	subs	r5, r4, r5
    f7f4:	movs	r3, #0
    f7f6:	adds	r2, #1
    f7f8:	strb	r3, [r4, #0]
    f7fa:	add	r7, r5
    f7fc:	str	r2, [sp, #24]
    f7fe:	mov	r4, r6
    f800:	b.w	ec04 <__ssvfscanf_r+0x90>
    f804:	mov	r2, r4
    f806:	strb	r4, [r6, #0]
    f808:	ldr	r3, [sp, #16]
    f80a:	ldr	r1, [sp, #40]	; 0x28
    f80c:	ldr	r4, [sp, #28]
    f80e:	mov	r0, sl
    f810:	blx	r4
    f812:	lsls	r2, r5, #26
    f814:	bmi.n	f8a4 <__ssvfscanf_r+0xd30>
    f816:	lsls	r3, r5, #29
    f818:	bpl.n	f912 <__ssvfscanf_r+0xd9e>
    f81a:	ldr	r2, [sp, #20]
    f81c:	ldr	r3, [r2, #0]
    f81e:	adds	r2, #4
    f820:	str	r2, [sp, #20]
    f822:	strh	r0, [r3, #0]
    f824:	ldr	r3, [sp, #24]
    f826:	adds	r3, #1
    f828:	str	r3, [sp, #24]
    f82a:	b.n	f6e0 <__ssvfscanf_r+0xb6c>
    f82c:	bl	b46c <__locale_mb_cur_max>
    f830:	cmp	r6, r0
    f832:	beq.w	edbe <__ssvfscanf_r+0x24a>
    f836:	ldmia.w	fp, {r2, r3}
    f83a:	ldrb.w	r0, [r2], #1
    f83e:	str.w	r2, [fp]
    f842:	ldr	r2, [sp, #32]
    f844:	str	r2, [sp, #0]
    f846:	add	r2, sp, #336	; 0x150
    f848:	adds	r5, r6, #1
    f84a:	subs	r3, #1
    f84c:	strb	r0, [r2, r6]
    f84e:	str.w	r3, [fp, #4]
    f852:	mov	r1, r8
    f854:	mov	r3, r5
    f856:	mov	r0, sl
    f858:	bl	11504 <_mbrtowc_r>
    f85c:	adds	r6, r0, #1
    f85e:	beq.w	edbe <__ssvfscanf_r+0x24a>
    f862:	cmp	r0, #0
    f864:	bne.n	f93e <__ssvfscanf_r+0xdca>
    f866:	str.w	r0, [r8]
    f86a:	bl	114c8 <iswspace>
    f86e:	cmp	r0, #0
    f870:	beq.w	f9d2 <__ssvfscanf_r+0xe5e>
    f874:	cmp	r5, #0
    f876:	beq.w	f02c <__ssvfscanf_r+0x4b8>
    f87a:	add	r3, sp, #336	; 0x150
    f87c:	adds	r4, r3, r5
    f87e:	subs	r5, #1
    f880:	mov	r2, fp
    f882:	ldrb.w	r1, [r4, #-1]!
    f886:	mov	r0, sl
    f888:	bl	12528 <_sungetc_r>
    f88c:	cmp	r5, #0
    f88e:	bne.n	f87e <__ssvfscanf_r+0xd0a>
    f890:	b.w	f02c <__ssvfscanf_r+0x4b8>
    f894:	bic.w	r5, r5, #896	; 0x380
    f898:	cbz	r7, f89e <__ssvfscanf_r+0xd2a>
    f89a:	subs	r7, #1
    f89c:	adds	r4, #1
    f89e:	add.w	r8, r8, #1
    f8a2:	b.n	f686 <__ssvfscanf_r+0xb12>
    f8a4:	ldr	r2, [sp, #20]
    f8a6:	ldr	r3, [r2, #0]
    f8a8:	adds	r2, #4
    f8aa:	str	r2, [sp, #20]
    f8ac:	str	r0, [r3, #0]
    f8ae:	b.n	f824 <__ssvfscanf_r+0xcb0>
    f8b0:	bic.w	r5, r5, #1920	; 0x780
    f8b4:	movs	r3, #1
    f8b6:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f8b8:	ldrb.w	r1, [r6, #-1]
    f8bc:	mov	r2, fp
    f8be:	mov	r0, sl
    f8c0:	bl	12528 <_sungetc_r>
    f8c4:	subs	r6, #1
    f8c6:	b.n	f6d0 <__ssvfscanf_r+0xb5c>
    f8c8:	add.w	r8, sp, #68	; 0x44
    f8cc:	b.w	f012 <__ssvfscanf_r+0x49e>
    f8d0:	bic.w	r5, r5, #1920	; 0x780
    f8d4:	mov.w	r8, #1
    f8d8:	b.n	f3a8 <__ssvfscanf_r+0x834>
    f8da:	ldr	r3, [sp, #44]	; 0x2c
    f8dc:	subs	r6, r6, r3
    f8de:	negs	r2, r6
    f8e0:	cmp	r6, #0
    f8e2:	beq.w	f4f8 <__ssvfscanf_r+0x984>
    f8e6:	addw	r3, sp, #675	; 0x2a3
    f8ea:	cmp	r9, r3
    f8ec:	it	cs
    f8ee:	addwcs	r9, sp, #674	; 0x2a2
    f8f2:	mov	r0, r9
    f8f4:	ldr	r1, [pc, #180]	; (f9ac <__ssvfscanf_r+0xe38>)
    f8f6:	bl	c038 <sprintf>
    f8fa:	b.n	f4f8 <__ssvfscanf_r+0x984>
    f8fc:	ldr	r4, [sp, #60]	; 0x3c
    f8fe:	mov	r1, r4
    f900:	movs	r3, #10
    f902:	adds	r1, #1
    f904:	mov	r0, sl
    f906:	bl	d468 <_strtol_r>
    f90a:	ldr	r3, [sp, #52]	; 0x34
    f90c:	mov	r9, r4
    f90e:	subs	r2, r0, r3
    f910:	b.n	f8e6 <__ssvfscanf_r+0xd72>
    f912:	ands.w	r2, r5, #1
    f916:	bne.n	f8a4 <__ssvfscanf_r+0xd30>
    f918:	lsls	r4, r5, #30
    f91a:	bpl.n	f8a4 <__ssvfscanf_r+0xd30>
    f91c:	ldr	r3, [sp, #28]
    f91e:	mov	r1, r3
    f920:	ldr	r3, [pc, #140]	; (f9b0 <__ssvfscanf_r+0xe3c>)
    f922:	cmp	r1, r3
    f924:	mov	r0, sl
    f926:	ldr	r3, [sp, #16]
    f928:	ldr	r1, [sp, #40]	; 0x28
    f92a:	beq.n	f9f6 <__ssvfscanf_r+0xe82>
    f92c:	bl	12068 <_strtoll_r>
    f930:	ldr	r2, [sp, #20]
    f932:	ldr	r3, [r2, #0]
    f934:	adds	r2, #4
    f936:	str	r2, [sp, #20]
    f938:	strd	r0, r1, [r3]
    f93c:	b.n	f824 <__ssvfscanf_r+0xcb0>
    f93e:	adds	r0, #2
    f940:	bne.n	f984 <__ssvfscanf_r+0xe10>
    f942:	mov	r6, r5
    f944:	ldr.w	r3, [fp, #4]
    f948:	cmp	r3, #0
    f94a:	bgt.w	f014 <__ssvfscanf_r+0x4a0>
    f94e:	mov	r1, fp
    f950:	mov	r0, sl
    f952:	bl	125ac <__ssrefill_r>
    f956:	cmp	r0, #0
    f958:	beq.w	f014 <__ssvfscanf_r+0x4a0>
    f95c:	cmp	r6, #0
    f95e:	bne.w	edbe <__ssvfscanf_r+0x24a>
    f962:	b.w	f02c <__ssvfscanf_r+0x4b8>
    f966:	ldr	r3, [sp, #40]	; 0x28
    f968:	cmp	r9, r3
    f96a:	bls.w	ec10 <__ssvfscanf_r+0x9c>
    f96e:	ldrb.w	r1, [r9, #-1]!
    f972:	mov	r2, fp
    f974:	mov	r0, sl
    f976:	bl	12528 <_sungetc_r>
    f97a:	ldr	r3, [sp, #40]	; 0x28
    f97c:	cmp	r9, r3
    f97e:	bne.n	f96e <__ssvfscanf_r+0xdfa>
    f980:	b.w	ec10 <__ssvfscanf_r+0x9c>
    f984:	ldr.w	r0, [r8]
    f988:	b.n	f86a <__ssvfscanf_r+0xcf6>
    f98a:	ldr	r3, [sp, #40]	; 0x28
    f98c:	cmp	r9, r3
    f98e:	bls.w	ec10 <__ssvfscanf_r+0x9c>
    f992:	ldrb.w	r1, [r9, #-1]!
    f996:	mov	r2, fp
    f998:	mov	r0, sl
    f99a:	bl	12528 <_sungetc_r>
    f99e:	ldr	r3, [sp, #40]	; 0x28
    f9a0:	cmp	r9, r3
    f9a2:	bne.n	f992 <__ssvfscanf_r+0xe1e>
    f9a4:	b.w	ec10 <__ssvfscanf_r+0x9c>
    f9a8:	.word	0x000134c4
    f9ac:	.word	0x000134e8
    f9b0:	.word	0x000121f5
    f9b4:	ldr	r3, [sp, #40]	; 0x28
    f9b6:	cmp	r9, r3
    f9b8:	bls.w	ec10 <__ssvfscanf_r+0x9c>
    f9bc:	ldrb.w	r1, [r9, #-1]!
    f9c0:	mov	r2, fp
    f9c2:	mov	r0, sl
    f9c4:	bl	12528 <_sungetc_r>
    f9c8:	ldr	r3, [sp, #40]	; 0x28
    f9ca:	cmp	r9, r3
    f9cc:	bne.n	f9bc <__ssvfscanf_r+0xe48>
    f9ce:	b.w	ec10 <__ssvfscanf_r+0x9c>
    f9d2:	add	r7, r5
    f9d4:	subs	r4, #1
    f9d6:	cmp.w	r9, #0
    f9da:	bne.n	f9e4 <__ssvfscanf_r+0xe70>
    f9dc:	add.w	r8, r8, #4
    f9e0:	mov	r6, r9
    f9e2:	b.n	f944 <__ssvfscanf_r+0xdd0>
    f9e4:	mov	r6, r0
    f9e6:	b.n	f944 <__ssvfscanf_r+0xdd0>
    f9e8:	mov	r0, r5
    f9ea:	bl	a418 <nanf>
    f9ee:	str	r6, [sp, #20]
    f9f0:	vstr	s0, [r4]
    f9f4:	b.n	f53c <__ssvfscanf_r+0x9c8>
    f9f6:	bl	12404 <_strtoull_r>
    f9fa:	b.n	f930 <__ssvfscanf_r+0xdbc>

0000f9fc <_vdprintf_r>:
    f9fc:	push	{r4, r5, r6, r7, lr}
    f9fe:	sub.w	sp, sp, #532	; 0x214
    fa02:	add	r5, sp, #16
    fa04:	str	r3, [sp, #0]
    fa06:	mov	r7, r1
    fa08:	mov	r3, r2
    fa0a:	mov.w	r4, #512	; 0x200
    fa0e:	add	r2, sp, #12
    fa10:	mov	r1, r5
    fa12:	str	r4, [sp, #12]
    fa14:	mov	r6, r0
    fa16:	bl	126e4 <_vasnprintf_r>
    fa1a:	cbz	r0, fa40 <_vdprintf_r+0x44>
    fa1c:	mov	r4, r0
    fa1e:	mov	r2, r0
    fa20:	mov	r1, r7
    fa22:	ldr	r3, [sp, #12]
    fa24:	mov	r0, r6
    fa26:	bl	fa7c <_write_r>
    fa2a:	cmp	r4, r5
    fa2c:	str	r0, [sp, #12]
    fa2e:	beq.n	fa3a <_vdprintf_r+0x3e>
    fa30:	mov	r0, r6
    fa32:	mov	r1, r4
    fa34:	bl	10b90 <_free_r>
    fa38:	ldr	r0, [sp, #12]
    fa3a:	add.w	sp, sp, #532	; 0x214
    fa3e:	pop	{r4, r5, r6, r7, pc}
    fa40:	mov.w	r0, #4294967295
    fa44:	b.n	fa3a <_vdprintf_r+0x3e>
    fa46:	nop

0000fa48 <vdprintf>:
    fa48:	push	{r4}
    fa4a:	ldr	r4, [pc, #16]	; (fa5c <vdprintf+0x14>)
    fa4c:	mov	r3, r2
    fa4e:	mov	r2, r1
    fa50:	mov	r1, r0
    fa52:	ldr	r0, [r4, #0]
    fa54:	ldr.w	r4, [sp], #4
    fa58:	b.w	f9fc <_vdprintf_r>
    fa5c:	.word	0x20014230

0000fa60 <__ascii_wctomb>:
    fa60:	cbz	r1, fa6c <__ascii_wctomb+0xc>
    fa62:	cmp	r2, #255	; 0xff
    fa64:	bhi.n	fa70 <__ascii_wctomb+0x10>
    fa66:	strb	r2, [r1, #0]
    fa68:	movs	r0, #1
    fa6a:	bx	lr
    fa6c:	mov	r0, r1
    fa6e:	bx	lr
    fa70:	movs	r3, #138	; 0x8a
    fa72:	str	r3, [r0, #0]
    fa74:	mov.w	r0, #4294967295
    fa78:	bx	lr
    fa7a:	nop

0000fa7c <_write_r>:
    fa7c:	push	{r4, r5, r6, lr}
    fa7e:	mov	r5, r1
    fa80:	ldr	r4, [pc, #32]	; (faa4 <_write_r+0x28>)
    fa82:	mov	r1, r2
    fa84:	mov	r6, r0
    fa86:	mov	r2, r3
    fa88:	mov	r0, r5
    fa8a:	movs	r3, #0
    fa8c:	str	r3, [r4, #0]
    fa8e:	bl	9ee8 <_write>
    fa92:	adds	r3, r0, #1
    fa94:	beq.n	fa98 <_write_r+0x1c>
    fa96:	pop	{r4, r5, r6, pc}
    fa98:	ldr	r3, [r4, #0]
    fa9a:	cmp	r3, #0
    fa9c:	beq.n	fa96 <_write_r+0x1a>
    fa9e:	str	r3, [r6, #0]
    faa0:	pop	{r4, r5, r6, pc}
    faa2:	nop
    faa4:	.word	0x2001a0ec

0000faa8 <__register_exitproc>:
    faa8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    faac:	ldr	r4, [pc, #148]	; (fb44 <__register_exitproc+0x9c>)
    faae:	ldr	r5, [r4, #0]
    fab0:	ldr.w	r4, [r5, #328]	; 0x148
    fab4:	mov	r6, r0
    fab6:	mov	r8, r1
    fab8:	mov	sl, r2
    faba:	mov	r9, r3
    fabc:	cbz	r4, fb30 <__register_exitproc+0x88>
    fabe:	ldr	r0, [r4, #4]
    fac0:	cmp	r0, #31
    fac2:	bgt.n	faf4 <__register_exitproc+0x4c>
    fac4:	adds	r3, r0, #1
    fac6:	cbz	r6, fae6 <__register_exitproc+0x3e>
    fac8:	add.w	r5, r4, r0, lsl #2
    facc:	movs	r2, #1
    face:	str.w	sl, [r5, #136]	; 0x88
    fad2:	ldr.w	r1, [r4, #392]	; 0x188
    fad6:	lsls	r2, r0
    fad8:	orrs	r1, r2
    fada:	cmp	r6, #2
    fadc:	str.w	r1, [r4, #392]	; 0x188
    fae0:	str.w	r9, [r5, #264]	; 0x108
    fae4:	beq.n	fb24 <__register_exitproc+0x7c>
    fae6:	adds	r0, #2
    fae8:	str	r3, [r4, #4]
    faea:	str.w	r8, [r4, r0, lsl #2]
    faee:	movs	r0, #0
    faf0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    faf4:	ldr	r3, [pc, #80]	; (fb48 <__register_exitproc+0xa0>)
    faf6:	cbz	r3, fb3a <__register_exitproc+0x92>
    faf8:	mov.w	r0, #400	; 0x190
    fafc:	bl	b4a4 <malloc>
    fb00:	mov	r4, r0
    fb02:	cbz	r0, fb3a <__register_exitproc+0x92>
    fb04:	ldr.w	r3, [r5, #328]	; 0x148
    fb08:	movs	r7, #0
    fb0a:	stmia.w	r0, {r3, r7}
    fb0e:	str.w	r4, [r5, #328]	; 0x148
    fb12:	mov	r0, r7
    fb14:	movs	r3, #1
    fb16:	str.w	r7, [r4, #392]	; 0x188
    fb1a:	str.w	r7, [r4, #396]	; 0x18c
    fb1e:	cmp	r6, #0
    fb20:	beq.n	fae6 <__register_exitproc+0x3e>
    fb22:	b.n	fac8 <__register_exitproc+0x20>
    fb24:	ldr.w	r1, [r4, #396]	; 0x18c
    fb28:	orrs	r2, r1
    fb2a:	str.w	r2, [r4, #396]	; 0x18c
    fb2e:	b.n	fae6 <__register_exitproc+0x3e>
    fb30:	add.w	r4, r5, #332	; 0x14c
    fb34:	str.w	r4, [r5, #328]	; 0x148
    fb38:	b.n	fabe <__register_exitproc+0x16>
    fb3a:	mov.w	r0, #4294967295
    fb3e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fb42:	nop
    fb44:	.word	0x000133e8
    fb48:	.word	0x0000b4a5

0000fb4c <register_fini>:
    fb4c:	ldr	r3, [pc, #8]	; (fb58 <register_fini+0xc>)
    fb4e:	cbz	r3, fb56 <register_fini+0xa>
    fb50:	ldr	r0, [pc, #8]	; (fb5c <register_fini+0x10>)
    fb52:	b.w	fb60 <atexit>
    fb56:	bx	lr
    fb58:	.word	0x00000000
    fb5c:	.word	0x00010acd

0000fb60 <atexit>:
    fb60:	movs	r3, #0
    fb62:	mov	r1, r0
    fb64:	mov	r2, r3
    fb66:	mov	r0, r3
    fb68:	b.w	faa8 <__register_exitproc>

0000fb6c <quorem>:
    fb6c:	ldr	r2, [r0, #16]
    fb6e:	ldr	r3, [r1, #16]
    fb70:	cmp	r3, r2
    fb72:	bgt.w	fc90 <quorem+0x124>
    fb76:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fb7a:	add.w	r8, r3, #4294967295
    fb7e:	add.w	r7, r1, #20
    fb82:	add.w	fp, r0, #20
    fb86:	ldr.w	r2, [r7, r8, lsl #2]
    fb8a:	ldr.w	r3, [fp, r8, lsl #2]
    fb8e:	mov.w	r4, r8, lsl #2
    fb92:	sub	sp, #12
    fb94:	adds	r2, #1
    fb96:	udiv	r9, r3, r2
    fb9a:	add.w	r3, fp, r4
    fb9e:	str	r4, [sp, #0]
    fba0:	add.w	sl, r7, r4
    fba4:	str	r3, [sp, #4]
    fba6:	cmp.w	r9, #0
    fbaa:	beq.n	fc20 <quorem+0xb4>
    fbac:	movs	r5, #0
    fbae:	mov	ip, r7
    fbb0:	mov	lr, fp
    fbb2:	mov	r3, r5
    fbb4:	ldr.w	r6, [ip], #4
    fbb8:	ldr.w	r2, [lr]
    fbbc:	uxth	r4, r6
    fbbe:	mla	r5, r9, r4, r5
    fbc2:	lsrs	r6, r6, #16
    fbc4:	lsrs	r4, r5, #16
    fbc6:	mla	r4, r9, r6, r4
    fbca:	uxth	r5, r5
    fbcc:	subs	r3, r3, r5
    fbce:	uxth	r6, r4
    fbd0:	uxtah	r3, r3, r2
    fbd4:	rsb	r6, r6, r2, lsr #16
    fbd8:	add.w	r6, r6, r3, asr #16
    fbdc:	uxth	r3, r3
    fbde:	orr.w	r3, r3, r6, lsl #16
    fbe2:	cmp	sl, ip
    fbe4:	str.w	r3, [lr], #4
    fbe8:	mov.w	r5, r4, lsr #16
    fbec:	mov.w	r3, r6, asr #16
    fbf0:	bcs.n	fbb4 <quorem+0x48>
    fbf2:	ldr	r3, [sp, #0]
    fbf4:	ldr.w	r3, [fp, r3]
    fbf8:	cbnz	r3, fc20 <quorem+0xb4>
    fbfa:	ldr	r4, [sp, #4]
    fbfc:	subs	r3, r4, #4
    fbfe:	cmp	fp, r3
    fc00:	bcs.n	fc1c <quorem+0xb0>
    fc02:	ldr.w	r3, [r4, #-4]
    fc06:	cbnz	r3, fc1c <quorem+0xb0>
    fc08:	sub.w	r3, r4, #8
    fc0c:	b.n	fc14 <quorem+0xa8>
    fc0e:	ldr	r2, [r3, #0]
    fc10:	subs	r3, #4
    fc12:	cbnz	r2, fc1c <quorem+0xb0>
    fc14:	cmp	fp, r3
    fc16:	add.w	r8, r8, #4294967295
    fc1a:	bcc.n	fc0e <quorem+0xa2>
    fc1c:	str.w	r8, [r0, #16]
    fc20:	mov	r4, r0
    fc22:	bl	11a08 <__mcmp>
    fc26:	cmp	r0, #0
    fc28:	blt.n	fc88 <quorem+0x11c>
    fc2a:	add.w	r9, r9, #1
    fc2e:	mov	r5, fp
    fc30:	movs	r3, #0
    fc32:	ldr.w	r1, [r7], #4
    fc36:	ldr	r0, [r5, #0]
    fc38:	uxth	r2, r1
    fc3a:	subs	r2, r3, r2
    fc3c:	lsrs	r1, r1, #16
    fc3e:	uxtah	r2, r2, r0
    fc42:	rsb	r3, r1, r0, lsr #16
    fc46:	add.w	r3, r3, r2, asr #16
    fc4a:	uxth	r1, r2
    fc4c:	orr.w	r1, r1, r3, lsl #16
    fc50:	cmp	sl, r7
    fc52:	str.w	r1, [r5], #4
    fc56:	mov.w	r3, r3, asr #16
    fc5a:	bcs.n	fc32 <quorem+0xc6>
    fc5c:	ldr.w	r2, [fp, r8, lsl #2]
    fc60:	add.w	r3, fp, r8, lsl #2
    fc64:	cbnz	r2, fc88 <quorem+0x11c>
    fc66:	subs	r2, r3, #4
    fc68:	cmp	fp, r2
    fc6a:	bcs.n	fc84 <quorem+0x118>
    fc6c:	ldr.w	r2, [r3, #-4]
    fc70:	cbnz	r2, fc84 <quorem+0x118>
    fc72:	subs	r3, #8
    fc74:	b.n	fc7c <quorem+0x110>
    fc76:	ldr	r2, [r3, #0]
    fc78:	subs	r3, #4
    fc7a:	cbnz	r2, fc84 <quorem+0x118>
    fc7c:	cmp	fp, r3
    fc7e:	add.w	r8, r8, #4294967295
    fc82:	bcc.n	fc76 <quorem+0x10a>
    fc84:	str.w	r8, [r4, #16]
    fc88:	mov	r0, r9
    fc8a:	add	sp, #12
    fc8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fc90:	movs	r0, #0
    fc92:	bx	lr
    fc94:			; <UNDEFINED> instruction: 0xffffffff

0000fc98 <_dtoa_r>:
    fc98:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fc9c:	vmov	r6, r7, d0
    fca0:	sub	sp, #108	; 0x6c
    fca2:	ldr	r4, [r0, #64]	; 0x40
    fca4:	ldr	r5, [sp, #144]	; 0x90
    fca6:	str	r1, [sp, #0]
    fca8:	mov	r9, r0
    fcaa:	str	r2, [sp, #20]
    fcac:	str	r3, [sp, #12]
    fcae:	vmov	sl, s0
    fcb2:	mov	fp, r7
    fcb4:	cbz	r4, fccc <_dtoa_r+0x34>
    fcb6:	ldr	r2, [r0, #68]	; 0x44
    fcb8:	str	r2, [r4, #4]
    fcba:	movs	r3, #1
    fcbc:	lsls	r3, r2
    fcbe:	str	r3, [r4, #8]
    fcc0:	mov	r1, r4
    fcc2:	bl	115ac <_Bfree>
    fcc6:	movs	r3, #0
    fcc8:	str.w	r3, [r9, #64]	; 0x40
    fccc:	cmp.w	fp, #0
    fcd0:	mov	r4, fp
    fcd2:	blt.n	fd3e <_dtoa_r+0xa6>
    fcd4:	movs	r3, #0
    fcd6:	str	r3, [r5, #0]
    fcd8:	ldr	r3, [pc, #644]	; (ff60 <_dtoa_r+0x2c8>)
    fcda:	mov	r2, r3
    fcdc:	ands	r3, r4
    fcde:	cmp	r3, r2
    fce0:	beq.n	fd10 <_dtoa_r+0x78>
    fce2:	movs	r2, #0
    fce4:	movs	r3, #0
    fce6:	mov	r0, sl
    fce8:	mov	r1, fp
    fcea:	bl	ac88 <__aeabi_dcmpeq>
    fcee:	mov	r6, sl
    fcf0:	mov	r7, fp
    fcf2:	mov	r8, r0
    fcf4:	cbz	r0, fd4a <_dtoa_r+0xb2>
    fcf6:	ldr	r2, [sp, #12]
    fcf8:	movs	r3, #1
    fcfa:	str	r3, [r2, #0]
    fcfc:	ldr	r3, [sp, #148]	; 0x94
    fcfe:	cmp	r3, #0
    fd00:	beq.w	fe80 <_dtoa_r+0x1e8>
    fd04:	ldr	r0, [pc, #604]	; (ff64 <_dtoa_r+0x2cc>)
    fd06:	str	r0, [r3, #0]
    fd08:	subs	r0, #1
    fd0a:	add	sp, #108	; 0x6c
    fd0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fd10:	ldr	r2, [sp, #12]
    fd12:	movw	r3, #9999	; 0x270f
    fd16:	str	r3, [r2, #0]
    fd18:	cmp.w	sl, #0
    fd1c:	beq.w	fe54 <_dtoa_r+0x1bc>
    fd20:	ldr	r0, [pc, #580]	; (ff68 <_dtoa_r+0x2d0>)
    fd22:	ldr	r3, [sp, #148]	; 0x94
    fd24:	cmp	r3, #0
    fd26:	beq.n	fd0a <_dtoa_r+0x72>
    fd28:	ldrb	r3, [r0, #3]
    fd2a:	cmp	r3, #0
    fd2c:	beq.w	fe84 <_dtoa_r+0x1ec>
    fd30:	add.w	r3, r0, #8
    fd34:	ldr	r2, [sp, #148]	; 0x94
    fd36:	str	r3, [r2, #0]
    fd38:	add	sp, #108	; 0x6c
    fd3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fd3e:	movs	r3, #1
    fd40:	bic.w	r4, fp, #2147483648	; 0x80000000
    fd44:	str	r3, [r5, #0]
    fd46:	mov	fp, r4
    fd48:	b.n	fcd8 <_dtoa_r+0x40>
    fd4a:	add	r2, sp, #96	; 0x60
    fd4c:	add	r1, sp, #100	; 0x64
    fd4e:	vmov	d0, r6, r7
    fd52:	mov	r0, r9
    fd54:	bl	11c84 <__d2b>
    fd58:	lsrs	r5, r4, #20
    fd5a:	str	r0, [sp, #40]	; 0x28
    fd5c:	bne.w	fe66 <_dtoa_r+0x1ce>
    fd60:	ldr	r5, [sp, #96]	; 0x60
    fd62:	ldr	r6, [sp, #100]	; 0x64
    fd64:	add	r6, r5
    fd66:	addw	r3, r6, #1074	; 0x432
    fd6a:	cmp	r3, #32
    fd6c:	ble.w	10280 <_dtoa_r+0x5e8>
    fd70:	rsb	r3, r3, #64	; 0x40
    fd74:	addw	r0, r6, #1042	; 0x412
    fd78:	lsls	r4, r3
    fd7a:	lsr.w	r0, sl, r0
    fd7e:	orrs	r0, r4
    fd80:	bl	a6cc <__aeabi_ui2d>
    fd84:	movs	r3, #1
    fd86:	subs	r4, r6, #1
    fd88:	sub.w	r1, r1, #32505856	; 0x1f00000
    fd8c:	str	r3, [sp, #60]	; 0x3c
    fd8e:	movs	r2, #0
    fd90:	ldr	r3, [pc, #472]	; (ff6c <_dtoa_r+0x2d4>)
    fd92:	bl	a450 <__aeabi_dsub>
    fd96:	add	r3, pc, #432	; (adr r3, ff48 <_dtoa_r+0x2b0>)
    fd98:	ldrd	r2, r3, [r3]
    fd9c:	bl	a7b8 <__aeabi_dmul>
    fda0:	add	r3, pc, #428	; (adr r3, ff50 <_dtoa_r+0x2b8>)
    fda2:	ldrd	r2, r3, [r3]
    fda6:	bl	a454 <__adddf3>
    fdaa:	mov	r6, r0
    fdac:	mov	r0, r4
    fdae:	mov	r7, r1
    fdb0:	bl	a6ec <__aeabi_i2d>
    fdb4:	add	r3, pc, #416	; (adr r3, ff58 <_dtoa_r+0x2c0>)
    fdb6:	ldrd	r2, r3, [r3]
    fdba:	bl	a7b8 <__aeabi_dmul>
    fdbe:	mov	r2, r0
    fdc0:	mov	r3, r1
    fdc2:	mov	r0, r6
    fdc4:	mov	r1, r7
    fdc6:	bl	a454 <__adddf3>
    fdca:	mov	r6, r0
    fdcc:	mov	r7, r1
    fdce:	bl	ad18 <__aeabi_d2iz>
    fdd2:	movs	r2, #0
    fdd4:	str	r0, [sp, #16]
    fdd6:	movs	r3, #0
    fdd8:	mov	r0, r6
    fdda:	mov	r1, r7
    fddc:	bl	ac9c <__aeabi_dcmplt>
    fde0:	cmp	r0, #0
    fde2:	bne.w	10236 <_dtoa_r+0x59e>
    fde6:	ldr	r6, [sp, #16]
    fde8:	cmp	r6, #22
    fdea:	bhi.w	10230 <_dtoa_r+0x598>
    fdee:	ldr	r3, [pc, #384]	; (ff70 <_dtoa_r+0x2d8>)
    fdf0:	add.w	r3, r3, r6, lsl #3
    fdf4:	ldrd	r0, r1, [r3]
    fdf8:	mov	r2, sl
    fdfa:	mov	r3, fp
    fdfc:	bl	acd8 <__aeabi_dcmpgt>
    fe00:	cmp	r0, #0
    fe02:	beq.w	1028a <_dtoa_r+0x5f2>
    fe06:	subs	r3, r6, #1
    fe08:	str	r3, [sp, #16]
    fe0a:	movs	r3, #0
    fe0c:	str	r3, [sp, #52]	; 0x34
    fe0e:	subs	r5, r5, r4
    fe10:	subs.w	r8, r5, #1
    fe14:	bmi.w	1026c <_dtoa_r+0x5d4>
    fe18:	movs	r3, #0
    fe1a:	str	r3, [sp, #28]
    fe1c:	ldr	r3, [sp, #16]
    fe1e:	cmp	r3, #0
    fe20:	blt.w	1025a <_dtoa_r+0x5c2>
    fe24:	add	r8, r3
    fe26:	str	r3, [sp, #48]	; 0x30
    fe28:	movs	r3, #0
    fe2a:	str	r3, [sp, #24]
    fe2c:	ldr	r3, [sp, #0]
    fe2e:	cmp	r3, #9
    fe30:	bhi.n	fe88 <_dtoa_r+0x1f0>
    fe32:	cmp	r3, #5
    fe34:	ble.w	10ac0 <_dtoa_r+0xe28>
    fe38:	subs	r3, #4
    fe3a:	str	r3, [sp, #0]
    fe3c:	movs	r6, #0
    fe3e:	ldr	r3, [sp, #0]
    fe40:	subs	r3, #2
    fe42:	cmp	r3, #3
    fe44:	bhi.w	10a8e <_dtoa_r+0xdf6>
    fe48:	tbh	[pc, r3, lsl #1]
    fe4c:	.word	0x0224032b
    fe50:	.word	0x04500336
    fe54:	ldr	r3, [pc, #272]	; (ff68 <_dtoa_r+0x2d0>)
    fe56:	ldr	r2, [pc, #284]	; (ff74 <_dtoa_r+0x2dc>)
    fe58:	ubfx	r0, r4, #0, #20
    fe5c:	cmp	r0, #0
    fe5e:	ite	ne
    fe60:	movne	r0, r3
    fe62:	moveq	r0, r2
    fe64:	b.n	fd22 <_dtoa_r+0x8a>
    fe66:	ubfx	r3, fp, #0, #20
    fe6a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    fe6e:	subw	r4, r5, #1023	; 0x3ff
    fe72:	mov	r0, sl
    fe74:	str.w	r8, [sp, #60]	; 0x3c
    fe78:	orr.w	r1, r1, #3145728	; 0x300000
    fe7c:	ldr	r5, [sp, #96]	; 0x60
    fe7e:	b.n	fd8e <_dtoa_r+0xf6>
    fe80:	ldr	r0, [pc, #244]	; (ff78 <_dtoa_r+0x2e0>)
    fe82:	b.n	fd0a <_dtoa_r+0x72>
    fe84:	adds	r3, r0, #3
    fe86:	b.n	fd34 <_dtoa_r+0x9c>
    fe88:	movs	r1, #0
    fe8a:	str.w	r1, [r9, #68]	; 0x44
    fe8e:	mov	r0, r9
    fe90:	mov	r4, r1
    fe92:	str	r1, [sp, #0]
    fe94:	bl	11560 <_Balloc>
    fe98:	mov.w	r3, #4294967295
    fe9c:	str	r3, [sp, #32]
    fe9e:	str	r3, [sp, #56]	; 0x38
    fea0:	movs	r3, #1
    fea2:	str	r0, [sp, #36]	; 0x24
    fea4:	str.w	r0, [r9, #64]	; 0x40
    fea8:	str	r4, [sp, #20]
    feaa:	str	r3, [sp, #44]	; 0x2c
    feac:	ldr	r3, [sp, #100]	; 0x64
    feae:	cmp	r3, #0
    feb0:	blt.w	10054 <_dtoa_r+0x3bc>
    feb4:	ldr	r2, [sp, #16]
    feb6:	cmp	r2, #14
    feb8:	bgt.w	10054 <_dtoa_r+0x3bc>
    febc:	ldr	r3, [pc, #176]	; (ff70 <_dtoa_r+0x2d8>)
    febe:	add.w	r3, r3, r2, lsl #3
    fec2:	vldr	d7, [r3]
    fec6:	ldr	r3, [sp, #20]
    fec8:	cmp	r3, #0
    feca:	vstr	d7, [sp]
    fece:	blt.w	104ce <_dtoa_r+0x836>
    fed2:	mov	r6, sl
    fed4:	mov	r7, fp
    fed6:	ldrd	sl, fp, [sp]
    feda:	mov	r0, r6
    fedc:	mov	r2, sl
    fede:	mov	r3, fp
    fee0:	mov	r1, r7
    fee2:	bl	aa0c <__aeabi_ddiv>
    fee6:	bl	ad18 <__aeabi_d2iz>
    feea:	mov	r4, r0
    feec:	bl	a6ec <__aeabi_i2d>
    fef0:	mov	r2, sl
    fef2:	mov	r3, fp
    fef4:	bl	a7b8 <__aeabi_dmul>
    fef8:	mov	r3, r1
    fefa:	mov	r2, r0
    fefc:	mov	r1, r7
    fefe:	mov	r0, r6
    ff00:	bl	a450 <__aeabi_dsub>
    ff04:	ldr	r5, [sp, #36]	; 0x24
    ff06:	add.w	r3, r4, #48	; 0x30
    ff0a:	strb	r3, [r5, #0]
    ff0c:	ldr	r3, [sp, #32]
    ff0e:	cmp	r3, #1
    ff10:	mov	r6, r0
    ff12:	mov	r7, r1
    ff14:	add.w	r5, r5, #1
    ff18:	beq.n	ffde <_dtoa_r+0x346>
    ff1a:	movs	r2, #0
    ff1c:	ldr	r3, [pc, #92]	; (ff7c <_dtoa_r+0x2e4>)
    ff1e:	bl	a7b8 <__aeabi_dmul>
    ff22:	movs	r2, #0
    ff24:	movs	r3, #0
    ff26:	mov	r6, r0
    ff28:	mov	r7, r1
    ff2a:	bl	ac88 <__aeabi_dcmpeq>
    ff2e:	cmp	r0, #0
    ff30:	bne.n	1002e <_dtoa_r+0x396>
    ff32:	str.w	r9, [sp, #20]
    ff36:	ldr.w	sl, [sp, #32]
    ff3a:	ldr.w	fp, [sp, #36]	; 0x24
    ff3e:	ldrd	r8, r9, [sp]
    ff42:	b.n	ff96 <_dtoa_r+0x2fe>
    ff44:	nop.w
    ff48:	.word	0x636f4361
    ff4c:	.word	0x3fd287a7
    ff50:	.word	0x8b60c8b3
    ff54:	.word	0x3fc68a28
    ff58:	.word	0x509f79fb
    ff5c:	.word	0x3fd34413
    ff60:	.word	0x7ff00000
    ff64:	.word	0x000134b1
    ff68:	.word	0x00013600
    ff6c:	.word	0x3ff80000
    ff70:	.word	0x00013708
    ff74:	.word	0x000135f4
    ff78:	.word	0x000134b0
    ff7c:	.word	0x40240000
    ff80:	bl	a7b8 <__aeabi_dmul>
    ff84:	movs	r2, #0
    ff86:	movs	r3, #0
    ff88:	mov	r6, r0
    ff8a:	mov	r7, r1
    ff8c:	bl	ac88 <__aeabi_dcmpeq>
    ff90:	cmp	r0, #0
    ff92:	bne.w	106f2 <_dtoa_r+0xa5a>
    ff96:	mov	r2, r8
    ff98:	mov	r3, r9
    ff9a:	mov	r0, r6
    ff9c:	mov	r1, r7
    ff9e:	bl	aa0c <__aeabi_ddiv>
    ffa2:	bl	ad18 <__aeabi_d2iz>
    ffa6:	mov	r4, r0
    ffa8:	bl	a6ec <__aeabi_i2d>
    ffac:	mov	r2, r8
    ffae:	mov	r3, r9
    ffb0:	bl	a7b8 <__aeabi_dmul>
    ffb4:	mov	r2, r0
    ffb6:	mov	r3, r1
    ffb8:	mov	r0, r6
    ffba:	mov	r1, r7
    ffbc:	bl	a450 <__aeabi_dsub>
    ffc0:	add.w	lr, r4, #48	; 0x30
    ffc4:	strb.w	lr, [r5], #1
    ffc8:	rsb	lr, fp, r5
    ffcc:	cmp	lr, sl
    ffce:	mov	r6, r0
    ffd0:	mov	r7, r1
    ffd2:	mov.w	r2, #0
    ffd6:	ldr	r3, [pc, #696]	; (10290 <_dtoa_r+0x5f8>)
    ffd8:	bne.n	ff80 <_dtoa_r+0x2e8>
    ffda:	ldr.w	r9, [sp, #20]
    ffde:	mov	r2, r6
    ffe0:	mov	r3, r7
    ffe2:	mov	r0, r6
    ffe4:	mov	r1, r7
    ffe6:	bl	a454 <__adddf3>
    ffea:	mov	r6, r0
    ffec:	mov	r7, r1
    ffee:	mov	r2, r0
    fff0:	mov	r3, r1
    fff2:	ldrd	r0, r1, [sp]
    fff6:	bl	ac9c <__aeabi_dcmplt>
    fffa:	cbnz	r0, 1000e <_dtoa_r+0x376>
    fffc:	mov	r2, r6
    fffe:	mov	r3, r7
   10000:	ldrd	r0, r1, [sp]
   10004:	bl	ac88 <__aeabi_dcmpeq>
   10008:	cbz	r0, 1002e <_dtoa_r+0x396>
   1000a:	lsls	r3, r4, #31
   1000c:	bpl.n	1002e <_dtoa_r+0x396>
   1000e:	ldrb.w	r4, [r5, #-1]
   10012:	ldr	r2, [sp, #36]	; 0x24
   10014:	subs	r3, r5, #1
   10016:	b.n	10022 <_dtoa_r+0x38a>
   10018:	cmp	r2, r3
   1001a:	beq.w	10816 <_dtoa_r+0xb7e>
   1001e:	ldrb.w	r4, [r3, #-1]!
   10022:	cmp	r4, #57	; 0x39
   10024:	add.w	r5, r3, #1
   10028:	beq.n	10018 <_dtoa_r+0x380>
   1002a:	adds	r4, #1
   1002c:	strb	r4, [r3, #0]
   1002e:	ldr	r1, [sp, #40]	; 0x28
   10030:	mov	r0, r9
   10032:	bl	115ac <_Bfree>
   10036:	movs	r2, #0
   10038:	ldr	r3, [sp, #16]
   1003a:	strb	r2, [r5, #0]
   1003c:	ldr	r2, [sp, #12]
   1003e:	adds	r3, #1
   10040:	str	r3, [r2, #0]
   10042:	ldr	r3, [sp, #148]	; 0x94
   10044:	cmp	r3, #0
   10046:	beq.w	10780 <_dtoa_r+0xae8>
   1004a:	ldr	r0, [sp, #36]	; 0x24
   1004c:	str	r5, [r3, #0]
   1004e:	add	sp, #108	; 0x6c
   10050:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10054:	ldr	r2, [sp, #44]	; 0x2c
   10056:	cmp	r2, #0
   10058:	beq.w	10278 <_dtoa_r+0x5e0>
   1005c:	ldr	r2, [sp, #0]
   1005e:	cmp	r2, #1
   10060:	ble.w	10512 <_dtoa_r+0x87a>
   10064:	ldr	r3, [sp, #32]
   10066:	ldr	r2, [sp, #24]
   10068:	subs	r7, r3, #1
   1006a:	cmp	r2, r7
   1006c:	blt.w	10786 <_dtoa_r+0xaee>
   10070:	subs	r7, r2, r7
   10072:	ldr	r3, [sp, #32]
   10074:	cmp	r3, #0
   10076:	blt.w	1097a <_dtoa_r+0xce2>
   1007a:	ldr	r5, [sp, #28]
   1007c:	ldr	r3, [sp, #32]
   1007e:	ldr	r2, [sp, #28]
   10080:	movs	r1, #1
   10082:	add	r2, r3
   10084:	mov	r0, r9
   10086:	str	r2, [sp, #28]
   10088:	add	r8, r3
   1008a:	bl	11774 <__i2b>
   1008e:	mov	r6, r0
   10090:	cbz	r5, 100ac <_dtoa_r+0x414>
   10092:	cmp.w	r8, #0
   10096:	ble.n	100ac <_dtoa_r+0x414>
   10098:	cmp	r5, r8
   1009a:	ldr	r2, [sp, #28]
   1009c:	mov	r3, r5
   1009e:	it	ge
   100a0:	movge	r3, r8
   100a2:	subs	r2, r2, r3
   100a4:	str	r2, [sp, #28]
   100a6:	subs	r5, r5, r3
   100a8:	rsb	r8, r3, r8
   100ac:	ldr	r3, [sp, #24]
   100ae:	cmp	r3, #0
   100b0:	ble.w	1069e <_dtoa_r+0xa06>
   100b4:	ldr	r2, [sp, #44]	; 0x2c
   100b6:	cmp	r2, #0
   100b8:	beq.w	104c0 <_dtoa_r+0x828>
   100bc:	cmp	r7, #0
   100be:	beq.w	104c0 <_dtoa_r+0x828>
   100c2:	mov	r1, r6
   100c4:	mov	r2, r7
   100c6:	mov	r0, r9
   100c8:	bl	118b8 <__pow5mult>
   100cc:	ldr	r2, [sp, #40]	; 0x28
   100ce:	mov	r1, r0
   100d0:	mov	r6, r0
   100d2:	mov	r0, r9
   100d4:	bl	11788 <__multiply>
   100d8:	ldr	r1, [sp, #40]	; 0x28
   100da:	mov	r4, r0
   100dc:	mov	r0, r9
   100de:	bl	115ac <_Bfree>
   100e2:	ldr	r3, [sp, #24]
   100e4:	subs	r3, r3, r7
   100e6:	str	r3, [sp, #24]
   100e8:	bne.w	104be <_dtoa_r+0x826>
   100ec:	movs	r1, #1
   100ee:	mov	r0, r9
   100f0:	bl	11774 <__i2b>
   100f4:	ldr	r3, [sp, #48]	; 0x30
   100f6:	str	r0, [sp, #24]
   100f8:	cmp	r3, #0
   100fa:	beq.w	10528 <_dtoa_r+0x890>
   100fe:	mov	r1, r0
   10100:	mov	r2, r3
   10102:	mov	r0, r9
   10104:	bl	118b8 <__pow5mult>
   10108:	ldr	r3, [sp, #0]
   1010a:	str	r0, [sp, #24]
   1010c:	cmp	r3, #1
   1010e:	ble.w	106f8 <_dtoa_r+0xa60>
   10112:	movs	r7, #0
   10114:	ldr	r2, [sp, #24]
   10116:	ldr	r3, [r2, #16]
   10118:	add.w	r3, r2, r3, lsl #2
   1011c:	ldr	r0, [r3, #16]
   1011e:	bl	116d8 <__hi0bits>
   10122:	rsb	r0, r0, #32
   10126:	add	r0, r8
   10128:	ands.w	r0, r0, #31
   1012c:	beq.w	10524 <_dtoa_r+0x88c>
   10130:	rsb	r3, r0, #32
   10134:	cmp	r3, #4
   10136:	ble.w	10ab4 <_dtoa_r+0xe1c>
   1013a:	rsb	r0, r0, #28
   1013e:	ldr	r3, [sp, #28]
   10140:	add	r3, r0
   10142:	str	r3, [sp, #28]
   10144:	add	r5, r0
   10146:	add	r8, r0
   10148:	ldr	r3, [sp, #28]
   1014a:	cmp	r3, #0
   1014c:	ble.n	1015a <_dtoa_r+0x4c2>
   1014e:	mov	r1, r4
   10150:	mov	r2, r3
   10152:	mov	r0, r9
   10154:	bl	11958 <__lshift>
   10158:	mov	r4, r0
   1015a:	cmp.w	r8, #0
   1015e:	ble.n	1016c <_dtoa_r+0x4d4>
   10160:	mov	r2, r8
   10162:	ldr	r1, [sp, #24]
   10164:	mov	r0, r9
   10166:	bl	11958 <__lshift>
   1016a:	str	r0, [sp, #24]
   1016c:	ldr	r3, [sp, #52]	; 0x34
   1016e:	cmp	r3, #0
   10170:	bne.w	10668 <_dtoa_r+0x9d0>
   10174:	ldr	r3, [sp, #32]
   10176:	cmp	r3, #0
   10178:	ble.w	106a2 <_dtoa_r+0xa0a>
   1017c:	ldr	r3, [sp, #44]	; 0x2c
   1017e:	cmp	r3, #0
   10180:	bne.w	1056c <_dtoa_r+0x8d4>
   10184:	ldr.w	fp, [sp, #36]	; 0x24
   10188:	ldr	r7, [sp, #32]
   1018a:	ldr.w	r8, [sp, #24]
   1018e:	mov	r5, fp
   10190:	b.n	10198 <_dtoa_r+0x500>
   10192:	bl	115c0 <__multadd>
   10196:	mov	r4, r0
   10198:	mov	r1, r8
   1019a:	mov	r0, r4
   1019c:	bl	fb6c <quorem>
   101a0:	add.w	sl, r0, #48	; 0x30
   101a4:	strb.w	sl, [r5], #1
   101a8:	rsb	r3, fp, r5
   101ac:	cmp	r3, r7
   101ae:	mov.w	r2, #10
   101b2:	mov.w	r3, #0
   101b6:	mov	r1, r4
   101b8:	mov	r0, r9
   101ba:	blt.n	10192 <_dtoa_r+0x4fa>
   101bc:	ldr	r3, [sp, #36]	; 0x24
   101be:	ldr	r2, [sp, #32]
   101c0:	cmp	r2, #1
   101c2:	ite	ge
   101c4:	addge	r3, r3, r2
   101c6:	addlt	r3, #1
   101c8:	mov	r5, r3
   101ca:	mov.w	fp, #0
   101ce:	mov	r1, r4
   101d0:	movs	r2, #1
   101d2:	mov	r0, r9
   101d4:	bl	11958 <__lshift>
   101d8:	ldr	r1, [sp, #24]
   101da:	str	r0, [sp, #40]	; 0x28
   101dc:	bl	11a08 <__mcmp>
   101e0:	cmp	r0, #0
   101e2:	ble.w	107f0 <_dtoa_r+0xb58>
   101e6:	ldrb.w	r2, [r5, #-1]
   101ea:	ldr	r1, [sp, #36]	; 0x24
   101ec:	subs	r3, r5, #1
   101ee:	b.n	101fa <_dtoa_r+0x562>
   101f0:	cmp	r3, r1
   101f2:	beq.w	106de <_dtoa_r+0xa46>
   101f6:	ldrb.w	r2, [r3, #-1]!
   101fa:	cmp	r2, #57	; 0x39
   101fc:	add.w	r5, r3, #1
   10200:	beq.n	101f0 <_dtoa_r+0x558>
   10202:	adds	r2, #1
   10204:	strb	r2, [r3, #0]
   10206:	ldr	r1, [sp, #24]
   10208:	mov	r0, r9
   1020a:	bl	115ac <_Bfree>
   1020e:	cmp	r6, #0
   10210:	beq.w	1002e <_dtoa_r+0x396>
   10214:	cmp.w	fp, #0
   10218:	beq.n	10226 <_dtoa_r+0x58e>
   1021a:	cmp	fp, r6
   1021c:	beq.n	10226 <_dtoa_r+0x58e>
   1021e:	mov	r1, fp
   10220:	mov	r0, r9
   10222:	bl	115ac <_Bfree>
   10226:	mov	r1, r6
   10228:	mov	r0, r9
   1022a:	bl	115ac <_Bfree>
   1022e:	b.n	1002e <_dtoa_r+0x396>
   10230:	movs	r3, #1
   10232:	str	r3, [sp, #52]	; 0x34
   10234:	b.n	fe0e <_dtoa_r+0x176>
   10236:	ldr.w	r8, [sp, #16]
   1023a:	mov	r0, r8
   1023c:	bl	a6ec <__aeabi_i2d>
   10240:	mov	r2, r0
   10242:	mov	r3, r1
   10244:	mov	r0, r6
   10246:	mov	r1, r7
   10248:	bl	ac88 <__aeabi_dcmpeq>
   1024c:	cmp	r0, #0
   1024e:	bne.w	fde6 <_dtoa_r+0x14e>
   10252:	add.w	r3, r8, #4294967295
   10256:	str	r3, [sp, #16]
   10258:	b.n	fde6 <_dtoa_r+0x14e>
   1025a:	ldr	r2, [sp, #28]
   1025c:	ldr	r3, [sp, #16]
   1025e:	subs	r2, r2, r3
   10260:	negs	r3, r3
   10262:	str	r3, [sp, #24]
   10264:	movs	r3, #0
   10266:	str	r2, [sp, #28]
   10268:	str	r3, [sp, #48]	; 0x30
   1026a:	b.n	fe2c <_dtoa_r+0x194>
   1026c:	rsb	r3, r8, #0
   10270:	str	r3, [sp, #28]
   10272:	mov.w	r8, #0
   10276:	b.n	fe1c <_dtoa_r+0x184>
   10278:	ldr	r7, [sp, #24]
   1027a:	ldr	r5, [sp, #28]
   1027c:	ldr	r6, [sp, #44]	; 0x2c
   1027e:	b.n	10090 <_dtoa_r+0x3f8>
   10280:	rsb	r4, r3, #32
   10284:	lsl.w	r0, sl, r4
   10288:	b.n	fd80 <_dtoa_r+0xe8>
   1028a:	str	r0, [sp, #52]	; 0x34
   1028c:	b.n	fe0e <_dtoa_r+0x176>
   1028e:	nop
   10290:	.word	0x40240000
   10294:	movs	r3, #0
   10296:	str	r3, [sp, #44]	; 0x2c
   10298:	ldr	r3, [sp, #16]
   1029a:	ldr	r2, [sp, #20]
   1029c:	add	r3, r2
   1029e:	str	r3, [sp, #56]	; 0x38
   102a0:	adds	r3, #1
   102a2:	cmp	r3, #0
   102a4:	str	r3, [sp, #32]
   102a6:	ble.w	107a4 <_dtoa_r+0xb0c>
   102aa:	ldr	r4, [sp, #32]
   102ac:	mov	r5, r4
   102ae:	movs	r1, #0
   102b0:	cmp	r5, #23
   102b2:	str.w	r1, [r9, #68]	; 0x44
   102b6:	bls.n	102d0 <_dtoa_r+0x638>
   102b8:	movs	r2, #1
   102ba:	movs	r3, #4
   102bc:	lsls	r3, r3, #1
   102be:	add.w	r0, r3, #20
   102c2:	cmp	r0, r5
   102c4:	mov	r1, r2
   102c6:	add.w	r2, r2, #1
   102ca:	bls.n	102bc <_dtoa_r+0x624>
   102cc:	str.w	r1, [r9, #68]	; 0x44
   102d0:	mov	r0, r9
   102d2:	bl	11560 <_Balloc>
   102d6:	cmp	r4, #14
   102d8:	str	r0, [sp, #36]	; 0x24
   102da:	str.w	r0, [r9, #64]	; 0x40
   102de:	bhi.w	feac <_dtoa_r+0x214>
   102e2:	cmp	r6, #0
   102e4:	beq.w	feac <_dtoa_r+0x214>
   102e8:	ldr	r1, [sp, #16]
   102ea:	cmp	r1, #0
   102ec:	strd	sl, fp, [sp, #64]	; 0x40
   102f0:	ble.w	10828 <_dtoa_r+0xb90>
   102f4:	ldr	r3, [pc, #576]	; (10538 <_dtoa_r+0x8a0>)
   102f6:	and.w	r2, r1, #15
   102fa:	asrs	r6, r1, #4
   102fc:	add.w	r3, r3, r2, lsl #3
   10300:	lsls	r0, r6, #27
   10302:	ldrd	r4, r5, [r3]
   10306:	bpl.w	10796 <_dtoa_r+0xafe>
   1030a:	ldr	r3, [pc, #560]	; (1053c <_dtoa_r+0x8a4>)
   1030c:	mov	r0, sl
   1030e:	mov	r1, fp
   10310:	ldrd	r2, r3, [r3, #32]
   10314:	bl	aa0c <__aeabi_ddiv>
   10318:	strd	r0, r1, [sp, #72]	; 0x48
   1031c:	and.w	r6, r6, #15
   10320:	mov.w	sl, #3
   10324:	cbz	r6, 10348 <_dtoa_r+0x6b0>
   10326:	ldr	r7, [pc, #532]	; (1053c <_dtoa_r+0x8a4>)
   10328:	lsls	r1, r6, #31
   1032a:	bpl.n	10340 <_dtoa_r+0x6a8>
   1032c:	mov	r0, r4
   1032e:	mov	r1, r5
   10330:	ldrd	r2, r3, [r7]
   10334:	bl	a7b8 <__aeabi_dmul>
   10338:	add.w	sl, sl, #1
   1033c:	mov	r4, r0
   1033e:	mov	r5, r1
   10340:	asrs	r6, r6, #1
   10342:	add.w	r7, r7, #8
   10346:	bne.n	10328 <_dtoa_r+0x690>
   10348:	mov	r2, r4
   1034a:	mov	r3, r5
   1034c:	ldrd	r0, r1, [sp, #72]	; 0x48
   10350:	bl	aa0c <__aeabi_ddiv>
   10354:	mov	r6, r0
   10356:	mov	r7, r1
   10358:	ldr	r3, [sp, #52]	; 0x34
   1035a:	cbz	r3, 1036e <_dtoa_r+0x6d6>
   1035c:	movs	r2, #0
   1035e:	ldr	r3, [pc, #480]	; (10540 <_dtoa_r+0x8a8>)
   10360:	mov	r0, r6
   10362:	mov	r1, r7
   10364:	bl	ac9c <__aeabi_dcmplt>
   10368:	cmp	r0, #0
   1036a:	bne.w	109a2 <_dtoa_r+0xd0a>
   1036e:	mov	r0, sl
   10370:	bl	a6ec <__aeabi_i2d>
   10374:	mov	r2, r6
   10376:	mov	r3, r7
   10378:	bl	a7b8 <__aeabi_dmul>
   1037c:	ldr	r3, [pc, #452]	; (10544 <_dtoa_r+0x8ac>)
   1037e:	movs	r2, #0
   10380:	bl	a454 <__adddf3>
   10384:	ldr	r3, [sp, #32]
   10386:	mov	r4, r0
   10388:	sub.w	r5, r1, #54525952	; 0x3400000
   1038c:	cmp	r3, #0
   1038e:	beq.w	10748 <_dtoa_r+0xab0>
   10392:	ldr	r3, [sp, #16]
   10394:	str	r3, [sp, #88]	; 0x58
   10396:	ldr	r3, [sp, #32]
   10398:	str	r3, [sp, #72]	; 0x48
   1039a:	ldr	r3, [sp, #44]	; 0x2c
   1039c:	cmp	r3, #0
   1039e:	beq.w	108ca <_dtoa_r+0xc32>
   103a2:	ldr	r2, [sp, #72]	; 0x48
   103a4:	ldr	r3, [pc, #400]	; (10538 <_dtoa_r+0x8a0>)
   103a6:	ldr	r1, [pc, #416]	; (10548 <_dtoa_r+0x8b0>)
   103a8:	add.w	r3, r3, r2, lsl #3
   103ac:	ldrd	r2, r3, [r3, #-8]
   103b0:	movs	r0, #0
   103b2:	bl	aa0c <__aeabi_ddiv>
   103b6:	mov	r2, r4
   103b8:	mov	r3, r5
   103ba:	bl	a450 <__aeabi_dsub>
   103be:	mov	sl, r0
   103c0:	mov	fp, r1
   103c2:	mov	r0, r6
   103c4:	mov	r1, r7
   103c6:	bl	ad18 <__aeabi_d2iz>
   103ca:	mov	r4, r0
   103cc:	bl	a6ec <__aeabi_i2d>
   103d0:	mov	r2, r0
   103d2:	mov	r3, r1
   103d4:	mov	r0, r6
   103d6:	mov	r1, r7
   103d8:	bl	a450 <__aeabi_dsub>
   103dc:	adds	r4, #48	; 0x30
   103de:	ldr	r5, [sp, #36]	; 0x24
   103e0:	uxtb	r4, r4
   103e2:	mov	r6, r0
   103e4:	mov	r7, r1
   103e6:	strb	r4, [r5, #0]
   103e8:	mov	r2, r0
   103ea:	mov	r3, r1
   103ec:	mov	r0, sl
   103ee:	mov	r1, fp
   103f0:	adds	r5, #1
   103f2:	bl	acd8 <__aeabi_dcmpgt>
   103f6:	cmp	r0, #0
   103f8:	bne.n	1049c <_dtoa_r+0x804>
   103fa:	mov	r2, r6
   103fc:	mov	r3, r7
   103fe:	movs	r0, #0
   10400:	ldr	r1, [pc, #316]	; (10540 <_dtoa_r+0x8a8>)
   10402:	bl	a450 <__aeabi_dsub>
   10406:	mov	r2, r0
   10408:	mov	r3, r1
   1040a:	mov	r0, sl
   1040c:	mov	r1, fp
   1040e:	bl	acd8 <__aeabi_dcmpgt>
   10412:	cmp	r0, #0
   10414:	bne.w	10a28 <_dtoa_r+0xd90>
   10418:	ldr	r2, [sp, #72]	; 0x48
   1041a:	cmp	r2, #1
   1041c:	ble.w	1080e <_dtoa_r+0xb76>
   10420:	ldr	r3, [sp, #72]	; 0x48
   10422:	ldr	r2, [sp, #36]	; 0x24
   10424:	str.w	r8, [sp, #72]	; 0x48
   10428:	add	r3, r2
   1042a:	mov	r8, r3
   1042c:	b.n	1044a <_dtoa_r+0x7b2>
   1042e:	movs	r0, #0
   10430:	ldr	r1, [pc, #268]	; (10540 <_dtoa_r+0x8a8>)
   10432:	bl	a450 <__aeabi_dsub>
   10436:	mov	r2, sl
   10438:	mov	r3, fp
   1043a:	bl	ac9c <__aeabi_dcmplt>
   1043e:	cmp	r0, #0
   10440:	bne.w	10a28 <_dtoa_r+0xd90>
   10444:	cmp	r5, r8
   10446:	beq.w	1080a <_dtoa_r+0xb72>
   1044a:	mov	r0, sl
   1044c:	mov	r1, fp
   1044e:	movs	r2, #0
   10450:	ldr	r3, [pc, #248]	; (1054c <_dtoa_r+0x8b4>)
   10452:	bl	a7b8 <__aeabi_dmul>
   10456:	movs	r2, #0
   10458:	ldr	r3, [pc, #240]	; (1054c <_dtoa_r+0x8b4>)
   1045a:	mov	sl, r0
   1045c:	mov	fp, r1
   1045e:	mov	r0, r6
   10460:	mov	r1, r7
   10462:	bl	a7b8 <__aeabi_dmul>
   10466:	mov	r7, r1
   10468:	mov	r6, r0
   1046a:	bl	ad18 <__aeabi_d2iz>
   1046e:	mov	r4, r0
   10470:	bl	a6ec <__aeabi_i2d>
   10474:	mov	r2, r0
   10476:	mov	r3, r1
   10478:	mov	r0, r6
   1047a:	mov	r1, r7
   1047c:	bl	a450 <__aeabi_dsub>
   10480:	adds	r4, #48	; 0x30
   10482:	uxtb	r4, r4
   10484:	mov	r2, sl
   10486:	mov	r3, fp
   10488:	strb.w	r4, [r5], #1
   1048c:	mov	r6, r0
   1048e:	mov	r7, r1
   10490:	bl	ac9c <__aeabi_dcmplt>
   10494:	mov	r2, r6
   10496:	mov	r3, r7
   10498:	cmp	r0, #0
   1049a:	beq.n	1042e <_dtoa_r+0x796>
   1049c:	ldr	r3, [sp, #88]	; 0x58
   1049e:	str	r3, [sp, #16]
   104a0:	b.n	1002e <_dtoa_r+0x396>
   104a2:	movs	r3, #0
   104a4:	str	r3, [sp, #44]	; 0x2c
   104a6:	ldr	r3, [sp, #20]
   104a8:	cmp	r3, #0
   104aa:	ble.w	107ae <_dtoa_r+0xb16>
   104ae:	mov	r5, r3
   104b0:	mov	r4, r3
   104b2:	str	r3, [sp, #56]	; 0x38
   104b4:	str	r3, [sp, #32]
   104b6:	b.n	102ae <_dtoa_r+0x616>
   104b8:	movs	r3, #1
   104ba:	str	r3, [sp, #44]	; 0x2c
   104bc:	b.n	104a6 <_dtoa_r+0x80e>
   104be:	str	r4, [sp, #40]	; 0x28
   104c0:	ldr	r2, [sp, #24]
   104c2:	ldr	r1, [sp, #40]	; 0x28
   104c4:	mov	r0, r9
   104c6:	bl	118b8 <__pow5mult>
   104ca:	mov	r4, r0
   104cc:	b.n	100ec <_dtoa_r+0x454>
   104ce:	ldr	r3, [sp, #32]
   104d0:	cmp	r3, #0
   104d2:	bgt.w	fed2 <_dtoa_r+0x23a>
   104d6:	bne.w	10778 <_dtoa_r+0xae0>
   104da:	movs	r2, #0
   104dc:	ldr	r3, [pc, #112]	; (10550 <_dtoa_r+0x8b8>)
   104de:	ldrd	r0, r1, [sp]
   104e2:	bl	a7b8 <__aeabi_dmul>
   104e6:	mov	r3, fp
   104e8:	mov	r2, sl
   104ea:	bl	acc4 <__aeabi_dcmpge>
   104ee:	ldr	r3, [sp, #32]
   104f0:	str	r3, [sp, #24]
   104f2:	mov	r6, r3
   104f4:	cmp	r0, #0
   104f6:	beq.w	106ce <_dtoa_r+0xa36>
   104fa:	ldr	r3, [sp, #20]
   104fc:	ldr	r5, [sp, #36]	; 0x24
   104fe:	mvns	r3, r3
   10500:	str	r3, [sp, #16]
   10502:	ldr	r1, [sp, #24]
   10504:	mov	r0, r9
   10506:	bl	115ac <_Bfree>
   1050a:	cmp	r6, #0
   1050c:	beq.w	1002e <_dtoa_r+0x396>
   10510:	b.n	10226 <_dtoa_r+0x58e>
   10512:	ldr	r2, [sp, #60]	; 0x3c
   10514:	cmp	r2, #0
   10516:	beq.w	1098a <_dtoa_r+0xcf2>
   1051a:	addw	r3, r3, #1075	; 0x433
   1051e:	ldr	r7, [sp, #24]
   10520:	ldr	r5, [sp, #28]
   10522:	b.n	1007e <_dtoa_r+0x3e6>
   10524:	movs	r0, #28
   10526:	b.n	1013e <_dtoa_r+0x4a6>
   10528:	ldr	r3, [sp, #0]
   1052a:	cmp	r3, #1
   1052c:	ble.w	10a30 <_dtoa_r+0xd98>
   10530:	ldr	r7, [sp, #48]	; 0x30
   10532:	movs	r0, #1
   10534:	b.n	10126 <_dtoa_r+0x48e>
   10536:	nop
   10538:	.word	0x00013708
   1053c:	.word	0x000137d0
   10540:	.word	0x3ff00000
   10544:	.word	0x401c0000
   10548:	.word	0x3fe00000
   1054c:	.word	0x40240000
   10550:	.word	0x40140000
   10554:	mov	r1, r6
   10556:	movs	r3, #0
   10558:	movs	r2, #10
   1055a:	mov	r0, r9
   1055c:	bl	115c0 <__multadd>
   10560:	ldr	r3, [sp, #56]	; 0x38
   10562:	cmp	r3, #0
   10564:	mov	r6, r0
   10566:	ble.w	10a84 <_dtoa_r+0xdec>
   1056a:	str	r3, [sp, #32]
   1056c:	cmp	r5, #0
   1056e:	ble.n	1057c <_dtoa_r+0x8e4>
   10570:	mov	r1, r6
   10572:	mov	r2, r5
   10574:	mov	r0, r9
   10576:	bl	11958 <__lshift>
   1057a:	mov	r6, r0
   1057c:	cmp	r7, #0
   1057e:	bne.w	1087a <_dtoa_r+0xbe2>
   10582:	mov	r8, r6
   10584:	ldr	r3, [sp, #32]
   10586:	ldr	r2, [sp, #36]	; 0x24
   10588:	subs	r3, #1
   1058a:	adds	r3, r2, r3
   1058c:	str	r3, [sp, #32]
   1058e:	and.w	r3, sl, #1
   10592:	str	r3, [sp, #40]	; 0x28
   10594:	mov	r7, r2
   10596:	ldr.w	fp, [sp, #24]
   1059a:	mov	r0, r4
   1059c:	mov	r1, fp
   1059e:	bl	fb6c <quorem>
   105a2:	mov	r1, r6
   105a4:	mov	r5, r0
   105a6:	mov	r0, r4
   105a8:	bl	11a08 <__mcmp>
   105ac:	mov	r2, r8
   105ae:	mov	r1, fp
   105b0:	mov	sl, r0
   105b2:	mov	r0, r9
   105b4:	bl	11a4c <__mdiff>
   105b8:	ldr	r2, [r0, #12]
   105ba:	mov	fp, r0
   105bc:	add.w	r3, r5, #48	; 0x30
   105c0:	cmp	r2, #0
   105c2:	bne.n	10658 <_dtoa_r+0x9c0>
   105c4:	mov	r1, r0
   105c6:	mov	r0, r4
   105c8:	str	r3, [sp, #28]
   105ca:	bl	11a08 <__mcmp>
   105ce:	mov	r1, fp
   105d0:	str	r0, [sp, #20]
   105d2:	mov	r0, r9
   105d4:	bl	115ac <_Bfree>
   105d8:	ldr	r2, [sp, #20]
   105da:	ldr	r3, [sp, #28]
   105dc:	cbnz	r2, 105ea <_dtoa_r+0x952>
   105de:	ldr	r1, [sp, #0]
   105e0:	cbnz	r1, 105ea <_dtoa_r+0x952>
   105e2:	ldr	r1, [sp, #40]	; 0x28
   105e4:	cmp	r1, #0
   105e6:	beq.w	10a54 <_dtoa_r+0xdbc>
   105ea:	cmp.w	sl, #0
   105ee:	blt.w	107b8 <_dtoa_r+0xb20>
   105f2:	bne.n	10600 <_dtoa_r+0x968>
   105f4:	ldr	r1, [sp, #0]
   105f6:	cbnz	r1, 10600 <_dtoa_r+0x968>
   105f8:	ldr	r1, [sp, #40]	; 0x28
   105fa:	cmp	r1, #0
   105fc:	beq.w	107b8 <_dtoa_r+0xb20>
   10600:	cmp	r2, #0
   10602:	bgt.w	108a2 <_dtoa_r+0xc0a>
   10606:	ldr	r2, [sp, #32]
   10608:	strb	r3, [r7, #0]
   1060a:	add.w	sl, r7, #1
   1060e:	cmp	r7, r2
   10610:	mov	r5, sl
   10612:	beq.w	108ba <_dtoa_r+0xc22>
   10616:	mov	r1, r4
   10618:	movs	r3, #0
   1061a:	movs	r2, #10
   1061c:	mov	r0, r9
   1061e:	bl	115c0 <__multadd>
   10622:	cmp	r6, r8
   10624:	mov	r4, r0
   10626:	mov	r1, r6
   10628:	mov.w	r3, #0
   1062c:	mov.w	r2, #10
   10630:	mov	r0, r9
   10632:	beq.n	1064c <_dtoa_r+0x9b4>
   10634:	bl	115c0 <__multadd>
   10638:	mov	r1, r8
   1063a:	mov	r6, r0
   1063c:	movs	r3, #0
   1063e:	movs	r2, #10
   10640:	mov	r0, r9
   10642:	bl	115c0 <__multadd>
   10646:	mov	r7, sl
   10648:	mov	r8, r0
   1064a:	b.n	10596 <_dtoa_r+0x8fe>
   1064c:	bl	115c0 <__multadd>
   10650:	mov	r7, sl
   10652:	mov	r6, r0
   10654:	mov	r8, r0
   10656:	b.n	10596 <_dtoa_r+0x8fe>
   10658:	mov	r1, r0
   1065a:	mov	r0, r9
   1065c:	str	r3, [sp, #20]
   1065e:	bl	115ac <_Bfree>
   10662:	movs	r2, #1
   10664:	ldr	r3, [sp, #20]
   10666:	b.n	105ea <_dtoa_r+0x952>
   10668:	ldr	r1, [sp, #24]
   1066a:	mov	r0, r4
   1066c:	bl	11a08 <__mcmp>
   10670:	cmp	r0, #0
   10672:	bge.w	10174 <_dtoa_r+0x4dc>
   10676:	mov	r1, r4
   10678:	ldr	r4, [sp, #16]
   1067a:	movs	r3, #0
   1067c:	subs	r4, #1
   1067e:	movs	r2, #10
   10680:	mov	r0, r9
   10682:	str	r4, [sp, #16]
   10684:	bl	115c0 <__multadd>
   10688:	ldr	r3, [sp, #44]	; 0x2c
   1068a:	mov	r4, r0
   1068c:	cmp	r3, #0
   1068e:	bne.w	10554 <_dtoa_r+0x8bc>
   10692:	ldr	r3, [sp, #56]	; 0x38
   10694:	cmp	r3, #0
   10696:	ble.w	10a74 <_dtoa_r+0xddc>
   1069a:	str	r3, [sp, #32]
   1069c:	b.n	10184 <_dtoa_r+0x4ec>
   1069e:	ldr	r4, [sp, #40]	; 0x28
   106a0:	b.n	100ec <_dtoa_r+0x454>
   106a2:	ldr	r3, [sp, #0]
   106a4:	cmp	r3, #2
   106a6:	ble.w	1017c <_dtoa_r+0x4e4>
   106aa:	ldr	r3, [sp, #32]
   106ac:	cmp	r3, #0
   106ae:	bne.w	109ec <_dtoa_r+0xd54>
   106b2:	ldr	r1, [sp, #24]
   106b4:	movs	r2, #5
   106b6:	mov	r0, r9
   106b8:	bl	115c0 <__multadd>
   106bc:	mov	r1, r0
   106be:	str	r0, [sp, #24]
   106c0:	mov	r0, r4
   106c2:	bl	11a08 <__mcmp>
   106c6:	cmp	r0, #0
   106c8:	str	r4, [sp, #40]	; 0x28
   106ca:	ble.w	104fa <_dtoa_r+0x862>
   106ce:	ldr	r2, [sp, #16]
   106d0:	ldr	r1, [sp, #36]	; 0x24
   106d2:	movs	r3, #49	; 0x31
   106d4:	adds	r2, #1
   106d6:	str	r2, [sp, #16]
   106d8:	strb	r3, [r1, #0]
   106da:	adds	r5, r1, #1
   106dc:	b.n	10502 <_dtoa_r+0x86a>
   106de:	ldr	r2, [sp, #16]
   106e0:	adds	r2, #1
   106e2:	str	r2, [sp, #16]
   106e4:	ldr	r2, [sp, #36]	; 0x24
   106e6:	movs	r3, #49	; 0x31
   106e8:	strb	r3, [r2, #0]
   106ea:	b.n	10206 <_dtoa_r+0x56e>
   106ec:	movs	r3, #1
   106ee:	str	r3, [sp, #44]	; 0x2c
   106f0:	b.n	10298 <_dtoa_r+0x600>
   106f2:	ldr.w	r9, [sp, #20]
   106f6:	b.n	1002e <_dtoa_r+0x396>
   106f8:	cmp.w	sl, #0
   106fc:	bne.w	10112 <_dtoa_r+0x47a>
   10700:	ubfx	r3, fp, #0, #20
   10704:	cmp	r3, #0
   10706:	bne.w	10986 <_dtoa_r+0xcee>
   1070a:	bic.w	r7, fp, #2147483648	; 0x80000000
   1070e:	lsrs	r7, r7, #20
   10710:	lsls	r7, r7, #20
   10712:	cbz	r7, 10720 <_dtoa_r+0xa88>
   10714:	ldr	r3, [sp, #28]
   10716:	adds	r3, #1
   10718:	str	r3, [sp, #28]
   1071a:	add.w	r8, r8, #1
   1071e:	movs	r7, #1
   10720:	ldr	r3, [sp, #48]	; 0x30
   10722:	movs	r0, #1
   10724:	cmp	r3, #0
   10726:	beq.w	10126 <_dtoa_r+0x48e>
   1072a:	b.n	10114 <_dtoa_r+0x47c>
   1072c:	mov	r0, sl
   1072e:	bl	a6ec <__aeabi_i2d>
   10732:	mov	r2, r6
   10734:	mov	r3, r7
   10736:	bl	a7b8 <__aeabi_dmul>
   1073a:	movs	r2, #0
   1073c:	ldr	r3, [pc, #764]	; (10a3c <_dtoa_r+0xda4>)
   1073e:	bl	a454 <__adddf3>
   10742:	mov	r4, r0
   10744:	sub.w	r5, r1, #54525952	; 0x3400000
   10748:	mov	r0, r6
   1074a:	mov	r1, r7
   1074c:	movs	r2, #0
   1074e:	ldr	r3, [pc, #752]	; (10a40 <_dtoa_r+0xda8>)
   10750:	bl	a450 <__aeabi_dsub>
   10754:	mov	r2, r4
   10756:	mov	r3, r5
   10758:	mov	r6, r0
   1075a:	mov	r7, r1
   1075c:	bl	acd8 <__aeabi_dcmpgt>
   10760:	cmp	r0, #0
   10762:	bne.w	108c2 <_dtoa_r+0xc2a>
   10766:	mov	r2, r4
   10768:	add.w	r3, r5, #2147483648	; 0x80000000
   1076c:	mov	r0, r6
   1076e:	mov	r1, r7
   10770:	bl	ac9c <__aeabi_dcmplt>
   10774:	cmp	r0, #0
   10776:	beq.n	1080e <_dtoa_r+0xb76>
   10778:	movs	r3, #0
   1077a:	str	r3, [sp, #24]
   1077c:	mov	r6, r3
   1077e:	b.n	104fa <_dtoa_r+0x862>
   10780:	ldr	r0, [sp, #36]	; 0x24
   10782:	b.w	fd0a <_dtoa_r+0x72>
   10786:	ldr	r3, [sp, #24]
   10788:	ldr	r2, [sp, #48]	; 0x30
   1078a:	str	r7, [sp, #24]
   1078c:	subs	r3, r7, r3
   1078e:	add	r2, r3
   10790:	str	r2, [sp, #48]	; 0x30
   10792:	movs	r7, #0
   10794:	b.n	10072 <_dtoa_r+0x3da>
   10796:	vldr	d7, [sp, #64]	; 0x40
   1079a:	mov.w	sl, #2
   1079e:	vstr	d7, [sp, #72]	; 0x48
   107a2:	b.n	10324 <_dtoa_r+0x68c>
   107a4:	mov	r4, r3
   107a6:	movs	r1, #0
   107a8:	str.w	r1, [r9, #68]	; 0x44
   107ac:	b.n	102d0 <_dtoa_r+0x638>
   107ae:	movs	r4, #1
   107b0:	str	r4, [sp, #56]	; 0x38
   107b2:	str	r4, [sp, #32]
   107b4:	str	r4, [sp, #20]
   107b6:	b.n	107a6 <_dtoa_r+0xb0e>
   107b8:	cmp	r2, #0
   107ba:	mov	sl, r3
   107bc:	ble.n	107e2 <_dtoa_r+0xb4a>
   107be:	mov	r1, r4
   107c0:	movs	r2, #1
   107c2:	mov	r0, r9
   107c4:	bl	11958 <__lshift>
   107c8:	ldr	r1, [sp, #24]
   107ca:	mov	r4, r0
   107cc:	bl	11a08 <__mcmp>
   107d0:	cmp	r0, #0
   107d2:	ble.w	10a66 <_dtoa_r+0xdce>
   107d6:	cmp.w	sl, #57	; 0x39
   107da:	beq.w	109f0 <_dtoa_r+0xd58>
   107de:	add.w	sl, r5, #49	; 0x31
   107e2:	mov	fp, r6
   107e4:	strb.w	sl, [r7]
   107e8:	adds	r5, r7, #1
   107ea:	mov	r6, r8
   107ec:	str	r4, [sp, #40]	; 0x28
   107ee:	b.n	10206 <_dtoa_r+0x56e>
   107f0:	bne.n	107fc <_dtoa_r+0xb64>
   107f2:	tst.w	sl, #1
   107f6:	beq.n	107fc <_dtoa_r+0xb64>
   107f8:	b.n	101e6 <_dtoa_r+0x54e>
   107fa:	mov	r5, r2
   107fc:	ldrb.w	r3, [r5, #-1]
   10800:	cmp	r3, #48	; 0x30
   10802:	add.w	r2, r5, #4294967295
   10806:	beq.n	107fa <_dtoa_r+0xb62>
   10808:	b.n	10206 <_dtoa_r+0x56e>
   1080a:	ldr.w	r8, [sp, #72]	; 0x48
   1080e:	ldrd	sl, fp, [sp, #64]	; 0x40
   10812:	b.w	feac <_dtoa_r+0x214>
   10816:	ldr	r1, [sp, #36]	; 0x24
   10818:	movs	r2, #48	; 0x30
   1081a:	strb	r2, [r1, #0]
   1081c:	ldr	r2, [sp, #16]
   1081e:	ldrb.w	r4, [r5, #-1]
   10822:	adds	r2, #1
   10824:	str	r2, [sp, #16]
   10826:	b.n	1002a <_dtoa_r+0x392>
   10828:	ldr	r3, [sp, #16]
   1082a:	negs	r4, r3
   1082c:	cmp	r4, #0
   1082e:	beq.w	10998 <_dtoa_r+0xd00>
   10832:	ldr	r3, [pc, #528]	; (10a44 <_dtoa_r+0xdac>)
   10834:	and.w	r2, r4, #15
   10838:	add.w	r3, r3, r2, lsl #3
   1083c:	ldrd	r2, r3, [r3]
   10840:	ldrd	r0, r1, [sp, #64]	; 0x40
   10844:	bl	a7b8 <__aeabi_dmul>
   10848:	asrs	r4, r4, #4
   1084a:	mov	r6, r0
   1084c:	mov	r7, r1
   1084e:	beq.w	10a7e <_dtoa_r+0xde6>
   10852:	ldr	r5, [pc, #500]	; (10a48 <_dtoa_r+0xdb0>)
   10854:	mov.w	sl, #2
   10858:	lsls	r2, r4, #31
   1085a:	bpl.n	10870 <_dtoa_r+0xbd8>
   1085c:	mov	r0, r6
   1085e:	mov	r1, r7
   10860:	ldrd	r2, r3, [r5]
   10864:	bl	a7b8 <__aeabi_dmul>
   10868:	add.w	sl, sl, #1
   1086c:	mov	r6, r0
   1086e:	mov	r7, r1
   10870:	asrs	r4, r4, #1
   10872:	add.w	r5, r5, #8
   10876:	bne.n	10858 <_dtoa_r+0xbc0>
   10878:	b.n	10358 <_dtoa_r+0x6c0>
   1087a:	ldr	r1, [r6, #4]
   1087c:	mov	r0, r9
   1087e:	bl	11560 <_Balloc>
   10882:	ldr	r3, [r6, #16]
   10884:	adds	r2, r3, #2
   10886:	mov	r5, r0
   10888:	lsls	r2, r2, #2
   1088a:	add.w	r1, r6, #12
   1088e:	adds	r0, #12
   10890:	bl	8b4c <memcpy>
   10894:	mov	r1, r5
   10896:	movs	r2, #1
   10898:	mov	r0, r9
   1089a:	bl	11958 <__lshift>
   1089e:	mov	r8, r0
   108a0:	b.n	10584 <_dtoa_r+0x8ec>
   108a2:	cmp	r3, #57	; 0x39
   108a4:	beq.w	109f0 <_dtoa_r+0xd58>
   108a8:	add.w	sl, r3, #1
   108ac:	mov	fp, r6
   108ae:	strb.w	sl, [r7]
   108b2:	adds	r5, r7, #1
   108b4:	mov	r6, r8
   108b6:	str	r4, [sp, #40]	; 0x28
   108b8:	b.n	10206 <_dtoa_r+0x56e>
   108ba:	mov	fp, r6
   108bc:	mov	sl, r3
   108be:	mov	r6, r8
   108c0:	b.n	101ce <_dtoa_r+0x536>
   108c2:	movs	r3, #0
   108c4:	str	r3, [sp, #24]
   108c6:	mov	r6, r3
   108c8:	b.n	106ce <_dtoa_r+0xa36>
   108ca:	ldr	r3, [sp, #72]	; 0x48
   108cc:	ldr	r1, [pc, #372]	; (10a44 <_dtoa_r+0xdac>)
   108ce:	subs	r2, r3, #1
   108d0:	add.w	r1, r1, r2, lsl #3
   108d4:	mov	r3, r5
   108d6:	str	r2, [sp, #92]	; 0x5c
   108d8:	ldrd	r0, r1, [r1]
   108dc:	mov	r2, r4
   108de:	bl	a7b8 <__aeabi_dmul>
   108e2:	strd	r0, r1, [sp, #80]	; 0x50
   108e6:	mov	r1, r7
   108e8:	mov	r0, r6
   108ea:	bl	ad18 <__aeabi_d2iz>
   108ee:	mov	r4, r0
   108f0:	bl	a6ec <__aeabi_i2d>
   108f4:	mov	r3, r1
   108f6:	mov	r2, r0
   108f8:	mov	r1, r7
   108fa:	mov	r0, r6
   108fc:	bl	a450 <__aeabi_dsub>
   10900:	ldr	r3, [sp, #72]	; 0x48
   10902:	mov	r7, r1
   10904:	ldr	r1, [sp, #36]	; 0x24
   10906:	adds	r4, #48	; 0x30
   10908:	cmp	r3, #1
   1090a:	mov	r6, r0
   1090c:	strb	r4, [r1, #0]
   1090e:	add.w	r5, r1, #1
   10912:	beq.n	10956 <_dtoa_r+0xcbe>
   10914:	ldr	r3, [sp, #72]	; 0x48
   10916:	ldr	r2, [sp, #36]	; 0x24
   10918:	add	r3, r2
   1091a:	mov	sl, r3
   1091c:	mov	fp, r5
   1091e:	movs	r2, #0
   10920:	ldr	r3, [pc, #296]	; (10a4c <_dtoa_r+0xdb4>)
   10922:	mov	r0, r6
   10924:	mov	r1, r7
   10926:	bl	a7b8 <__aeabi_dmul>
   1092a:	mov	r7, r1
   1092c:	mov	r6, r0
   1092e:	bl	ad18 <__aeabi_d2iz>
   10932:	mov	r4, r0
   10934:	bl	a6ec <__aeabi_i2d>
   10938:	adds	r4, #48	; 0x30
   1093a:	mov	r2, r0
   1093c:	mov	r3, r1
   1093e:	mov	r0, r6
   10940:	mov	r1, r7
   10942:	bl	a450 <__aeabi_dsub>
   10946:	strb.w	r4, [fp], #1
   1094a:	cmp	sl, fp
   1094c:	mov	r6, r0
   1094e:	mov	r7, r1
   10950:	bne.n	1091e <_dtoa_r+0xc86>
   10952:	ldr	r3, [sp, #92]	; 0x5c
   10954:	add	r5, r3
   10956:	movs	r2, #0
   10958:	ldr	r3, [pc, #244]	; (10a50 <_dtoa_r+0xdb8>)
   1095a:	ldrd	r0, r1, [sp, #80]	; 0x50
   1095e:	bl	a454 <__adddf3>
   10962:	mov	r2, r6
   10964:	mov	r3, r7
   10966:	bl	ac9c <__aeabi_dcmplt>
   1096a:	cmp	r0, #0
   1096c:	beq.n	10a00 <_dtoa_r+0xd68>
   1096e:	ldr	r3, [sp, #88]	; 0x58
   10970:	str	r3, [sp, #16]
   10972:	ldrb.w	r4, [r5, #-1]
   10976:	b.w	10012 <_dtoa_r+0x37a>
   1097a:	ldr	r3, [sp, #28]
   1097c:	ldr	r2, [sp, #32]
   1097e:	subs	r5, r3, r2
   10980:	movs	r3, #0
   10982:	b.w	1007e <_dtoa_r+0x3e6>
   10986:	movs	r7, #0
   10988:	b.n	10720 <_dtoa_r+0xa88>
   1098a:	ldr	r3, [sp, #96]	; 0x60
   1098c:	ldr	r7, [sp, #24]
   1098e:	ldr	r5, [sp, #28]
   10990:	rsb	r3, r3, #54	; 0x36
   10994:	b.w	1007e <_dtoa_r+0x3e6>
   10998:	ldrd	r6, r7, [sp, #64]	; 0x40
   1099c:	mov.w	sl, #2
   109a0:	b.n	10358 <_dtoa_r+0x6c0>
   109a2:	ldr	r3, [sp, #32]
   109a4:	cmp	r3, #0
   109a6:	beq.w	1072c <_dtoa_r+0xa94>
   109aa:	ldr	r3, [sp, #56]	; 0x38
   109ac:	cmp	r3, #0
   109ae:	ble.w	1080e <_dtoa_r+0xb76>
   109b2:	movs	r2, #0
   109b4:	ldr	r3, [pc, #148]	; (10a4c <_dtoa_r+0xdb4>)
   109b6:	mov	r0, r6
   109b8:	mov	r1, r7
   109ba:	bl	a7b8 <__aeabi_dmul>
   109be:	mov	r6, r0
   109c0:	mov	r7, r1
   109c2:	add.w	r0, sl, #1
   109c6:	bl	a6ec <__aeabi_i2d>
   109ca:	mov	r2, r6
   109cc:	mov	r3, r7
   109ce:	bl	a7b8 <__aeabi_dmul>
   109d2:	movs	r2, #0
   109d4:	ldr	r3, [pc, #100]	; (10a3c <_dtoa_r+0xda4>)
   109d6:	bl	a454 <__adddf3>
   109da:	ldr	r2, [sp, #16]
   109dc:	ldr	r3, [sp, #56]	; 0x38
   109de:	str	r3, [sp, #72]	; 0x48
   109e0:	subs	r2, #1
   109e2:	mov	r4, r0
   109e4:	sub.w	r5, r1, #54525952	; 0x3400000
   109e8:	str	r2, [sp, #88]	; 0x58
   109ea:	b.n	1039a <_dtoa_r+0x702>
   109ec:	str	r4, [sp, #40]	; 0x28
   109ee:	b.n	104fa <_dtoa_r+0x862>
   109f0:	movs	r2, #57	; 0x39
   109f2:	mov	fp, r6
   109f4:	str	r4, [sp, #40]	; 0x28
   109f6:	mov	r6, r8
   109f8:	strb	r2, [r7, #0]
   109fa:	adds	r5, r7, #1
   109fc:	b.w	101ea <_dtoa_r+0x552>
   10a00:	ldrd	r2, r3, [sp, #80]	; 0x50
   10a04:	movs	r0, #0
   10a06:	ldr	r1, [pc, #72]	; (10a50 <_dtoa_r+0xdb8>)
   10a08:	bl	a450 <__aeabi_dsub>
   10a0c:	mov	r2, r6
   10a0e:	mov	r3, r7
   10a10:	bl	acd8 <__aeabi_dcmpgt>
   10a14:	cbnz	r0, 10a1a <_dtoa_r+0xd82>
   10a16:	b.n	1080e <_dtoa_r+0xb76>
   10a18:	mov	r5, r2
   10a1a:	ldrb.w	r3, [r5, #-1]
   10a1e:	cmp	r3, #48	; 0x30
   10a20:	add.w	r2, r5, #4294967295
   10a24:	beq.n	10a18 <_dtoa_r+0xd80>
   10a26:	b.n	1049c <_dtoa_r+0x804>
   10a28:	ldr	r3, [sp, #88]	; 0x58
   10a2a:	str	r3, [sp, #16]
   10a2c:	b.w	10012 <_dtoa_r+0x37a>
   10a30:	cmp.w	sl, #0
   10a34:	bne.w	10530 <_dtoa_r+0x898>
   10a38:	b.n	10700 <_dtoa_r+0xa68>
   10a3a:	nop
   10a3c:	.word	0x401c0000
   10a40:	.word	0x40140000
   10a44:	.word	0x00013708
   10a48:	.word	0x000137d0
   10a4c:	.word	0x40240000
   10a50:	.word	0x3fe00000
   10a54:	cmp	r3, #57	; 0x39
   10a56:	mov	fp, sl
   10a58:	mov	sl, r3
   10a5a:	beq.n	109f0 <_dtoa_r+0xd58>
   10a5c:	cmp.w	fp, #0
   10a60:	bgt.w	107de <_dtoa_r+0xb46>
   10a64:	b.n	107e2 <_dtoa_r+0xb4a>
   10a66:	bne.w	107e2 <_dtoa_r+0xb4a>
   10a6a:	tst.w	sl, #1
   10a6e:	beq.w	107e2 <_dtoa_r+0xb4a>
   10a72:	b.n	107d6 <_dtoa_r+0xb3e>
   10a74:	ldr	r3, [sp, #0]
   10a76:	cmp	r3, #2
   10a78:	bgt.n	10ac6 <_dtoa_r+0xe2e>
   10a7a:	ldr	r3, [sp, #56]	; 0x38
   10a7c:	b.n	1069a <_dtoa_r+0xa02>
   10a7e:	mov.w	sl, #2
   10a82:	b.n	10358 <_dtoa_r+0x6c0>
   10a84:	ldr	r3, [sp, #0]
   10a86:	cmp	r3, #2
   10a88:	bgt.n	10ac6 <_dtoa_r+0xe2e>
   10a8a:	ldr	r3, [sp, #56]	; 0x38
   10a8c:	b.n	1056a <_dtoa_r+0x8d2>
   10a8e:	movs	r4, #0
   10a90:	str.w	r4, [r9, #68]	; 0x44
   10a94:	mov	r1, r4
   10a96:	mov	r0, r9
   10a98:	bl	11560 <_Balloc>
   10a9c:	mov.w	r3, #4294967295
   10aa0:	str	r3, [sp, #32]
   10aa2:	str	r3, [sp, #56]	; 0x38
   10aa4:	movs	r3, #1
   10aa6:	str	r0, [sp, #36]	; 0x24
   10aa8:	str	r4, [sp, #20]
   10aaa:	str.w	r0, [r9, #64]	; 0x40
   10aae:	str	r3, [sp, #44]	; 0x2c
   10ab0:	b.w	feac <_dtoa_r+0x214>
   10ab4:	beq.w	10148 <_dtoa_r+0x4b0>
   10ab8:	rsb	r0, r0, #60	; 0x3c
   10abc:	b.w	1013e <_dtoa_r+0x4a6>
   10ac0:	movs	r6, #1
   10ac2:	b.w	fe3e <_dtoa_r+0x1a6>
   10ac6:	ldr	r3, [sp, #56]	; 0x38
   10ac8:	str	r3, [sp, #32]
   10aca:	b.n	106aa <_dtoa_r+0xa12>

00010acc <__libc_fini_array>:
   10acc:	push	{r3, r4, r5, lr}
   10ace:	ldr	r5, [pc, #28]	; (10aec <__libc_fini_array+0x20>)
   10ad0:	ldr	r4, [pc, #28]	; (10af0 <__libc_fini_array+0x24>)
   10ad2:	subs	r4, r5, r4
   10ad4:	asrs	r4, r4, #2
   10ad6:	beq.n	10ae4 <__libc_fini_array+0x18>
   10ad8:	subs	r4, #1
   10ada:	ldr.w	r3, [r5, #-4]!
   10ade:	blx	r3
   10ae0:	cmp	r4, #0
   10ae2:	bne.n	10ad8 <__libc_fini_array+0xc>
   10ae4:	ldmia.w	sp!, {r3, r4, r5, lr}
   10ae8:	b.w	13864 <__init_array_end>
	...

00010af4 <_malloc_trim_r>:
   10af4:	push	{r3, r4, r5, r6, r7, lr}
   10af6:	ldr	r7, [pc, #140]	; (10b84 <_malloc_trim_r+0x90>)
   10af8:	mov	r4, r1
   10afa:	mov	r6, r0
   10afc:	bl	bc2c <__malloc_lock>
   10b00:	ldr	r3, [r7, #8]
   10b02:	ldr	r5, [r3, #4]
   10b04:	bic.w	r5, r5, #3
   10b08:	subs	r1, r5, r4
   10b0a:	addw	r1, r1, #4079	; 0xfef
   10b0e:	bic.w	r1, r1, #4080	; 0xff0
   10b12:	bic.w	r1, r1, #15
   10b16:	sub.w	r4, r1, #4096	; 0x1000
   10b1a:	cmp.w	r4, #4096	; 0x1000
   10b1e:	blt.n	10b30 <_malloc_trim_r+0x3c>
   10b20:	movs	r1, #0
   10b22:	mov	r0, r6
   10b24:	bl	c014 <_sbrk_r>
   10b28:	ldr	r3, [r7, #8]
   10b2a:	add	r3, r5
   10b2c:	cmp	r0, r3
   10b2e:	beq.n	10b3a <_malloc_trim_r+0x46>
   10b30:	mov	r0, r6
   10b32:	bl	bc30 <__malloc_unlock>
   10b36:	movs	r0, #0
   10b38:	pop	{r3, r4, r5, r6, r7, pc}
   10b3a:	negs	r1, r4
   10b3c:	mov	r0, r6
   10b3e:	bl	c014 <_sbrk_r>
   10b42:	adds	r0, #1
   10b44:	beq.n	10b62 <_malloc_trim_r+0x6e>
   10b46:	ldr	r3, [pc, #64]	; (10b88 <_malloc_trim_r+0x94>)
   10b48:	ldr	r2, [r7, #8]
   10b4a:	ldr	r1, [r3, #0]
   10b4c:	subs	r5, r5, r4
   10b4e:	orr.w	r5, r5, #1
   10b52:	mov	r0, r6
   10b54:	subs	r1, r1, r4
   10b56:	str	r5, [r2, #4]
   10b58:	str	r1, [r3, #0]
   10b5a:	bl	bc30 <__malloc_unlock>
   10b5e:	movs	r0, #1
   10b60:	pop	{r3, r4, r5, r6, r7, pc}
   10b62:	movs	r1, #0
   10b64:	mov	r0, r6
   10b66:	bl	c014 <_sbrk_r>
   10b6a:	ldr	r2, [r7, #8]
   10b6c:	subs	r3, r0, r2
   10b6e:	cmp	r3, #15
   10b70:	ble.n	10b30 <_malloc_trim_r+0x3c>
   10b72:	ldr	r4, [pc, #24]	; (10b8c <_malloc_trim_r+0x98>)
   10b74:	ldr	r1, [pc, #16]	; (10b88 <_malloc_trim_r+0x94>)
   10b76:	ldr	r4, [r4, #0]
   10b78:	orr.w	r3, r3, #1
   10b7c:	subs	r0, r0, r4
   10b7e:	str	r3, [r2, #4]
   10b80:	str	r0, [r1, #0]
   10b82:	b.n	10b30 <_malloc_trim_r+0x3c>
   10b84:	.word	0x200143a0
   10b88:	.word	0x2001a0b0
   10b8c:	.word	0x200147ac

00010b90 <_free_r>:
   10b90:	cmp	r1, #0
   10b92:	beq.n	10c20 <_free_r+0x90>
   10b94:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10b98:	mov	r5, r1
   10b9a:	mov	r8, r0
   10b9c:	bl	bc2c <__malloc_lock>
   10ba0:	ldr.w	r7, [r5, #-4]
   10ba4:	ldr	r1, [pc, #424]	; (10d50 <_free_r+0x1c0>)
   10ba6:	bic.w	r3, r7, #1
   10baa:	sub.w	r4, r5, #8
   10bae:	adds	r2, r4, r3
   10bb0:	ldr	r6, [r1, #8]
   10bb2:	ldr	r0, [r2, #4]
   10bb4:	cmp	r2, r6
   10bb6:	bic.w	r0, r0, #3
   10bba:	beq.n	10c82 <_free_r+0xf2>
   10bbc:	lsls	r6, r7, #31
   10bbe:	str	r0, [r2, #4]
   10bc0:	bmi.n	10bda <_free_r+0x4a>
   10bc2:	ldr.w	r7, [r5, #-8]
   10bc6:	subs	r4, r4, r7
   10bc8:	add.w	lr, r1, #8
   10bcc:	ldr	r5, [r4, #8]
   10bce:	cmp	r5, lr
   10bd0:	add	r3, r7
   10bd2:	beq.n	10cb4 <_free_r+0x124>
   10bd4:	ldr	r7, [r4, #12]
   10bd6:	str	r7, [r5, #12]
   10bd8:	str	r5, [r7, #8]
   10bda:	adds	r5, r2, r0
   10bdc:	ldr	r5, [r5, #4]
   10bde:	lsls	r5, r5, #31
   10be0:	bpl.n	10c68 <_free_r+0xd8>
   10be2:	orr.w	r2, r3, #1
   10be6:	str	r2, [r4, #4]
   10be8:	str	r3, [r4, r3]
   10bea:	cmp.w	r3, #512	; 0x200
   10bee:	bcs.n	10c22 <_free_r+0x92>
   10bf0:	lsrs	r3, r3, #3
   10bf2:	adds	r2, r3, #1
   10bf4:	ldr	r5, [r1, #4]
   10bf6:	ldr.w	r7, [r1, r2, lsl #3]
   10bfa:	str	r7, [r4, #8]
   10bfc:	movs	r0, #1
   10bfe:	asrs	r3, r3, #2
   10c00:	lsl.w	r3, r0, r3
   10c04:	add.w	r0, r1, r2, lsl #3
   10c08:	orrs	r5, r3
   10c0a:	subs	r0, #8
   10c0c:	str	r0, [r4, #12]
   10c0e:	str	r5, [r1, #4]
   10c10:	str.w	r4, [r1, r2, lsl #3]
   10c14:	str	r4, [r7, #12]
   10c16:	mov	r0, r8
   10c18:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10c1c:	b.w	bc30 <__malloc_unlock>
   10c20:	bx	lr
   10c22:	lsrs	r2, r3, #9
   10c24:	cmp	r2, #4
   10c26:	bhi.n	10cd0 <_free_r+0x140>
   10c28:	lsrs	r2, r3, #6
   10c2a:	add.w	r7, r2, #57	; 0x39
   10c2e:	lsls	r7, r7, #1
   10c30:	add.w	r5, r2, #56	; 0x38
   10c34:	add.w	r0, r1, r7, lsl #2
   10c38:	ldr.w	r2, [r1, r7, lsl #2]
   10c3c:	ldr	r1, [pc, #272]	; (10d50 <_free_r+0x1c0>)
   10c3e:	subs	r0, #8
   10c40:	cmp	r0, r2
   10c42:	beq.n	10ce0 <_free_r+0x150>
   10c44:	ldr	r1, [r2, #4]
   10c46:	bic.w	r1, r1, #3
   10c4a:	cmp	r3, r1
   10c4c:	bcs.n	10c54 <_free_r+0xc4>
   10c4e:	ldr	r2, [r2, #8]
   10c50:	cmp	r0, r2
   10c52:	bne.n	10c44 <_free_r+0xb4>
   10c54:	ldr	r0, [r2, #12]
   10c56:	str	r0, [r4, #12]
   10c58:	str	r2, [r4, #8]
   10c5a:	str	r4, [r0, #8]
   10c5c:	str	r4, [r2, #12]
   10c5e:	mov	r0, r8
   10c60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10c64:	b.w	bc30 <__malloc_unlock>
   10c68:	ldr	r5, [r2, #8]
   10c6a:	ldr	r7, [pc, #232]	; (10d54 <_free_r+0x1c4>)
   10c6c:	cmp	r5, r7
   10c6e:	add	r3, r0
   10c70:	beq.n	10cf2 <_free_r+0x162>
   10c72:	ldr	r0, [r2, #12]
   10c74:	str	r0, [r5, #12]
   10c76:	orr.w	r2, r3, #1
   10c7a:	str	r5, [r0, #8]
   10c7c:	str	r2, [r4, #4]
   10c7e:	str	r3, [r4, r3]
   10c80:	b.n	10bea <_free_r+0x5a>
   10c82:	lsls	r7, r7, #31
   10c84:	add	r3, r0
   10c86:	bmi.n	10c98 <_free_r+0x108>
   10c88:	ldr.w	r2, [r5, #-8]
   10c8c:	subs	r4, r4, r2
   10c8e:	add	r3, r2
   10c90:	ldr	r0, [r4, #8]
   10c92:	ldr	r2, [r4, #12]
   10c94:	str	r2, [r0, #12]
   10c96:	str	r0, [r2, #8]
   10c98:	ldr	r2, [pc, #188]	; (10d58 <_free_r+0x1c8>)
   10c9a:	ldr	r2, [r2, #0]
   10c9c:	orr.w	r0, r3, #1
   10ca0:	cmp	r3, r2
   10ca2:	str	r0, [r4, #4]
   10ca4:	str	r4, [r1, #8]
   10ca6:	bcc.n	10c16 <_free_r+0x86>
   10ca8:	ldr	r3, [pc, #176]	; (10d5c <_free_r+0x1cc>)
   10caa:	mov	r0, r8
   10cac:	ldr	r1, [r3, #0]
   10cae:	bl	10af4 <_malloc_trim_r>
   10cb2:	b.n	10c16 <_free_r+0x86>
   10cb4:	adds	r1, r2, r0
   10cb6:	ldr	r1, [r1, #4]
   10cb8:	lsls	r1, r1, #31
   10cba:	bmi.n	10d46 <_free_r+0x1b6>
   10cbc:	ldr	r1, [r2, #8]
   10cbe:	ldr	r2, [r2, #12]
   10cc0:	str	r2, [r1, #12]
   10cc2:	add	r3, r0
   10cc4:	orr.w	r0, r3, #1
   10cc8:	str	r1, [r2, #8]
   10cca:	str	r0, [r4, #4]
   10ccc:	str	r3, [r4, r3]
   10cce:	b.n	10c16 <_free_r+0x86>
   10cd0:	cmp	r2, #20
   10cd2:	bhi.n	10d04 <_free_r+0x174>
   10cd4:	add.w	r7, r2, #92	; 0x5c
   10cd8:	lsls	r7, r7, #1
   10cda:	add.w	r5, r2, #91	; 0x5b
   10cde:	b.n	10c34 <_free_r+0xa4>
   10ce0:	asrs	r2, r5, #2
   10ce2:	ldr	r3, [r1, #4]
   10ce4:	movs	r5, #1
   10ce6:	lsl.w	r2, r5, r2
   10cea:	orrs	r3, r2
   10cec:	str	r3, [r1, #4]
   10cee:	mov	r2, r0
   10cf0:	b.n	10c56 <_free_r+0xc6>
   10cf2:	orr.w	r2, r3, #1
   10cf6:	str	r4, [r1, #20]
   10cf8:	str	r4, [r1, #16]
   10cfa:	str	r5, [r4, #12]
   10cfc:	str	r5, [r4, #8]
   10cfe:	str	r2, [r4, #4]
   10d00:	str	r3, [r4, r3]
   10d02:	b.n	10c16 <_free_r+0x86>
   10d04:	cmp	r2, #84	; 0x54
   10d06:	bhi.n	10d16 <_free_r+0x186>
   10d08:	lsrs	r2, r3, #12
   10d0a:	add.w	r7, r2, #111	; 0x6f
   10d0e:	lsls	r7, r7, #1
   10d10:	add.w	r5, r2, #110	; 0x6e
   10d14:	b.n	10c34 <_free_r+0xa4>
   10d16:	cmp.w	r2, #340	; 0x154
   10d1a:	bhi.n	10d2a <_free_r+0x19a>
   10d1c:	lsrs	r2, r3, #15
   10d1e:	add.w	r7, r2, #120	; 0x78
   10d22:	lsls	r7, r7, #1
   10d24:	add.w	r5, r2, #119	; 0x77
   10d28:	b.n	10c34 <_free_r+0xa4>
   10d2a:	movw	r0, #1364	; 0x554
   10d2e:	cmp	r2, r0
   10d30:	bhi.n	10d40 <_free_r+0x1b0>
   10d32:	lsrs	r2, r3, #18
   10d34:	add.w	r7, r2, #125	; 0x7d
   10d38:	lsls	r7, r7, #1
   10d3a:	add.w	r5, r2, #124	; 0x7c
   10d3e:	b.n	10c34 <_free_r+0xa4>
   10d40:	movs	r7, #254	; 0xfe
   10d42:	movs	r5, #126	; 0x7e
   10d44:	b.n	10c34 <_free_r+0xa4>
   10d46:	orr.w	r2, r3, #1
   10d4a:	str	r2, [r4, #4]
   10d4c:	str	r3, [r4, r3]
   10d4e:	b.n	10c16 <_free_r+0x86>
   10d50:	.word	0x200143a0
   10d54:	.word	0x200143a8
   10d58:	.word	0x200147a8
   10d5c:	.word	0x2001a0ac

00010d60 <rshift>:
   10d60:	ldr	r2, [r0, #16]
   10d62:	asrs	r3, r1, #5
   10d64:	cmp	r3, r2
   10d66:	bge.n	10dc6 <rshift+0x66>
   10d68:	push	{r4, r5, r6, r7, lr}
   10d6a:	ands.w	r1, r1, #31
   10d6e:	add.w	r6, r0, #20
   10d72:	add.w	r2, r6, r2, lsl #2
   10d76:	add.w	lr, r6, r3, lsl #2
   10d7a:	beq.n	10dd0 <rshift+0x70>
   10d7c:	ldr.w	r3, [r6, r3, lsl #2]
   10d80:	add.w	r5, lr, #4
   10d84:	cmp	r2, r5
   10d86:	lsr.w	r4, r3, r1
   10d8a:	rsb	ip, r1, #32
   10d8e:	bls.n	10e04 <rshift+0xa4>
   10d90:	add.w	r7, r0, #16
   10d94:	ldr	r3, [r5, #0]
   10d96:	lsl.w	r3, r3, ip
   10d9a:	orrs	r3, r4
   10d9c:	str.w	r3, [r7, #4]!
   10da0:	ldr.w	r3, [r5], #4
   10da4:	cmp	r2, r5
   10da6:	lsr.w	r4, r3, r1
   10daa:	bhi.n	10d94 <rshift+0x34>
   10dac:	rsb	r2, lr, r2
   10db0:	subs	r2, #5
   10db2:	bic.w	r2, r2, #3
   10db6:	adds	r2, #4
   10db8:	add	r2, r6
   10dba:	str	r4, [r2, #0]
   10dbc:	cbz	r4, 10dc0 <rshift+0x60>
   10dbe:	adds	r2, #4
   10dc0:	subs	r3, r2, r6
   10dc2:	asrs	r3, r3, #2
   10dc4:	b.n	10df4 <rshift+0x94>
   10dc6:	movs	r3, #0
   10dc8:	str	r3, [r0, #16]
   10dca:	movs	r3, #0
   10dcc:	str	r3, [r0, #20]
   10dce:	bx	lr
   10dd0:	cmp	r2, lr
   10dd2:	bls.n	10dfa <rshift+0x9a>
   10dd4:	add.w	r4, r0, #16
   10dd8:	mov	r1, lr
   10dda:	ldr.w	r5, [r1], #4
   10dde:	str.w	r5, [r4, #4]!
   10de2:	cmp	r2, r1
   10de4:	bhi.n	10dda <rshift+0x7a>
   10de6:	mvn.w	r3, lr
   10dea:	add	r3, r2
   10dec:	bic.w	r3, r3, #3
   10df0:	adds	r3, #4
   10df2:	asrs	r3, r3, #2
   10df4:	str	r3, [r0, #16]
   10df6:	cbz	r3, 10dfe <rshift+0x9e>
   10df8:	pop	{r4, r5, r6, r7, pc}
   10dfa:	movs	r3, #0
   10dfc:	str	r3, [r0, #16]
   10dfe:	movs	r3, #0
   10e00:	str	r3, [r0, #20]
   10e02:	pop	{r4, r5, r6, r7, pc}
   10e04:	mov	r2, r6
   10e06:	b.n	10dba <rshift+0x5a>

00010e08 <__gethex>:
   10e08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10e0c:	sub	sp, #44	; 0x2c
   10e0e:	mov	r9, r1
   10e10:	str	r0, [sp, #20]
   10e12:	ldr	r0, [sp, #88]	; 0x58
   10e14:	str	r2, [sp, #12]
   10e16:	str	r3, [sp, #32]
   10e18:	bl	114e4 <__localeconv_l>
   10e1c:	ldr	r3, [r0, #0]
   10e1e:	str	r3, [sp, #8]
   10e20:	mov	r0, r3
   10e22:	mov	r4, r3
   10e24:	bl	c280 <strlen>
   10e28:	ldr.w	r3, [r9]
   10e2c:	str	r0, [sp, #0]
   10e2e:	ldrb	r2, [r3, #2]
   10e30:	adds	r1, r4, r0
   10e32:	cmp	r2, #48	; 0x30
   10e34:	ldrb.w	fp, [r1, #-1]
   10e38:	bne.w	1118e <__gethex+0x386>
   10e3c:	adds	r3, #3
   10e3e:	mov.w	r8, #0
   10e42:	mov	r4, r3
   10e44:	ldrb.w	r2, [r3], #1
   10e48:	cmp	r2, #48	; 0x30
   10e4a:	add.w	r8, r8, #1
   10e4e:	beq.n	10e42 <__gethex+0x3a>
   10e50:	ldr	r6, [pc, #712]	; (1111c <__gethex+0x314>)
   10e52:	ldrb	r3, [r6, r2]
   10e54:	cmp	r3, #0
   10e56:	beq.w	1103a <__gethex+0x232>
   10e5a:	ldrb	r3, [r4, #0]
   10e5c:	mov.w	sl, #0
   10e60:	ldrb	r3, [r6, r3]
   10e62:	mov	r5, sl
   10e64:	mov	r7, r4
   10e66:	cbz	r3, 10e72 <__gethex+0x6a>
   10e68:	ldrb.w	r3, [r7, #1]!
   10e6c:	ldrb	r3, [r6, r3]
   10e6e:	cmp	r3, #0
   10e70:	bne.n	10e68 <__gethex+0x60>
   10e72:	ldr	r2, [sp, #0]
   10e74:	ldr	r1, [sp, #8]
   10e76:	mov	r0, r7
   10e78:	bl	c35c <strncmp>
   10e7c:	cmp	r0, #0
   10e7e:	beq.w	10fa6 <__gethex+0x19e>
   10e82:	ldrb	r3, [r7, #0]
   10e84:	cmp	r5, #0
   10e86:	beq.w	1116c <__gethex+0x364>
   10e8a:	subs	r5, r5, r7
   10e8c:	lsls	r2, r5, #2
   10e8e:	str	r2, [sp, #4]
   10e90:	cmp	r3, #80	; 0x50
   10e92:	beq.w	10fb8 <__gethex+0x1b0>
   10e96:	cmp	r3, #112	; 0x70
   10e98:	beq.w	10fb8 <__gethex+0x1b0>
   10e9c:	mov	r5, r7
   10e9e:	str.w	r7, [r9]
   10ea2:	cmp.w	sl, #0
   10ea6:	bne.w	11018 <__gethex+0x210>
   10eaa:	subs	r3, r5, r4
   10eac:	subs	r3, #1
   10eae:	cmp	r3, #7
   10eb0:	mov	r1, sl
   10eb2:	ble.n	10ebe <__gethex+0xb6>
   10eb4:	asrs	r3, r3, #1
   10eb6:	cmp	r3, #7
   10eb8:	add.w	r1, r1, #1
   10ebc:	bgt.n	10eb4 <__gethex+0xac>
   10ebe:	ldr	r0, [sp, #20]
   10ec0:	bl	11560 <_Balloc>
   10ec4:	mov	r3, r0
   10ec6:	adds	r3, #20
   10ec8:	cmp	r5, r4
   10eca:	str	r0, [sp, #16]
   10ecc:	str	r3, [sp, #28]
   10ece:	bls.w	11278 <__gethex+0x470>
   10ed2:	mov	r9, r3
   10ed4:	ldr	r3, [sp, #0]
   10ed6:	mov.w	r8, #0
   10eda:	rsb	r3, r3, #1
   10ede:	mov	r7, r8
   10ee0:	str	r3, [sp, #24]
   10ee2:	b.n	10f04 <__gethex+0xfc>
   10ee4:	cmp	r7, #32
   10ee6:	beq.w	11028 <__gethex+0x220>
   10eea:	mov	r2, r7
   10eec:	adds	r7, #4
   10eee:	ldrb.w	r3, [r5, #-1]
   10ef2:	ldrb	r3, [r6, r3]
   10ef4:	mov	r5, sl
   10ef6:	and.w	r3, r3, #15
   10efa:	lsls	r3, r2
   10efc:	cmp	r5, r4
   10efe:	orr.w	r8, r8, r3
   10f02:	bls.n	10f30 <__gethex+0x128>
   10f04:	ldrb.w	r3, [r5, #-1]
   10f08:	cmp	r3, fp
   10f0a:	add.w	sl, r5, #4294967295
   10f0e:	bne.n	10ee4 <__gethex+0xdc>
   10f10:	ldr	r3, [sp, #24]
   10f12:	add	r3, sl
   10f14:	cmp	r3, r4
   10f16:	bcc.n	10ee4 <__gethex+0xdc>
   10f18:	mov	r0, r3
   10f1a:	ldr	r2, [sp, #0]
   10f1c:	ldr	r1, [sp, #8]
   10f1e:	str	r3, [sp, #36]	; 0x24
   10f20:	bl	c35c <strncmp>
   10f24:	ldr	r3, [sp, #36]	; 0x24
   10f26:	cmp	r0, #0
   10f28:	bne.n	10ee4 <__gethex+0xdc>
   10f2a:	mov	r5, r3
   10f2c:	cmp	r5, r4
   10f2e:	bhi.n	10f04 <__gethex+0xfc>
   10f30:	str.w	r8, [r9], #4
   10f34:	ldr	r3, [sp, #28]
   10f36:	ldr	r2, [sp, #16]
   10f38:	rsb	r9, r3, r9
   10f3c:	mov.w	r3, r9, asr #2
   10f40:	str	r3, [r2, #16]
   10f42:	mov	r0, r8
   10f44:	mov.w	r9, r3, lsl #5
   10f48:	bl	116d8 <__hi0bits>
   10f4c:	ldr	r3, [sp, #12]
   10f4e:	ldr	r6, [r3, #0]
   10f50:	rsb	r0, r0, r9
   10f54:	cmp	r0, r6
   10f56:	bgt.w	11120 <__gethex+0x318>
   10f5a:	blt.w	11170 <__gethex+0x368>
   10f5e:	movs	r7, #0
   10f60:	ldr	r3, [sp, #12]
   10f62:	ldr	r2, [sp, #4]
   10f64:	ldr	r3, [r3, #8]
   10f66:	cmp	r2, r3
   10f68:	bgt.w	1109a <__gethex+0x292>
   10f6c:	ldr	r0, [sp, #12]
   10f6e:	ldr	r1, [sp, #4]
   10f70:	ldr	r3, [r0, #4]
   10f72:	cmp	r1, r3
   10f74:	bge.w	110e2 <__gethex+0x2da>
   10f78:	subs	r5, r3, r1
   10f7a:	cmp	r6, r5
   10f7c:	bgt.w	1119e <__gethex+0x396>
   10f80:	ldr	r2, [r0, #12]
   10f82:	cmp	r2, #2
   10f84:	beq.w	11286 <__gethex+0x47e>
   10f88:	cmp	r2, #3
   10f8a:	beq.w	11246 <__gethex+0x43e>
   10f8e:	cmp	r2, #1
   10f90:	beq.w	1128e <__gethex+0x486>
   10f94:	ldr	r0, [sp, #20]
   10f96:	ldr	r1, [sp, #16]
   10f98:	bl	115ac <_Bfree>
   10f9c:	ldr	r2, [sp, #80]	; 0x50
   10f9e:	movs	r3, #0
   10fa0:	str	r3, [r2, #0]
   10fa2:	movs	r0, #80	; 0x50
   10fa4:	b.n	11022 <__gethex+0x21a>
   10fa6:	cmp	r5, #0
   10fa8:	beq.w	111de <__gethex+0x3d6>
   10fac:	ldrb	r3, [r7, #0]
   10fae:	b.n	10e8a <__gethex+0x82>
   10fb0:	movs	r3, #0
   10fb2:	str	r3, [sp, #4]
   10fb4:	mov.w	sl, #1
   10fb8:	ldrb	r3, [r7, #1]
   10fba:	cmp	r3, #43	; 0x2b
   10fbc:	beq.w	11118 <__gethex+0x310>
   10fc0:	cmp	r3, #45	; 0x2d
   10fc2:	beq.n	110b0 <__gethex+0x2a8>
   10fc4:	adds	r1, r7, #1
   10fc6:	movs	r5, #0
   10fc8:	ldrb	r3, [r6, r3]
   10fca:	ldr	r0, [pc, #336]	; (1111c <__gethex+0x314>)
   10fcc:	subs	r2, r3, #1
   10fce:	cmp	r2, #24
   10fd0:	bhi.w	10e9c <__gethex+0x94>
   10fd4:	ldrb	r2, [r1, #1]
   10fd6:	ldrb	r2, [r0, r2]
   10fd8:	subs	r0, r2, #1
   10fda:	cmp	r0, #24
   10fdc:	sub.w	r3, r3, #16
   10fe0:	add.w	r1, r1, #1
   10fe4:	bhi.n	10ffe <__gethex+0x1f6>
   10fe6:	ldrb.w	r0, [r1, #1]!
   10fea:	add.w	r3, r3, r3, lsl #2
   10fee:	add.w	r3, r2, r3, lsl #1
   10ff2:	ldrb	r2, [r6, r0]
   10ff4:	subs	r0, r2, #1
   10ff6:	cmp	r0, #24
   10ff8:	sub.w	r3, r3, #16
   10ffc:	bls.n	10fe6 <__gethex+0x1de>
   10ffe:	cbz	r5, 11002 <__gethex+0x1fa>
   11000:	negs	r3, r3
   11002:	ldr	r2, [sp, #4]
   11004:	mov	r5, r7
   11006:	add	r2, r3
   11008:	mov	r7, r1
   1100a:	str	r2, [sp, #4]
   1100c:	str.w	r7, [r9]
   11010:	cmp.w	sl, #0
   11014:	beq.w	10eaa <__gethex+0xa2>
   11018:	cmp.w	r8, #0
   1101c:	ite	eq
   1101e:	moveq	r0, #6
   11020:	movne	r0, #0
   11022:	add	sp, #44	; 0x2c
   11024:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11028:	str.w	r8, [r9]
   1102c:	mov.w	r8, #0
   11030:	add.w	r9, r9, #4
   11034:	mov	r2, r8
   11036:	movs	r7, #4
   11038:	b.n	10eee <__gethex+0xe6>
   1103a:	ldr	r5, [sp, #0]
   1103c:	ldr	r1, [sp, #8]
   1103e:	mov	r2, r5
   11040:	mov	r0, r4
   11042:	bl	c35c <strncmp>
   11046:	cmp	r0, #0
   11048:	beq.n	110b8 <__gethex+0x2b0>
   1104a:	ldrb	r3, [r4, #0]
   1104c:	mov	r7, r4
   1104e:	cmp	r3, #80	; 0x50
   11050:	beq.n	10fb0 <__gethex+0x1a8>
   11052:	cmp	r3, #112	; 0x70
   11054:	beq.n	10fb0 <__gethex+0x1a8>
   11056:	str.w	r7, [r9]
   1105a:	b.n	11018 <__gethex+0x210>
   1105c:	ldr	r3, [sp, #16]
   1105e:	ldr	r3, [r3, #8]
   11060:	cmp	r7, r3
   11062:	bge.w	112ce <__gethex+0x4c6>
   11066:	mov	r3, r7
   11068:	ldr	r0, [sp, #16]
   1106a:	add.w	r2, r0, r3, lsl #2
   1106e:	movs	r1, #1
   11070:	adds	r3, #1
   11072:	cmp	r4, #2
   11074:	str	r3, [r0, #16]
   11076:	str	r1, [r2, #20]
   11078:	beq.w	112ac <__gethex+0x4a4>
   1107c:	cmp	r7, r3
   1107e:	bge.w	11238 <__gethex+0x430>
   11082:	movs	r1, #1
   11084:	ldr	r0, [sp, #16]
   11086:	bl	10d60 <rshift>
   1108a:	ldr	r3, [sp, #12]
   1108c:	ldr	r2, [sp, #4]
   1108e:	ldr	r3, [r3, #8]
   11090:	adds	r2, #1
   11092:	cmp	r2, r3
   11094:	str	r2, [sp, #4]
   11096:	ble.w	1123e <__gethex+0x436>
   1109a:	ldr	r0, [sp, #20]
   1109c:	ldr	r1, [sp, #16]
   1109e:	bl	115ac <_Bfree>
   110a2:	ldr	r2, [sp, #80]	; 0x50
   110a4:	movs	r3, #0
   110a6:	movs	r0, #163	; 0xa3
   110a8:	str	r3, [r2, #0]
   110aa:	add	sp, #44	; 0x2c
   110ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   110b0:	movs	r5, #1
   110b2:	ldrb	r3, [r7, #2]
   110b4:	adds	r1, r7, #2
   110b6:	b.n	10fc8 <__gethex+0x1c0>
   110b8:	ldrb	r2, [r4, r5]
   110ba:	ldrb	r3, [r6, r2]
   110bc:	adds	r7, r4, r5
   110be:	cmp	r3, #0
   110c0:	beq.n	11196 <__gethex+0x38e>
   110c2:	cmp	r2, #48	; 0x30
   110c4:	mov	r4, r7
   110c6:	bne.n	110d2 <__gethex+0x2ca>
   110c8:	ldrb.w	r3, [r4, #1]!
   110cc:	cmp	r3, #48	; 0x30
   110ce:	beq.n	110c8 <__gethex+0x2c0>
   110d0:	ldrb	r3, [r6, r3]
   110d2:	clz	sl, r3
   110d6:	mov	r5, r7
   110d8:	mov.w	sl, sl, lsr #5
   110dc:	mov.w	r8, #1
   110e0:	b.n	10e64 <__gethex+0x5c>
   110e2:	movs	r4, #1
   110e4:	cbz	r7, 11100 <__gethex+0x2f8>
   110e6:	ldr	r3, [sp, #12]
   110e8:	ldr	r3, [r3, #12]
   110ea:	cmp	r3, #2
   110ec:	beq.w	111fa <__gethex+0x3f2>
   110f0:	cmp	r3, #3
   110f2:	beq.w	11202 <__gethex+0x3fa>
   110f6:	cmp	r3, #1
   110f8:	beq.w	11266 <__gethex+0x45e>
   110fc:	orr.w	r4, r4, #16
   11100:	ldr	r3, [sp, #80]	; 0x50
   11102:	mov	r2, r3
   11104:	ldr	r3, [sp, #16]
   11106:	str	r3, [r2, #0]
   11108:	ldr	r3, [sp, #32]
   1110a:	mov	r2, r3
   1110c:	ldr	r3, [sp, #4]
   1110e:	str	r3, [r2, #0]
   11110:	mov	r0, r4
   11112:	add	sp, #44	; 0x2c
   11114:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11118:	movs	r5, #0
   1111a:	b.n	110b2 <__gethex+0x2aa>
   1111c:	.word	0x00013604
   11120:	subs	r4, r0, r6
   11122:	mov	r1, r4
   11124:	ldr	r0, [sp, #16]
   11126:	bl	11de8 <__any_on>
   1112a:	cmp	r0, #0
   1112c:	beq.n	1119a <__gethex+0x392>
   1112e:	subs	r2, r4, #1
   11130:	asrs	r1, r2, #5
   11132:	ldr	r0, [sp, #28]
   11134:	and.w	r3, r2, #31
   11138:	ldr.w	r1, [r0, r1, lsl #2]
   1113c:	movs	r7, #1
   1113e:	lsl.w	r3, r7, r3
   11142:	tst	r3, r1
   11144:	beq.n	1115c <__gethex+0x354>
   11146:	cmp	r2, r7
   11148:	ble.w	11282 <__gethex+0x47a>
   1114c:	subs	r1, r4, #2
   1114e:	ldr	r0, [sp, #16]
   11150:	bl	11de8 <__any_on>
   11154:	cmp	r0, #0
   11156:	beq.w	11282 <__gethex+0x47a>
   1115a:	movs	r7, #3
   1115c:	ldr	r3, [sp, #4]
   1115e:	ldr	r0, [sp, #16]
   11160:	add	r3, r4
   11162:	mov	r1, r4
   11164:	str	r3, [sp, #4]
   11166:	bl	10d60 <rshift>
   1116a:	b.n	10f60 <__gethex+0x158>
   1116c:	str	r5, [sp, #4]
   1116e:	b.n	10e90 <__gethex+0x88>
   11170:	subs	r4, r6, r0
   11172:	ldr	r1, [sp, #16]
   11174:	ldr	r0, [sp, #20]
   11176:	mov	r2, r4
   11178:	bl	11958 <__lshift>
   1117c:	ldr	r3, [sp, #4]
   1117e:	str	r0, [sp, #16]
   11180:	subs	r3, r3, r4
   11182:	str	r3, [sp, #4]
   11184:	mov	r3, r0
   11186:	adds	r3, #20
   11188:	str	r3, [sp, #28]
   1118a:	movs	r7, #0
   1118c:	b.n	10f60 <__gethex+0x158>
   1118e:	adds	r4, r3, #2
   11190:	mov.w	r8, #0
   11194:	b.n	10e50 <__gethex+0x48>
   11196:	mov	r3, r2
   11198:	b.n	1104e <__gethex+0x246>
   1119a:	mov	r7, r0
   1119c:	b.n	1115c <__gethex+0x354>
   1119e:	subs	r4, r5, #1
   111a0:	cmp	r7, #0
   111a2:	bne.n	11242 <__gethex+0x43a>
   111a4:	cbz	r4, 111b0 <__gethex+0x3a8>
   111a6:	mov	r1, r4
   111a8:	ldr	r0, [sp, #16]
   111aa:	bl	11de8 <__any_on>
   111ae:	mov	r7, r0
   111b0:	asrs	r3, r4, #5
   111b2:	ldr	r2, [sp, #28]
   111b4:	ldr	r0, [sp, #16]
   111b6:	ldr.w	r2, [r2, r3, lsl #2]
   111ba:	and.w	r4, r4, #31
   111be:	movs	r3, #1
   111c0:	lsl.w	r4, r3, r4
   111c4:	tst	r4, r2
   111c6:	mov	r1, r5
   111c8:	it	ne
   111ca:	orrne.w	r7, r7, #2
   111ce:	bl	10d60 <rshift>
   111d2:	ldr	r3, [sp, #12]
   111d4:	ldr	r3, [r3, #4]
   111d6:	str	r3, [sp, #4]
   111d8:	subs	r6, r6, r5
   111da:	movs	r4, #2
   111dc:	b.n	110e4 <__gethex+0x2dc>
   111de:	ldr	r1, [sp, #0]
   111e0:	ldrb	r3, [r7, r1]
   111e2:	ldrb	r2, [r6, r3]
   111e4:	adds	r5, r7, r1
   111e6:	mov	r7, r5
   111e8:	cmp	r2, #0
   111ea:	beq.w	10e8a <__gethex+0x82>
   111ee:	ldrb.w	r3, [r7, #1]!
   111f2:	ldrb	r2, [r6, r3]
   111f4:	cmp	r2, #0
   111f6:	bne.n	111ee <__gethex+0x3e6>
   111f8:	b.n	10e8a <__gethex+0x82>
   111fa:	ldr	r3, [sp, #84]	; 0x54
   111fc:	rsb	r3, r3, #1
   11200:	str	r3, [sp, #84]	; 0x54
   11202:	ldr	r3, [sp, #84]	; 0x54
   11204:	cmp	r3, #0
   11206:	beq.w	110fc <__gethex+0x2f4>
   1120a:	ldr	r3, [sp, #16]
   1120c:	ldr	r5, [sp, #28]
   1120e:	ldr	r7, [r3, #16]
   11210:	mov.w	r8, r7, lsl #2
   11214:	add.w	r0, r5, r8
   11218:	mov	r3, r5
   1121a:	movs	r1, #0
   1121c:	b.n	11228 <__gethex+0x420>
   1121e:	str.w	r1, [r3], #4
   11222:	cmp	r0, r3
   11224:	bls.w	1105c <__gethex+0x254>
   11228:	ldr	r2, [r3, #0]
   1122a:	cmp.w	r2, #4294967295
   1122e:	beq.n	1121e <__gethex+0x416>
   11230:	adds	r2, #1
   11232:	cmp	r4, #2
   11234:	str	r2, [r3, #0]
   11236:	beq.n	112ac <__gethex+0x4a4>
   11238:	ands.w	r6, r6, #31
   1123c:	bne.n	112ba <__gethex+0x4b2>
   1123e:	movs	r4, #33	; 0x21
   11240:	b.n	11100 <__gethex+0x2f8>
   11242:	movs	r7, #1
   11244:	b.n	111b0 <__gethex+0x3a8>
   11246:	ldr	r2, [sp, #84]	; 0x54
   11248:	cmp	r2, #0
   1124a:	beq.w	10f94 <__gethex+0x18c>
   1124e:	ldr	r1, [sp, #32]
   11250:	str	r3, [r1, #0]
   11252:	ldr	r3, [sp, #28]
   11254:	ldr	r1, [sp, #16]
   11256:	movs	r2, #1
   11258:	str	r2, [r1, #16]
   1125a:	str	r2, [r3, #0]
   1125c:	ldr	r3, [sp, #80]	; 0x50
   1125e:	mov	r2, r3
   11260:	movs	r0, #98	; 0x62
   11262:	str	r1, [r2, #0]
   11264:	b.n	11022 <__gethex+0x21a>
   11266:	lsls	r2, r7, #30
   11268:	bpl.w	110fc <__gethex+0x2f4>
   1126c:	ldr	r3, [sp, #28]
   1126e:	ldr	r3, [r3, #0]
   11270:	orrs	r3, r7
   11272:	lsls	r3, r3, #31
   11274:	bmi.n	1120a <__gethex+0x402>
   11276:	b.n	110fc <__gethex+0x2f4>
   11278:	ldr.w	r9, [sp, #28]
   1127c:	mov.w	r8, #0
   11280:	b.n	10f30 <__gethex+0x128>
   11282:	movs	r7, #2
   11284:	b.n	1115c <__gethex+0x354>
   11286:	ldr	r2, [sp, #84]	; 0x54
   11288:	cmp	r2, #0
   1128a:	beq.n	1124e <__gethex+0x446>
   1128c:	b.n	10f94 <__gethex+0x18c>
   1128e:	cmp	r6, r5
   11290:	bne.w	10f94 <__gethex+0x18c>
   11294:	cmp	r6, #1
   11296:	ble.n	1124e <__gethex+0x446>
   11298:	subs	r1, r6, #1
   1129a:	ldr	r0, [sp, #16]
   1129c:	bl	11de8 <__any_on>
   112a0:	cmp	r0, #0
   112a2:	beq.w	10f94 <__gethex+0x18c>
   112a6:	ldr	r3, [sp, #12]
   112a8:	ldr	r3, [r3, #4]
   112aa:	b.n	1124e <__gethex+0x446>
   112ac:	ldr	r3, [sp, #12]
   112ae:	ldr	r3, [r3, #0]
   112b0:	subs	r3, #1
   112b2:	cmp	r6, r3
   112b4:	beq.n	11300 <__gethex+0x4f8>
   112b6:	movs	r4, #34	; 0x22
   112b8:	b.n	11100 <__gethex+0x2f8>
   112ba:	add	r5, r8
   112bc:	rsb	r6, r6, #32
   112c0:	ldr.w	r0, [r5, #-4]
   112c4:	bl	116d8 <__hi0bits>
   112c8:	cmp	r0, r6
   112ca:	bge.n	1123e <__gethex+0x436>
   112cc:	b.n	11082 <__gethex+0x27a>
   112ce:	ldr	r3, [sp, #16]
   112d0:	ldr.w	r9, [sp, #20]
   112d4:	ldr	r1, [r3, #4]
   112d6:	mov	r0, r9
   112d8:	adds	r1, #1
   112da:	bl	11560 <_Balloc>
   112de:	ldr	r1, [sp, #16]
   112e0:	ldr	r3, [r1, #16]
   112e2:	adds	r2, r3, #2
   112e4:	mov	r5, r0
   112e6:	lsls	r2, r2, #2
   112e8:	adds	r1, #12
   112ea:	adds	r0, #12
   112ec:	bl	8b4c <memcpy>
   112f0:	ldr	r1, [sp, #16]
   112f2:	mov	r0, r9
   112f4:	bl	115ac <_Bfree>
   112f8:	str	r5, [sp, #16]
   112fa:	ldr	r3, [r5, #16]
   112fc:	adds	r5, #20
   112fe:	b.n	11068 <__gethex+0x260>
   11300:	asrs	r3, r6, #5
   11302:	and.w	r6, r6, #31
   11306:	ldr.w	r2, [r5, r3, lsl #2]
   1130a:	movs	r3, #1
   1130c:	lsls	r3, r6
   1130e:	tst	r3, r2
   11310:	ite	ne
   11312:	movne	r4, #33	; 0x21
   11314:	moveq	r4, #34	; 0x22
   11316:	b.n	11100 <__gethex+0x2f8>

00011318 <__match>:
   11318:	push	{r4, r5}
   1131a:	ldr	r4, [r0, #0]
   1131c:	b.n	11330 <__match+0x18>
   1131e:	ldrb.w	r3, [r4, #1]!
   11322:	sub.w	r5, r3, #65	; 0x41
   11326:	cmp	r5, #25
   11328:	it	ls
   1132a:	addls	r3, #32
   1132c:	cmp	r3, r2
   1132e:	bne.n	11342 <__match+0x2a>
   11330:	ldrb.w	r2, [r1], #1
   11334:	cmp	r2, #0
   11336:	bne.n	1131e <__match+0x6>
   11338:	adds	r4, #1
   1133a:	str	r4, [r0, #0]
   1133c:	movs	r0, #1
   1133e:	pop	{r4, r5}
   11340:	bx	lr
   11342:	movs	r0, #0
   11344:	pop	{r4, r5}
   11346:	bx	lr

00011348 <__hexnan>:
   11348:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1134c:	ldr	r3, [r1, #0]
   1134e:	ldr.w	r9, [pc, #372]	; 114c4 <__hexnan+0x17c>
   11352:	sub	sp, #20
   11354:	asrs	r1, r3, #5
   11356:	add.w	r1, r2, r1, lsl #2
   1135a:	ands.w	r3, r3, #31
   1135e:	str	r1, [sp, #4]
   11360:	itt	ne
   11362:	addne	r1, #4
   11364:	strne	r1, [sp, #4]
   11366:	ldr	r4, [sp, #4]
   11368:	str	r0, [sp, #8]
   1136a:	str	r3, [sp, #12]
   1136c:	movs	r3, #0
   1136e:	mov	r1, r3
   11370:	str.w	r3, [r4, #-4]
   11374:	mov	sl, r3
   11376:	mov	lr, r3
   11378:	ldr	r3, [sp, #8]
   1137a:	sub.w	ip, r4, #4
   1137e:	ldr	r5, [r3, #0]
   11380:	mov	r8, ip
   11382:	mov	r0, ip
   11384:	ldrb.w	r3, [r5, #1]!
   11388:	cbz	r3, 113d4 <__hexnan+0x8c>
   1138a:	ldrb.w	r4, [r9, r3]
   1138e:	cmp	r4, #0
   11390:	bne.n	1141a <__hexnan+0xd2>
   11392:	cmp	r3, #32
   11394:	bhi.n	11452 <__hexnan+0x10a>
   11396:	cmp	lr, sl
   11398:	ble.n	11384 <__hexnan+0x3c>
   1139a:	cmp	r0, r8
   1139c:	bcs.n	113c6 <__hexnan+0x7e>
   1139e:	cmp	r1, #7
   113a0:	bgt.n	113c6 <__hexnan+0x7e>
   113a2:	rsb	r1, r1, #8
   113a6:	lsls	r1, r1, #2
   113a8:	ldr	r6, [r0, #0]
   113aa:	rsb	fp, r1, #32
   113ae:	mov	r3, r0
   113b0:	ldr	r7, [r3, #4]
   113b2:	lsl.w	r4, r7, fp
   113b6:	orrs	r4, r6
   113b8:	lsr.w	r6, r7, r1
   113bc:	str	r4, [r3, #0]
   113be:	str.w	r6, [r3, #4]!
   113c2:	cmp	r8, r3
   113c4:	bhi.n	113b0 <__hexnan+0x68>
   113c6:	cmp	r0, r2
   113c8:	bhi.n	11440 <__hexnan+0xf8>
   113ca:	ldrb.w	r3, [r5, #1]!
   113ce:	movs	r1, #8
   113d0:	cmp	r3, #0
   113d2:	bne.n	1138a <__hexnan+0x42>
   113d4:	cmp.w	lr, #0
   113d8:	beq.n	11456 <__hexnan+0x10e>
   113da:	cmp	r0, r8
   113dc:	bcs.n	113e2 <__hexnan+0x9a>
   113de:	cmp	r1, #7
   113e0:	ble.n	1149c <__hexnan+0x154>
   113e2:	cmp	r0, r2
   113e4:	bls.n	1145e <__hexnan+0x116>
   113e6:	mov	r3, r2
   113e8:	ldr.w	r1, [r0], #4
   113ec:	str.w	r1, [r3], #4
   113f0:	cmp	ip, r0
   113f2:	bcs.n	113e8 <__hexnan+0xa0>
   113f4:	movs	r1, #0
   113f6:	str.w	r1, [r3], #4
   113fa:	cmp	ip, r3
   113fc:	bcs.n	113f6 <__hexnan+0xae>
   113fe:	ldr	r3, [sp, #4]
   11400:	ldr.w	r3, [r3, #-4]
   11404:	cbnz	r3, 11412 <__hexnan+0xca>
   11406:	cmp	r2, ip
   11408:	beq.n	11480 <__hexnan+0x138>
   1140a:	ldr.w	r3, [ip, #-4]!
   1140e:	cmp	r3, #0
   11410:	beq.n	11406 <__hexnan+0xbe>
   11412:	movs	r0, #5
   11414:	add	sp, #20
   11416:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1141a:	adds	r1, #1
   1141c:	cmp	r1, #8
   1141e:	add.w	lr, lr, #1
   11422:	ble.n	11432 <__hexnan+0xea>
   11424:	cmp	r0, r2
   11426:	bls.n	11384 <__hexnan+0x3c>
   11428:	movs	r3, #0
   1142a:	str.w	r3, [r0, #-4]
   1142e:	movs	r1, #1
   11430:	subs	r0, #4
   11432:	ldr	r3, [r0, #0]
   11434:	and.w	r4, r4, #15
   11438:	orr.w	r4, r4, r3, lsl #4
   1143c:	str	r4, [r0, #0]
   1143e:	b.n	11384 <__hexnan+0x3c>
   11440:	movs	r3, #0
   11442:	sub.w	r8, r0, #4
   11446:	str.w	r3, [r0, #-4]
   1144a:	mov	sl, lr
   1144c:	mov	r0, r8
   1144e:	mov	r1, r3
   11450:	b.n	11384 <__hexnan+0x3c>
   11452:	cmp	r3, #41	; 0x29
   11454:	beq.n	1148e <__hexnan+0x146>
   11456:	movs	r0, #4
   11458:	add	sp, #20
   1145a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1145e:	ldr	r3, [sp, #12]
   11460:	cmp	r3, #0
   11462:	beq.n	113fe <__hexnan+0xb6>
   11464:	ldr	r4, [sp, #4]
   11466:	ldr	r3, [sp, #12]
   11468:	ldr.w	r1, [r4, #-4]
   1146c:	rsb	r3, r3, #32
   11470:	mov.w	r0, #4294967295
   11474:	lsr.w	r3, r0, r3
   11478:	ands	r3, r1
   1147a:	str.w	r3, [r4, #-4]
   1147e:	b.n	11404 <__hexnan+0xbc>
   11480:	movs	r3, #1
   11482:	movs	r0, #5
   11484:	str.w	r3, [ip]
   11488:	add	sp, #20
   1148a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1148e:	ldr	r3, [sp, #8]
   11490:	adds	r5, #1
   11492:	str	r5, [r3, #0]
   11494:	cmp.w	lr, #0
   11498:	bne.n	113da <__hexnan+0x92>
   1149a:	b.n	11456 <__hexnan+0x10e>
   1149c:	rsb	r3, r1, #8
   114a0:	lsls	r3, r3, #2
   114a2:	ldr	r5, [r0, #0]
   114a4:	rsb	r7, r3, #32
   114a8:	mov	r1, r0
   114aa:	ldr	r6, [r1, #4]
   114ac:	lsl.w	r4, r6, r7
   114b0:	orrs	r4, r5
   114b2:	lsr.w	r5, r6, r3
   114b6:	str	r4, [r1, #0]
   114b8:	str.w	r5, [r1, #4]!
   114bc:	cmp	r8, r1
   114be:	bhi.n	114aa <__hexnan+0x162>
   114c0:	b.n	113e2 <__hexnan+0x9a>
   114c2:	nop
   114c4:	.word	0x00013604

000114c8 <iswspace>:
   114c8:	cmp	r0, #255	; 0xff
   114ca:	bls.n	114d0 <iswspace+0x8>
   114cc:	movs	r0, #0
   114ce:	bx	lr
   114d0:	push	{r4, lr}
   114d2:	mov	r4, r0
   114d4:	bl	b490 <__locale_ctype_ptr>
   114d8:	add	r0, r4
   114da:	ldrb	r0, [r0, #1]
   114dc:	and.w	r0, r0, #8
   114e0:	uxtb	r0, r0
   114e2:	pop	{r4, pc}

000114e4 <__localeconv_l>:
   114e4:	adds	r0, #240	; 0xf0
   114e6:	bx	lr

000114e8 <_localeconv_r>:
   114e8:	ldr	r2, [pc, #16]	; (114fc <_localeconv_r+0x14>)
   114ea:	ldr	r3, [pc, #20]	; (11500 <_localeconv_r+0x18>)
   114ec:	ldr	r2, [r2, #0]
   114ee:	ldr	r0, [r2, #52]	; 0x34
   114f0:	cmp	r0, #0
   114f2:	it	eq
   114f4:	moveq	r0, r3
   114f6:	adds	r0, #240	; 0xf0
   114f8:	bx	lr
   114fa:	nop
   114fc:	.word	0x20014230
   11500:	.word	0x20014234

00011504 <_mbrtowc_r>:
   11504:	push	{r4, r5, r6, r7, lr}
   11506:	sub	sp, #12
   11508:	mov	r7, r0
   1150a:	ldr	r5, [sp, #32]
   1150c:	cbz	r2, 11534 <_mbrtowc_r+0x30>
   1150e:	ldr	r4, [pc, #68]	; (11554 <_mbrtowc_r+0x50>)
   11510:	ldr	r6, [pc, #68]	; (11558 <_mbrtowc_r+0x54>)
   11512:	ldr	r4, [r4, #0]
   11514:	ldr	r4, [r4, #52]	; 0x34
   11516:	str	r5, [sp, #0]
   11518:	cmp	r4, #0
   1151a:	it	eq
   1151c:	moveq	r4, r6
   1151e:	ldr.w	r4, [r4, #228]	; 0xe4
   11522:	blx	r4
   11524:	adds	r3, r0, #1
   11526:	bne.n	11530 <_mbrtowc_r+0x2c>
   11528:	movs	r2, #0
   1152a:	movs	r3, #138	; 0x8a
   1152c:	str	r2, [r5, #0]
   1152e:	str	r3, [r7, #0]
   11530:	add	sp, #12
   11532:	pop	{r4, r5, r6, r7, pc}
   11534:	ldr	r3, [pc, #28]	; (11554 <_mbrtowc_r+0x50>)
   11536:	ldr	r1, [pc, #32]	; (11558 <_mbrtowc_r+0x54>)
   11538:	ldr	r3, [r3, #0]
   1153a:	ldr	r3, [r3, #52]	; 0x34
   1153c:	str	r5, [sp, #0]
   1153e:	cmp	r3, #0
   11540:	it	eq
   11542:	moveq	r3, r1
   11544:	mov	r4, r2
   11546:	mov	r1, r4
   11548:	ldr	r2, [pc, #16]	; (1155c <_mbrtowc_r+0x58>)
   1154a:	ldr.w	r4, [r3, #228]	; 0xe4
   1154e:	movs	r3, #1
   11550:	blx	r4
   11552:	b.n	11524 <_mbrtowc_r+0x20>
   11554:	.word	0x20014230
   11558:	.word	0x20014234
   1155c:	.word	0x00013490

00011560 <_Balloc>:
   11560:	ldr	r3, [r0, #76]	; 0x4c
   11562:	push	{r4, r5, r6, lr}
   11564:	mov	r5, r0
   11566:	mov	r4, r1
   11568:	cbz	r3, 1157e <_Balloc+0x1e>
   1156a:	ldr.w	r0, [r3, r4, lsl #2]
   1156e:	cbz	r0, 11592 <_Balloc+0x32>
   11570:	ldr	r2, [r0, #0]
   11572:	str.w	r2, [r3, r4, lsl #2]
   11576:	movs	r3, #0
   11578:	str	r3, [r0, #16]
   1157a:	str	r3, [r0, #12]
   1157c:	pop	{r4, r5, r6, pc}
   1157e:	movs	r2, #33	; 0x21
   11580:	movs	r1, #4
   11582:	bl	12744 <_calloc_r>
   11586:	str	r0, [r5, #76]	; 0x4c
   11588:	mov	r3, r0
   1158a:	cmp	r0, #0
   1158c:	bne.n	1156a <_Balloc+0xa>
   1158e:	movs	r0, #0
   11590:	pop	{r4, r5, r6, pc}
   11592:	movs	r1, #1
   11594:	lsl.w	r6, r1, r4
   11598:	adds	r2, r6, #5
   1159a:	mov	r0, r5
   1159c:	lsls	r2, r2, #2
   1159e:	bl	12744 <_calloc_r>
   115a2:	cmp	r0, #0
   115a4:	beq.n	1158e <_Balloc+0x2e>
   115a6:	str	r4, [r0, #4]
   115a8:	str	r6, [r0, #8]
   115aa:	b.n	11576 <_Balloc+0x16>

000115ac <_Bfree>:
   115ac:	cbz	r1, 115bc <_Bfree+0x10>
   115ae:	ldr	r3, [r0, #76]	; 0x4c
   115b0:	ldr	r2, [r1, #4]
   115b2:	ldr.w	r0, [r3, r2, lsl #2]
   115b6:	str	r0, [r1, #0]
   115b8:	str.w	r1, [r3, r2, lsl #2]
   115bc:	bx	lr
   115be:	nop

000115c0 <__multadd>:
   115c0:	push	{r4, r5, r6, r7, lr}
   115c2:	ldr	r4, [r1, #16]
   115c4:	sub	sp, #12
   115c6:	mov	r5, r1
   115c8:	mov	r6, r0
   115ca:	add.w	lr, r1, #20
   115ce:	movs	r7, #0
   115d0:	ldr.w	r0, [lr]
   115d4:	uxth	r1, r0
   115d6:	mla	r1, r2, r1, r3
   115da:	lsrs	r3, r1, #16
   115dc:	lsrs	r0, r0, #16
   115de:	mla	r3, r2, r0, r3
   115e2:	uxth	r1, r1
   115e4:	adds	r7, #1
   115e6:	add.w	r1, r1, r3, lsl #16
   115ea:	cmp	r4, r7
   115ec:	str.w	r1, [lr], #4
   115f0:	mov.w	r3, r3, lsr #16
   115f4:	bgt.n	115d0 <__multadd+0x10>
   115f6:	cbz	r3, 11608 <__multadd+0x48>
   115f8:	ldr	r2, [r5, #8]
   115fa:	cmp	r4, r2
   115fc:	bge.n	1160e <__multadd+0x4e>
   115fe:	add.w	r2, r5, r4, lsl #2
   11602:	adds	r4, #1
   11604:	str	r3, [r2, #20]
   11606:	str	r4, [r5, #16]
   11608:	mov	r0, r5
   1160a:	add	sp, #12
   1160c:	pop	{r4, r5, r6, r7, pc}
   1160e:	ldr	r1, [r5, #4]
   11610:	str	r3, [sp, #4]
   11612:	adds	r1, #1
   11614:	mov	r0, r6
   11616:	bl	11560 <_Balloc>
   1161a:	ldr	r2, [r5, #16]
   1161c:	adds	r2, #2
   1161e:	add.w	r1, r5, #12
   11622:	mov	r7, r0
   11624:	lsls	r2, r2, #2
   11626:	adds	r0, #12
   11628:	bl	8b4c <memcpy>
   1162c:	ldr	r2, [r6, #76]	; 0x4c
   1162e:	ldr	r1, [r5, #4]
   11630:	ldr	r3, [sp, #4]
   11632:	ldr.w	r0, [r2, r1, lsl #2]
   11636:	str	r0, [r5, #0]
   11638:	str.w	r5, [r2, r1, lsl #2]
   1163c:	mov	r5, r7
   1163e:	b.n	115fe <__multadd+0x3e>

00011640 <__s2b>:
   11640:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11644:	ldr	r4, [pc, #140]	; (116d4 <__s2b+0x94>)
   11646:	ldr	r5, [sp, #32]
   11648:	mov	r7, r3
   1164a:	adds	r3, #8
   1164c:	smull	r4, lr, r4, r3
   11650:	asrs	r3, r3, #31
   11652:	rsb	lr, r3, lr, asr #1
   11656:	cmp.w	lr, #1
   1165a:	mov	r6, r0
   1165c:	mov	r4, r1
   1165e:	mov	r8, r2
   11660:	ble.n	116ce <__s2b+0x8e>
   11662:	movs	r3, #1
   11664:	movs	r1, #0
   11666:	lsls	r3, r3, #1
   11668:	cmp	lr, r3
   1166a:	add.w	r1, r1, #1
   1166e:	bgt.n	11666 <__s2b+0x26>
   11670:	mov	r0, r6
   11672:	bl	11560 <_Balloc>
   11676:	movs	r3, #1
   11678:	cmp.w	r8, #9
   1167c:	str	r5, [r0, #20]
   1167e:	str	r3, [r0, #16]
   11680:	ble.n	116c6 <__s2b+0x86>
   11682:	add.w	r9, r4, #9
   11686:	mov	r5, r9
   11688:	add	r4, r8
   1168a:	ldrb.w	r3, [r5], #1
   1168e:	mov	r1, r0
   11690:	subs	r3, #48	; 0x30
   11692:	movs	r2, #10
   11694:	mov	r0, r6
   11696:	bl	115c0 <__multadd>
   1169a:	cmp	r5, r4
   1169c:	bne.n	1168a <__s2b+0x4a>
   1169e:	add.w	r4, r9, r8
   116a2:	subs	r4, #8
   116a4:	cmp	r7, r8
   116a6:	ble.n	116c2 <__s2b+0x82>
   116a8:	rsb	r7, r8, r7
   116ac:	add	r7, r4
   116ae:	ldrb.w	r3, [r4], #1
   116b2:	mov	r1, r0
   116b4:	subs	r3, #48	; 0x30
   116b6:	movs	r2, #10
   116b8:	mov	r0, r6
   116ba:	bl	115c0 <__multadd>
   116be:	cmp	r7, r4
   116c0:	bne.n	116ae <__s2b+0x6e>
   116c2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   116c6:	adds	r4, #10
   116c8:	mov.w	r8, #9
   116cc:	b.n	116a4 <__s2b+0x64>
   116ce:	movs	r1, #0
   116d0:	b.n	11670 <__s2b+0x30>
   116d2:	nop
   116d4:	.word	0x38e38e39

000116d8 <__hi0bits>:
   116d8:	lsrs	r3, r0, #16
   116da:	lsls	r3, r3, #16
   116dc:	cbnz	r3, 1170c <__hi0bits+0x34>
   116de:	lsls	r0, r0, #16
   116e0:	movs	r3, #16
   116e2:	tst.w	r0, #4278190080	; 0xff000000
   116e6:	itt	eq
   116e8:	lsleq	r0, r0, #8
   116ea:	addeq	r3, #8
   116ec:	tst.w	r0, #4026531840	; 0xf0000000
   116f0:	itt	eq
   116f2:	lsleq	r0, r0, #4
   116f4:	addeq	r3, #4
   116f6:	tst.w	r0, #3221225472	; 0xc0000000
   116fa:	itt	eq
   116fc:	lsleq	r0, r0, #2
   116fe:	addeq	r3, #2
   11700:	cmp	r0, #0
   11702:	blt.n	11714 <__hi0bits+0x3c>
   11704:	lsls	r2, r0, #1
   11706:	bmi.n	11710 <__hi0bits+0x38>
   11708:	movs	r0, #32
   1170a:	bx	lr
   1170c:	movs	r3, #0
   1170e:	b.n	116e2 <__hi0bits+0xa>
   11710:	adds	r0, r3, #1
   11712:	bx	lr
   11714:	mov	r0, r3
   11716:	bx	lr

00011718 <__lo0bits>:
   11718:	ldr	r3, [r0, #0]
   1171a:	ands.w	r2, r3, #7
   1171e:	beq.n	11730 <__lo0bits+0x18>
   11720:	lsls	r1, r3, #31
   11722:	bmi.n	11766 <__lo0bits+0x4e>
   11724:	lsls	r2, r3, #30
   11726:	bmi.n	1176a <__lo0bits+0x52>
   11728:	lsrs	r3, r3, #2
   1172a:	str	r3, [r0, #0]
   1172c:	movs	r0, #2
   1172e:	bx	lr
   11730:	uxth	r1, r3
   11732:	cbnz	r1, 11738 <__lo0bits+0x20>
   11734:	lsrs	r3, r3, #16
   11736:	movs	r2, #16
   11738:	tst.w	r3, #255	; 0xff
   1173c:	itt	eq
   1173e:	lsreq	r3, r3, #8
   11740:	addeq	r2, #8
   11742:	lsls	r1, r3, #28
   11744:	itt	eq
   11746:	lsreq	r3, r3, #4
   11748:	addeq	r2, #4
   1174a:	lsls	r1, r3, #30
   1174c:	itt	eq
   1174e:	lsreq	r3, r3, #2
   11750:	addeq	r2, #2
   11752:	lsls	r1, r3, #31
   11754:	bmi.n	11760 <__lo0bits+0x48>
   11756:	lsrs	r3, r3, #1
   11758:	bne.n	1175e <__lo0bits+0x46>
   1175a:	movs	r0, #32
   1175c:	bx	lr
   1175e:	adds	r2, #1
   11760:	str	r3, [r0, #0]
   11762:	mov	r0, r2
   11764:	bx	lr
   11766:	movs	r0, #0
   11768:	bx	lr
   1176a:	lsrs	r3, r3, #1
   1176c:	str	r3, [r0, #0]
   1176e:	movs	r0, #1
   11770:	bx	lr
   11772:	nop

00011774 <__i2b>:
   11774:	push	{r4, lr}
   11776:	mov	r4, r1
   11778:	movs	r1, #1
   1177a:	bl	11560 <_Balloc>
   1177e:	movs	r2, #1
   11780:	str	r4, [r0, #20]
   11782:	str	r2, [r0, #16]
   11784:	pop	{r4, pc}
   11786:	nop

00011788 <__multiply>:
   11788:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1178c:	ldr	r5, [r1, #16]
   1178e:	ldr	r7, [r2, #16]
   11790:	cmp	r5, r7
   11792:	sub	sp, #12
   11794:	mov	r4, r1
   11796:	mov	r6, r2
   11798:	bge.n	117a4 <__multiply+0x1c>
   1179a:	mov	r2, r5
   1179c:	mov	r4, r6
   1179e:	mov	r5, r7
   117a0:	mov	r6, r1
   117a2:	mov	r7, r2
   117a4:	ldr	r3, [r4, #8]
   117a6:	ldr	r1, [r4, #4]
   117a8:	add.w	r8, r5, r7
   117ac:	cmp	r8, r3
   117ae:	it	gt
   117b0:	addgt	r1, #1
   117b2:	bl	11560 <_Balloc>
   117b6:	add.w	ip, r0, #20
   117ba:	add.w	r9, ip, r8, lsl #2
   117be:	cmp	ip, r9
   117c0:	str	r0, [sp, #0]
   117c2:	bcs.n	117d0 <__multiply+0x48>
   117c4:	mov	r3, ip
   117c6:	movs	r1, #0
   117c8:	str.w	r1, [r3], #4
   117cc:	cmp	r9, r3
   117ce:	bhi.n	117c8 <__multiply+0x40>
   117d0:	add.w	r2, r6, #20
   117d4:	add.w	sl, r2, r7, lsl #2
   117d8:	add.w	r3, r4, #20
   117dc:	cmp	r2, sl
   117de:	add.w	lr, r3, r5, lsl #2
   117e2:	bcs.n	1188e <__multiply+0x106>
   117e4:	str.w	r9, [sp, #4]
   117e8:	mov	r9, r3
   117ea:	ldr.w	r3, [r2], #4
   117ee:	uxth.w	fp, r3
   117f2:	cmp.w	fp, #0
   117f6:	beq.n	1183a <__multiply+0xb2>
   117f8:	movs	r0, #0
   117fa:	mov	r7, r9
   117fc:	mov	r6, ip
   117fe:	mov	r5, r0
   11800:	b.n	11804 <__multiply+0x7c>
   11802:	mov	r6, r3
   11804:	ldr.w	r4, [r7], #4
   11808:	ldr	r0, [r6, #0]
   1180a:	uxth	r1, r4
   1180c:	uxth	r3, r0
   1180e:	mla	r1, fp, r1, r3
   11812:	lsrs	r4, r4, #16
   11814:	lsrs	r0, r0, #16
   11816:	adds	r3, r1, r5
   11818:	mla	r0, fp, r4, r0
   1181c:	add.w	r0, r0, r3, lsr #16
   11820:	uxth	r1, r3
   11822:	mov	r3, r6
   11824:	orr.w	r1, r1, r0, lsl #16
   11828:	cmp	lr, r7
   1182a:	mov.w	r5, r0, lsr #16
   1182e:	str.w	r1, [r3], #4
   11832:	bhi.n	11802 <__multiply+0x7a>
   11834:	str	r5, [r6, #4]
   11836:	ldr.w	r3, [r2, #-4]
   1183a:	movs.w	fp, r3, lsr #16
   1183e:	beq.n	11882 <__multiply+0xfa>
   11840:	ldr.w	r3, [ip]
   11844:	mov	r7, ip
   11846:	mov	r0, r3
   11848:	mov	r5, r9
   1184a:	movs	r1, #0
   1184c:	b.n	11850 <__multiply+0xc8>
   1184e:	mov	r7, r6
   11850:	ldrh	r4, [r5, #0]
   11852:	lsrs	r0, r0, #16
   11854:	mla	r0, fp, r4, r0
   11858:	add	r1, r0
   1185a:	uxth	r4, r3
   1185c:	mov	r6, r7
   1185e:	orr.w	r3, r4, r1, lsl #16
   11862:	str.w	r3, [r6], #4
   11866:	ldr	r0, [r7, #4]
   11868:	ldr.w	r4, [r5], #4
   1186c:	uxth	r3, r0
   1186e:	lsrs	r4, r4, #16
   11870:	mla	r4, fp, r4, r3
   11874:	add.w	r3, r4, r1, lsr #16
   11878:	cmp	lr, r5
   1187a:	mov.w	r1, r3, lsr #16
   1187e:	bhi.n	1184e <__multiply+0xc6>
   11880:	str	r3, [r7, #4]
   11882:	cmp	sl, r2
   11884:	add.w	ip, ip, #4
   11888:	bhi.n	117ea <__multiply+0x62>
   1188a:	ldr.w	r9, [sp, #4]
   1188e:	cmp.w	r8, #0
   11892:	ble.n	118ac <__multiply+0x124>
   11894:	ldr.w	r3, [r9, #-4]
   11898:	sub.w	r9, r9, #4
   1189c:	cbz	r3, 118a6 <__multiply+0x11e>
   1189e:	b.n	118ac <__multiply+0x124>
   118a0:	ldr.w	r3, [r9, #-4]!
   118a4:	cbnz	r3, 118ac <__multiply+0x124>
   118a6:	subs.w	r8, r8, #1
   118aa:	bne.n	118a0 <__multiply+0x118>
   118ac:	ldr	r0, [sp, #0]
   118ae:	str.w	r8, [r0, #16]
   118b2:	add	sp, #12
   118b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000118b8 <__pow5mult>:
   118b8:	ands.w	r3, r2, #3
   118bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   118c0:	mov	r4, r2
   118c2:	mov	r7, r0
   118c4:	bne.n	11924 <__pow5mult+0x6c>
   118c6:	mov	r6, r1
   118c8:	asrs	r4, r4, #2
   118ca:	beq.n	11906 <__pow5mult+0x4e>
   118cc:	ldr	r5, [r7, #72]	; 0x48
   118ce:	cbz	r5, 11936 <__pow5mult+0x7e>
   118d0:	lsls	r3, r4, #31
   118d2:	mov.w	r8, #0
   118d6:	bmi.n	118e6 <__pow5mult+0x2e>
   118d8:	asrs	r4, r4, #1
   118da:	beq.n	11906 <__pow5mult+0x4e>
   118dc:	ldr	r0, [r5, #0]
   118de:	cbz	r0, 1190c <__pow5mult+0x54>
   118e0:	mov	r5, r0
   118e2:	lsls	r3, r4, #31
   118e4:	bpl.n	118d8 <__pow5mult+0x20>
   118e6:	mov	r2, r5
   118e8:	mov	r1, r6
   118ea:	mov	r0, r7
   118ec:	bl	11788 <__multiply>
   118f0:	cbz	r6, 11920 <__pow5mult+0x68>
   118f2:	ldr	r2, [r6, #4]
   118f4:	ldr	r3, [r7, #76]	; 0x4c
   118f6:	asrs	r4, r4, #1
   118f8:	ldr.w	r1, [r3, r2, lsl #2]
   118fc:	str	r1, [r6, #0]
   118fe:	str.w	r6, [r3, r2, lsl #2]
   11902:	mov	r6, r0
   11904:	bne.n	118dc <__pow5mult+0x24>
   11906:	mov	r0, r6
   11908:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1190c:	mov	r2, r5
   1190e:	mov	r1, r5
   11910:	mov	r0, r7
   11912:	bl	11788 <__multiply>
   11916:	str	r0, [r5, #0]
   11918:	str.w	r8, [r0]
   1191c:	mov	r5, r0
   1191e:	b.n	118e2 <__pow5mult+0x2a>
   11920:	mov	r6, r0
   11922:	b.n	118d8 <__pow5mult+0x20>
   11924:	subs	r2, r3, #1
   11926:	ldr	r5, [pc, #44]	; (11954 <__pow5mult+0x9c>)
   11928:	movs	r3, #0
   1192a:	ldr.w	r2, [r5, r2, lsl #2]
   1192e:	bl	115c0 <__multadd>
   11932:	mov	r6, r0
   11934:	b.n	118c8 <__pow5mult+0x10>
   11936:	movs	r1, #1
   11938:	mov	r0, r7
   1193a:	bl	11560 <_Balloc>
   1193e:	movw	r1, #625	; 0x271
   11942:	movs	r2, #1
   11944:	movs	r3, #0
   11946:	str	r1, [r0, #20]
   11948:	str	r2, [r0, #16]
   1194a:	mov	r5, r0
   1194c:	str	r0, [r7, #72]	; 0x48
   1194e:	str	r3, [r0, #0]
   11950:	b.n	118d0 <__pow5mult+0x18>
   11952:	nop
   11954:	.word	0x000137f8

00011958 <__lshift>:
   11958:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1195c:	mov	r9, r2
   1195e:	ldr	r2, [r1, #16]
   11960:	ldr	r3, [r1, #8]
   11962:	mov.w	r4, r9, asr #5
   11966:	add.w	r8, r4, r2
   1196a:	add.w	r5, r8, #1
   1196e:	cmp	r5, r3
   11970:	mov	r6, r1
   11972:	mov	sl, r0
   11974:	ldr	r1, [r1, #4]
   11976:	ble.n	11982 <__lshift+0x2a>
   11978:	lsls	r3, r3, #1
   1197a:	cmp	r5, r3
   1197c:	add.w	r1, r1, #1
   11980:	bgt.n	11978 <__lshift+0x20>
   11982:	mov	r0, sl
   11984:	bl	11560 <_Balloc>
   11988:	cmp	r4, #0
   1198a:	add.w	r2, r0, #20
   1198e:	ble.n	11a02 <__lshift+0xaa>
   11990:	add.w	r3, r2, r4, lsl #2
   11994:	movs	r1, #0
   11996:	str.w	r1, [r2], #4
   1199a:	cmp	r3, r2
   1199c:	bne.n	11996 <__lshift+0x3e>
   1199e:	ldr	r4, [r6, #16]
   119a0:	add.w	r1, r6, #20
   119a4:	ands.w	r9, r9, #31
   119a8:	add.w	lr, r1, r4, lsl #2
   119ac:	beq.n	119f2 <__lshift+0x9a>
   119ae:	rsb	r2, r9, #32
   119b2:	movs	r4, #0
   119b4:	ldr	r7, [r1, #0]
   119b6:	lsl.w	ip, r7, r9
   119ba:	orr.w	r4, ip, r4
   119be:	mov	ip, r3
   119c0:	str.w	r4, [r3], #4
   119c4:	ldr.w	r4, [r1], #4
   119c8:	cmp	lr, r1
   119ca:	lsr.w	r4, r4, r2
   119ce:	bhi.n	119b4 <__lshift+0x5c>
   119d0:	str.w	r4, [ip, #4]
   119d4:	cbz	r4, 119da <__lshift+0x82>
   119d6:	add.w	r5, r8, #2
   119da:	ldr.w	r3, [sl, #76]	; 0x4c
   119de:	ldr	r2, [r6, #4]
   119e0:	subs	r5, #1
   119e2:	ldr.w	r1, [r3, r2, lsl #2]
   119e6:	str	r5, [r0, #16]
   119e8:	str	r1, [r6, #0]
   119ea:	str.w	r6, [r3, r2, lsl #2]
   119ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   119f2:	subs	r3, #4
   119f4:	ldr.w	r2, [r1], #4
   119f8:	str.w	r2, [r3, #4]!
   119fc:	cmp	lr, r1
   119fe:	bhi.n	119f4 <__lshift+0x9c>
   11a00:	b.n	119da <__lshift+0x82>
   11a02:	mov	r3, r2
   11a04:	b.n	1199e <__lshift+0x46>
   11a06:	nop

00011a08 <__mcmp>:
   11a08:	ldr	r2, [r0, #16]
   11a0a:	ldr	r3, [r1, #16]
   11a0c:	subs	r2, r2, r3
   11a0e:	bne.n	11a38 <__mcmp+0x30>
   11a10:	lsls	r3, r3, #2
   11a12:	adds	r0, #20
   11a14:	adds	r1, #20
   11a16:	add	r1, r3
   11a18:	push	{r4}
   11a1a:	add	r3, r0
   11a1c:	b.n	11a22 <__mcmp+0x1a>
   11a1e:	cmp	r0, r3
   11a20:	bcs.n	11a3c <__mcmp+0x34>
   11a22:	ldr.w	r4, [r3, #-4]!
   11a26:	ldr.w	r2, [r1, #-4]!
   11a2a:	cmp	r4, r2
   11a2c:	beq.n	11a1e <__mcmp+0x16>
   11a2e:	bcc.n	11a44 <__mcmp+0x3c>
   11a30:	movs	r0, #1
   11a32:	ldr.w	r4, [sp], #4
   11a36:	bx	lr
   11a38:	mov	r0, r2
   11a3a:	bx	lr
   11a3c:	movs	r0, #0
   11a3e:	ldr.w	r4, [sp], #4
   11a42:	bx	lr
   11a44:	mov.w	r0, #4294967295
   11a48:	b.n	11a32 <__mcmp+0x2a>
   11a4a:	nop

00011a4c <__mdiff>:
   11a4c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11a50:	ldr	r3, [r1, #16]
   11a52:	mov	r7, r1
   11a54:	ldr	r1, [r2, #16]
   11a56:	subs	r3, r3, r1
   11a58:	cmp	r3, #0
   11a5a:	mov	r8, r2
   11a5c:	bne.n	11a8e <__mdiff+0x42>
   11a5e:	lsls	r1, r1, #2
   11a60:	add.w	r2, r7, #20
   11a64:	add.w	r5, r8, #20
   11a68:	adds	r3, r2, r1
   11a6a:	add	r1, r5
   11a6c:	b.n	11a72 <__mdiff+0x26>
   11a6e:	cmp	r2, r3
   11a70:	bcs.n	11b30 <__mdiff+0xe4>
   11a72:	ldr.w	r6, [r3, #-4]!
   11a76:	ldr.w	r4, [r1, #-4]!
   11a7a:	cmp	r6, r4
   11a7c:	beq.n	11a6e <__mdiff+0x22>
   11a7e:	bcs.n	11b42 <__mdiff+0xf6>
   11a80:	mov	r3, r7
   11a82:	mov	r4, r2
   11a84:	mov	r7, r8
   11a86:	mov.w	r9, #1
   11a8a:	mov	r8, r3
   11a8c:	b.n	11a9c <__mdiff+0x50>
   11a8e:	blt.n	11b4c <__mdiff+0x100>
   11a90:	add.w	r5, r7, #20
   11a94:	add.w	r4, r2, #20
   11a98:	mov.w	r9, #0
   11a9c:	ldr	r1, [r7, #4]
   11a9e:	bl	11560 <_Balloc>
   11aa2:	ldr.w	r3, [r8, #16]
   11aa6:	ldr	r6, [r7, #16]
   11aa8:	str.w	r9, [r0, #12]
   11aac:	add.w	ip, r4, r3, lsl #2
   11ab0:	mov	lr, r4
   11ab2:	add.w	r7, r5, r6, lsl #2
   11ab6:	add.w	r4, r0, #20
   11aba:	movs	r3, #0
   11abc:	ldr.w	r1, [lr], #4
   11ac0:	ldr.w	r8, [r5], #4
   11ac4:	uxth	r2, r1
   11ac6:	uxtah	r3, r3, r8
   11aca:	lsrs	r1, r1, #16
   11acc:	subs	r2, r3, r2
   11ace:	rsb	r3, r1, r8, lsr #16
   11ad2:	add.w	r3, r3, r2, asr #16
   11ad6:	uxth	r2, r2
   11ad8:	orr.w	r2, r2, r3, lsl #16
   11adc:	cmp	ip, lr
   11ade:	str.w	r2, [r4], #4
   11ae2:	mov.w	r3, r3, asr #16
   11ae6:	bhi.n	11abc <__mdiff+0x70>
   11ae8:	cmp	r7, r5
   11aea:	bls.n	11b1c <__mdiff+0xd0>
   11aec:	mov	ip, r4
   11aee:	mov	r1, r5
   11af0:	ldr.w	lr, [r1], #4
   11af4:	uxtah	r2, r3, lr
   11af8:	asrs	r3, r2, #16
   11afa:	add.w	r3, r3, lr, lsr #16
   11afe:	uxth	r2, r2
   11b00:	orr.w	r2, r2, r3, lsl #16
   11b04:	cmp	r7, r1
   11b06:	str.w	r2, [ip], #4
   11b0a:	mov.w	r3, r3, asr #16
   11b0e:	bhi.n	11af0 <__mdiff+0xa4>
   11b10:	mvns	r5, r5
   11b12:	add	r5, r7
   11b14:	bic.w	r5, r5, #3
   11b18:	adds	r5, #4
   11b1a:	add	r4, r5
   11b1c:	subs	r4, #4
   11b1e:	cbnz	r2, 11b2a <__mdiff+0xde>
   11b20:	ldr.w	r3, [r4, #-4]!
   11b24:	subs	r6, #1
   11b26:	cmp	r3, #0
   11b28:	beq.n	11b20 <__mdiff+0xd4>
   11b2a:	str	r6, [r0, #16]
   11b2c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11b30:	movs	r1, #0
   11b32:	bl	11560 <_Balloc>
   11b36:	movs	r2, #1
   11b38:	movs	r3, #0
   11b3a:	str	r2, [r0, #16]
   11b3c:	str	r3, [r0, #20]
   11b3e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11b42:	mov	r4, r5
   11b44:	mov.w	r9, #0
   11b48:	mov	r5, r2
   11b4a:	b.n	11a9c <__mdiff+0x50>
   11b4c:	mov	r3, r7
   11b4e:	add.w	r4, r7, #20
   11b52:	add.w	r5, r8, #20
   11b56:	mov	r7, r8
   11b58:	mov.w	r9, #1
   11b5c:	mov	r8, r3
   11b5e:	b.n	11a9c <__mdiff+0x50>

00011b60 <__ulp>:
   11b60:	ldr	r3, [pc, #76]	; (11bb0 <__ulp+0x50>)
   11b62:	vmov	r2, s1
   11b66:	ands	r2, r3
   11b68:	sub.w	r3, r2, #54525952	; 0x3400000
   11b6c:	cmp	r3, #0
   11b6e:	ble.n	11b7a <__ulp+0x1a>
   11b70:	movs	r0, #0
   11b72:	mov	r1, r3
   11b74:	vmov	d0, r0, r1
   11b78:	bx	lr
   11b7a:	negs	r3, r3
   11b7c:	asrs	r3, r3, #20
   11b7e:	cmp	r3, #19
   11b80:	ble.n	11b9e <__ulp+0x3e>
   11b82:	subs	r3, #20
   11b84:	cmp	r3, #30
   11b86:	ittte	le
   11b88:	rsble	r3, r3, #31
   11b8c:	movle	r2, #1
   11b8e:	lslle.w	r3, r2, r3
   11b92:	movgt	r3, #1
   11b94:	movs	r1, #0
   11b96:	mov	r0, r3
   11b98:	vmov	d0, r0, r1
   11b9c:	bx	lr
   11b9e:	mov.w	r2, #524288	; 0x80000
   11ba2:	movs	r0, #0
   11ba4:	asr.w	r1, r2, r3
   11ba8:	vmov	d0, r0, r1
   11bac:	bx	lr
   11bae:	nop
   11bb0:	.word	0x7ff00000

00011bb4 <__b2d>:
   11bb4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11bb8:	ldr	r6, [r0, #16]
   11bba:	add.w	r8, r0, #20
   11bbe:	add.w	r6, r8, r6, lsl #2
   11bc2:	ldr.w	r7, [r6, #-4]
   11bc6:	mov	r0, r7
   11bc8:	bl	116d8 <__hi0bits>
   11bcc:	rsb	r3, r0, #32
   11bd0:	cmp	r0, #10
   11bd2:	str	r3, [r1, #0]
   11bd4:	sub.w	r3, r6, #4
   11bd8:	bgt.n	11c0c <__b2d+0x58>
   11bda:	cmp	r8, r3
   11bdc:	rsb	r2, r0, #11
   11be0:	it	cc
   11be2:	ldrcc.w	r3, [r6, #-8]
   11be6:	lsr.w	r1, r7, r2
   11bea:	add.w	r0, r0, #21
   11bee:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   11bf2:	ite	cc
   11bf4:	lsrcc	r3, r2
   11bf6:	movcs	r3, #0
   11bf8:	lsl.w	r0, r7, r0
   11bfc:	orr.w	r5, r5, #3145728	; 0x300000
   11c00:	orr.w	r4, r0, r3
   11c04:	vmov	d0, r4, r5
   11c08:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11c0c:	cmp	r8, r3
   11c0e:	bcs.n	11c52 <__b2d+0x9e>
   11c10:	subs.w	r3, r0, #11
   11c14:	ldr.w	r2, [r6, #-8]
   11c18:	beq.n	11c58 <__b2d+0xa4>
   11c1a:	lsl.w	r0, r7, r3
   11c1e:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   11c22:	rsb	lr, r3, #32
   11c26:	sub.w	r1, r6, #8
   11c2a:	orr.w	r7, r7, #3145728	; 0x300000
   11c2e:	lsr.w	r0, r2, lr
   11c32:	cmp	r8, r1
   11c34:	orr.w	r5, r7, r0
   11c38:	bcs.n	11c7c <__b2d+0xc8>
   11c3a:	ldr.w	r1, [r6, #-12]
   11c3e:	lsl.w	r0, r2, r3
   11c42:	lsr.w	r3, r1, lr
   11c46:	orrs	r0, r3
   11c48:	mov	r4, r0
   11c4a:	vmov	d0, r4, r5
   11c4e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11c52:	subs	r0, #11
   11c54:	bne.n	11c6a <__b2d+0xb6>
   11c56:	mov	r2, r0
   11c58:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   11c5c:	orr.w	r5, r5, #3145728	; 0x300000
   11c60:	mov	r4, r2
   11c62:	vmov	d0, r4, r5
   11c66:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11c6a:	lsl.w	r0, r7, r0
   11c6e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   11c72:	movs	r0, #0
   11c74:	orr.w	r5, r5, #3145728	; 0x300000
   11c78:	mov	r4, r0
   11c7a:	b.n	11c4a <__b2d+0x96>
   11c7c:	lsl.w	r0, r2, r3
   11c80:	mov	r4, r0
   11c82:	b.n	11c4a <__b2d+0x96>

00011c84 <__d2b>:
   11c84:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11c88:	vmov	r6, r7, d0
   11c8c:	sub	sp, #12
   11c8e:	mov	r8, r1
   11c90:	movs	r1, #1
   11c92:	mov	r4, r7
   11c94:	ubfx	r5, r7, #20, #11
   11c98:	mov	r7, r2
   11c9a:	bl	11560 <_Balloc>
   11c9e:	ubfx	r4, r4, #0, #20
   11ca2:	mov	r9, r0
   11ca4:	cbz	r5, 11caa <__d2b+0x26>
   11ca6:	orr.w	r4, r4, #1048576	; 0x100000
   11caa:	str	r4, [sp, #4]
   11cac:	cbz	r6, 11cf6 <__d2b+0x72>
   11cae:	add	r0, sp, #8
   11cb0:	str.w	r6, [r0, #-8]!
   11cb4:	bl	11718 <__lo0bits>
   11cb8:	cmp	r0, #0
   11cba:	bne.n	11d26 <__d2b+0xa2>
   11cbc:	ldmia.w	sp, {r2, r3}
   11cc0:	str.w	r2, [r9, #20]
   11cc4:	cmp	r3, #0
   11cc6:	ite	eq
   11cc8:	moveq	r1, #1
   11cca:	movne	r1, #2
   11ccc:	str.w	r3, [r9, #24]
   11cd0:	str.w	r1, [r9, #16]
   11cd4:	cbnz	r5, 11d0e <__d2b+0x8a>
   11cd6:	add.w	r3, r9, r1, lsl #2
   11cda:	subw	r0, r0, #1074	; 0x432
   11cde:	str.w	r0, [r8]
   11ce2:	ldr	r0, [r3, #16]
   11ce4:	bl	116d8 <__hi0bits>
   11ce8:	rsb	r0, r0, r1, lsl #5
   11cec:	str	r0, [r7, #0]
   11cee:	mov	r0, r9
   11cf0:	add	sp, #12
   11cf2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11cf6:	add	r0, sp, #4
   11cf8:	bl	11718 <__lo0bits>
   11cfc:	ldr	r3, [sp, #4]
   11cfe:	str.w	r3, [r9, #20]
   11d02:	movs	r1, #1
   11d04:	adds	r0, #32
   11d06:	str.w	r1, [r9, #16]
   11d0a:	cmp	r5, #0
   11d0c:	beq.n	11cd6 <__d2b+0x52>
   11d0e:	subw	r5, r5, #1075	; 0x433
   11d12:	add	r5, r0
   11d14:	rsb	r0, r0, #53	; 0x35
   11d18:	str.w	r5, [r8]
   11d1c:	str	r0, [r7, #0]
   11d1e:	mov	r0, r9
   11d20:	add	sp, #12
   11d22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11d26:	ldmia.w	sp, {r2, r3}
   11d2a:	rsb	r1, r0, #32
   11d2e:	lsl.w	r1, r3, r1
   11d32:	orrs	r2, r1
   11d34:	lsrs	r3, r0
   11d36:	str	r3, [sp, #4]
   11d38:	str.w	r2, [r9, #20]
   11d3c:	b.n	11cc4 <__d2b+0x40>
   11d3e:	nop

00011d40 <__ratio>:
   11d40:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11d44:	sub	sp, #12
   11d46:	mov	r8, r1
   11d48:	mov	r1, sp
   11d4a:	mov	r9, r0
   11d4c:	bl	11bb4 <__b2d>
   11d50:	mov	r0, r8
   11d52:	add	r1, sp, #4
   11d54:	vmov	r4, r5, d0
   11d58:	bl	11bb4 <__b2d>
   11d5c:	ldmia.w	sp, {r1, r3}
   11d60:	ldr.w	r2, [r9, #16]
   11d64:	ldr.w	r0, [r8, #16]
   11d68:	subs	r1, r1, r3
   11d6a:	subs	r0, r2, r0
   11d6c:	add.w	r3, r1, r0, lsl #5
   11d70:	cmp	r3, #0
   11d72:	vmov	r6, r7, d0
   11d76:	ble.n	11d94 <__ratio+0x54>
   11d78:	add.w	r1, r5, r3, lsl #20
   11d7c:	mov	r5, r1
   11d7e:	mov	r2, r6
   11d80:	mov	r3, r7
   11d82:	mov	r0, r4
   11d84:	mov	r1, r5
   11d86:	bl	aa0c <__aeabi_ddiv>
   11d8a:	vmov	d0, r0, r1
   11d8e:	add	sp, #12
   11d90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11d94:	sub.w	r9, r7, r3, lsl #20
   11d98:	vmov	r6, s0
   11d9c:	mov	r7, r9
   11d9e:	b.n	11d7e <__ratio+0x3e>

00011da0 <__copybits>:
   11da0:	push	{r4, r5, r6}
   11da2:	ldr	r4, [r2, #16]
   11da4:	add.w	r3, r2, #20
   11da8:	subs	r1, #1
   11daa:	asrs	r6, r1, #5
   11dac:	add.w	r4, r3, r4, lsl #2
   11db0:	adds	r6, #1
   11db2:	cmp	r3, r4
   11db4:	add.w	r6, r0, r6, lsl #2
   11db8:	bcs.n	11dd4 <__copybits+0x34>
   11dba:	subs	r1, r0, #4
   11dbc:	ldr.w	r5, [r3], #4
   11dc0:	str.w	r5, [r1, #4]!
   11dc4:	cmp	r4, r3
   11dc6:	bhi.n	11dbc <__copybits+0x1c>
   11dc8:	subs	r3, r4, r2
   11dca:	subs	r3, #21
   11dcc:	bic.w	r3, r3, #3
   11dd0:	adds	r3, #4
   11dd2:	add	r0, r3
   11dd4:	cmp	r6, r0
   11dd6:	bls.n	11de2 <__copybits+0x42>
   11dd8:	movs	r3, #0
   11dda:	str.w	r3, [r0], #4
   11dde:	cmp	r6, r0
   11de0:	bhi.n	11dda <__copybits+0x3a>
   11de2:	pop	{r4, r5, r6}
   11de4:	bx	lr
   11de6:	nop

00011de8 <__any_on>:
   11de8:	ldr	r3, [r0, #16]
   11dea:	asrs	r2, r1, #5
   11dec:	cmp	r3, r2
   11dee:	push	{r4}
   11df0:	add.w	r4, r0, #20
   11df4:	bge.n	11e18 <__any_on+0x30>
   11df6:	add.w	r3, r4, r3, lsl #2
   11dfa:	cmp	r4, r3
   11dfc:	bcs.n	11e42 <__any_on+0x5a>
   11dfe:	ldr.w	r0, [r3, #-4]
   11e02:	subs	r3, #4
   11e04:	cbz	r0, 11e0e <__any_on+0x26>
   11e06:	b.n	11e34 <__any_on+0x4c>
   11e08:	ldr.w	r2, [r3, #-4]!
   11e0c:	cbnz	r2, 11e34 <__any_on+0x4c>
   11e0e:	cmp	r4, r3
   11e10:	bcc.n	11e08 <__any_on+0x20>
   11e12:	ldr.w	r4, [sp], #4
   11e16:	bx	lr
   11e18:	ble.n	11e3c <__any_on+0x54>
   11e1a:	ands.w	r1, r1, #31
   11e1e:	beq.n	11e3c <__any_on+0x54>
   11e20:	ldr.w	r0, [r4, r2, lsl #2]
   11e24:	lsr.w	r3, r0, r1
   11e28:	lsl.w	r1, r3, r1
   11e2c:	cmp	r0, r1
   11e2e:	add.w	r3, r4, r2, lsl #2
   11e32:	beq.n	11dfa <__any_on+0x12>
   11e34:	movs	r0, #1
   11e36:	ldr.w	r4, [sp], #4
   11e3a:	bx	lr
   11e3c:	add.w	r3, r4, r2, lsl #2
   11e40:	b.n	11dfa <__any_on+0x12>
   11e42:	movs	r0, #0
   11e44:	b.n	11e12 <__any_on+0x2a>
   11e46:	nop

00011e48 <__sccl>:
   11e48:	push	{r4, r5, r6}
   11e4a:	ldrb	r5, [r1, #0]
   11e4c:	cmp	r5, #94	; 0x5e
   11e4e:	beq.n	11eb0 <__sccl+0x68>
   11e50:	movs	r2, #0
   11e52:	adds	r1, #1
   11e54:	mov	r6, r2
   11e56:	subs	r3, r0, #1
   11e58:	add.w	r4, r0, #255	; 0xff
   11e5c:	strb.w	r2, [r3, #1]!
   11e60:	cmp	r3, r4
   11e62:	bne.n	11e5c <__sccl+0x14>
   11e64:	cbz	r5, 11e88 <__sccl+0x40>
   11e66:	eor.w	r2, r6, #1
   11e6a:	strb	r2, [r0, r5]
   11e6c:	adds	r4, r1, #1
   11e6e:	ldrb.w	r3, [r4, #-1]
   11e72:	cmp	r3, #45	; 0x2d
   11e74:	beq.n	11e94 <__sccl+0x4c>
   11e76:	cmp	r3, #93	; 0x5d
   11e78:	beq.n	11e8e <__sccl+0x46>
   11e7a:	cbz	r3, 11e82 <__sccl+0x3a>
   11e7c:	mov	r5, r3
   11e7e:	mov	r1, r4
   11e80:	b.n	11e6a <__sccl+0x22>
   11e82:	mov	r0, r1
   11e84:	pop	{r4, r5, r6}
   11e86:	bx	lr
   11e88:	subs	r0, r1, #1
   11e8a:	pop	{r4, r5, r6}
   11e8c:	bx	lr
   11e8e:	mov	r0, r4
   11e90:	pop	{r4, r5, r6}
   11e92:	bx	lr
   11e94:	ldrb	r6, [r1, #1]
   11e96:	cmp	r6, #93	; 0x5d
   11e98:	beq.n	11e7c <__sccl+0x34>
   11e9a:	cmp	r5, r6
   11e9c:	bgt.n	11e7c <__sccl+0x34>
   11e9e:	adds	r1, #2
   11ea0:	adds	r3, r0, r5
   11ea2:	adds	r5, #1
   11ea4:	cmp	r6, r5
   11ea6:	strb.w	r2, [r3, #1]!
   11eaa:	bgt.n	11ea2 <__sccl+0x5a>
   11eac:	adds	r4, #2
   11eae:	b.n	11e6e <__sccl+0x26>
   11eb0:	movs	r2, #1
   11eb2:	ldrb	r5, [r1, #1]
   11eb4:	mov	r6, r2
   11eb6:	adds	r1, #2
   11eb8:	b.n	11e56 <__sccl+0xe>
   11eba:	nop

00011ebc <_strtoll_l.isra.0>:
   11ebc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ec0:	sub	sp, #20
   11ec2:	mov	sl, r3
   11ec4:	str	r1, [sp, #8]
   11ec6:	str	r0, [sp, #12]
   11ec8:	str	r2, [sp, #4]
   11eca:	mov	r7, r1
   11ecc:	ldr	r6, [sp, #56]	; 0x38
   11ece:	b.n	11ed2 <_strtoll_l.isra.0+0x16>
   11ed0:	mov	r7, r5
   11ed2:	mov	r5, r7
   11ed4:	mov	r0, r6
   11ed6:	ldrb.w	r4, [r5], #1
   11eda:	bl	b488 <__locale_ctype_ptr_l>
   11ede:	add	r0, r4
   11ee0:	ldrb	r3, [r0, #1]
   11ee2:	and.w	r3, r3, #8
   11ee6:	and.w	r2, r3, #255	; 0xff
   11eea:	cmp	r3, #0
   11eec:	bne.n	11ed0 <_strtoll_l.isra.0+0x14>
   11eee:	cmp	r4, #45	; 0x2d
   11ef0:	beq.w	11ffa <_strtoll_l.isra.0+0x13e>
   11ef4:	cmp	r4, #43	; 0x2b
   11ef6:	it	eq
   11ef8:	ldrbeq	r4, [r7, #1]
   11efa:	str	r2, [sp, #0]
   11efc:	it	eq
   11efe:	addeq	r5, r7, #2
   11f00:	cmp.w	sl, #0
   11f04:	beq.n	11f20 <_strtoll_l.isra.0+0x64>
   11f06:	cmp.w	sl, #16
   11f0a:	beq.w	12038 <_strtoll_l.isra.0+0x17c>
   11f0e:	ldr	r3, [sp, #0]
   11f10:	mov	r6, sl
   11f12:	asrs	r7, r6, #31
   11f14:	cbnz	r3, 11f32 <_strtoll_l.isra.0+0x76>
   11f16:	mov.w	r8, #4294967295
   11f1a:	mvn.w	r9, #2147483648	; 0x80000000
   11f1e:	b.n	11f3a <_strtoll_l.isra.0+0x7e>
   11f20:	cmp	r4, #48	; 0x30
   11f22:	beq.n	12024 <_strtoll_l.isra.0+0x168>
   11f24:	movs	r6, #10
   11f26:	movs	r7, #0
   11f28:	mov.w	sl, #10
   11f2c:	ldr	r3, [sp, #0]
   11f2e:	cmp	r3, #0
   11f30:	beq.n	11f16 <_strtoll_l.isra.0+0x5a>
   11f32:	mov.w	r8, #0
   11f36:	mov.w	r9, #2147483648	; 0x80000000
   11f3a:	mov	r2, r6
   11f3c:	mov	r3, r7
   11f3e:	mov	r0, r8
   11f40:	mov	r1, r9
   11f42:	bl	b064 <__aeabi_uldivmod>
   11f46:	mov	r3, r7
   11f48:	mov	fp, r2
   11f4a:	mov	r0, r8
   11f4c:	mov	r2, r6
   11f4e:	mov	r1, r9
   11f50:	bl	b064 <__aeabi_uldivmod>
   11f54:	mov.w	lr, #0
   11f58:	movs	r2, #0
   11f5a:	movs	r3, #0
   11f5c:	b.n	11f7e <_strtoll_l.isra.0+0xc2>
   11f5e:	beq.n	11fec <_strtoll_l.isra.0+0x130>
   11f60:	mul.w	r4, r2, r7
   11f64:	mla	r4, r6, r3, r4
   11f68:	umull	r2, r3, r2, r6
   11f6c:	add	r3, r4
   11f6e:	adds.w	r2, r2, ip
   11f72:	adc.w	r3, r3, ip, asr #31
   11f76:	mov.w	lr, #1
   11f7a:	ldrb.w	r4, [r5], #1
   11f7e:	sub.w	ip, r4, #48	; 0x30
   11f82:	cmp.w	ip, #9
   11f86:	bls.n	11f96 <_strtoll_l.isra.0+0xda>
   11f88:	sub.w	ip, r4, #65	; 0x41
   11f8c:	cmp.w	ip, #25
   11f90:	bhi.n	11fae <_strtoll_l.isra.0+0xf2>
   11f92:	sub.w	ip, r4, #55	; 0x37
   11f96:	cmp	sl, ip
   11f98:	ble.n	11fc0 <_strtoll_l.isra.0+0x104>
   11f9a:	cmp.w	lr, #4294967295
   11f9e:	beq.n	11f7a <_strtoll_l.isra.0+0xbe>
   11fa0:	cmp	r1, r3
   11fa2:	it	eq
   11fa4:	cmpeq	r0, r2
   11fa6:	bcs.n	11f5e <_strtoll_l.isra.0+0xa2>
   11fa8:	mov.w	lr, #4294967295
   11fac:	b.n	11f7a <_strtoll_l.isra.0+0xbe>
   11fae:	sub.w	ip, r4, #97	; 0x61
   11fb2:	cmp.w	ip, #25
   11fb6:	bhi.n	11fc0 <_strtoll_l.isra.0+0x104>
   11fb8:	sub.w	ip, r4, #87	; 0x57
   11fbc:	cmp	sl, ip
   11fbe:	bgt.n	11f9a <_strtoll_l.isra.0+0xde>
   11fc0:	cmp.w	lr, #4294967295
   11fc4:	beq.n	12004 <_strtoll_l.isra.0+0x148>
   11fc6:	ldr	r1, [sp, #0]
   11fc8:	cbz	r1, 11fd0 <_strtoll_l.isra.0+0x114>
   11fca:	negs	r2, r2
   11fcc:	sbc.w	r3, r3, r3, lsl #1
   11fd0:	ldr	r1, [sp, #4]
   11fd2:	cmp	r1, #0
   11fd4:	beq.n	1205c <_strtoll_l.isra.0+0x1a0>
   11fd6:	cmp.w	lr, #0
   11fda:	bne.n	1201c <_strtoll_l.isra.0+0x160>
   11fdc:	ldr	r5, [sp, #8]
   11fde:	mov	r0, r2
   11fe0:	mov	r1, r3
   11fe2:	ldr	r3, [sp, #4]
   11fe4:	str	r5, [r3, #0]
   11fe6:	add	sp, #20
   11fe8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11fec:	cmp	fp, ip
   11fee:	bge.n	11f60 <_strtoll_l.isra.0+0xa4>
   11ff0:	mov	r2, r0
   11ff2:	mov	r3, r1
   11ff4:	mov.w	lr, #4294967295
   11ff8:	b.n	11f7a <_strtoll_l.isra.0+0xbe>
   11ffa:	movs	r3, #1
   11ffc:	adds	r5, r7, #2
   11ffe:	ldrb	r4, [r7, #1]
   12000:	str	r3, [sp, #0]
   12002:	b.n	11f00 <_strtoll_l.isra.0+0x44>
   12004:	ldr	r3, [sp, #0]
   12006:	cbnz	r3, 12054 <_strtoll_l.isra.0+0x198>
   12008:	mov.w	r0, #4294967295
   1200c:	mvn.w	r1, #2147483648	; 0x80000000
   12010:	ldr	r2, [sp, #12]
   12012:	movs	r3, #34	; 0x22
   12014:	str	r3, [r2, #0]
   12016:	ldr	r3, [sp, #4]
   12018:	cbnz	r3, 12020 <_strtoll_l.isra.0+0x164>
   1201a:	b.n	11fe6 <_strtoll_l.isra.0+0x12a>
   1201c:	mov	r0, r2
   1201e:	mov	r1, r3
   12020:	subs	r5, #1
   12022:	b.n	11fe2 <_strtoll_l.isra.0+0x126>
   12024:	ldrb	r3, [r5, #0]
   12026:	and.w	r3, r3, #223	; 0xdf
   1202a:	cmp	r3, #88	; 0x58
   1202c:	beq.n	12046 <_strtoll_l.isra.0+0x18a>
   1202e:	movs	r6, #8
   12030:	movs	r7, #0
   12032:	mov.w	sl, #8
   12036:	b.n	11f2c <_strtoll_l.isra.0+0x70>
   12038:	cmp	r4, #48	; 0x30
   1203a:	bne.n	12062 <_strtoll_l.isra.0+0x1a6>
   1203c:	ldrb	r3, [r5, #0]
   1203e:	and.w	r3, r3, #223	; 0xdf
   12042:	cmp	r3, #88	; 0x58
   12044:	bne.n	12062 <_strtoll_l.isra.0+0x1a6>
   12046:	ldrb	r4, [r5, #1]
   12048:	movs	r6, #16
   1204a:	movs	r7, #0
   1204c:	adds	r5, #2
   1204e:	mov.w	sl, #16
   12052:	b.n	11f2c <_strtoll_l.isra.0+0x70>
   12054:	movs	r0, #0
   12056:	mov.w	r1, #2147483648	; 0x80000000
   1205a:	b.n	12010 <_strtoll_l.isra.0+0x154>
   1205c:	mov	r0, r2
   1205e:	mov	r1, r3
   12060:	b.n	11fe6 <_strtoll_l.isra.0+0x12a>
   12062:	movs	r6, #16
   12064:	movs	r7, #0
   12066:	b.n	11f2c <_strtoll_l.isra.0+0x70>

00012068 <_strtoll_r>:
   12068:	push	{r4, r5, lr}
   1206a:	ldr	r4, [pc, #24]	; (12084 <_strtoll_r+0x1c>)
   1206c:	ldr	r5, [pc, #24]	; (12088 <_strtoll_r+0x20>)
   1206e:	ldr	r4, [r4, #0]
   12070:	ldr	r4, [r4, #52]	; 0x34
   12072:	sub	sp, #12
   12074:	cmp	r4, #0
   12076:	it	eq
   12078:	moveq	r4, r5
   1207a:	str	r4, [sp, #0]
   1207c:	bl	11ebc <_strtoll_l.isra.0>
   12080:	add	sp, #12
   12082:	pop	{r4, r5, pc}
   12084:	.word	0x20014230
   12088:	.word	0x20014234

0001208c <_strtoul_l.isra.0>:
   1208c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12090:	ldr.w	r9, [sp, #40]	; 0x28
   12094:	mov	r6, r1
   12096:	mov	r7, r0
   12098:	mov	r5, r2
   1209a:	mov	r8, r3
   1209c:	mov	fp, r1
   1209e:	b.n	120a2 <_strtoul_l.isra.0+0x16>
   120a0:	mov	fp, r4
   120a2:	mov	r4, fp
   120a4:	mov	r0, r9
   120a6:	ldrb.w	sl, [r4], #1
   120aa:	bl	b488 <__locale_ctype_ptr_l>
   120ae:	add	r0, sl
   120b0:	ldrb	r0, [r0, #1]
   120b2:	and.w	r0, r0, #8
   120b6:	and.w	ip, r0, #255	; 0xff
   120ba:	cmp	r0, #0
   120bc:	bne.n	120a0 <_strtoul_l.isra.0+0x14>
   120be:	mov	r1, sl
   120c0:	cmp	r1, #45	; 0x2d
   120c2:	beq.n	12188 <_strtoul_l.isra.0+0xfc>
   120c4:	cmp	r1, #43	; 0x2b
   120c6:	itt	eq
   120c8:	ldrbeq.w	r1, [fp, #1]
   120cc:	addeq.w	r4, fp, #2
   120d0:	cmp.w	r8, #0
   120d4:	beq.n	120f0 <_strtoul_l.isra.0+0x64>
   120d6:	cmp.w	r8, #16
   120da:	beq.n	12196 <_strtoul_l.isra.0+0x10a>
   120dc:	mov.w	r3, #4294967295
   120e0:	udiv	r3, r3, r8
   120e4:	mul.w	sl, r8, r3
   120e8:	mvn.w	sl, sl
   120ec:	mov	r9, r8
   120ee:	b.n	12100 <_strtoul_l.isra.0+0x74>
   120f0:	cmp	r1, #48	; 0x30
   120f2:	beq.n	121b8 <_strtoul_l.isra.0+0x12c>
   120f4:	mov.w	r8, #10
   120f8:	ldr	r3, [pc, #244]	; (121f0 <_strtoul_l.isra.0+0x164>)
   120fa:	mov	r9, r8
   120fc:	mov.w	sl, #5
   12100:	mov.w	lr, #0
   12104:	mov	r0, lr
   12106:	b.n	12116 <_strtoul_l.isra.0+0x8a>
   12108:	beq.n	1216a <_strtoul_l.isra.0+0xde>
   1210a:	mla	r0, r9, r0, r2
   1210e:	mov.w	lr, #1
   12112:	ldrb.w	r1, [r4], #1
   12116:	sub.w	r2, r1, #48	; 0x30
   1211a:	cmp	r2, #9
   1211c:	bls.n	1212a <_strtoul_l.isra.0+0x9e>
   1211e:	sub.w	r2, r1, #65	; 0x41
   12122:	cmp	r2, #25
   12124:	bhi.n	1213e <_strtoul_l.isra.0+0xb2>
   12126:	sub.w	r2, r1, #55	; 0x37
   1212a:	cmp	r8, r2
   1212c:	ble.n	1214e <_strtoul_l.isra.0+0xc2>
   1212e:	cmp.w	lr, #4294967295
   12132:	beq.n	12112 <_strtoul_l.isra.0+0x86>
   12134:	cmp	r0, r3
   12136:	bls.n	12108 <_strtoul_l.isra.0+0x7c>
   12138:	mov.w	lr, #4294967295
   1213c:	b.n	12112 <_strtoul_l.isra.0+0x86>
   1213e:	sub.w	r2, r1, #97	; 0x61
   12142:	cmp	r2, #25
   12144:	bhi.n	1214e <_strtoul_l.isra.0+0xc2>
   12146:	sub.w	r2, r1, #87	; 0x57
   1214a:	cmp	r8, r2
   1214c:	bgt.n	1212e <_strtoul_l.isra.0+0xa2>
   1214e:	cmp.w	lr, #4294967295
   12152:	beq.n	12178 <_strtoul_l.isra.0+0xec>
   12154:	cmp.w	ip, #0
   12158:	beq.n	1215c <_strtoul_l.isra.0+0xd0>
   1215a:	negs	r0, r0
   1215c:	cbz	r5, 12174 <_strtoul_l.isra.0+0xe8>
   1215e:	cmp.w	lr, #0
   12162:	bne.n	12180 <_strtoul_l.isra.0+0xf4>
   12164:	str	r6, [r5, #0]
   12166:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1216a:	cmp	r2, sl
   1216c:	ble.n	1210a <_strtoul_l.isra.0+0x7e>
   1216e:	mov.w	lr, #4294967295
   12172:	b.n	12112 <_strtoul_l.isra.0+0x86>
   12174:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12178:	movs	r3, #34	; 0x22
   1217a:	str	r3, [r7, #0]
   1217c:	mov	r0, lr
   1217e:	cbz	r5, 121d2 <_strtoul_l.isra.0+0x146>
   12180:	subs	r6, r4, #1
   12182:	str	r6, [r5, #0]
   12184:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12188:	add.w	r4, fp, #2
   1218c:	ldrb.w	r1, [fp, #1]
   12190:	mov.w	ip, #1
   12194:	b.n	120d0 <_strtoul_l.isra.0+0x44>
   12196:	cmp	r1, #48	; 0x30
   12198:	bne.n	121d6 <_strtoul_l.isra.0+0x14a>
   1219a:	ldrb	r3, [r4, #0]
   1219c:	and.w	r3, r3, #223	; 0xdf
   121a0:	cmp	r3, #88	; 0x58
   121a2:	bne.n	121e2 <_strtoul_l.isra.0+0x156>
   121a4:	mov.w	r9, #16
   121a8:	ldrb	r1, [r4, #1]
   121aa:	mov	r8, r9
   121ac:	mov.w	sl, #15
   121b0:	adds	r4, #2
   121b2:	mvn.w	r3, #4026531840	; 0xf0000000
   121b6:	b.n	12100 <_strtoul_l.isra.0+0x74>
   121b8:	ldrb	r3, [r4, #0]
   121ba:	and.w	r3, r3, #223	; 0xdf
   121be:	cmp	r3, #88	; 0x58
   121c0:	beq.n	121a4 <_strtoul_l.isra.0+0x118>
   121c2:	mov.w	r8, #8
   121c6:	mov	r9, r8
   121c8:	mov.w	sl, #7
   121cc:	mvn.w	r3, #3758096384	; 0xe0000000
   121d0:	b.n	12100 <_strtoul_l.isra.0+0x74>
   121d2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   121d6:	mov.w	sl, #15
   121da:	mvn.w	r3, #4026531840	; 0xf0000000
   121de:	mov	r9, r8
   121e0:	b.n	12100 <_strtoul_l.isra.0+0x74>
   121e2:	mov	r9, r8
   121e4:	mov.w	sl, #15
   121e8:	mvn.w	r3, #4026531840	; 0xf0000000
   121ec:	b.n	12100 <_strtoul_l.isra.0+0x74>
   121ee:	nop
   121f0:	.word	0x19999999

000121f4 <_strtoul_r>:
   121f4:	push	{r4, r5, lr}
   121f6:	ldr	r4, [pc, #24]	; (12210 <_strtoul_r+0x1c>)
   121f8:	ldr	r5, [pc, #24]	; (12214 <_strtoul_r+0x20>)
   121fa:	ldr	r4, [r4, #0]
   121fc:	ldr	r4, [r4, #52]	; 0x34
   121fe:	sub	sp, #12
   12200:	cmp	r4, #0
   12202:	it	eq
   12204:	moveq	r4, r5
   12206:	str	r4, [sp, #0]
   12208:	bl	1208c <_strtoul_l.isra.0>
   1220c:	add	sp, #12
   1220e:	pop	{r4, r5, pc}
   12210:	.word	0x20014230
   12214:	.word	0x20014234

00012218 <_strtoull_l.isra.0>:
   12218:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1221c:	sub	sp, #20
   1221e:	mov	fp, r1
   12220:	str	r0, [sp, #8]
   12222:	mov	r7, r2
   12224:	mov	r6, r3
   12226:	mov	r8, r1
   12228:	ldr	r4, [sp, #56]	; 0x38
   1222a:	b.n	1222e <_strtoull_l.isra.0+0x16>
   1222c:	mov	r8, r5
   1222e:	mov	r5, r8
   12230:	mov	r0, r4
   12232:	ldrb.w	r9, [r5], #1
   12236:	bl	b488 <__locale_ctype_ptr_l>
   1223a:	add	r0, r9
   1223c:	ldrb	r3, [r0, #1]
   1223e:	and.w	r3, r3, #8
   12242:	and.w	r2, r3, #255	; 0xff
   12246:	cmp	r3, #0
   12248:	bne.n	1222c <_strtoull_l.isra.0+0x14>
   1224a:	mov	r4, r9
   1224c:	cmp	r4, #45	; 0x2d
   1224e:	beq.w	1236a <_strtoull_l.isra.0+0x152>
   12252:	cmp	r4, #43	; 0x2b
   12254:	it	eq
   12256:	ldrbeq.w	r4, [r8, #1]
   1225a:	str	r2, [sp, #4]
   1225c:	it	eq
   1225e:	addeq.w	r5, r8, #2
   12262:	cbz	r6, 1229c <_strtoull_l.isra.0+0x84>
   12264:	cmp	r6, #16
   12266:	beq.w	12378 <_strtoull_l.isra.0+0x160>
   1226a:	mov.w	r9, r6, asr #31
   1226e:	mov	r2, r6
   12270:	mov	r3, r9
   12272:	mov.w	r0, #4294967295
   12276:	mov.w	r1, #4294967295
   1227a:	bl	b064 <__aeabi_uldivmod>
   1227e:	mov	r2, r6
   12280:	str	r0, [sp, #12]
   12282:	mov	sl, r1
   12284:	mov	r3, r9
   12286:	mov.w	r0, #4294967295
   1228a:	mov.w	r1, #4294967295
   1228e:	bl	b064 <__aeabi_uldivmod>
   12292:	mov	r8, r6
   12294:	mov	lr, r2
   12296:	ldr	r2, [sp, #12]
   12298:	mov	r3, sl
   1229a:	b.n	122b6 <_strtoull_l.isra.0+0x9e>
   1229c:	cmp	r4, #48	; 0x30
   1229e:	beq.w	123a4 <_strtoull_l.isra.0+0x18c>
   122a2:	ldr	r3, [pc, #348]	; (12400 <_strtoull_l.isra.0+0x1e8>)
   122a4:	mov.w	lr, #5
   122a8:	mov.w	r2, #2576980377	; 0x99999999
   122ac:	mov.w	r8, #10
   122b0:	mov.w	r9, #0
   122b4:	movs	r6, #10
   122b6:	mov.w	ip, #0
   122ba:	movs	r0, #0
   122bc:	movs	r1, #0
   122be:	b.n	122e6 <_strtoull_l.isra.0+0xce>
   122c0:	cmp	r1, r3
   122c2:	it	eq
   122c4:	cmpeq	r0, r2
   122c6:	beq.n	1234a <_strtoull_l.isra.0+0x132>
   122c8:	mul.w	r4, r0, r9
   122cc:	mla	r4, r8, r1, r4
   122d0:	umull	r0, r1, r0, r8
   122d4:	add	r1, r4
   122d6:	adds.w	r0, r0, sl
   122da:	adc.w	r1, r1, sl, asr #31
   122de:	mov.w	ip, #1
   122e2:	ldrb.w	r4, [r5], #1
   122e6:	sub.w	sl, r4, #48	; 0x30
   122ea:	cmp.w	sl, #9
   122ee:	bls.n	122fe <_strtoull_l.isra.0+0xe6>
   122f0:	sub.w	sl, r4, #65	; 0x41
   122f4:	cmp.w	sl, #25
   122f8:	bhi.n	12316 <_strtoull_l.isra.0+0xfe>
   122fa:	sub.w	sl, r4, #55	; 0x37
   122fe:	cmp	r6, sl
   12300:	ble.n	12328 <_strtoull_l.isra.0+0x110>
   12302:	cmp.w	ip, #4294967295
   12306:	beq.n	122e2 <_strtoull_l.isra.0+0xca>
   12308:	cmp	r3, r1
   1230a:	it	eq
   1230c:	cmpeq	r2, r0
   1230e:	bcs.n	122c0 <_strtoull_l.isra.0+0xa8>
   12310:	mov.w	ip, #4294967295
   12314:	b.n	122e2 <_strtoull_l.isra.0+0xca>
   12316:	sub.w	sl, r4, #97	; 0x61
   1231a:	cmp.w	sl, #25
   1231e:	bhi.n	12328 <_strtoull_l.isra.0+0x110>
   12320:	sub.w	sl, r4, #87	; 0x57
   12324:	cmp	r6, sl
   12326:	bgt.n	12302 <_strtoull_l.isra.0+0xea>
   12328:	cmp.w	ip, #4294967295
   1232c:	beq.n	12354 <_strtoull_l.isra.0+0x13c>
   1232e:	ldr	r3, [sp, #4]
   12330:	cbz	r3, 12338 <_strtoull_l.isra.0+0x120>
   12332:	negs	r0, r0
   12334:	sbc.w	r1, r1, r1, lsl #1
   12338:	cbz	r7, 12344 <_strtoull_l.isra.0+0x12c>
   1233a:	cmp.w	ip, #0
   1233e:	bne.n	12366 <_strtoull_l.isra.0+0x14e>
   12340:	mov	r5, fp
   12342:	str	r5, [r7, #0]
   12344:	add	sp, #20
   12346:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1234a:	cmp	sl, lr
   1234c:	ble.n	122c8 <_strtoull_l.isra.0+0xb0>
   1234e:	mov.w	ip, #4294967295
   12352:	b.n	122e2 <_strtoull_l.isra.0+0xca>
   12354:	ldr	r2, [sp, #8]
   12356:	movs	r3, #34	; 0x22
   12358:	str	r3, [r2, #0]
   1235a:	mov.w	r0, #4294967295
   1235e:	mov.w	r1, #4294967295
   12362:	cmp	r7, #0
   12364:	beq.n	12344 <_strtoull_l.isra.0+0x12c>
   12366:	subs	r5, #1
   12368:	b.n	12342 <_strtoull_l.isra.0+0x12a>
   1236a:	movs	r3, #1
   1236c:	add.w	r5, r8, #2
   12370:	ldrb.w	r4, [r8, #1]
   12374:	str	r3, [sp, #4]
   12376:	b.n	12262 <_strtoull_l.isra.0+0x4a>
   12378:	cmp	r4, #48	; 0x30
   1237a:	bne.n	123c6 <_strtoull_l.isra.0+0x1ae>
   1237c:	ldrb	r3, [r5, #0]
   1237e:	and.w	r3, r3, #223	; 0xdf
   12382:	cmp	r3, #88	; 0x58
   12384:	bne.n	123dc <_strtoull_l.isra.0+0x1c4>
   12386:	mov.w	r3, #4294967295
   1238a:	ldrb	r4, [r5, #1]
   1238c:	str	r3, [sp, #12]
   1238e:	mov.w	lr, #15
   12392:	adds	r5, #2
   12394:	mvn.w	sl, #4026531840	; 0xf0000000
   12398:	mov.w	r8, #16
   1239c:	mov.w	r9, #0
   123a0:	movs	r6, #16
   123a2:	b.n	12296 <_strtoull_l.isra.0+0x7e>
   123a4:	ldrb	r3, [r5, #0]
   123a6:	and.w	r3, r3, #223	; 0xdf
   123aa:	cmp	r3, #88	; 0x58
   123ac:	beq.n	12386 <_strtoull_l.isra.0+0x16e>
   123ae:	mov.w	lr, #7
   123b2:	mov.w	r2, #4294967295
   123b6:	mvn.w	r3, #3758096384	; 0xe0000000
   123ba:	mov.w	r8, #8
   123be:	mov.w	r9, #0
   123c2:	movs	r6, #8
   123c4:	b.n	122b6 <_strtoull_l.isra.0+0x9e>
   123c6:	mov.w	lr, #15
   123ca:	mov.w	r2, #4294967295
   123ce:	mvn.w	r3, #4026531840	; 0xf0000000
   123d2:	mov.w	r8, #16
   123d6:	mov.w	r9, #0
   123da:	b.n	122b6 <_strtoull_l.isra.0+0x9e>
   123dc:	mov.w	r8, #16
   123e0:	mov.w	r9, #0
   123e4:	mov	r2, r8
   123e6:	mov	r3, r9
   123e8:	mov.w	r0, #4294967295
   123ec:	mov.w	r1, #4294967295
   123f0:	bl	b064 <__aeabi_uldivmod>
   123f4:	mvn.w	r3, #4026531840	; 0xf0000000
   123f8:	mov	lr, r2
   123fa:	mov.w	r2, #4294967295
   123fe:	b.n	122b6 <_strtoull_l.isra.0+0x9e>
   12400:	.word	0x19999999

00012404 <_strtoull_r>:
   12404:	push	{r4, r5, lr}
   12406:	ldr	r4, [pc, #24]	; (12420 <_strtoull_r+0x1c>)
   12408:	ldr	r5, [pc, #24]	; (12424 <_strtoull_r+0x20>)
   1240a:	ldr	r4, [r4, #0]
   1240c:	ldr	r4, [r4, #52]	; 0x34
   1240e:	sub	sp, #12
   12410:	cmp	r4, #0
   12412:	it	eq
   12414:	moveq	r4, r5
   12416:	str	r4, [sp, #0]
   12418:	bl	12218 <_strtoull_l.isra.0>
   1241c:	add	sp, #12
   1241e:	pop	{r4, r5, pc}
   12420:	.word	0x20014230
   12424:	.word	0x20014234

00012428 <__ssprint_r>:
   12428:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1242c:	ldr	r3, [r2, #8]
   1242e:	sub	sp, #12
   12430:	mov	r8, r2
   12432:	cmp	r3, #0
   12434:	beq.n	1251c <__ssprint_r+0xf4>
   12436:	mov	fp, r0
   12438:	mov.w	r9, #0
   1243c:	ldr	r6, [r2, #0]
   1243e:	ldr	r0, [r1, #0]
   12440:	ldr	r3, [r1, #8]
   12442:	mov	r5, r1
   12444:	mov	r4, r9
   12446:	cmp	r4, #0
   12448:	beq.n	124d6 <__ssprint_r+0xae>
   1244a:	cmp	r4, r3
   1244c:	mov	r7, r3
   1244e:	mov	sl, r3
   12450:	bcc.n	124e0 <__ssprint_r+0xb8>
   12452:	ldrh	r3, [r5, #12]
   12454:	tst.w	r3, #1152	; 0x480
   12458:	beq.n	124b6 <__ssprint_r+0x8e>
   1245a:	ldr	r7, [r5, #20]
   1245c:	ldr	r1, [r5, #16]
   1245e:	add.w	r7, r7, r7, lsl #1
   12462:	rsb	sl, r1, r0
   12466:	add.w	r7, r7, r7, lsr #31
   1246a:	adds	r0, r4, #1
   1246c:	asrs	r7, r7, #1
   1246e:	add	r0, sl
   12470:	cmp	r0, r7
   12472:	mov	r2, r7
   12474:	itt	hi
   12476:	movhi	r7, r0
   12478:	movhi	r2, r7
   1247a:	lsls	r3, r3, #21
   1247c:	bpl.n	124e6 <__ssprint_r+0xbe>
   1247e:	mov	r1, r2
   12480:	mov	r0, fp
   12482:	bl	b4c4 <_malloc_r>
   12486:	cmp	r0, #0
   12488:	beq.n	124fa <__ssprint_r+0xd2>
   1248a:	mov	r2, sl
   1248c:	ldr	r1, [r5, #16]
   1248e:	str	r0, [sp, #4]
   12490:	bl	8b4c <memcpy>
   12494:	ldrh	r2, [r5, #12]
   12496:	ldr	r3, [sp, #4]
   12498:	bic.w	r2, r2, #1152	; 0x480
   1249c:	orr.w	r2, r2, #128	; 0x80
   124a0:	strh	r2, [r5, #12]
   124a2:	rsb	r2, sl, r7
   124a6:	add.w	r0, r3, sl
   124aa:	str	r7, [r5, #20]
   124ac:	str	r3, [r5, #16]
   124ae:	str	r0, [r5, #0]
   124b0:	str	r2, [r5, #8]
   124b2:	mov	r7, r4
   124b4:	mov	sl, r4
   124b6:	mov	r2, sl
   124b8:	mov	r1, r9
   124ba:	bl	bb64 <memmove>
   124be:	ldr.w	r2, [r8, #8]
   124c2:	ldr	r3, [r5, #8]
   124c4:	ldr	r0, [r5, #0]
   124c6:	subs	r3, r3, r7
   124c8:	add	r0, sl
   124ca:	subs	r4, r2, r4
   124cc:	str	r3, [r5, #8]
   124ce:	str	r0, [r5, #0]
   124d0:	str.w	r4, [r8, #8]
   124d4:	cbz	r4, 1251c <__ssprint_r+0xf4>
   124d6:	ldr.w	r9, [r6]
   124da:	ldr	r4, [r6, #4]
   124dc:	adds	r6, #8
   124de:	b.n	12446 <__ssprint_r+0x1e>
   124e0:	mov	r7, r4
   124e2:	mov	sl, r4
   124e4:	b.n	124b6 <__ssprint_r+0x8e>
   124e6:	mov	r0, fp
   124e8:	bl	bc34 <_realloc_r>
   124ec:	mov	r3, r0
   124ee:	cmp	r0, #0
   124f0:	bne.n	124a2 <__ssprint_r+0x7a>
   124f2:	ldr	r1, [r5, #16]
   124f4:	mov	r0, fp
   124f6:	bl	10b90 <_free_r>
   124fa:	movs	r3, #12
   124fc:	str.w	r3, [fp]
   12500:	ldrh	r3, [r5, #12]
   12502:	movs	r2, #0
   12504:	orr.w	r3, r3, #64	; 0x40
   12508:	mov.w	r0, #4294967295
   1250c:	strh	r3, [r5, #12]
   1250e:	str.w	r2, [r8, #8]
   12512:	str.w	r2, [r8, #4]
   12516:	add	sp, #12
   12518:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1251c:	movs	r0, #0
   1251e:	str.w	r0, [r8, #4]
   12522:	add	sp, #12
   12524:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00012528 <_sungetc_r>:
   12528:	adds	r3, r1, #1
   1252a:	push	{r4, r5, r6, lr}
   1252c:	beq.n	12566 <_sungetc_r+0x3e>
   1252e:	ldrh	r3, [r2, #12]
   12530:	ldr	r4, [r2, #48]	; 0x30
   12532:	bic.w	r3, r3, #32
   12536:	strh	r3, [r2, #12]
   12538:	uxtb	r5, r1
   1253a:	cbz	r4, 1256c <_sungetc_r+0x44>
   1253c:	mov	r4, r2
   1253e:	ldr	r2, [r2, #4]
   12540:	ldr	r3, [r4, #52]	; 0x34
   12542:	cmp	r2, r3
   12544:	mov	r6, r1
   12546:	bge.n	1255c <_sungetc_r+0x34>
   12548:	ldr	r3, [r4, #0]
   1254a:	subs	r2, r3, #1
   1254c:	str	r2, [r4, #0]
   1254e:	strb.w	r6, [r3, #-1]
   12552:	ldr	r3, [r4, #4]
   12554:	adds	r3, #1
   12556:	str	r3, [r4, #4]
   12558:	mov	r0, r5
   1255a:	pop	{r4, r5, r6, pc}
   1255c:	mov	r1, r4
   1255e:	bl	1266c <__submore>
   12562:	cmp	r0, #0
   12564:	beq.n	12548 <_sungetc_r+0x20>
   12566:	mov.w	r5, #4294967295
   1256a:	b.n	12558 <_sungetc_r+0x30>
   1256c:	ldr	r0, [r2, #16]
   1256e:	ldr	r3, [r2, #0]
   12570:	cbz	r0, 1257e <_sungetc_r+0x56>
   12572:	cmp	r0, r3
   12574:	bcs.n	1257e <_sungetc_r+0x56>
   12576:	ldrb.w	r0, [r3, #-1]
   1257a:	cmp	r5, r0
   1257c:	beq.n	1259e <_sungetc_r+0x76>
   1257e:	str	r3, [r2, #56]	; 0x38
   12580:	mov	r3, r2
   12582:	ldr	r6, [r2, #4]
   12584:	str	r6, [r2, #60]	; 0x3c
   12586:	add.w	r4, r2, #64	; 0x40
   1258a:	movs	r0, #3
   1258c:	str	r0, [r2, #52]	; 0x34
   1258e:	str	r4, [r2, #48]	; 0x30
   12590:	strb.w	r1, [r3, #66]!
   12594:	movs	r1, #1
   12596:	str	r3, [r2, #0]
   12598:	str	r1, [r2, #4]
   1259a:	mov	r0, r5
   1259c:	pop	{r4, r5, r6, pc}
   1259e:	ldr	r1, [r2, #4]
   125a0:	subs	r3, #1
   125a2:	adds	r1, #1
   125a4:	str	r3, [r2, #0]
   125a6:	str	r1, [r2, #4]
   125a8:	b.n	12558 <_sungetc_r+0x30>
   125aa:	nop

000125ac <__ssrefill_r>:
   125ac:	push	{r4, lr}
   125ae:	mov	r4, r1
   125b0:	ldr	r1, [r1, #48]	; 0x30
   125b2:	cbz	r1, 125d0 <__ssrefill_r+0x24>
   125b4:	add.w	r3, r4, #64	; 0x40
   125b8:	cmp	r1, r3
   125ba:	beq.n	125c0 <__ssrefill_r+0x14>
   125bc:	bl	10b90 <_free_r>
   125c0:	ldr	r3, [r4, #60]	; 0x3c
   125c2:	str	r3, [r4, #4]
   125c4:	movs	r0, #0
   125c6:	str	r0, [r4, #48]	; 0x30
   125c8:	cbz	r3, 125d0 <__ssrefill_r+0x24>
   125ca:	ldr	r3, [r4, #56]	; 0x38
   125cc:	str	r3, [r4, #0]
   125ce:	pop	{r4, pc}
   125d0:	ldrh	r3, [r4, #12]
   125d2:	ldr	r2, [r4, #16]
   125d4:	str	r2, [r4, #0]
   125d6:	orr.w	r3, r3, #32
   125da:	movs	r2, #0
   125dc:	strh	r3, [r4, #12]
   125de:	str	r2, [r4, #4]
   125e0:	mov.w	r0, #4294967295
   125e4:	pop	{r4, pc}
   125e6:	nop

000125e8 <_sfread_r>:
   125e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   125ec:	sub	sp, #12
   125ee:	mul.w	r9, r2, r3
   125f2:	str	r2, [sp, #4]
   125f4:	mov	sl, r3
   125f6:	ldr	r4, [sp, #48]	; 0x30
   125f8:	cmp.w	r9, #0
   125fc:	beq.n	12652 <_sfread_r+0x6a>
   125fe:	mov	r7, r0
   12600:	mov	r6, r1
   12602:	mov	r5, r9
   12604:	mov.w	r8, #0
   12608:	b.n	1262a <_sfread_r+0x42>
   1260a:	ldr	r1, [r4, #0]
   1260c:	bl	8b4c <memcpy>
   12610:	ldr	r2, [r4, #0]
   12612:	str.w	r8, [r4, #4]
   12616:	add	r2, fp
   12618:	str	r2, [r4, #0]
   1261a:	mov	r1, r4
   1261c:	mov	r0, r7
   1261e:	add	r6, fp
   12620:	rsb	r5, fp, r5
   12624:	bl	125ac <__ssrefill_r>
   12628:	cbnz	r0, 1265a <_sfread_r+0x72>
   1262a:	ldr.w	fp, [r4, #4]
   1262e:	cmp	r5, fp
   12630:	mov	r0, r6
   12632:	mov	r2, fp
   12634:	bhi.n	1260a <_sfread_r+0x22>
   12636:	mov	r2, r5
   12638:	ldr	r1, [r4, #0]
   1263a:	bl	8b4c <memcpy>
   1263e:	ldr	r2, [r4, #4]
   12640:	ldr	r3, [r4, #0]
   12642:	subs	r2, r2, r5
   12644:	add	r3, r5
   12646:	mov	r0, sl
   12648:	str	r2, [r4, #4]
   1264a:	str	r3, [r4, #0]
   1264c:	add	sp, #12
   1264e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12652:	mov	r0, r9
   12654:	add	sp, #12
   12656:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1265a:	ldr	r3, [sp, #4]
   1265c:	rsb	r9, r5, r9
   12660:	udiv	r0, r9, r3
   12664:	add	sp, #12
   12666:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1266a:	nop

0001266c <__submore>:
   1266c:	add.w	r3, r1, #64	; 0x40
   12670:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12674:	mov	r4, r1
   12676:	ldr	r1, [r1, #48]	; 0x30
   12678:	cmp	r1, r3
   1267a:	beq.n	126a6 <__submore+0x3a>
   1267c:	ldr	r6, [r4, #52]	; 0x34
   1267e:	lsls	r7, r6, #1
   12680:	mov	r2, r7
   12682:	bl	bc34 <_realloc_r>
   12686:	mov	r5, r0
   12688:	cbz	r0, 126dc <__submore+0x70>
   1268a:	add.w	r8, r0, r6
   1268e:	mov	r2, r6
   12690:	mov	r0, r8
   12692:	mov	r1, r5
   12694:	bl	8b4c <memcpy>
   12698:	str.w	r8, [r4]
   1269c:	str	r5, [r4, #48]	; 0x30
   1269e:	str	r7, [r4, #52]	; 0x34
   126a0:	movs	r0, #0
   126a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   126a6:	mov.w	r1, #1024	; 0x400
   126aa:	bl	b4c4 <_malloc_r>
   126ae:	cbz	r0, 126dc <__submore+0x70>
   126b0:	ldrb.w	r3, [r4, #66]	; 0x42
   126b4:	str	r0, [r4, #48]	; 0x30
   126b6:	mov.w	r2, #1024	; 0x400
   126ba:	str	r2, [r4, #52]	; 0x34
   126bc:	strb.w	r3, [r0, #1023]	; 0x3ff
   126c0:	ldrb.w	r3, [r4, #65]	; 0x41
   126c4:	strb.w	r3, [r0, #1022]	; 0x3fe
   126c8:	ldrb.w	r3, [r4, #64]	; 0x40
   126cc:	strb.w	r3, [r0, #1021]	; 0x3fd
   126d0:	addw	r0, r0, #1021	; 0x3fd
   126d4:	str	r0, [r4, #0]
   126d6:	movs	r0, #0
   126d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   126dc:	mov.w	r0, #4294967295
   126e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000126e4 <_vasnprintf_r>:
   126e4:	push	{r4, r5, r6, lr}
   126e6:	mov	r5, r2
   126e8:	sub	sp, #104	; 0x68
   126ea:	ldr	r4, [r2, #0]
   126ec:	cbz	r1, 126f2 <_vasnprintf_r+0xe>
   126ee:	cmp	r4, #0
   126f0:	bne.n	12728 <_vasnprintf_r+0x44>
   126f2:	movs	r4, #0
   126f4:	mov.w	r2, #648	; 0x288
   126f8:	strh.w	r2, [sp, #12]
   126fc:	str	r4, [sp, #0]
   126fe:	str	r4, [sp, #16]
   12700:	mov	r2, r3
   12702:	movw	r6, #65535	; 0xffff
   12706:	ldr	r3, [sp, #120]	; 0x78
   12708:	str	r4, [sp, #8]
   1270a:	mov	r1, sp
   1270c:	str	r4, [sp, #20]
   1270e:	strh.w	r6, [sp, #14]
   12712:	bl	d490 <_svfprintf_r>
   12716:	cmp	r0, #0
   12718:	blt.n	1273e <_vasnprintf_r+0x5a>
   1271a:	ldr	r3, [sp, #0]
   1271c:	str	r0, [r5, #0]
   1271e:	movs	r2, #0
   12720:	strb	r2, [r3, #0]
   12722:	ldr	r0, [sp, #16]
   12724:	add	sp, #104	; 0x68
   12726:	pop	{r4, r5, r6, pc}
   12728:	mov.w	r2, #1544	; 0x608
   1272c:	str	r1, [sp, #0]
   1272e:	str	r1, [sp, #16]
   12730:	strh.w	r2, [sp, #12]
   12734:	bge.n	12700 <_vasnprintf_r+0x1c>
   12736:	movs	r3, #139	; 0x8b
   12738:	str	r3, [r0, #0]
   1273a:	movs	r0, #0
   1273c:	b.n	12724 <_vasnprintf_r+0x40>
   1273e:	movs	r0, #0
   12740:	b.n	12724 <_vasnprintf_r+0x40>
   12742:	nop

00012744 <_calloc_r>:
   12744:	push	{r4, lr}
   12746:	mul.w	r1, r2, r1
   1274a:	bl	b4c4 <_malloc_r>
   1274e:	mov	r4, r0
   12750:	cbz	r0, 1278a <_calloc_r+0x46>
   12752:	ldr.w	r2, [r0, #-4]
   12756:	bic.w	r2, r2, #3
   1275a:	subs	r2, #4
   1275c:	cmp	r2, #36	; 0x24
   1275e:	bhi.n	12792 <_calloc_r+0x4e>
   12760:	cmp	r2, #19
   12762:	bls.n	1278e <_calloc_r+0x4a>
   12764:	movs	r3, #0
   12766:	cmp	r2, #27
   12768:	str	r3, [r0, #0]
   1276a:	str	r3, [r0, #4]
   1276c:	bls.n	1279c <_calloc_r+0x58>
   1276e:	cmp	r2, #36	; 0x24
   12770:	str	r3, [r0, #8]
   12772:	str	r3, [r0, #12]
   12774:	iteee	ne
   12776:	addne.w	r2, r0, #16
   1277a:	streq	r3, [r0, #16]
   1277c:	streq	r3, [r0, #20]
   1277e:	addeq.w	r2, r0, #24
   12782:	movs	r3, #0
   12784:	str	r3, [r2, #0]
   12786:	str	r3, [r2, #4]
   12788:	str	r3, [r2, #8]
   1278a:	mov	r0, r4
   1278c:	pop	{r4, pc}
   1278e:	mov	r2, r0
   12790:	b.n	12782 <_calloc_r+0x3e>
   12792:	movs	r1, #0
   12794:	bl	8cf4 <memset>
   12798:	mov	r0, r4
   1279a:	pop	{r4, pc}
   1279c:	add.w	r2, r0, #8
   127a0:	b.n	12782 <_calloc_r+0x3e>
   127a2:	nop

000127a4 <vtable for AudioStream>:
	...
   127ac:	....

000127b0 <vtable for mRecordQueue<500>>:
	...
   127b8:	....

000127bc <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   127c4:	........m...a...
   127d4:	....m...I...

000127e0 <vtable for FsFile>:
	...
   127e8:	........m...a...
   127f8:	....m...I...%02d
   12808:	:%02d:%02d.%04d/
   12818:	%02d/%02d.%d %d 
   12828:	%d %d %d %d %d..
   12838:	.%s_%04d_%02d_%0
   12848:	2d_%02d_%02d_%02
   12858:	d%s.%04d_%02d_%0
   12868:	2d_%02d_%02d_%02
   12878:	d.RIFF.WAVE.fmt 
   12888:	.data.SD_s_%s.tx
   12898:	t.%04d_%02d_%02d
   128a8:	,.%02d_%02d_%02d
   128b8:	,.%10d...Config.
   128c8:	txt.%s...%d.Envi
   128d8:	_%s.txt.%10.1f,.
   128e8:	close acquisitio
   128f8:	n.Hibernate now 
   12908:	1.Hibernate now 
   12918:	3.?!xa.oar1234nd
   12928:	tchwseikp.%02d..
   12938:	.%c %5d on_time.
   12948:	..%c %5d acq_tim
   12958:	e...%c %5d rep_r
   12968:	ate...%c %5d fir
   12978:	st_hour...%c %5d
   12988:	 second_hour...%
   12998:	c %5d third_hour
   129a8:	...%c %5d last_h
   129b8:	our...%c %s name
   129c8:	...%c %s date...
   129d8:	%c %s time...ext
   129e8:	er 'a' to print 
   129f8:	this.exter '?c' 
   12a08:	to read value c=
   12a18:	(o,a,r,1,2,3,4,n
   12a28:	,d,t,c,h,w,s,m,i
   12a38:	,k,p).  e.g.: ?1
   12a48:	 will print firs
   12a58:	t hour.exter '!c
   12a68:	val' to read val
   12a78:	ue c=(0,a,r,1,2,
   12a88:	3,4,n,d,t,c,h,w,
   12a98:	s,m,i,k,p) and v
   12aa8:	al is new value.
   12ab8:	  e.g.: !110 wil
   12ac8:	l set first hour
   12ad8:	 to 10.exter 'xv
   12ae8:	al' to exit menu
   12af8:	 (x is delay in 
   12b08:	minutes, -1 mean
   12b18:	s immediate).  e
   12b28:	.g.: x10 will ex
   12b38:	it and hibernate
   12b48:	 for 10 minutes.
   12b58:	        x-1 with
   12b68:	 exit and start 
   12b78:	immediately.micr
   12b88:	oSoundRecorder.E
   12b98:	nd of Setup.logF
   12ba8:	ile.txt.SdError:
   12bb8:	 0X.,0X.Check SD
   12bc8:	 format..error: 
   12bd8:	.file.open faile
   12be8:	d.file.write dat
   12bf8:	a failed.file.pr
   12c08:	eAllocate failed
   12c18:	.closed..loop: %
   12c28:	5d %4d; %5d %5d;
   12c38:	 %5d..loop: %5d 
   12c48:	%4d; %5d %5d; %5
   12c58:	d...

00012c5c <vtable for I2S_32>:
	...
   12c64:	....

00012c68 <monthDays>:
   12c68:	............

00012c74 <vtable for Stream>:
	...
   12c7c:	........m...q...
   12c8c:	............

00012c98 <vtable for File>:
	...
   12ca0:	.#...#..m....#..
   12cb0:	.#...#...#..}%..
   12cc0:	.%..

00012cc4 <vtable for SDFile>:
	...
   12ccc:	.&...&..+'..[(..
   12cdc:	1&..!'...'...%..
   12cec:	5'...%...%...&..
   12cfc:	.&...$..[&...(..
   12d0c:	e&...$..u$..%(..
   12d1c:	.'..

00012d20 <TwoWire::i2c0_hardware>:
   12d20:	4..@@.....".0...
   12d30:	....!./.........

00012d40 <TwoWire::i2c1_hardware>:
   12d40:	4..@....&:......
   12d50:	..%;............

00012d60 <TwoWire::i2c2_hardware>:
   12d60:	(..@@...........
   12d70:	............J...

00012d80 <vtable for TwoWire>:
	...
   12d88:	+*..Q*..m...)*..
   12d98:	.)...)...*..

00012da4 <vtable for SDClass>:
	...
   12dac:	.-...+...,...,..
   12dbc:	[,...,...-...-..
   12dcc:	./.../..

00012dd4 <FsGetPartitionInfo::mbdpGuid>:
   12dd4:	......3D..h..&..
   12de4:	EFI PART..

00012dee <lookupTable>:
   12dee:	..x...C.........
   12dfe:	..............=.
   12e0e:	.. .............
   12e1e:	................
   12e2e:	................
   12e3e:	....:.e,<.;.>.f,
   12e4e:	B.A.S...T...V...
   12e5e:	W...Y...[...`...
   12e6e:	c...h...i...k.b,
   12e7e:	o...r...u...}.d,
   12e8e:	..............D.
   12e9e:	..........E.....
   12eae:	{...|...}.......
   12ebe:	................
   12ece:	................
   12ede:	}.c,Q.Y.S.[.U.].
   12eee:	W._.x...y.......
   12efe:	............N!2!
   12f0e:	.!.!a,`,v,u,

00012f1a <mapTable>:
   12f1a:	a..............0
   12f2a:	2...9...J...y...
   12f3a:	................
   12f4a:	.......("...F...
   12f5a:	................
   12f6a:	0.. P...`.."...6
   12f7a:	.......Da..&....
   12f8a:	...Z........ ...
   12f9a:	0...@...`...p.J.
   12faa:	r.V.v.d.z.p.|.~.
   12fba:	................
   12fca:	........p!...$..
   12fda:	0,./g,...,.d.-.&
   12fea:	A...Device is to
   12ffa:	o small...Writin
   1300a:	g FAT .Writing u
   1301a:	pcase table...Wr
   1302a:	iting root...For
   1303a:	mat done...Forma
   1304a:	t failed...EXFAT
   1305a:	.Bad cluster cou
   1306a:	nt...Card is too
   1307a:	 small....Format
   1308a:	 Done...Format F
   1309a:	ailed.....

000130a4 <vtable for SdSpiCard>:
	...
   130ac:	)s..+s..%t...s..
   130bc:	.x..!y..9s...y..
   130cc:	.{...t..!u...z..
   130dc:	.s...s...x..{x..
   130ec:	.x..}...%s...{..
   130fc:	.y...z..

00013104 <vtable for SdioCard>:
	...
   1310c:	I}...}..........
   1311c:	................
   1312c:	-.......I.......
   1313c:	.|...|...}...}..
   1314c:	9}..e~...}......
   1315c:	A...%...

00013164 <digital_pin_to_info_PGM>:
   13164:	@..C@..@D..CD..@
   13174:	...C...@0..C0..@
   13184:	4..C4..@...C...@
   13194:	...C...@...C...@
   131a4:	...C...@...C...@
   131b4:	...C...@...C...@
   131c4:	...C...@...C...@
   131d4:	...C...@...C...@
   131e4:	...C...@...C...@
   131f4:	...C...@...C...@
   13204:	...C...@...C...@
   13214:	...C...@...C...@
   13224:	h .Ch..@...C...@
   13234:	8..C8..@<..C<..@
   13244:	@..C@..@H..CH..@
   13254:	L..CL..@(..C(..@
   13264:	,..C,..@` .C`..@
   13274:	d .Cd..@ ..C ..@
   13284:	$..C$..@(..C(..@
   13294:	,..C,..@D..CD..@
   132a4:	p..Cp..@t..Ct..@
   132b4:	h..Ch..@P..CP..@
   132c4:	X..CX..@\..C\..@
   132d4:	T..CT..@ ..C ..@
   132e4:	$..C$..@...C...@
   132f4:	...C...@8..C8..@
   13304:	4..C4..@0..C0..@
   13314:	<..C<..@,..C,..@
   13324:	( .C(..@, .C,..@
   13334:	. .C...@. .C...@
   13344:	. .C...@. .C...@
   13354:	. .C...@. .C...@

00013364 <vtable for usb_serial_class>:
	...
   1336c:	................
   1337c:	........}...y...
   1338c:	..

0001338e <usb_endpoint_config_table>:
   1338e:	......

00013394 <usb_descriptor_list>:
   13394:	....e=. ........
   133a4:	.=. C........=. 
   133b4:	........x=. ....
   133c4:	.....=. ........
   133d4:	.=. ............
   133e4:	....

000133e8 <_global_impure_ptr>:
   133e8:	.>. C...POSIX...
   133f8:	....

000133fc <fpi.6173>:
   133fc:	5...............
   1340c:	....nf..inity...
   1341c:	an..

00013420 <fpinan.6209>:
   13420:	4...............
   13430:	........

00013438 <tinytens>:
   13438:	.......<3...#.I9
   13448:	=..D...2......[%
   13458:	Co.d(.h.

00013460 <zeroes.7258>:
   13460:	0000000000000000
   13470:	INF.inf.NAN.nan.
   13480:	0123456789ABCDEF
   13490:	....0123456789ab
   134a0:	cdef....(null)..
   134b0:	0...

000134b4 <blanks.7257>:
   134b4:	                

000134c4 <basefix.7328>:
   134c4:	................
   134d4:	................
   134e4:	....e%ld....

000134f0 <_ctype_>:
   134f0:	.         ((((( 
   13500:	                
   13510:	 ...............
   13520:	................
   13530:	..AAAAAA........
   13540:	................
   13550:	..BBBBBB........
   13560:	................
   13570:	 ...............
	...
   135f0:	....Infinity....
   13600:	NaN.

00013604 <__hexdig>:
	...
   13634:	................
   13644:	................
	...
   13664:	................
	...
   13704:	....

00013708 <__mprec_tens>:
   13708:	.......?......$@
   13718:	......Y@.....@.@
   13728:	.......@.....j.@
   13738:	.......A......cA
   13748:	.......A....e..A
   13758:	... _..B....vH7B
   13768:	......mB..@..0.B
   13778:	.......B..4&.k.C
   13788:	...7y.AC....W4vC
   13798:	..Ngm..C.=.`.X.C
   137a8:	@..x...DP.....KD
   137b8:	..M....D.J...-.D
   137c8:	...yCx.D

000137d0 <__mprec_bigtens>:
   137d0:	...7y.AC.n.....F
   137e0:	..?..O8M2.0.Hw.Z
   137f0:	<.s..O.u

000137f8 <p05.6087>:
   137f8:	........}...

00013804 <_init>:
   13804:	push	{r3, r4, r5, r6, r7, lr}
   13806:	nop
   13808:	pop	{r3, r4, r5, r6, r7}
   1380a:	pop	{r3}
   1380c:	mov	lr, r3
   1380e:	bx	lr

00013810 <__init_array_start>:
   13810:	.word	0x0000fb4d

00013814 <__frame_dummy_init_array_entry>:
   13814:	5........"..."..
   13824:	."..."...#..!#..
   13834:	9#..i#...#..))..
   13844:	A)..Y)..q)...)..
   13854:	.)...)...).../..

Disassembly of section .fini:

00013864 <_fini>:
   13864:	push	{r3, r4, r5, r6, r7, lr}
   13866:	nop
